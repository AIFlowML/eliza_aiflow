Directory Structure:

â””â”€â”€ ./
    â”œâ”€â”€ .github
    â”‚   â””â”€â”€ workflows
    â”‚       â””â”€â”€ main.yaml
    â”œâ”€â”€ ci
    â”‚   â”œâ”€â”€ proxy
    â”‚   â”‚   â”œâ”€â”€ grpc.yaml
    â”‚   â”‚   â””â”€â”€ http.yaml
    â”‚   â”œâ”€â”€ docker-compose-async.yml
    â”‚   â”œâ”€â”€ docker-compose.yml
    â”‚   â”œâ”€â”€ run_dependencies.sh
    â”‚   â””â”€â”€ stop_dependencies.sh
    â”œâ”€â”€ examples
    â”‚   â”œâ”€â”€ javascript
    â”‚   â”‚   â””â”€â”€ index.js
    â”‚   â”œâ”€â”€ typescript
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ package.json
    â”‚   â”‚   â””â”€â”€ tsconfig.json
    â”‚   â””â”€â”€ README.md
    â”œâ”€â”€ src
    â”‚   â”œâ”€â”€ backup
    â”‚   â”‚   â”œâ”€â”€ backupCreateStatusGetter.ts
    â”‚   â”‚   â”œâ”€â”€ backupCreator.ts
    â”‚   â”‚   â”œâ”€â”€ backupGetter.ts
    â”‚   â”‚   â”œâ”€â”€ backupRestorer.ts
    â”‚   â”‚   â”œâ”€â”€ backupRestoreStatusGetter.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ journey.test.ts
    â”‚   â”‚   â””â”€â”€ validation.ts
    â”‚   â”œâ”€â”€ batch
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ journey.test.ts
    â”‚   â”‚   â”œâ”€â”€ objectsBatchDeleter.ts
    â”‚   â”‚   â”œâ”€â”€ objectsBatcher.ts
    â”‚   â”‚   â”œâ”€â”€ path.test.ts
    â”‚   â”‚   â”œâ”€â”€ path.ts
    â”‚   â”‚   â”œâ”€â”€ referencePayloadBuilder.ts
    â”‚   â”‚   â””â”€â”€ referencesBatcher.ts
    â”‚   â”œâ”€â”€ c11y
    â”‚   â”‚   â”œâ”€â”€ conceptsGetter.ts
    â”‚   â”‚   â”œâ”€â”€ extensionCreator.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â””â”€â”€ journey.test.ts
    â”‚   â”œâ”€â”€ classifications
    â”‚   â”‚   â”œâ”€â”€ contextual.journey.test.ts
    â”‚   â”‚   â”œâ”€â”€ getter.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ knn.journey.test.ts
    â”‚   â”‚   â””â”€â”€ scheduler.ts
    â”‚   â”œâ”€â”€ cluster
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â””â”€â”€ nodesStatusGetter.ts
    â”‚   â”œâ”€â”€ collections
    â”‚   â”‚   â”œâ”€â”€ aggregate
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â””â”€â”€ integration.test.ts
    â”‚   â”‚   â”œâ”€â”€ backup
    â”‚   â”‚   â”‚   â”œâ”€â”€ client.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ collection.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ types.ts
    â”‚   â”‚   â”‚   â””â”€â”€ unit.test.ts
    â”‚   â”‚   â”œâ”€â”€ cluster
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â””â”€â”€ integration.test.ts
    â”‚   â”‚   â”œâ”€â”€ collection
    â”‚   â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ config
    â”‚   â”‚   â”‚   â”œâ”€â”€ types
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ generative.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ reranker.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vectorIndex.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ vectorizer.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ classes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ unit.test.ts
    â”‚   â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â”‚   â”œâ”€â”€ configure
    â”‚   â”‚   â”‚   â”œâ”€â”€ types
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ base.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ generative.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vectorIndex.ts
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ vectorizer.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ generative.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ parsing.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ reranker.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ unit.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ vectorIndex.ts
    â”‚   â”‚   â”‚   â””â”€â”€ vectorizer.ts
    â”‚   â”‚   â”œâ”€â”€ data
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â””â”€â”€ integration.test.ts
    â”‚   â”‚   â”œâ”€â”€ deserialize
    â”‚   â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ filters
    â”‚   â”‚   â”‚   â”œâ”€â”€ classes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ types.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ unit.test.ts
    â”‚   â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â”‚   â”œâ”€â”€ generate
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â”‚   â””â”€â”€ types.ts
    â”‚   â”‚   â”œâ”€â”€ iterator
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â””â”€â”€ integration.test.ts
    â”‚   â”‚   â”œâ”€â”€ query
    â”‚   â”‚   â”‚   â”œâ”€â”€ check.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ types.ts
    â”‚   â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â”‚   â”œâ”€â”€ references
    â”‚   â”‚   â”‚   â”œâ”€â”€ classes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ types.ts
    â”‚   â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â”‚   â”œâ”€â”€ serialize
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â””â”€â”€ unit.test.ts
    â”‚   â”‚   â”œâ”€â”€ sort
    â”‚   â”‚   â”‚   â”œâ”€â”€ classes.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â”‚   â””â”€â”€ types.ts
    â”‚   â”‚   â”œâ”€â”€ tenants
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ types.ts
    â”‚   â”‚   â”‚   â””â”€â”€ unit.test.ts
    â”‚   â”‚   â”œâ”€â”€ types
    â”‚   â”‚   â”‚   â”œâ”€â”€ batch.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ data.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ generate.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”‚   â”œâ”€â”€ internal.ts
    â”‚   â”‚   â”‚   â””â”€â”€ query.ts
    â”‚   â”‚   â”œâ”€â”€ vectors
    â”‚   â”‚   â”‚   â””â”€â”€ multiTargetVector.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â””â”€â”€ journey.test.ts
    â”‚   â”œâ”€â”€ connection
    â”‚   â”‚   â”œâ”€â”€ auth.ts
    â”‚   â”‚   â”œâ”€â”€ gql.ts
    â”‚   â”‚   â”œâ”€â”€ grpc.ts
    â”‚   â”‚   â”œâ”€â”€ helpers.test.ts
    â”‚   â”‚   â”œâ”€â”€ helpers.ts
    â”‚   â”‚   â”œâ”€â”€ http.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ integration.test.ts
    â”‚   â”‚   â”œâ”€â”€ journey.test.ts
    â”‚   â”‚   â”œâ”€â”€ proxy.test.ts
    â”‚   â”‚   â””â”€â”€ unit.test.ts
    â”‚   â”œâ”€â”€ data
    â”‚   â”‚   â”œâ”€â”€ checker.ts
    â”‚   â”‚   â”œâ”€â”€ creator.ts
    â”‚   â”‚   â”œâ”€â”€ deleter.ts
    â”‚   â”‚   â”œâ”€â”€ getter.ts
    â”‚   â”‚   â”œâ”€â”€ getterById.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ journey.test.ts
    â”‚   â”‚   â”œâ”€â”€ merger.ts
    â”‚   â”‚   â”œâ”€â”€ path.test.ts
    â”‚   â”‚   â”œâ”€â”€ path.ts
    â”‚   â”‚   â”œâ”€â”€ referenceCreator.ts
    â”‚   â”‚   â”œâ”€â”€ referenceDeleter.ts
    â”‚   â”‚   â”œâ”€â”€ referencePayloadBuilder.ts
    â”‚   â”‚   â”œâ”€â”€ referenceReplacer.ts
    â”‚   â”‚   â”œâ”€â”€ replication.ts
    â”‚   â”‚   â”œâ”€â”€ updater.ts
    â”‚   â”‚   â””â”€â”€ validator.ts
    â”‚   â”œâ”€â”€ graphql
    â”‚   â”‚   â”œâ”€â”€ aggregator.ts
    â”‚   â”‚   â”œâ”€â”€ ask.ts
    â”‚   â”‚   â”œâ”€â”€ bm25.ts
    â”‚   â”‚   â”œâ”€â”€ explorer.ts
    â”‚   â”‚   â”œâ”€â”€ generate.ts
    â”‚   â”‚   â”œâ”€â”€ getter.test.ts
    â”‚   â”‚   â”œâ”€â”€ getter.ts
    â”‚   â”‚   â”œâ”€â”€ group.ts
    â”‚   â”‚   â”œâ”€â”€ groupBy.ts
    â”‚   â”‚   â”œâ”€â”€ hybrid.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ journey.test.ts
    â”‚   â”‚   â”œâ”€â”€ nearImage.ts
    â”‚   â”‚   â”œâ”€â”€ nearMedia.ts
    â”‚   â”‚   â”œâ”€â”€ nearObject.ts
    â”‚   â”‚   â”œâ”€â”€ nearText.ts
    â”‚   â”‚   â”œâ”€â”€ nearVector.ts
    â”‚   â”‚   â”œâ”€â”€ raw.test.ts
    â”‚   â”‚   â”œâ”€â”€ raw.ts
    â”‚   â”‚   â”œâ”€â”€ sort.ts
    â”‚   â”‚   â””â”€â”€ where.ts
    â”‚   â”œâ”€â”€ grpc
    â”‚   â”‚   â”œâ”€â”€ base.ts
    â”‚   â”‚   â”œâ”€â”€ batcher.ts
    â”‚   â”‚   â”œâ”€â”€ retry.ts
    â”‚   â”‚   â”œâ”€â”€ searcher.ts
    â”‚   â”‚   â””â”€â”€ tenantsManager.ts
    â”‚   â”œâ”€â”€ misc
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ journey.test.ts
    â”‚   â”‚   â”œâ”€â”€ liveChecker.ts
    â”‚   â”‚   â”œâ”€â”€ metaGetter.ts
    â”‚   â”‚   â”œâ”€â”€ openidConfigurationGetter.ts
    â”‚   â”‚   â””â”€â”€ readyChecker.ts
    â”‚   â”œâ”€â”€ openapi
    â”‚   â”‚   â”œâ”€â”€ schema.ts
    â”‚   â”‚   â””â”€â”€ types.ts
    â”‚   â”œâ”€â”€ proto
    â”‚   â”‚   â”œâ”€â”€ google
    â”‚   â”‚   â”‚   â”œâ”€â”€ health
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ v1
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ health.ts
    â”‚   â”‚   â”‚   â””â”€â”€ protobuf
    â”‚   â”‚   â”‚       â””â”€â”€ struct.ts
    â”‚   â”‚   â””â”€â”€ v1
    â”‚   â”‚       â”œâ”€â”€ base.ts
    â”‚   â”‚       â”œâ”€â”€ batch_delete.ts
    â”‚   â”‚       â”œâ”€â”€ batch.ts
    â”‚   â”‚       â”œâ”€â”€ generative.ts
    â”‚   â”‚       â”œâ”€â”€ properties.ts
    â”‚   â”‚       â”œâ”€â”€ search_get.ts
    â”‚   â”‚       â”œâ”€â”€ tenants.ts
    â”‚   â”‚       â””â”€â”€ weaviate.ts
    â”‚   â”œâ”€â”€ schema
    â”‚   â”‚   â”œâ”€â”€ classCreator.ts
    â”‚   â”‚   â”œâ”€â”€ classDeleter.ts
    â”‚   â”‚   â”œâ”€â”€ classExists.ts
    â”‚   â”‚   â”œâ”€â”€ classGetter.ts
    â”‚   â”‚   â”œâ”€â”€ classUpdater.ts
    â”‚   â”‚   â”œâ”€â”€ deleteAll.ts
    â”‚   â”‚   â”œâ”€â”€ getter.ts
    â”‚   â”‚   â”œâ”€â”€ index.ts
    â”‚   â”‚   â”œâ”€â”€ journey.test.ts
    â”‚   â”‚   â”œâ”€â”€ propertyCreator.ts
    â”‚   â”‚   â”œâ”€â”€ shardsGetter.ts
    â”‚   â”‚   â”œâ”€â”€ shardsUpdater.ts
    â”‚   â”‚   â”œâ”€â”€ shardUpdater.ts
    â”‚   â”‚   â”œâ”€â”€ tenantsCreator.ts
    â”‚   â”‚   â”œâ”€â”€ tenantsDeleter.ts
    â”‚   â”‚   â”œâ”€â”€ tenantsExists.ts
    â”‚   â”‚   â”œâ”€â”€ tenantsGetter.ts
    â”‚   â”‚   â””â”€â”€ tenantsUpdater.ts
    â”‚   â”œâ”€â”€ utils
    â”‚   â”‚   â”œâ”€â”€ base64.ts
    â”‚   â”‚   â”œâ”€â”€ beaconPath.ts
    â”‚   â”‚   â”œâ”€â”€ dbVersion.ts
    â”‚   â”‚   â”œâ”€â”€ journey.test.ts
    â”‚   â”‚   â”œâ”€â”€ testData.ts
    â”‚   â”‚   â””â”€â”€ uuid.ts
    â”‚   â”œâ”€â”€ v2
    â”‚   â”‚   â””â”€â”€ index.ts
    â”‚   â”œâ”€â”€ validation
    â”‚   â”‚   â”œâ”€â”€ commandBase.ts
    â”‚   â”‚   â”œâ”€â”€ number.ts
    â”‚   â”‚   â”œâ”€â”€ string.ts
    â”‚   â”‚   â””â”€â”€ version.ts
    â”‚   â”œâ”€â”€ errors.ts
    â”‚   â”œâ”€â”€ index.ts
    â”‚   â””â”€â”€ integration.test.ts
    â”œâ”€â”€ test
    â”‚   â”œâ”€â”€ dbVersionProvider.ts
    â”‚   â”œâ”€â”€ images.journey.test.ts
    â”‚   â””â”€â”€ server.ts
    â”œâ”€â”€ .eslintrc.cjs
    â”œâ”€â”€ jest.config.ts
    â””â”€â”€ tsup.config.ts



---
File: /.github/workflows/main.yaml
---

on:
  push:
    branches:
      - main
    tags:
      - '**'
  pull_request:

env:
  WEAVIATE_124: 1.24.26
  WEAVIATE_125: 1.25.25
  WEAVIATE_126: 1.26.10
  WEAVIATE_127: 1.27.3

jobs:
  checks:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '22.x'
    - name: "Run checks"
      run: |
        npm ci
        npm run lint
        npm run format:check
        npm run docs

  tests:
    needs: checks
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        versions: [
          { node: "22.x", weaviate: $WEAVIATE_124},
          { node: "22.x", weaviate: $WEAVIATE_125},
          { node: "22.x", weaviate: $WEAVIATE_126},
          { node: "18.x", weaviate: $WEAVIATE_127},
          { node: "20.x", weaviate: $WEAVIATE_127},
          { node: "22.x", weaviate: $WEAVIATE_127}
        ]
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.versions.node }}
    - name: Login to Docker Hub
      if: ${{ !github.event.pull_request.head.repo.fork && github.triggering_actor != 'dependabot[bot]' }}
      uses: docker/login-action@v3
      with:
        username: ${{secrets.DOCKER_USERNAME}}
        password: ${{secrets.DOCKER_PASSWORD}}
    - name: "Install dependencies"
      run: |
        npm ci
        ci/run_dependencies.sh ${{ matrix.versions.weaviate }}
    - name: "Run tests with authentication tests"
      if: ${{ !github.event.pull_request.head.repo.fork }}
      env:
        OKTA_DUMMY_CI_PW: ${{ secrets.OKTA_DUMMY_CI_PW }}
        WCS_DUMMY_CI_PW: ${{ secrets.WCS_DUMMY_CI_PW }}
        AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
        OKTA_CLIENT_SECRET: ${{ secrets.OKTA_CLIENT_SECRET }}
      run: WEAVIATE_VERSION=${{ matrix.versions.weaviate }} npm test
    - name: "Run tests without authentication tests (for forks)"
      if: ${{ github.event.pull_request.head.repo.fork }}
      run: WEAVIATE_VERSION=${{ matrix.versions.weaviate }} npm test
    - name: "Transpile the package"
      run: npm run build
    - name: "Stop Weaviate"
      run: ci/stop_dependencies.sh ${{ matrix.versions.weaviate }}

  publish:
    needs: tests
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags')
    runs-on: ubuntu-latest
    permissions:
      contents: write   # to upload the release
      pages: write      # to deploy to Pages
      id-token: write   # to verify the deployment originates from an appropriate source
    steps:
      - uses: actions/checkout@v3
      # Setup .npmrc file to publish to npm
      - uses: actions/setup-node@v3
        with:
          node-version: '22.x'
          registry-url: 'https://registry.npmjs.org'
      - run: npm ci
      - run: npm run build
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTOMATION_TOKEN }}
      - run: npm run docs
      - name: "Upload docs as pages artifact"
        uses: actions/upload-pages-artifact@v3
        with:
          path: ./docs
      - name: "Deploy the uploaded pages artifact"
        uses: actions/deploy-pages@v4
      - name: "Create a GitHub release"
        uses: softprops/action-gh-release@v1
        with:
          generate_release_notes: true
          draft: true


---
File: /ci/proxy/grpc.yaml
---

# This proxy configuration is one that allows the use of a gRPC proxy between Weaviate and the client.
# It is used in the CI/CD pipeline to test the gRPC proxy functionality of the client.
# It follows the method as described here: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/upgrades#connect-support
# where special attention should be paid to the fact that we are using a terminating HTTP/2 connection,
# as in this example: https://github.com/envoyproxy/envoy/blob/8e93d16d433d3364c2b000dc9067ffc400e8f0d6/configs/terminate_http2_connect.yaml,
# because Weaviate itself is not capable of handling CONNECT requests. So Envoy instead upgrades these to POSTs and sends them on
admin:
  address:
    socket_address:
      protocol: TCP
      address: 127.0.0.1
      port_value: 9902
static_resources:
  listeners:
  - name: proxy
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: local_service
              domains:
              - "*"
              routes:
              - match:
                  connect_matcher: {}
                route:
                  cluster: weaviate-grpc
                  upgrade_configs:
                  - upgrade_type: CONNECT
                    connect_config:
                      {}
          http_filters:
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
          http2_protocol_options:
            allow_connect: true
          upgrade_configs:
          - upgrade_type: CONNECT
  clusters:
  - name: weaviate-grpc
    type: STRICT_DNS
    typed_extension_protocol_options:
      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
        "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
        explicit_http_config:
          http2_protocol_options: {}
    load_assignment:
      cluster_name: weaviate-grpc
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: weaviate-proxy
                port_value: 8021


---
File: /ci/proxy/http.yaml
---

# This proxy configuration is one that allows the use of a gRPC proxy between Weaviate and the client.
# It is used in the CI/CD pipeline to test the gRPC proxy functionality of the client.
# It follows the method as described here: https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/http/upgrades#connect-support
# where special attention should be paid to the fact that we are using a terminating HTTP/2 connection,
# as in this example: https://github.com/envoyproxy/envoy/blob/8e93d16d433d3364c2b000dc9067ffc400e8f0d6/configs/terminate_http2_connect.yaml,
# because Weaviate itself is not capable of handling CONNECT requests. So Envoy instead upgrades these to POSTs and sends them on
admin:
  address:
    socket_address:
      protocol: TCP
      address: 127.0.0.1
      port_value: 9902
static_resources:
  listeners:
  - name: proxy
    address:
      socket_address:
        protocol: TCP
        address: 0.0.0.0
        port_value: 10000
    filter_chains:
    - filters:
      - name: envoy.filters.network.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          stat_prefix: ingress_http
          codec_type: HTTP1
          route_config:
            name: local_route
            virtual_hosts:
            - name: local_service
              domains:
              - "*"
              routes:
              - match:
                  prefix: "/http"
                route:
                  prefix_rewrite: "/"
                  cluster: weaviate-http
          http_filters:
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

  clusters:
  - name: weaviate-http
    type: STRICT_DNS
    connect_timeout: 5s
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: weaviate-http
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: weaviate-proxy
                port_value: 8020


---
File: /ci/docker-compose-async.yml
---

---
version: '3.4'
services:
  weaviate_async:
    command:
      - --host
      - 0.0.0.0
      - --port
      - '8090'
      - --scheme
      - http
    image: semitechnologies/weaviate:${WEAVIATE_VERSION}
    ports:
      - "8078:8090"
      - "50049:50051"
    restart: on-failure:0
    environment:
      QUERY_DEFAULTS_LIMIT: 25
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'true'
      PERSISTENCE_DATA_PATH: '/var/lib/weaviate'
      CLUSTER_HOSTNAME: 'node1'
      ASYNC_INDEXING: 'true'
      DISABLE_TELEMETRY: 'true'



---
File: /ci/docker-compose.yml
---

---
version: '3.4'
services:
  weaviate:
    command:
      - --host
      - 0.0.0.0
      - --port
      - '8080'
      - --scheme
      - http
      - --write-timeout=600s
    image: semitechnologies/weaviate:${WEAVIATE_VERSION}
    ports:
      - "8080:8080"
      - "50051:50051"
    restart: on-failure:0
    environment:
      CONTEXTIONARY_URL: contextionary:9999
      QUERY_DEFAULTS_LIMIT: 25
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'true'
      PERSISTENCE_DATA_PATH: '/var/lib/weaviate'
      DEFAULT_VECTORIZER_MODULE: 'text2vec-contextionary'
      ENABLE_MODULES: text2vec-contextionary,backup-filesystem,img2vec-neural
      BACKUP_FILESYSTEM_PATH: "/tmp/backups"
      CLUSTER_GOSSIP_BIND_PORT: "7100"
      CLUSTER_DATA_BIND_PORT: "7101"
      CLUSTER_HOSTNAME: "node1"
      AUTOSCHEMA_ENABLED: 'false'
      IMAGE_INFERENCE_API: "http://i2v-neural:8080"
      DISABLE_TELEMETRY: 'true'
  contextionary:
    environment:
      OCCURRENCE_WEIGHT_LINEAR_FACTOR: 0.75
      EXTENSIONS_STORAGE_MODE: weaviate
      EXTENSIONS_STORAGE_ORIGIN: http://weaviate:8080
      NEIGHBOR_OCCURRENCE_IGNORE_PERCENTILE: 5
      ENABLE_COMPOUND_SPLITTING: 'false'
    image: semitechnologies/contextionary:en0.16.0-v1.2.0
    ports:
      - 9999:9999
  i2v-neural:
    image: semitechnologies/img2vec-pytorch:resnet50
...



---
File: /ci/run_dependencies.sh
---

#!/usr/bin/env bash

set -eou pipefail

export WEAVIATE_VERSION=$1

source ./ci/compose.sh

echo "Stop existing session if running"
compose_down_all
rm -rf weaviate-data || true

echo "Run Docker compose"
compose_up_all

echo "Wait until all containers are up"

function wait(){
  MAX_WAIT_SECONDS=60
  ALREADY_WAITING=0

  echo "Waiting for $1"
  while true; do
    # first check if weaviate already responds
    if ! curl -s $1 > /dev/null; then
      continue
    fi

    # endpoint available, check if it is ready
    HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$1/v1/.well-known/ready")

    if [ "$HTTP_STATUS" -eq 200 ]; then
      break
    else
      echo "Weaviate is not up yet. (waited for ${ALREADY_WAITING}s)"
      if [ $ALREADY_WAITING -gt $MAX_WAIT_SECONDS ]; then
        echo "Weaviate did not start up in $MAX_WAIT_SECONDS."
        exit 1
      else
        sleep 2
        let ALREADY_WAITING=$ALREADY_WAITING+2
      fi
    fi
  done

  echo "Weaviate is up and running!"
}

for port in $(all_weaviate_ports); do
  wait "http://localhost:$port"
done

echo "All containers running"



---
File: /ci/stop_dependencies.sh
---

#!/usr/bin/env bash

set -eou pipefail

export WEAVIATE_VERSION=$1

source ./ci/compose.sh

compose_down_all
rm -rf weaviate-data || true



---
File: /examples/javascript/index.js
---

const { default: weaviate } = require('weaviate-ts-client');

const client = weaviate.client({
  scheme: 'http',
  host: 'localhost:8080',
});

console.log(
  JSON.stringify(
    new weaviate.AuthAccessTokenCredentials({
      accessToken: 'token123',
      expiresIn: 123,
    })
  )
);

console.log(
  JSON.stringify(
    new weaviate.AuthUserPasswordCredentials({
      username: 'user123',
      password: 'password',
    })
  )
);

console.log(
  JSON.stringify(
    new weaviate.AuthClientCredentials({
      clientSecret: 'secret123',
    })
  )
);

console.log(JSON.stringify(new weaviate.ApiKey('abcd1234')));

client.misc
  .metaGetter()
  .do()
  .then((res) => console.log(`res: ${JSON.stringify(res)}`));



---
File: /examples/typescript/index.ts
---

import weaviate, {
  ApiKey,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
  AuthUserPasswordCredentials,
  generateUuid5,
} from 'weaviate-ts-client';

const client = weaviate.client({
  scheme: 'http',
  host: 'localhost:8080',
});

console.log(
  JSON.stringify(
    new AuthAccessTokenCredentials({
      accessToken: 'token123',
      expiresIn: 123,
    })
  )
);

console.log(
  JSON.stringify(
    new AuthUserPasswordCredentials({
      username: 'user123',
      password: 'password',
    })
  )
);

console.log(
  JSON.stringify(
    new AuthClientCredentials({
      clientSecret: 'secret123',
    })
  )
);

console.log(JSON.stringify(new ApiKey('abcd1234')));
console.log(generateUuid5('55dfccce-0142-4807-a1ff-60be9b38f5cc', 'the-best-namespace'));

client.misc
  .metaGetter()
  .do()
  .then((res: any) => console.log(`res: ${JSON.stringify(res)}`));



---
File: /examples/typescript/package.json
---

{
  "name": "weaviate-ts-example",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "dependencies": {
    "weaviate-ts-client": "latest"
  },
  "scripts": {
    "start": "tsc && node dist/index.js"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "typescript": "^4.9.5"
  }
}



---
File: /examples/typescript/tsconfig.json
---

{
  "compilerOptions": {
    "target": "es2020",
    "strict": true,
    "preserveConstEnums": true,
    "noEmit": false,
    "sourceMap": false,
    "module":"ES2022",
    "moduleResolution":"node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "outDir": "./dist"
  },
  "include": ["**/*"],
  "exclude": ["node_modules"]
}



---
File: /examples/README.md
---

# Weaviate TypeScript Client Examples

These examples reflect the most current state of the client and its features, so please make sure that you have the latest version of `weaviate-ts-client` installed ðŸ™‚

## JavaScript

Usage within a CommonJS project.

## TypeScipt

TypeScript & ESM JavaScript usage.



---
File: /src/backup/backupCreateStatusGetter.ts
---

import Connection from '../connection/index.js';
import { WeaviateInvalidInputError } from '../errors.js';
import { BackupCreateStatusResponse } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { Backend } from './index.js';
import { validateBackend, validateBackupId } from './validation.js';

export default class BackupCreateStatusGetter extends CommandBase {
  private backend?: Backend;
  private backupId?: string;

  constructor(client: Connection) {
    super(client);
  }

  withBackend(backend: Backend) {
    this.backend = backend;
    return this;
  }

  withBackupId(backupId: string) {
    this.backupId = backupId;
    return this;
  }

  validate = (): void => {
    this.addErrors([...validateBackend(this.backend), ...validateBackupId(this.backupId)]);
  };

  do = (): Promise<BackupCreateStatusResponse> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new WeaviateInvalidInputError('invalid usage: ' + this.errors.join(', ')));
    }
    return this.client.get(this._path()) as Promise<BackupCreateStatusResponse>;
  };

  private _path = (): string => {
    return `/backups/${this.backend}/${this.backupId}`;
  };
}



---
File: /src/backup/backupCreator.ts
---

import Connection from '../connection/index.js';
import { WeaviateInvalidInputError } from '../errors.js';
import {
  BackupConfig,
  BackupCreateRequest,
  BackupCreateResponse,
  BackupCreateStatusResponse,
} from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import BackupCreateStatusGetter from './backupCreateStatusGetter.js';
import { Backend } from './index.js';
import {
  validateBackend,
  validateBackupId,
  validateExcludeClassNames,
  validateIncludeClassNames,
} from './validation.js';

const WAIT_INTERVAL = 1000;

export default class BackupCreator extends CommandBase {
  private backend!: Backend;
  private backupId!: string;
  private excludeClassNames?: string[];
  private includeClassNames?: string[];
  private statusGetter: BackupCreateStatusGetter;
  private waitForCompletion!: boolean;
  private config?: BackupConfig;

  constructor(client: Connection, statusGetter: BackupCreateStatusGetter) {
    super(client);
    this.statusGetter = statusGetter;
  }

  withIncludeClassNames(...classNames: string[]) {
    let cls = classNames;
    if (classNames.length && Array.isArray(classNames[0])) {
      cls = classNames[0];
    }
    this.includeClassNames = cls;
    return this;
  }

  withExcludeClassNames(...classNames: string[]) {
    let cls = classNames;
    if (classNames.length && Array.isArray(classNames[0])) {
      cls = classNames[0];
    }
    this.excludeClassNames = cls;
    return this;
  }

  withBackend(backend: Backend) {
    this.backend = backend;
    return this;
  }

  withBackupId(backupId: string) {
    this.backupId = backupId;
    return this;
  }

  withWaitForCompletion(waitForCompletion: boolean) {
    this.waitForCompletion = waitForCompletion;
    return this;
  }

  withConfig(cfg: BackupConfig) {
    this.config = cfg;
    return this;
  }

  validate = (): void => {
    this.addErrors([
      ...validateIncludeClassNames(this.includeClassNames),
      ...validateExcludeClassNames(this.excludeClassNames),
      ...validateBackend(this.backend),
      ...validateBackupId(this.backupId),
    ]);
  };

  do = (): Promise<BackupCreateResponse> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new WeaviateInvalidInputError('invalid usage: ' + this.errors.join(', ')));
    }

    const payload = {
      id: this.backupId,
      config: this.config,
      include: this.includeClassNames,
      exclude: this.excludeClassNames,
    } as BackupCreateRequest;

    if (this.waitForCompletion) {
      return this._createAndWaitForCompletion(payload);
    }
    return this._create(payload);
  };

  _create = (payload: BackupCreateRequest): Promise<BackupCreateResponse> => {
    return this.client.postReturn(this._path(), payload) as Promise<BackupCreateResponse>;
  };

  _createAndWaitForCompletion = (payload: BackupCreateRequest): Promise<BackupCreateResponse> => {
    return new Promise<BackupCreateResponse>((resolve, reject) => {
      this._create(payload)
        .then((createResponse: any) => {
          this.statusGetter.withBackend(this.backend).withBackupId(this.backupId);

          const loop = () => {
            this.statusGetter
              .do()
              .then((createStatusResponse: any) => {
                if (createStatusResponse.status == 'SUCCESS' || createStatusResponse.status == 'FAILED') {
                  resolve(this._merge(createStatusResponse, createResponse));
                } else {
                  setTimeout(loop, WAIT_INTERVAL);
                }
              })
              .catch(reject);
          };

          loop();
        })
        .catch(reject);
    });
  };

  private _path = (): string => {
    return `/backups/${this.backend}`;
  };

  _merge = (
    createStatusResponse: BackupCreateStatusResponse,
    createResponse: BackupCreateResponse
  ): BackupCreateResponse => {
    const merged: BackupCreateResponse = {};
    if ('id' in createStatusResponse) {
      merged.id = createStatusResponse.id;
    }
    if ('path' in createStatusResponse) {
      merged.path = createStatusResponse.path;
    }
    if ('backend' in createStatusResponse) {
      merged.backend = createStatusResponse.backend;
    }
    if ('status' in createStatusResponse) {
      merged.status = createStatusResponse.status;
    }
    if ('error' in createStatusResponse) {
      merged.error = createStatusResponse.error;
    }
    if ('classes' in createResponse) {
      merged.classes = createResponse.classes;
    }
    return merged;
  };
}



---
File: /src/backup/backupGetter.ts
---

import Connection from '../connection/index.js';
import { WeaviateInvalidInputError } from '../errors.js';
import { BackupCreateResponse } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { Backend } from './index.js';
import { validateBackend } from './validation.js';

export default class BackupGetter extends CommandBase {
  private backend?: Backend;

  constructor(client: Connection) {
    super(client);
  }

  withBackend(backend: Backend) {
    this.backend = backend;
    return this;
  }

  validate = (): void => {
    this.addErrors(validateBackend(this.backend));
  };

  do = (): Promise<BackupCreateResponse[]> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new WeaviateInvalidInputError('invalid usage: ' + this.errors.join(', ')));
    }

    return this.client.get(this._path());
  };

  private _path = (): string => {
    return `/backups/${this.backend}`;
  };
}



---
File: /src/backup/backupRestorer.ts
---

import Connection from '../connection/index.js';
import { WeaviateInvalidInputError } from '../errors.js';
import {
  BackupRestoreRequest,
  BackupRestoreResponse,
  BackupRestoreStatusResponse,
  RestoreConfig,
} from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import BackupRestoreStatusGetter from './backupRestoreStatusGetter.js';
import { Backend } from './index.js';
import {
  validateBackend,
  validateBackupId,
  validateExcludeClassNames,
  validateIncludeClassNames,
} from './validation.js';

const WAIT_INTERVAL = 1000;

export default class BackupRestorer extends CommandBase {
  private backend!: Backend;
  private backupId!: string;
  private excludeClassNames?: string[];
  private includeClassNames?: string[];
  private statusGetter: BackupRestoreStatusGetter;
  private waitForCompletion?: boolean;
  private config?: RestoreConfig;

  constructor(client: Connection, statusGetter: BackupRestoreStatusGetter) {
    super(client);
    this.statusGetter = statusGetter;
  }

  withIncludeClassNames(...classNames: string[]) {
    let cls = classNames;
    if (classNames.length && Array.isArray(classNames[0])) {
      cls = classNames[0];
    }
    this.includeClassNames = cls;
    return this;
  }

  withExcludeClassNames(...classNames: string[]) {
    let cls = classNames;
    if (classNames.length && Array.isArray(classNames[0])) {
      cls = classNames[0];
    }
    this.excludeClassNames = cls;
    return this;
  }

  withBackend(backend: Backend) {
    this.backend = backend;
    return this;
  }

  withBackupId(backupId: string) {
    this.backupId = backupId;
    return this;
  }

  withWaitForCompletion(waitForCompletion: boolean) {
    this.waitForCompletion = waitForCompletion;
    return this;
  }

  withConfig(cfg: RestoreConfig) {
    this.config = cfg;
    return this;
  }

  validate = (): void => {
    this.addErrors([
      ...validateIncludeClassNames(this.includeClassNames || []),
      ...validateExcludeClassNames(this.excludeClassNames || []),
      ...validateBackend(this.backend),
      ...validateBackupId(this.backupId),
    ]);
  };

  do = (): Promise<BackupRestoreResponse> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new WeaviateInvalidInputError('invalid usage: ' + this.errors.join(', ')));
    }

    const payload = {
      config: this.config,
      include: this.includeClassNames,
      exclude: this.excludeClassNames,
    } as BackupRestoreRequest;

    if (this.waitForCompletion) {
      return this._restoreAndWaitForCompletion(payload);
    }
    return this._restore(payload);
  };

  _restore = (payload: BackupRestoreRequest): Promise<BackupRestoreResponse> => {
    return this.client.postReturn(this._path(), payload);
  };

  _restoreAndWaitForCompletion = (payload: BackupRestoreRequest): Promise<BackupRestoreResponse> => {
    return new Promise<BackupRestoreResponse>((resolve, reject) => {
      this._restore(payload)
        .then((restoreResponse: any) => {
          this.statusGetter.withBackend(this.backend).withBackupId(this.backupId);

          const loop = () => {
            this.statusGetter
              .do()
              .then((restoreStatusResponse: any) => {
                if (restoreStatusResponse.status == 'SUCCESS' || restoreStatusResponse.status == 'FAILED') {
                  resolve(this._merge(restoreStatusResponse, restoreResponse));
                } else {
                  setTimeout(loop, WAIT_INTERVAL);
                }
              })
              .catch(reject);
          };

          loop();
        })
        .catch(reject);
    });
  };

  private _path = (): string => {
    return `/backups/${this.backend}/${this.backupId}/restore`;
  };

  _merge = (
    restoreStatusResponse: BackupRestoreStatusResponse,
    restoreResponse: BackupRestoreResponse
  ): BackupRestoreResponse => {
    const merged: BackupRestoreResponse = {};
    if ('id' in restoreStatusResponse) {
      merged.id = restoreStatusResponse.id;
    }
    if ('path' in restoreStatusResponse) {
      merged.path = restoreStatusResponse.path;
    }
    if ('backend' in restoreStatusResponse) {
      merged.backend = restoreStatusResponse.backend;
    }
    if ('status' in restoreStatusResponse) {
      merged.status = restoreStatusResponse.status;
    }
    if ('error' in restoreStatusResponse) {
      merged.error = restoreStatusResponse.error;
    }
    if ('classes' in restoreResponse) {
      merged.classes = restoreResponse.classes;
    }
    return merged;
  };
}



---
File: /src/backup/backupRestoreStatusGetter.ts
---

import Connection from '../connection/index.js';
import { WeaviateInvalidInputError } from '../errors.js';
import { BackupRestoreStatusResponse } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { Backend } from './index.js';
import { validateBackend, validateBackupId } from './validation.js';

export default class BackupRestoreStatusGetter extends CommandBase {
  private backend?: Backend;
  private backupId?: string;

  constructor(client: Connection) {
    super(client);
  }

  withBackend(backend: Backend) {
    this.backend = backend;
    return this;
  }

  withBackupId(backupId: string) {
    this.backupId = backupId;
    return this;
  }

  validate = (): void => {
    this.addErrors([...validateBackend(this.backend), ...validateBackupId(this.backupId)]);
  };

  do = (): Promise<BackupRestoreStatusResponse> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new WeaviateInvalidInputError('invalid usage: ' + this.errors.join(', ')));
    }

    return this.client.get(this._path());
  };

  private _path = (): string => {
    return `/backups/${this.backend}/${this.backupId}/restore`;
  };
}



---
File: /src/backup/index.ts
---

import Connection from '../connection/index.js';
import BackupCreateStatusGetter from './backupCreateStatusGetter.js';
import BackupCreator from './backupCreator.js';
import BackupRestoreStatusGetter from './backupRestoreStatusGetter.js';
import BackupRestorer from './backupRestorer.js';

export type Backend = 'filesystem' | 's3' | 'gcs' | 'azure';
export type BackupStatus = 'STARTED' | 'TRANSFERRING' | 'TRANSFERRED' | 'SUCCESS' | 'FAILED';
export type BackupCompressionLevel = 'DefaultCompression' | 'BestSpeed' | 'BestCompression';

export interface Backup {
  creator: () => BackupCreator;
  createStatusGetter: () => BackupCreateStatusGetter;
  restorer: () => BackupRestorer;
  restoreStatusGetter: () => BackupRestoreStatusGetter;
}

const backup = (client: Connection): Backup => {
  return {
    creator: () => new BackupCreator(client, new BackupCreateStatusGetter(client)),
    createStatusGetter: () => new BackupCreateStatusGetter(client),
    restorer: () => new BackupRestorer(client, new BackupRestoreStatusGetter(client)),
    restoreStatusGetter: () => new BackupRestoreStatusGetter(client),
  };
};

export default backup;
export { default as BackupCreateStatusGetter } from './backupCreateStatusGetter.js';
export { default as BackupCreator } from './backupCreator.js';
export { default as BackupRestoreStatusGetter } from './backupRestoreStatusGetter.js';
export { default as BackupRestorer } from './backupRestorer.js';



---
File: /src/backup/journey.test.ts
---

import {
  BackupCreateResponse,
  BackupCreateStatusResponse,
  BackupRestoreResponse,
  BackupRestoreStatusResponse,
} from '../openapi/types.js';
import weaviate, { WeaviateClient } from '../v2/index.js';
import { Backend } from './index.js';

const {
  createTestFoodSchemaAndData,
  cleanupTestFood,
  PIZZA_CLASS_NAME,
  SOUP_CLASS_NAME,
} = require('../utils/testData');

const DOCKER_COMPOSE_BACKUPS_DIR = '/tmp/backups';

describe('create and restore backup with waiting', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('asserts data exist', () => assertThatAllPizzasExist(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .then((createResponse: BackupCreateResponse) => {
        expect(createResponse.id).toBe(BACKUP_ID);
        expect(createResponse.classes).toHaveLength(1);
        expect(createResponse.classes).toContain(PIZZA_CLASS_NAME);
        expect(createResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(createResponse.backend).toBe(BACKEND);
        expect(createResponse.status).toBe('SUCCESS');
        expect(createResponse.error).toBeUndefined();
      })
      .catch((err: any) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('asserts data still exist', () => assertThatAllPizzasExist(client));

  it('checks create status', () => {
    return client.backup
      .createStatusGetter()
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then((createStatusResponse: BackupCreateStatusResponse) => {
        expect(createStatusResponse.id).toBe(BACKUP_ID);
        expect(createStatusResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(createStatusResponse.backend).toBe(BACKEND);
        expect(createStatusResponse.status).toBe('SUCCESS');
        expect(createStatusResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on create status: ' + err);
      });
  });

  it('removes existing class', () => {
    return client.schema
      .classDeleter()
      .withClassName(PIZZA_CLASS_NAME)
      .do()
      .catch((err: any) => {
        throw new Error('should not fail on class delete: ' + err);
      });
  });

  it('restores backup', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .then((restoreResponse: BackupRestoreResponse) => {
        expect(restoreResponse.id).toBe(BACKUP_ID);
        expect(restoreResponse.classes).toHaveLength(1);
        expect(restoreResponse.classes).toContain(PIZZA_CLASS_NAME);
        expect(restoreResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(restoreResponse.backend).toBe(BACKEND);
        expect(restoreResponse.status).toBe('SUCCESS');
        expect(restoreResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on restore backup: ' + err);
      });
  });

  it('asserts data again exist', () => assertThatAllPizzasExist(client));

  it('checks restore status', () => {
    return client.backup
      .restoreStatusGetter()
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then((restoreStatusResponse: BackupRestoreStatusResponse) => {
        expect(restoreStatusResponse.id).toBe(BACKUP_ID);
        expect(restoreStatusResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(restoreStatusResponse.backend).toBe(BACKEND);
        expect(restoreStatusResponse.status).toBe('SUCCESS');
        expect(restoreStatusResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on restore status: ' + err);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('create and restore backup without waiting', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('asserts data exist', () => assertThatAllPizzasExist(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then((createResponse: BackupCreateResponse) => {
        expect(createResponse.id).toBe(BACKUP_ID);
        expect(createResponse.classes).toHaveLength(1);
        expect(createResponse.classes).toContain(PIZZA_CLASS_NAME);
        expect(createResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(createResponse.backend).toBe(BACKEND);
        expect(createResponse.status).toBe('STARTED');
        expect(createResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('waits until created', () => {
    return new Promise((resolve, reject) => {
      const statusGetter = client.backup.createStatusGetter().withBackend(BACKEND).withBackupId(BACKUP_ID);
      const loop = () => {
        statusGetter
          .do()
          .then((createStatusResponse: BackupCreateStatusResponse) => {
            if (createStatusResponse.status == 'SUCCESS' || createStatusResponse.status == 'FAILED') {
              resolve(createStatusResponse);
            } else {
              setTimeout(loop, 100);
            }
          })
          .catch(reject);
      };
      loop();
    })
      .then((createStatusResponse: any) => {
        expect(createStatusResponse.id).toBe(BACKUP_ID);
        expect(createStatusResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(createStatusResponse.backend).toBe(BACKEND);
        expect(createStatusResponse.status).toBe('SUCCESS');
        expect(createStatusResponse.error).toBeUndefined();
      })
      .catch((err: any) => {
        throw new Error('should not fail on create status: ' + err);
      });
  });

  it('asserts data still exist', () => assertThatAllPizzasExist(client));

  it('removes existing class', () => {
    return client.schema
      .classDeleter()
      .withClassName(PIZZA_CLASS_NAME)
      .do()
      .catch((err: any) => {
        throw new Error('should not fail on class delete: ' + err);
      });
  });

  it('restores backup', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then((restoreResponse: BackupRestoreResponse) => {
        expect(restoreResponse.id).toBe(BACKUP_ID);
        expect(restoreResponse.classes).toHaveLength(1);
        expect(restoreResponse.classes).toContain(PIZZA_CLASS_NAME);
        expect(restoreResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(restoreResponse.backend).toBe(BACKEND);
        expect(restoreResponse.status).toBe('STARTED');
        expect(restoreResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on restore backup: ' + err);
      });
  });

  it('waits until restored', () => {
    return new Promise((resolve, reject) => {
      const statusGetter = client.backup.restoreStatusGetter().withBackend(BACKEND).withBackupId(BACKUP_ID);
      const loop = () => {
        statusGetter
          .do()
          .then((restoreStatusResponse: BackupRestoreStatusResponse) => {
            if (restoreStatusResponse.status == 'SUCCESS' || restoreStatusResponse.status == 'FAILED') {
              resolve(restoreStatusResponse);
            } else {
              setTimeout(loop, 100);
            }
          })
          .catch(reject);
      };
      loop();
    })
      .then((restoreStatusResponse: any) => {
        expect(restoreStatusResponse.id).toBe(BACKUP_ID);
        expect(restoreStatusResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(restoreStatusResponse.backend).toBe(BACKEND);
        expect(restoreStatusResponse.status).toBe('SUCCESS');
        expect(restoreStatusResponse.error).toBeUndefined();
      })
      .catch((err: any) => {
        throw new Error('should not fail on restore backup: ' + err);
      });
  });

  it('asserts data again exist', () => assertThatAllPizzasExist(client));

  it('cleans up', () => cleanupTestFood(client));
});

describe('create and restore 1 of 2 classes', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('asserts data exist', () =>
    Promise.all([assertThatAllPizzasExist(client), assertThatAllSoupsExist(client)]));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .then((createResponse: BackupCreateResponse) => {
        expect(createResponse.id).toBe(BACKUP_ID);
        expect(createResponse.classes).toContain(PIZZA_CLASS_NAME);
        expect(createResponse.classes).toContain(SOUP_CLASS_NAME);
        expect(createResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(createResponse.backend).toBe(BACKEND);
        expect(createResponse.status).toBe('SUCCESS');
        expect(createResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('asserts data still exist', () =>
    Promise.all([assertThatAllPizzasExist(client), assertThatAllSoupsExist(client)]));

  it('checks create status', () => {
    return client.backup
      .createStatusGetter()
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then((createStatusResponse: BackupCreateStatusResponse) => {
        expect(createStatusResponse.id).toBe(BACKUP_ID);
        expect(createStatusResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(createStatusResponse.backend).toBe(BACKEND);
        expect(createStatusResponse.status).toBe('SUCCESS');
        expect(createStatusResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on create status: ' + err);
      });
  });

  it('removes existing class', () => {
    return client.schema
      .classDeleter()
      .withClassName(PIZZA_CLASS_NAME)
      .do()
      .catch((err: any) => {
        throw new Error('should not fail on class delete: ' + err);
      });
  });

  it('restores backup', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .then((restoreResponse: BackupRestoreResponse) => {
        expect(restoreResponse.id).toBe(BACKUP_ID);
        expect(restoreResponse.classes).toHaveLength(1);
        expect(restoreResponse.classes).toContain(PIZZA_CLASS_NAME);
        expect(restoreResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(restoreResponse.backend).toBe(BACKEND);
        expect(restoreResponse.status).toBe('SUCCESS');
        expect(restoreResponse.error).toBeUndefined();
      })
      .catch((err: any) => {
        throw new Error('should not fail on restore backup: ' + err);
      });
  });

  it('asserts data again exist', () =>
    Promise.all([assertThatAllPizzasExist(client), assertThatAllSoupsExist(client)]));

  it('checks restore status', () => {
    return client.backup
      .restoreStatusGetter()
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then((restoreStatusResponse: BackupRestoreStatusResponse) => {
        expect(restoreStatusResponse.id).toBe(BACKUP_ID);
        expect(restoreStatusResponse.path).toBe(`${DOCKER_COMPOSE_BACKUPS_DIR}/${BACKUP_ID}`);
        expect(restoreStatusResponse.backend).toBe(BACKEND);
        expect(restoreStatusResponse.status).toBe('SUCCESS');
        expect(restoreStatusResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on restore status: ' + err);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fail creating backup for not existing class', () => {
  const CLASS_NAME = 'not-existing-class';
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('fails creating', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then(() => {
        throw new Error('should fail on create backup');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain(CLASS_NAME);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fail restoring backup for existing class', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .catch((err: Error) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('fails restoring', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .then((resp: BackupRestoreResponse) => {
        expect(resp.error).toContain('already exists');
        expect(resp.error).toContain(PIZZA_CLASS_NAME);
        expect(resp.status).toBe('FAILED');
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fail creating existing backup', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .catch((err: Error) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('fails creating', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then(() => {
        throw new Error('should fail on create backup');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain(BACKUP_ID);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fail checking create status for not existing backup', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('fails checking create status', () => {
    return client.backup
      .createStatusGetter()
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then(() => {
        throw new Error('should fail on create status');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('404');
        expect(err.message).toContain(BACKUP_ID);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fail restoring not existing backup', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('fails restoring', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then(() => {
        throw new Error('should fail on restore backup');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('404');
        expect(err.message).toContain(BACKUP_ID);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fail checking restore status for not started restore', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .catch((err: Error) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('fails checking restore status', () => {
    return client.backup
      .restoreStatusGetter()
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then(() => {
        throw new Error('should fail on restore status');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('404');
        expect(err.message).toContain(BACKUP_ID);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fail creating backup for both include and exclude classes', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('fails creating backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withExcludeClassNames(SOUP_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .then(() => {
        throw new Error('should fail on create');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('include');
        expect(err.message).toContain('exclude');
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fail restoring backup for both include and exclude classes', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME, SOUP_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .catch((err: Error) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('removes existing class', () => {
    return client.schema
      .classDeleter()
      .withClassName(PIZZA_CLASS_NAME)
      .do()
      .catch((err: Error) => {
        throw new Error('should not fail on class delete: ' + err);
      });
  });

  it('fails restoring backup', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withExcludeClassNames(SOUP_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then(() => {
        throw new Error('should fail on restore');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('include');
        expect(err.message).toContain('exclude');
      });
  });

  it('cleans up', () => cleanupTestFood(client).catch(() => Promise.resolve('ignore not exising Pizza')));
});

describe('creates backup with valid compression config values', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME, SOUP_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .withConfig({
        CPUPercentage: 80,
        ChunkSize: 512,
        CompressionLevel: 'BestSpeed',
      })
      .do()
      .catch((err: Error) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fails creating backup with invalid compression config', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('fails creating backup with CPUPercentage too high', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withConfig({
        CPUPercentage: 81, // Max is 80
      })
      .do()
      .then(() => {
        throw new Error('should fail on create backup');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('CPUPercentage');
      });
  });

  it('fails creating backup with CPUPercentage too low', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withConfig({
        CPUPercentage: -1,
      })
      .do()
      .then(() => {
        throw new Error('should fail on create backup');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('CPUPercentage');
      });
  });

  it('fails creating backup with ChunkSize too high', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withConfig({
        ChunkSize: 513, // Max is 512
      })
      .do()
      .then(() => {
        throw new Error('should fail on create backup');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('ChunkSize');
      });
  });

  it('fails creating backup with ChunkSize too low', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withConfig({
        ChunkSize: 1, // Min is 2
      })
      .do()
      .then(() => {
        throw new Error('should fail on create backup');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('ChunkSize');
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('restores backup with valid compression config values', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('asserts data exist', () => assertThatAllPizzasExist(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .catch((err: any) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('removes existing class', () => {
    return client.schema
      .classDeleter()
      .withClassName(PIZZA_CLASS_NAME)
      .do()
      .catch((err: any) => {
        throw new Error('should not fail on class delete: ' + err);
      });
  });

  it('restores backup', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .withConfig({
        CPUPercentage: 80,
      })
      .do()
      .then((restoreResponse: BackupRestoreResponse) => {
        expect(restoreResponse.status).toBe('SUCCESS');
        expect(restoreResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on restore backup: ' + err);
      });
  });

  it('asserts data again exist', () => assertThatAllPizzasExist(client));

  it('checks restore status', () => {
    return client.backup
      .restoreStatusGetter()
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .do()
      .then((restoreStatusResponse: BackupRestoreStatusResponse) => {
        expect(restoreStatusResponse.status).toBe('SUCCESS');
        expect(restoreStatusResponse.error).toBeUndefined();
      })
      .catch((err: Error) => {
        throw new Error('should not fail on restore status: ' + err);
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

describe('fails restoring backup with invalid compression config', () => {
  const BACKEND: Backend = 'filesystem';
  const BACKUP_ID = randomBackupId();

  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up', () => createTestFoodSchemaAndData(client));

  it('asserts data exist', () => assertThatAllPizzasExist(client));

  it('creates backup', () => {
    return client.backup
      .creator()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withWaitForCompletion(true)
      .do()
      .catch((err: any) => {
        throw new Error('should not fail on create backup: ' + err);
      });
  });

  it('removes existing class', () => {
    return client.schema
      .classDeleter()
      .withClassName(PIZZA_CLASS_NAME)
      .do()
      .catch((err: any) => {
        throw new Error('should not fail on class delete: ' + err);
      });
  });

  it('fails restoring backup with too high CPUPercentage', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withExcludeClassNames(SOUP_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withConfig({
        CPUPercentage: 81, // Max is 80
      })
      .do()
      .then(() => {
        throw new Error('should fail on restore');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('CPUPercentage');
      });
  });

  it('fails restoring backup with too low CPUPercentage', () => {
    return client.backup
      .restorer()
      .withIncludeClassNames(PIZZA_CLASS_NAME)
      .withExcludeClassNames(SOUP_CLASS_NAME)
      .withBackend(BACKEND)
      .withBackupId(BACKUP_ID)
      .withConfig({
        CPUPercentage: -1,
      })
      .do()
      .then(() => {
        throw new Error('should fail on restore');
      })
      .catch((err: Error) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('CPUPercentage');
      });
  });

  it('cleans up', () => cleanupTestFood(client));
});

// describe("get all exising backups", () => {
//   const BACKEND: Backend = 'filesystem';
//   const BACKUP_ID = randomBackupId()
//   const BACKUP_ID_PIZZA = BACKUP_ID + "-pizza";
//   const BACKUP_ID_SOUP = BACKUP_ID + "-soup";

//   const client = weaviate.client({
//     scheme: "http",
//     host: "localhost:8080",
//   });

//   it("sets up", () => createTestFoodSchemaAndData(client));

//   it("creates backup pizza", () => {
//     return client.backup.creator()
//       .withIncludeClassNames(PIZZA_CLASS_NAME)
//       .withBackend(BACKEND)
//       .withBackupId(BACKUP_ID_PIZZA)
//       .withWaitForCompletion(true)
//       .do()
//       .catch((err: any) => {throw new Error("should not fail on create backup: " + err)});
//   });

//   it("creates backup soup", () => {
//     return client.backup.creator()
//       .withIncludeClassNames(SOUP_CLASS_NAME)
//       .withBackend(BACKEND)
//       .withBackupId(BACKUP_ID_SOUP)
//       .withWaitForCompletion(true)
//       .do()
//       .catch((err: any) => {throw new Error("should not fail on create backup: " + err)});
//   });

//   it("get all", () => {
//     return client.backup.getter()
//       .withBackend(BACKEND)
//       .do()
//       .then(allResponse => {
//         expect(allResponse).toHaveLength(2);
//         expect(allResponse).toEqual(expect.arrayContaining([
//           expect.objectContaining({id: BACKUP_ID_PIZZA}),
//           expect.objectContaining({id: BACKUP_ID_SOUP}),
//         ]));
//       })
//       .catch((err: any) => {throw new Error("should not fail on getting all: " + err)});
//   });

//   it("cleans up", () => cleanupTestFood(client));
// });

function assertThatAllPizzasExist(client: WeaviateClient) {
  return assertThatAllFoodObjectsExist(client, 'Pizza', 4);
}

function assertThatAllSoupsExist(client: WeaviateClient) {
  return assertThatAllFoodObjectsExist(client, 'Soup', 2);
}

function assertThatAllFoodObjectsExist(client: WeaviateClient, className: string, number: number) {
  return client.graphql
    .get()
    .withClassName(className)
    .withFields('name')
    .do()
    .then((data) => expect(data.data.Get[className].length).toBe(number))
    .catch((err: any) => {
      throw new Error(number + ' objects should exist: ' + err);
    });
}

function randomBackupId() {
  return 'backup-id-' + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
}



---
File: /src/backup/validation.ts
---

import { isValidStringProperty } from '../validation/string.js';

export function validateIncludeClassNames(classNames?: string[]) {
  if (Array.isArray(classNames)) {
    const errors: any[] = [];
    classNames.forEach((className) => {
      if (!isValidStringProperty(className)) {
        errors.push('string className invalid - set with .withIncludeClassNames(...classNames)');
      }
    });
    return errors;
  }
  if (classNames !== null && classNames !== undefined) {
    return ['strings classNames invalid - set with .withIncludeClassNames(...classNames)'];
  }
  return [];
}

export function validateExcludeClassNames(classNames?: string[]) {
  if (Array.isArray(classNames)) {
    const errors: any[] = [];
    classNames.forEach((className) => {
      if (!isValidStringProperty(className)) {
        errors.push('string className invalid - set with .withExcludeClassNames(...classNames)');
      }
    });
    return errors;
  }
  if (classNames !== null && classNames !== undefined) {
    return ['strings classNames invalid - set with .withExcludeClassNames(...classNames)'];
  }
  return [];
}

export function validateBackend(backend?: string) {
  if (!isValidStringProperty(backend)) {
    return ['string backend must set - set with .withBackend(backend)'];
  }
  return [];
}

export function validateBackupId(backupId?: string) {
  if (!isValidStringProperty(backupId)) {
    return ['string backupId must be set - set with .withBackupId(backupId)'];
  }
  return [];
}



---
File: /src/batch/index.ts
---

import Connection from '../connection/index.js';
import { BeaconPath } from '../utils/beaconPath.js';
import { DbVersionSupport } from '../utils/dbVersion.js';
import ObjectsBatchDeleter from './objectsBatchDeleter.js';
import ObjectsBatcher from './objectsBatcher.js';
import ReferencePayloadBuilder from './referencePayloadBuilder.js';
import ReferencesBatcher from './referencesBatcher.js';

export type DeleteOutput = 'verbose' | 'minimal';
export type DeleteResultStatus = 'SUCCESS' | 'FAILED' | 'DRYRUN';

export interface Batch {
  objectsBatcher: () => ObjectsBatcher;
  objectsBatchDeleter: () => ObjectsBatchDeleter;
  referencesBatcher: () => ReferencesBatcher;
  referencePayloadBuilder: () => ReferencePayloadBuilder;
}

const batch = (client: Connection, dbVersionSupport: DbVersionSupport): Batch => {
  const beaconPath = new BeaconPath(dbVersionSupport);

  return {
    objectsBatcher: () => new ObjectsBatcher(client),
    objectsBatchDeleter: () => new ObjectsBatchDeleter(client),
    referencesBatcher: () => new ReferencesBatcher(client, beaconPath),
    referencePayloadBuilder: () => new ReferencePayloadBuilder(client),
  };
};

export default batch;
export { default as ObjectsBatchDeleter } from './objectsBatchDeleter.js';
export { default as ObjectsBatcher } from './objectsBatcher.js';
export { default as ReferencesBatcher } from './referencesBatcher.js';



---
File: /src/batch/journey.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import {
  BatchDeleteResponse,
  BatchReference,
  BatchReferenceResponse,
  Tenant,
  WeaviateClass,
  WeaviateObject,
} from '../openapi/types.js';
import weaviate, { WeaviateClient } from '../v2/index.js';

const thingClassName = 'BatchJourneyTestThing';
const otherThingClassName = 'BatchJourneyTestOtherThing';

const thingIds = [
  'c25365bd-276b-4d88-9d8f-9e924701aa89',
  'e0754de5-1458-4814-b21f-382a77b5d64b',
  '5c345f46-c3c4-4f42-8ad6-65c6c60840b4',
  '5f4b0aa2-0704-4529-919f-c1f614e685f4',
];

const otherThingIds = ['5b354a0f-fe66-4fe7-ad62-4db72ddab815', '8727fa2b-610a-4a5c-af26-e558943f71c7'];

const someObjects: WeaviateObject[] = [
  {
    class: thingClassName,
    id: thingIds[0],
    properties: { stringProp: 'foo1' },
  },
  {
    class: thingClassName,
    id: thingIds[1],
    properties: { stringProp: 'bar1' },
  },
  {
    class: thingClassName,
    id: thingIds[2],
    properties: { stringProp: 'foo2' },
  },
  {
    class: thingClassName,
    id: thingIds[3],
    properties: { stringProp: 'bar2' },
  },
  {
    class: otherThingClassName,
    id: otherThingIds[0],
    properties: { stringProp: 'foo3' },
  },
  {
    class: otherThingClassName,
    id: otherThingIds[1],
    properties: { stringProp: 'bar3' },
  },
];

const someReferences = [
  {
    from: `weaviate://localhost/${thingClassName}/${thingIds[0]}/refProp`,
    to: `weaviate://localhost/${otherThingClassName}/${otherThingIds[0]}`,
  },
  {
    from: `weaviate://localhost/${thingClassName}/${thingIds[1]}/refProp`,
    to: `weaviate://localhost/${otherThingClassName}/${otherThingIds[1]}`,
  },
  {
    from: `weaviate://localhost/${thingClassName}/${thingIds[2]}/refProp`,
    to: `weaviate://localhost/${otherThingClassName}/${otherThingIds[1]}`,
  },
  {
    from: `weaviate://localhost/${thingClassName}/${thingIds[3]}/refProp`,
    to: `weaviate://localhost/${otherThingClassName}/${otherThingIds[1]}`,
  },
];

describe('batch importing', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('can add objects with different methods', () => {
    const batcher = client.batch
      .objectsBatcher()
      .withObject(someObjects[0])
      .withObjects(someObjects[1])
      .withObjects(someObjects[2], someObjects[3])
      .withObjects(...[someObjects[4], someObjects[5]]);

    expect(batcher.objects).toHaveLength(someObjects.length);
    batcher.objects.forEach((obj: WeaviateObject, i: number) => {
      expect(obj.class).toBe(someObjects[i].class);
      expect(obj.id).toBe(someObjects[i].id);
    });
  });

  it('sets up', () => setup(client));

  describe('import thing objects', () => {
    describe('hand assembling the objects', () => {
      const toImport = [
        {
          class: thingClassName,
          id: thingIds[0],
          properties: { stringProp: 'foo' },
        },
        {
          class: thingClassName,
          id: thingIds[1],
          properties: { stringProp: 'bar' },
        },
      ];

      it('imports them', () => {
        client.batch
          .objectsBatcher()
          .withObject(toImport[0])
          .withObject(toImport[1])
          .do()
          .then()
          .catch((e: Error) => {
            throw new Error('it should not have errord ' + e);
          });
      });

      it('waits for es index refresh', () => {
        return new Promise((resolve) => setTimeout(resolve, 1000));
      });

      it('verifies they are now queryable', () => {
        return Promise.all([
          client.data.getterById().withId(thingIds[0]).withClassName(thingClassName).do(),
          client.data.getterById().withId(thingIds[1]).withClassName(thingClassName).do(),
        ]).catch((e: Error) => {
          throw new Error('it should not have errord ' + e);
        });
      });
    });

    describe('using the thing builder to assemble the objects', () => {
      const toImport = [
        client.data
          .creator()
          .withClassName(thingClassName)
          .withId(thingIds[2])
          .withProperties({ stringProp: 'foo' })
          .payload(), // note the .payload(), not .do()!
        client.data
          .creator()
          .withClassName(thingClassName)
          .withId(thingIds[3])
          .withProperties({ stringProp: 'foo' })
          .payload(), // note the .payload(), not .do()!
      ];

      it('imports them', () => {
        client.batch
          .objectsBatcher()
          .withObjects(toImport[0], toImport[1])
          .do()
          .then()
          .catch((e: any) => {
            throw new Error('it should not have errord ' + e);
          });
      });

      it('waits for es index refresh', () => {
        return new Promise((resolve) => setTimeout(resolve, 1000));
      });

      it('verifies they are now queryable', () => {
        return Promise.all([
          client.data.getterById().withId(thingIds[2]).withClassName(thingClassName).do(),
          client.data.getterById().withId(thingIds[3]).withClassName(thingClassName).do(),
        ]).catch((e: any) => {
          throw new Error('it should not have errord ' + e);
        });
      });
    });
  });

  describe('import other thing objects', () => {
    describe('hand assembling the objects', () => {
      const toImport = [
        {
          class: otherThingClassName,
          id: otherThingIds[0],
          properties: { stringProp: 'foo' },
        },
        {
          class: otherThingClassName,
          id: otherThingIds[1],
          properties: { stringProp: 'bar' },
        },
      ];

      it('imports them with consistency level', () => {
        client.batch
          .objectsBatcher()
          .withConsistencyLevel('ONE')
          .withObjects(...[toImport[0], toImport[1]])
          .do()
          .then()
          .catch((e: any) => {
            throw new Error('it should not have errord ' + e);
          });
      });

      it('waits for es index refresh', () => {
        return new Promise((resolve) => setTimeout(resolve, 1000));
      });

      it('verifies they are now queryable', () => {
        return Promise.all([
          client.data.getterById().withId(toImport[0].id).withClassName(toImport[0].class).do(),
          client.data.getterById().withId(toImport[1].id).withClassName(toImport[1].class).do(),
        ]).catch((e: any) => {
          throw new Error('it should not have errord ' + e);
        });
      });
    });
  });

  describe('batch reference between the thing and otherThing objects', () => {
    it('can add references with different methods', () => {
      const batcher = client.batch
        .referencesBatcher()
        .withReference(someReferences[0])
        .withReferences(someReferences[1], someReferences[2])
        .withReferences(...[someReferences[3]]);

      expect(batcher.references).toHaveLength(someReferences.length);
      batcher.references.forEach((ref: BatchReference, i: number) => {
        expect(ref.from).toBe(someReferences[i].from);
        expect(ref.to).toBe(someReferences[i].to);
      });
    });

    it('imports the refs with raw objects and consistency level', () => {
      return client.batch
        .referencesBatcher()
        .withReference({
          from: `weaviate://localhost/${thingClassName}/${thingIds[0]}/refProp`,
          to: `weaviate://localhost/${otherThingClassName}/${otherThingIds[0]}`,
        })
        .withReference({
          from: `weaviate://localhost/${thingClassName}/${thingIds[1]}/refProp`,
          to: `weaviate://localhost/${otherThingClassName}/${otherThingIds[1]}`,
        })
        .withConsistencyLevel('ALL')
        .do()
        .then((res: BatchReferenceResponse[]) => {
          res.forEach((elem: BatchReferenceResponse) => {
            expect(elem.result!.errors).toBeUndefined();
          });
        })
        .catch((e: any) => {
          throw new Error('it should not have errord ' + e);
        });
    });

    it('imports more refs with a builder pattern', () => {
      const reference1 = client.batch
        .referencePayloadBuilder()
        .withFromClassName(thingClassName)
        .withFromRefProp('refProp')
        .withFromId(thingIds[2])
        .withToId(otherThingIds[0])
        .withToClassName(otherThingClassName)
        .payload();
      const reference2 = client.batch
        .referencePayloadBuilder()
        .withFromClassName(thingClassName)
        .withFromRefProp('refProp')
        .withFromId(thingIds[3])
        .withToId(otherThingIds[1])
        .withToClassName(otherThingClassName)
        .payload();
      return client.batch
        .referencesBatcher()
        .withReferences(reference1, reference2)
        .do()
        .then((res: BatchReferenceResponse[]) => {
          res.forEach((elem: BatchReferenceResponse) => {
            expect(elem.result!.errors).toBeUndefined();
          });
        })
        .catch((e: any) => {
          throw new Error('it should not have errord ' + e);
        });
    });

    it('waits for es index refresh', () => {
      return new Promise((resolve) => setTimeout(resolve, 1000));
    });

    it('verifies the refs are now set', () => {
      return Promise.all([
        client.data
          .getterById()
          .withId(thingIds[0])
          .withClassName(thingClassName)
          .do()
          .then((res: any) => {
            expect(res.properties.refProp[0].beacon).toEqual(
              `weaviate://localhost/${otherThingClassName}/${otherThingIds[0]}`
            );
          }),
        client.data
          .getterById()
          .withId(thingIds[1])
          .withClassName(thingClassName)
          .do()
          .then((res: any) => {
            expect(res.properties.refProp[0].beacon).toEqual(
              `weaviate://localhost/${otherThingClassName}/${otherThingIds[1]}`
            );
          }),
        client.data
          .getterById()
          .withId(thingIds[2])
          .withClassName(thingClassName)
          .do()
          .then((res: any) => {
            expect(res.properties.refProp[0].beacon).toEqual(
              `weaviate://localhost/${otherThingClassName}/${otherThingIds[0]}`
            );
          }),
        client.data
          .getterById()
          .withId(thingIds[3])
          .withClassName(thingClassName)
          .do()
          .then((res: any) => {
            expect(res.properties.refProp[0].beacon).toEqual(
              `weaviate://localhost/${otherThingClassName}/${otherThingIds[1]}`
            );
          }),
      ]).catch((e: any) => {
        throw new Error('it should not have errord ' + e);
      });
    });
  });

  it('tears down and cleans up', () => cleanup(client));
});

describe('batch deleting', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('sets up schema', () => setup(client));
  it('sets up data', () => setupData(client));

  it('batch deletes with dryRun and verbose output', () =>
    client.batch
      .objectsBatchDeleter()
      .withClassName(thingClassName)
      .withWhere({
        operator: 'Equal',
        valueText: 'bar1',
        path: ['stringProp'],
      })
      .withDryRun(true)
      .withOutput('verbose')
      .do()
      .then((result: any) => {
        expect(result.dryRun).toBe(true);
        expect(result.output).toBe('verbose');
        expect(result.match).toEqual({
          class: thingClassName,
          where: {
            operands: null,
            operator: 'Equal',
            valueText: 'bar1',
            path: ['stringProp'],
          },
        });
        expect(result.results).toEqual({
          successful: 0,
          failed: 0,
          matches: 1,
          limit: 10000,
          objects: [
            {
              id: thingIds[1],
              status: 'DRYRUN',
            },
          ],
        });
      }));

  it('batch deletes with dryRun and minimal output', () =>
    client.batch
      .objectsBatchDeleter()
      .withClassName(otherThingClassName)
      .withWhere({
        operator: 'Like',
        valueText: 'foo3',
        path: ['stringProp'],
      })
      .withDryRun(true)
      .withOutput('minimal')
      .do()
      .then((result: BatchDeleteResponse) => {
        expect(result.dryRun).toBe(true);
        expect(result.output).toBe('minimal');
        expect(result.match).toEqual({
          class: otherThingClassName,
          where: {
            operands: null,
            operator: 'Like',
            valueText: 'foo3',
            path: ['stringProp'],
          },
        });
        expect(result.results).toEqual({
          successful: 0,
          failed: 0,
          matches: 1,
          limit: 10000,
          objects: null,
        });
      }));

  it('batch deletes but no matches with default dryRun and output', () =>
    client.batch
      .objectsBatchDeleter()
      .withClassName(otherThingClassName)
      .withWhere({
        operator: 'Equal',
        valueText: 'doesNotExist',
        path: ['stringProp'],
      })
      .do()
      .then((result: any) => {
        expect(result.dryRun).toBe(false);
        expect(result.output).toBe('minimal');
        expect(result.match).toEqual({
          class: otherThingClassName,
          where: {
            operands: null,
            operator: 'Equal',
            valueText: 'doesNotExist',
            path: ['stringProp'],
          },
        });
        expect(result.results).toEqual({
          successful: 0,
          failed: 0,
          matches: 0,
          limit: 10000,
          objects: null,
        });
      }));

  it('batch deletes with default dryRun and consistency level', () => {
    const inAMinute = '' + (new Date().getTime() + 60 * 1000);
    return client.batch
      .objectsBatchDeleter()
      .withClassName(otherThingClassName)
      .withWhere({
        operator: 'LessThan',
        valueText: inAMinute,
        path: ['_creationTimeUnix'],
      })
      .withOutput('verbose')
      .withConsistencyLevel('QUORUM')
      .do()
      .then((result: any) => {
        expect(result.dryRun).toBe(false);
        expect(result.output).toBe('verbose');
        expect(result.match).toEqual({
          class: otherThingClassName,
          where: {
            operands: null,
            operator: 'LessThan',
            valueText: inAMinute,
            path: ['_creationTimeUnix'],
          },
        });
        expect(result.results.successful).toBe(2);
        expect(result.results.failed).toBe(0);
        expect(result.results.matches).toBe(2);
        expect(result.results.limit).toBe(10000);
        expect(result.results.objects).toHaveLength(2);
        expect(result.results.objects).toContainEqual({
          id: otherThingIds[0],
          status: 'SUCCESS',
        });
        expect(result.results.objects).toContainEqual({
          id: otherThingIds[1],
          status: 'SUCCESS',
        });
      });
  });

  it('tears down and cleans up', () => cleanup(client));
});

describe('multi tenancy', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  const passageClassName = 'Passage';
  const passage: WeaviateClass = {
    class: passageClassName,
    properties: [
      {
        name: 'content',
        dataType: ['text'],
      },
    ],
    multiTenancyConfig: { enabled: true },
  };

  const tenants: Array<Tenant> = [{ name: 'tenantA' }, { name: 'tenantB' }];
  const passageIDs = [
    '00000000-0000-0000-0000-000000000001',
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000003',
  ];
  const txts = [
    'A generative adversarial network (GAN) is a class of machine learning frameworks designed by Ian Goodfellow and his colleagues in June 2014.',
    'OpenAI is an American artificial intelligence (AI) research laboratory consisting of the non-profit OpenAI Incorporated and its for-profit subsidiary corporation OpenAI Limited Partnership.',
    'The Space Exploration Technologies Corporation, commonly referred to as SpaceX is an American spacecraft manufacturer, launcher, and satellite communications company headquartered in Hawthorne, California.',
  ];

  it('create Passage class', () => {
    return client.schema
      .classCreator()
      .withClass(passage)
      .do()
      .then((res) => {
        expect(res).toBeDefined();
        expect(res.class).toBe(passageClassName);
      })
      .catch((e) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('creates Passage class tenants', () => {
    return client.schema
      .tenantsCreator(passageClassName, tenants)
      .do()
      .then((res) => {
        expect(res).toHaveLength(2);
      })
      .catch((e) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('gets Passage class tenants', () => {
    return client.schema
      .tenantsGetter(passageClassName)
      .do()
      .then((res) => {
        expect(res).toHaveLength(2);
      })
      .catch((e) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('updates Passage class tenants (deactivates)', () => {
    return client.schema
      .tenantsUpdater(passageClassName, [
        { name: tenants[0].name, activityStatus: 'COLD' },
        { name: tenants[1].name, activityStatus: 'COLD' },
      ])
      .do()
      .then((res) => {
        expect(res).toHaveLength(2);
      })
      .catch((e) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('does not get objects due to inactivity', () => {
    return client.data
      .getter()
      .withClassName(passageClassName)
      .withTenant(tenants[0].name!)
      .do()
      .then(() => {
        throw new Error('should fail on data get');
      })
      .catch((err) => {
        expect(err.message).toContain('422');
        expect(err.message).toContain('tenant not active');
      });
  });

  it('updates Passage class tenants (activates again)', () => {
    return client.schema
      .tenantsUpdater(passageClassName, [
        { name: tenants[0].name, activityStatus: 'HOT' },
        { name: tenants[1].name, activityStatus: 'HOT' },
      ])
      .do()
      .then((res) => {
        expect(res).toHaveLength(2);
      })
      .catch((e) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('should batch import Passage objects', () => {
    const toImport: WeaviateObject[] = [];
    for (let i = 0; i < passageIDs.length; i++) {
      toImport.push({
        class: passageClassName,
        id: passageIDs[i],
        properties: { content: txts[i] },
        tenant: tenants[0].name!,
      });
    }
    return client.batch
      .objectsBatcher()
      .withObjects(...toImport)
      .do()
      .then((res) => {
        expect(res).toHaveLength(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('should get 3 Passage objects', () => {
    return client.data
      .getter()
      .withClassName(passageClassName)
      .withTenant(tenants[0].name!)
      .do()
      .then((res) => {
        expect(res).toBeDefined();
        expect(res.objects).toBeDefined();
        expect(res.objects).toHaveLength(3);
      })
      .catch((e) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('should not batch delete without tenant parameter', () => {
    return client.batch
      .objectsBatchDeleter()
      .withClassName(passageClassName)
      .withWhere({
        operator: 'Equal',
        valueText: passageIDs[0],
        path: ['id'],
      })
      .withOutput('verbose')
      .withDryRun(false)
      .do()
      .catch((e: any) => {
        expect(e).toBeDefined();
      });
  });

  it('batch delete with 1 tenant', () => {
    return client.batch
      .objectsBatchDeleter()
      .withClassName(passageClassName)
      .withWhere({
        operator: 'Equal',
        valueText: passageIDs[0],
        path: ['id'],
      })
      .withTenant(tenants[0].name!)
      .withOutput('verbose')
      .withDryRun(false)
      .do()
      .then((result: any) => {
        expect(result.dryRun).toBe(false);
        expect(result.output).toBe('verbose');
        expect(result.match).toEqual({
          class: passageClassName,
          where: {
            operands: null,
            operator: 'Equal',
            valueText: passageIDs[0],
            path: ['id'],
          },
        });
        expect(result.results.successful).toBe(1);
        expect(result.results.failed).toBe(0);
        expect(result.results.matches).toBe(1);
        expect(result.results.limit).toBe(10000);
        expect(result.results.objects).toHaveLength(1);
        expect(result.results.objects).toContainEqual({
          id: passageIDs[0],
          status: 'SUCCESS',
        });
      })
      .catch((e: any) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('should get only 2 Passage objects', () => {
    return client.data
      .getter()
      .withClassName(passageClassName)
      .withTenant(tenants[0].name!)
      .do()
      .then((res) => {
        expect(res).toBeDefined();
        expect(res.objects).toBeDefined();
        expect(res.objects).toHaveLength(2);
      })
      .catch((e) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('should remove Passage class', () => {
    return client.schema.classDeleter().withClassName(passageClassName).do();
  });
});

const setup = async (client: WeaviateClient) => {
  // first import the classes
  await Promise.all([
    client.schema
      .classCreator()
      .withClass({
        class: thingClassName,
        properties: [
          {
            name: 'stringProp',
            dataType: ['string'],
          },
        ],
      })
      .do(),
    client.schema
      .classCreator()
      .withClass({
        class: otherThingClassName,
        properties: [
          {
            name: 'stringProp',
            dataType: ['string'],
          },
        ],
        invertedIndexConfig: {
          indexTimestamps: true,
        },
      })
      .do(),
  ]);

  // now set a link from thing to otherThing class, so we can batch import
  // references

  return client.schema
    .propertyCreator()
    .withClassName(thingClassName)
    .withProperty({ name: 'refProp', dataType: [otherThingClassName] })
    .do();
};

const setupData = (client: WeaviateClient) => {
  return client.batch
    .objectsBatcher()
    .withObjects(...someObjects)
    .do();
};

const cleanup = (client: WeaviateClient) =>
  Promise.all([
    client.schema.classDeleter().withClassName(thingClassName).do(),
    client.schema.classDeleter().withClassName(otherThingClassName).do(),
  ]);



---
File: /src/batch/objectsBatchDeleter.ts
---

import Connection from '../connection/index.js';
import { ConsistencyLevel } from '../data/replication.js';
import { BatchDelete, BatchDeleteResponse, WhereFilter } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';
import { DeleteOutput } from './index.js';
import { buildObjectsPath } from './path.js';

export default class ObjectsBatchDeleter extends CommandBase {
  private className?: string;
  private consistencyLevel?: ConsistencyLevel;
  private dryRun?: boolean;
  private output?: DeleteOutput;
  private whereFilter?: WhereFilter;
  private tenant?: string;

  constructor(client: Connection) {
    super(client);
  }

  withClassName(className: string) {
    this.className = className;
    return this;
  }

  withWhere(whereFilter: WhereFilter) {
    this.whereFilter = whereFilter;
    return this;
  }

  withOutput(output: DeleteOutput) {
    this.output = output;
    return this;
  }

  withDryRun(dryRun: boolean) {
    this.dryRun = dryRun;
    return this;
  }

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  withTenant(tenant: string) {
    this.tenant = tenant;
    return this;
  }

  payload = (): BatchDelete => {
    return {
      match: {
        class: this.className,
        where: this.whereFilter,
      },
      output: this.output,
      dryRun: this.dryRun,
    };
  };

  validateClassName = (): void => {
    if (!isValidStringProperty(this.className)) {
      this.addError('string className must be set - set with .withClassName(className)');
    }
  };

  validateWhereFilter = (): void => {
    if (typeof this.whereFilter != 'object') {
      this.addError('object where must be set - set with .withWhere(whereFilter)');
    }
  };

  validate = (): void => {
    this.validateClassName();
    this.validateWhereFilter();
  };

  do = (): Promise<BatchDeleteResponse> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const params = new URLSearchParams();
    if (this.consistencyLevel) {
      params.set('consistency_level', this.consistencyLevel);
    }
    if (this.tenant) {
      params.set('tenant', this.tenant);
    }
    const path = buildObjectsPath(params);
    return this.client.delete(path, this.payload(), true);
  };
}



---
File: /src/batch/objectsBatcher.ts
---

import Connection from '../connection/index.js';
import { ConsistencyLevel } from '../data/replication.js';
import { BatchRequest, WeaviateObject, WeaviateObjectsGet } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { buildObjectsPath } from './path.js';

export default class ObjectsBatcher extends CommandBase {
  private consistencyLevel?: ConsistencyLevel;
  public objects: WeaviateObject[];

  constructor(client: Connection) {
    super(client);
    this.objects = [];
  }

  /**
   * can be called as:
   *  - withObjects(...[obj1, obj2, obj3])
   *  - withObjects(obj1, obj2, obj3)
   *  - withObjects(obj1)
   * @param  {...WeaviateObject[]} objects
   */
  withObjects(...objects: WeaviateObject[]) {
    let objs = objects;
    if (objects.length && Array.isArray(objects[0])) {
      objs = objects[0];
    }
    this.objects = [...this.objects, ...objs];
    return this;
  }

  withObject(object: WeaviateObject) {
    return this.withObjects(object);
  }

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  payload = (): BatchRequest => ({
    objects: this.objects,
  });

  validateObjectCount = (): void => {
    if (this.objects.length == 0) {
      this.addError('need at least one object to send a request, add one with .withObject(obj)');
    }
  };

  validate = (): void => {
    this.validateObjectCount();
  };

  do = (): Promise<WeaviateObjectsGet[]> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const params = new URLSearchParams();
    if (this.consistencyLevel) {
      params.set('consistency_level', this.consistencyLevel);
    }
    const path = buildObjectsPath(params);
    return this.client.postReturn(path, this.payload());
  };
}



---
File: /src/batch/path.test.ts
---

import { buildObjectsPath, buildRefsPath } from './path.js';

describe('paths', () => {
  it('builds batch objects without params', () => {
    const path = buildObjectsPath(new URLSearchParams());
    expect(path).toEqual('/batch/objects');
  });

  it('builds batch objects with params', () => {
    const path = buildObjectsPath(
      new URLSearchParams({
        consistency_level: 'ONE',
      })
    );
    expect(path).toEqual('/batch/objects?consistency_level=ONE');
  });

  it('builds batch references without params', () => {
    const path = buildRefsPath(new URLSearchParams());
    expect(path).toEqual('/batch/references');
  });

  it('builds batch object with params', () => {
    const path = buildRefsPath(
      new URLSearchParams({
        consistency_level: 'ONE',
      })
    );
    expect(path).toEqual('/batch/references?consistency_level=ONE');
  });
});



---
File: /src/batch/path.ts
---

export function buildObjectsPath(queryParams: any): string {
  const path = '/batch/objects';
  return buildPath(path, queryParams);
}

export function buildRefsPath(queryParams: any): string {
  const path = '/batch/references';
  return buildPath(path, queryParams);
}

function buildPath(path: string, queryParams: any): string {
  if (queryParams && queryParams.toString() != '') {
    path = `${path}?${queryParams.toString()}`;
  }
  return path;
}



---
File: /src/batch/referencePayloadBuilder.ts
---

import Connection from '../connection/index.js';
import { BatchReference } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class ReferencesBatcher extends CommandBase {
  private fromClassName?: string;
  private fromId?: string;
  private fromRefProp?: string;
  private toClassName?: string;
  private toId?: string;

  constructor(client: Connection) {
    super(client);
  }

  withFromId = (id: string) => {
    this.fromId = id;
    return this;
  };

  withToId = (id: string) => {
    this.toId = id;
    return this;
  };

  withFromClassName = (className: string) => {
    this.fromClassName = className;
    return this;
  };

  withFromRefProp = (refProp: string) => {
    this.fromRefProp = refProp;
    return this;
  };

  withToClassName(className: string) {
    this.toClassName = className;
    return this;
  }

  validateIsSet = (prop: string | undefined | null, name: string, setter: string): void => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = (): void => {
    this.validateIsSet(this.fromId, 'fromId', '.withFromId(id)');
    this.validateIsSet(this.toId, 'toId', '.withToId(id)');
    this.validateIsSet(this.fromClassName, 'fromClassName', '.withFromClassName(className)');
    this.validateIsSet(this.fromRefProp, 'fromRefProp', '.withFromRefProp(refProp)');
  };

  payload = (): BatchReference => {
    this.validate();
    if (this.errors.length > 0) {
      throw new Error(this.errors.join(', '));
    }

    let beaconTo = `weaviate://localhost`;
    if (isValidStringProperty(this.toClassName)) {
      beaconTo = `${beaconTo}/${this.toClassName}`;
    }

    return {
      from: `weaviate://localhost/${this.fromClassName}/${this.fromId}/${this.fromRefProp}`,
      to: `${beaconTo}/${this.toId}`,
    };
  };

  do = (): Promise<any> => {
    return Promise.reject(new Error('Should never be called'));
  };
}



---
File: /src/batch/referencesBatcher.ts
---

import Connection from '../connection/index.js';
import { ConsistencyLevel } from '../data/replication.js';
import { BatchReference, BatchReferenceResponse } from '../openapi/types.js';
import { BeaconPath } from '../utils/beaconPath.js';
import { CommandBase } from '../validation/commandBase.js';
import { buildRefsPath } from './path.js';

export default class ReferencesBatcher extends CommandBase {
  private beaconPath: BeaconPath;
  private consistencyLevel?: ConsistencyLevel;
  public references: BatchReference[];

  constructor(client: Connection, beaconPath: BeaconPath) {
    super(client);
    this.beaconPath = beaconPath;
    this.references = [];
  }

  /**
   * can be called as:
   *  - withReferences(...[ref1, ref2, ref3])
   *  - withReferences(ref1, ref2, ref3)
   *  - withReferences(ref1)
   * @param  {...BatchReference[]} references
   */
  withReferences(...references: BatchReference[]) {
    let refs = references;
    if (references.length && Array.isArray(references[0])) {
      refs = references[0];
    }
    this.references = [...this.references, ...refs];
    return this;
  }

  withReference(reference: BatchReference) {
    return this.withReferences(reference);
  }

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  payload = (): BatchReference[] => this.references;

  validateReferenceCount = (): void => {
    if (this.references.length == 0) {
      this.addError('need at least one reference to send a request, add one with .withReference(obj)');
    }
  };

  validate = () => {
    this.validateReferenceCount();
  };

  do = (): Promise<BatchReferenceResponse[]> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const params = new URLSearchParams();
    if (this.consistencyLevel) {
      params.set('consistency_level', this.consistencyLevel);
    }
    const path = buildRefsPath(params);
    const payloadPromise = Promise.all(this.references.map((ref) => this.rebuildReferencePromise(ref)));

    return payloadPromise.then((payload) => this.client.postReturn(path, payload));
  };

  rebuildReferencePromise = (reference: BatchReference): Promise<BatchReference> => {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return this.beaconPath.rebuild(reference.to!).then((beaconTo: any) => ({
      from: reference.from,
      to: beaconTo,
      tenant: reference.tenant,
    }));
  };
}



---
File: /src/c11y/conceptsGetter.ts
---

import Connection from '../connection/index.js';
import { C11yWordsResponse } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class ConceptsGetter extends CommandBase {
  private concept?: string;

  constructor(client: Connection) {
    super(client);
  }

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  withConcept = (concept: string) => {
    this.concept = concept;
    return this;
  };

  validate = (): void => {
    this.validateIsSet(this.concept, 'concept', 'withConcept(concept)');
  };

  do = (): Promise<C11yWordsResponse> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    const path = `/modules/text2vec-contextionary/concepts/${this.concept}`;
    return this.client.get(path);
  };
}



---
File: /src/c11y/extensionCreator.ts
---

import Connection from '../connection/index.js';
import { C11yExtension } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class ExtensionCreator extends CommandBase {
  private concept?: string;
  private definition?: string;
  private weight?: number;

  constructor(client: Connection) {
    super(client);
  }

  withConcept = (concept: string) => {
    this.concept = concept;
    return this;
  };

  withDefinition = (definition: string) => {
    this.definition = definition;
    return this;
  };

  withWeight = (weight: number) => {
    this.weight = weight;
    return this;
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string): void => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = (): void => {
    this.validateIsSet(this.concept, 'concept', 'withConcept(concept)');
    this.validateIsSet(this.definition, 'definition', 'withDefinition(definition)');
    this.validateIsSet(this.weight?.toString() || '', 'weight', 'withWeight(weight)');
  };

  payload = (): C11yExtension => ({
    concept: this.concept,
    definition: this.definition,
    weight: this.weight,
  });

  do = (): Promise<C11yExtension> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    const path = `/modules/text2vec-contextionary/extensions`;
    return this.client.postReturn(path, this.payload());
  };
}



---
File: /src/c11y/index.ts
---

import Connection from '../connection/index.js';
import ConceptsGetter from './conceptsGetter.js';
import ExtensionCreator from './extensionCreator.js';

export interface C11y {
  conceptsGetter: () => ConceptsGetter;
  extensionCreator: () => ExtensionCreator;
}

const c11y = (client: Connection): C11y => {
  return {
    conceptsGetter: () => new ConceptsGetter(client),
    extensionCreator: () => new ExtensionCreator(client),
  };
};

export default c11y;
export { default as ConceptsGetter } from './conceptsGetter.js';
export { default as ExtensionCreator } from './extensionCreator.js';



---
File: /src/c11y/journey.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { C11yExtension, C11yWordsResponse } from '../openapi/types.js';
import weaviate from '../v2/index.js';

describe('c11y endpoints', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('displays info about a concept', () => {
    return client.c11y
      .conceptsGetter()
      .withConcept('car')
      .do()
      .then((res: C11yWordsResponse) => {
        expect(res.individualWords![0].word!).toEqual('car');
      });
  });

  it('extends the c11y with a custom concept', () => {
    return client.c11y
      .extensionCreator()
      .withConcept('clientalmostdonehappyness')
      .withDefinition(
        'the happyness you feel when the Weaviate TypeScript client ' +
          'is almost complete and ready to be released'
      )
      .withWeight(1)
      .do()
      .then((res: C11yExtension) => {
        expect(res).toEqual({
          concept: 'clientalmostdonehappyness',
          definition:
            'the happyness you feel when the Weaviate TypeScript client ' +
            'is almost complete and ready to be released',
          weight: 1,
        });
      });
  });
});



---
File: /src/classifications/contextual.journey.test.ts
---

import { Classification } from '../openapi/types.js';
import weaviate from '../v2/index.js';

const targetDessertId = '9f399d3e-45a4-44f4-b0fd-fa291abfb211';
const targetSavoryId = 'b7a64fbd-7c22-44ac-afbb-8d1432b8061b';
const unclassifiedOneId = '89024ad4-3434-4daa-bfde-a5c6fc4b7f33';
const unclassifiedTwoId = 'afed0b20-bc9a-44c0-84af-09bb6214b3b7';

describe('a classification journey', () => {
  // this journey test is more minimal compared to the kNN one, as a lot of
  // things that are already tested there, don't need to be tested again.

  describe("knn - using the client's wait method", () => {
    const client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });

    it('setups the schema and data', () => setup(client));

    let id: any; // will be assigned by weaviate, see then block in scheduler

    it(
      'triggers a classification with waiting',
      // eslint-disable-next-line require-await
      async () => {
        return client.classifications
          .scheduler()
          .withType('text2vec-contextionary-contextual')
          .withClassName('ContextualClassificationJourneySource')
          .withClassifyProperties(['toTarget'])
          .withBasedOnProperties(['description'])
          .withWaitForCompletion()
          .withWaitTimeout(60 * 1000)
          .do()
          .then((res: Classification) => {
            expect(res.status).toEqual('completed');
            expect(res.type).toEqual('text2vec-contextionary-contextual');
            id = res.id;
          })
          .catch((e: Error) => {
            throw new Error('it should not have errord: ' + e);
          });
      },
      60 * 1000 // jest timeout
    );

    it('tears down and cleans up', () => cleanup(client));
  });
});

const setup = async (client: any) => {
  let targetClass = {
    class: 'ContextualClassificationJourneyTarget',
    properties: [
      {
        name: 'name',
        dataType: ['string'],
      },
    ],
  };

  await client.schema.classCreator().withClass(targetClass).do();

  targetClass = {
    class: 'ContextualClassificationJourneySource',
    properties: [
      {
        name: 'description',
        dataType: ['text'],
      },
      {
        name: 'toTarget',
        dataType: ['ContextualClassificationJourneyTarget'],
      },
    ],
  };

  await client.schema.classCreator().withClass(targetClass).do();

  // import targets
  await Promise.all([
    client.data
      .creator()
      .withClassName('ContextualClassificationJourneyTarget')
      .withProperties({ name: 'Dessert' })
      .withId(targetDessertId)
      .do(),
    client.data
      .creator()
      .withClassName('ContextualClassificationJourneyTarget')
      .withProperties({ name: 'Savory' })
      .withId(targetSavoryId)
      .do(),
  ]);

  // import to-be-classifieds
  await Promise.all([
    client.data
      .creator()
      .withId(unclassifiedOneId)
      .withClassName('ContextualClassificationJourneySource')
      .withProperties({
        description: 'This sweet cake contains sugar.',
      })
      .do(),
    client.data
      .creator()
      .withId(unclassifiedTwoId)
      .withClassName('ContextualClassificationJourneySource')
      .withProperties({
        description: 'Potatoes and fried fish',
      })
      .do(),
  ]);
};

const cleanup = (client: any) => {
  return Promise.all([
    client.schema.classDeleter().withClassName('ContextualClassificationJourneySource').do(),
    client.schema.classDeleter().withClassName('ContextualClassificationJourneyTarget').do(),
  ]);
};

const beaconTo = (target: any) => `weaviate://localhost/things/${target}`;



---
File: /src/classifications/getter.ts
---

import Connection from '../connection/index.js';
import { Classification } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class ClassificationsGetter extends CommandBase {
  private id?: string;

  constructor(client: Connection) {
    super(client);
  }

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string): void => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validateId = (): void => {
    this.validateIsSet(this.id, 'id', '.withId(id)');
  };

  validate = (): void => {
    this.validateId();
  };

  do = (): Promise<Classification> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    const path = `/classifications/${this.id}`;
    return this.client.get(path);
  };
}



---
File: /src/classifications/index.ts
---

import Connection from '../connection/index.js';
import ClassificationsGetter from './getter.js';
import ClassificationsScheduler from './scheduler.js';

export interface Classifications {
  scheduler: () => ClassificationsScheduler;
  getter: () => ClassificationsGetter;
}

const data = (client: Connection): Classifications => {
  return {
    scheduler: () => new ClassificationsScheduler(client),
    getter: () => new ClassificationsGetter(client),
  };
};

export default data;
export { default as ClassificationsGetter } from './getter.js';
export { default as ClassificationsScheduler } from './scheduler.js';



---
File: /src/classifications/knn.journey.test.ts
---

import { Classification } from '../openapi/types.js';
import weaviate, { WeaviateClient } from '../v2/index.js';

const targetDessertId = 'cd54852a-209d-423b-bf1c-884468215237';
const targetSavoryId = 'e5da0127-327e-4184-85b8-7b9d1af4a850';
const unclassifiedOneId = '8bde517e-01a7-47c9-8db6-d09a2e8d3db7';
const unclassifiedTwoId = '39a04208-b6b6-4df4-9aba-caed9e0df2c3';

describe('a classification journey', () => {
  describe('knn - manually polling the status', () => {
    const client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });

    it('setups the schema and data', () => setup(client));

    let id: any; // will be assigned by weaviate, see then block in scheduler

    it('triggers a classification without waiting', () => {
      return client.classifications
        .scheduler()
        .withType('knn')
        .withSettings({ k: 3 })
        .withClassName('ClassificationJourneySource')
        .withClassifyProperties(['toTarget'])
        .withBasedOnProperties(['description'])
        .do()
        .then((res: Classification) => {
          expect(res.id).toBeDefined();
          id = res.id;
        })
        .catch((e: any) => {
          throw new Error('it should not have errord: ' + e);
        });
    });

    it('is now completed', () => {
      return client.classifications
        .getter()
        .withId(id)
        .do()
        .then((res: Classification) => {
          expect(res.status).toEqual('completed');
        });
    });

    it('eventually turns to completed', () => {
      const timeoutMS = 5 * 1000;

      return new Promise((resolve, reject) => {
        const timeout = setTimeout(reject, timeoutMS);
        const backgroundWork = setInterval(() => {
          client.classifications
            .getter()
            .withId(id)
            .do()
            .then((res: Classification) => {
              clearInterval(backgroundWork);
              clearTimeout(timeout);
              if (res.status === 'completed') resolve(undefined);
            });
        }, 500);
      }).catch(() => {
        throw new Error('timed out');
      });
    });

    it('waits for es index updates to have refreshed', () => {
      return new Promise((resolve) => setTimeout(resolve, 1200));
    });

    // removed as the classification results - not affecting the client itself-
    // seem to be flaky
    // it('has correctly classified the items', () => {
    //   return Promise.all([
    //     client.data
    //       .getterById()
    //       .withId(unclassifiedOneId)
    //       .do()
    //       .then((res: any) => {
    //         expect(res.schema.toTarget[0].beacon).toEqual(
    //           beaconTo(targetDessertId),
    //         );
    //       })
    //       .catch(e => {throw new Error('it should not have errord: ' + e)),
    //     client.data
    //       .getterById()
    //       .withId(unclassifiedTwoId)
    //       .do()
    //       .then((res: any) => {
    //         expect(res.schema.toTarget[0].beacon).toEqual(
    //           beaconTo(targetSavoryId),
    //         );
    //       })
    //       .catch(e => {throw new Error('it should not have errord: ' + e)),
    //   ]);
    // });

    it('tears down and cleans up', () => cleanup(client));
  });

  describe("knn - using the client's wait method", () => {
    const client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });

    it('setups the schema and data', () => setup(client));

    let id; // will be assigned by weaviate, see then block in scheduler

    // eslint-disable-next-line require-await
    it('triggers a classification and waits', async () => {
      return client.classifications
        .scheduler()
        .withType('knn')
        .withSettings({ k: 3 })
        .withClassName('ClassificationJourneySource')
        .withClassifyProperties(['toTarget'])
        .withBasedOnProperties(['description'])
        .withWaitForCompletion()
        .withWaitTimeout(60 * 1000)
        .do()
        .then((res: Classification) => {
          expect(res.status).toEqual('completed');
          id = res.id;
        })
        .catch((e: Error) => {
          throw new Error('it should not have errord: ' + e);
        });
    });

    it('waits for es index updates to have refreshed', () => {
      return new Promise((resolve) => setTimeout(resolve, 1200));
    });

    // removed as the classification results - not affecting the client itself-
    // seem to be flaky
    // it('has correctly classified the items', () => {
    //   return Promise.all([
    //     client.data
    //       .getterById()
    //       .withId(unclassifiedOneId)
    //       .do()
    //       .then((res: any) => {
    //         expect(res.schema.toTarget[0].beacon).toEqual(
    //           beaconTo(targetDessertId),
    //         );
    //       })
    //       .catch(e => {throw new Error('it should not have errord: ' + e)),
    //     client.data
    //       .getterById()
    //       .withId(unclassifiedTwoId)
    //       .do()
    //       .then((res: any) => {
    //         expect(res.schema.toTarget[0].beacon).toEqual(
    //           beaconTo(targetSavoryId),
    //         );
    //       })
    //       .catch(e => {throw new Error('it should not have errord: ' + e)),
    //   ]);
    // });

    it('tears down and cleans up', () => cleanup(client));
  });

  describe('knn - running into a timeout', () => {
    const client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });

    it('setups the schema and data', () => setup(client));

    it('fails a classification with an impossibly small timeout', () => {
      return client.classifications
        .scheduler()
        .withType('knn')
        .withSettings({ k: 3 })
        .withClassName('ClassificationJourneySource')
        .withClassifyProperties(['toTarget'])
        .withBasedOnProperties(['description'])
        .withWaitForCompletion()
        .withWaitTimeout(1) // that's going to be difficult ;-)
        .do()
        .then((res: Classification) => {
          fail('it should have errord');
        })
        .catch((e: Error) => {
          expect(e).toEqual(
            new Error(
              "classification didn't finish within configured timeout, " +
                'set larger timeout with .withWaitTimeout(timeout)'
            )
          );
        });
    });

    it('wait with tear down until the classification actually finishes', () => {
      return new Promise((resolve) => setTimeout(resolve, 1000));
    });

    it('tears down and cleans up', () => cleanup(client));
  });
});

const setup = async (client: WeaviateClient) => {
  let targetClass = {
    class: 'ClassificationJourneyTarget',
    properties: [
      {
        name: 'name',
        dataType: ['string'],
      },
    ],
  };

  await client.schema.classCreator().withClass(targetClass).do();

  targetClass = {
    class: 'ClassificationJourneySource',
    properties: [
      {
        name: 'description',
        dataType: ['text'],
      },
      {
        name: 'toTarget',
        dataType: ['ClassificationJourneyTarget'],
      },
    ],
  };

  await client.schema.classCreator().withClass(targetClass).do();

  // import targets
  await client.data
    .creator()
    .withClassName('ClassificationJourneyTarget')
    .withProperties({ name: 'Dessert' })
    .withId(targetDessertId)
    .do();

  await client.data
    .creator()
    .withClassName('ClassificationJourneyTarget')
    .withProperties({ name: 'Savory' })
    .withId(targetSavoryId)
    .do();
  // import training data

  await client.data
    .creator()
    .withClassName('ClassificationJourneySource')
    .withProperties({
      description: 'Lots of Sugar, Cream and Flour. Maybe Eggs.',
      toTarget: [{ beacon: beaconTo(targetDessertId) }],
    })
    .do();
  await client.data
    .creator()
    .withClassName('ClassificationJourneySource')
    .withProperties({
      description: 'French Fries and Sausage',
      toTarget: [{ beacon: beaconTo(targetSavoryId) }],
    })
    .do();

  // import to-be-classifieds
  await client.data
    .creator()
    .withId(unclassifiedOneId)
    .withClassName('ClassificationJourneySource')
    .withProperties({
      description: 'This sweet cake contains sugar.',
    })
    .do();
  await client.data
    .creator()
    .withId(unclassifiedTwoId)
    .withClassName('ClassificationJourneySource')
    .withProperties({
      description: 'Potatoes and fried fish',
    })
    .do();
};

const cleanup = (client: WeaviateClient) => {
  return Promise.all([
    client.schema.classDeleter().withClassName('ClassificationJourneySource').do(),
    client.schema.classDeleter().withClassName('ClassificationJourneyTarget').do(),
  ]);
};

const beaconTo = (target: any) => `weaviate://localhost/${target}`;



---
File: /src/classifications/scheduler.ts
---

import Connection from '../connection/index.js';
import { Classification } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import ClassificationsGetter from './getter.js';

export default class ClassificationsScheduler extends CommandBase {
  private basedOnProperties?: string[];
  private classifyProperties?: string[];
  private className?: string;
  private settings?: any;
  private type?: string;
  private waitForCompletion: boolean;
  private waitTimeout: number;

  constructor(client: Connection) {
    super(client);
    this.waitTimeout = 10 * 60 * 1000; // 10 minutes
    this.waitForCompletion = false;
  }

  withType = (type: string) => {
    this.type = type;
    return this;
  };

  withSettings = (settings: any) => {
    this.settings = settings;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withClassifyProperties = (props: string[]) => {
    this.classifyProperties = props;
    return this;
  };

  withBasedOnProperties = (props: string[]) => {
    this.basedOnProperties = props;
    return this;
  };

  withWaitForCompletion = () => {
    this.waitForCompletion = true;
    return this;
  };

  withWaitTimeout = (timeout: number) => {
    this.waitTimeout = timeout;
    return this;
  };

  validateIsSet = (prop: string | undefined | null | any[], name: string, setter: string): void => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validateClassName = (): void => {
    this.validateIsSet(this.className, 'className', '.withClassName(className)');
  };

  validateBasedOnProperties = (): void => {
    this.validateIsSet(
      this.basedOnProperties,
      'basedOnProperties',
      '.withBasedOnProperties(basedOnProperties)'
    );
  };

  validateClassifyProperties = (): void => {
    this.validateIsSet(
      this.classifyProperties,
      'classifyProperties',
      '.withClassifyProperties(classifyProperties)'
    );
  };

  validate = (): void => {
    this.validateClassName();
    this.validateClassifyProperties();
    this.validateBasedOnProperties();
  };

  payload = (): Classification => ({
    type: this.type,
    settings: this.settings,
    class: this.className,
    classifyProperties: this.classifyProperties,
    basedOnProperties: this.basedOnProperties,
  });

  pollForCompletion = (id: any): Promise<Classification> => {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        clearInterval(interval);
        clearTimeout(timeout);
        reject(
          new Error(
            "classification didn't finish within configured timeout, " +
              'set larger timeout with .withWaitTimeout(timeout)'
          )
        );
      }, this.waitTimeout);

      const interval = setInterval(() => {
        new ClassificationsGetter(this.client)
          .withId(id)
          .do()
          .then((res: Classification) => {
            if (res.status === 'completed') {
              clearInterval(interval);
              clearTimeout(timeout);
              resolve(res);
            }
          });
      }, 500);
    });
  };

  do = (): Promise<Classification> => {
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    this.validate();

    const path = `/classifications`;
    return this.client.postReturn(path, this.payload()).then((res: any) => {
      if (!this.waitForCompletion) {
        return Promise.resolve(res);
      }

      return this.pollForCompletion(res.id);
    });
  };
}



---
File: /src/cluster/index.ts
---

import Connection from '../connection/index.js';
import NodesStatusGetter from './nodesStatusGetter.js';

export type NodeStatus = 'HEALTHY' | 'UNHEALTHY' | 'UNAVAILABLE';

export interface Cluster {
  nodesStatusGetter: () => NodesStatusGetter;
}

const cluster = (client: Connection): Cluster => {
  return {
    nodesStatusGetter: () => new NodesStatusGetter(client),
  };
};

export default cluster;
export { default as NodesStatusGetter } from './nodesStatusGetter.js';



---
File: /src/cluster/nodesStatusGetter.ts
---

import Connection from '../connection/index.js';
import { NodesStatusResponse } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class NodesStatusGetter extends CommandBase {
  private className?: string;
  private output?: string;

  constructor(client: Connection) {
    super(client);
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withOutput = (output: 'minimal' | 'verbose') => {
    this.output = output;
    return this;
  };

  validate() {
    // nothing to validate
  }

  do = (): Promise<NodesStatusResponse> => {
    let path = '/nodes';
    if (this.className) {
      path = `${path}/${this.className}`;
    }
    if (this.output) {
      path = `${path}?output=${this.output}`;
    } else {
      path = `${path}?output=verbose`;
    }
    return this.client.get(path);
  };
}



---
File: /src/collections/aggregate/index.ts
---

import Connection from '../../connection/index.js';

import { ConsistencyLevel } from '../../data/index.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';

import { FilterValue } from '../filters/index.js';

import { WeaviateQueryError } from '../../errors.js';
import { Aggregator } from '../../graphql/index.js';
import { toBase64FromMedia } from '../../index.js';
import { Serialize } from '../serialize/index.js';

export type AggregateBaseOptions<T, M> = {
  filters?: FilterValue;
  returnMetrics?: M;
};

export type AggregateGroupByOptions<T, M> = AggregateOptions<T, M> & {
  groupBy: (keyof T & string) | GroupByAggregate<T>;
};

export type GroupByAggregate<T> = {
  property: keyof T & string;
  limit?: number;
};

export type AggregateOptions<T, M> = AggregateBaseOptions<T, M>;

export type AggregateBaseOverAllOptions<T, M> = AggregateBaseOptions<T, M>;

export type AggregateNearOptions<T, M> = AggregateBaseOptions<T, M> & {
  certainty?: number;
  distance?: number;
  objectLimit?: number;
  targetVector?: string;
};

export type AggregateGroupByNearOptions<T, M> = AggregateNearOptions<T, M> & {
  groupBy: (keyof T & string) | GroupByAggregate<T>;
};

export type AggregateBoolean = {
  count?: number;
  percentageFalse?: number;
  percentageTrue?: number;
  totalFalse?: number;
  totalTrue?: number;
};

export type AggregateDate = {
  count?: number;
  maximum?: number;
  median?: number;
  minimum?: number;
  mode?: number;
};

export type AggregateNumber = {
  count?: number;
  maximum?: number;
  mean?: number;
  median?: number;
  minimum?: number;
  mode?: number;
  sum?: number;
};

export type AggregateReference = {
  pointingTo?: string;
};

export type AggregateText = {
  count?: number;
  topOccurrences?: {
    occurs?: number;
    value?: number;
  }[];
};

export type MetricsInput<N extends string> =
  | MetricsBoolean<N>
  | MetricsInteger<N>
  | MetricsNumber<N>
  | MetricsText<N>
  | MetricsDate<N>;
// | MetricsReference<T>;

export type PropertiesMetrics<T> = T extends undefined
  ? MetricsInput<string> | MetricsInput<string>[]
  : MetricsInput<keyof T & string> | MetricsInput<keyof T & string>[];

export type MetricsBase<N extends string, K extends 'boolean' | 'date' | 'integer' | 'number' | 'text'> = {
  kind: K;
  propertyName: N;
};

export type Option<A> = { [key in keyof A]: boolean };

export type BooleanKeys = 'count' | 'percentageFalse' | 'percentageTrue' | 'totalFalse' | 'totalTrue';
export type DateKeys = 'count' | 'maximum' | 'median' | 'minimum' | 'mode';
export type NumberKeys = 'count' | 'maximum' | 'mean' | 'median' | 'minimum' | 'mode' | 'sum';

export type MetricsBoolean<N extends string> = MetricsBase<N, 'boolean'> &
  Partial<{ [key in BooleanKeys]: boolean }>;
export type MetricsDate<N extends string> = MetricsBase<N, 'date'> & Partial<{ [key in DateKeys]: boolean }>;
export type MetricsInteger<N extends string> = MetricsBase<N, 'integer'> &
  Partial<{ [key in NumberKeys]: boolean }>;
export type MetricsNumber<N extends string> = MetricsBase<N, 'number'> &
  Partial<{ [key in NumberKeys]: boolean }>;
// type MetricsReference<T> = {
//   kind: 'reference';
//   propertyName: RefKeys<T>;
//   pointingTo?: boolean;
//   type?: boolean;
// };
export type MetricsText<N extends string> = MetricsBase<N, 'text'> & {
  count?: boolean;
  topOccurrences?: {
    occurs?: boolean;
    value?: boolean;
  };
  minOccurrences?: number;
};

export type AggregateMetrics<M> = {
  [K in keyof M]: M[K] extends true ? number : never;
};

export type MetricsProperty<T> = T extends undefined ? string : keyof T & string;

export const metrics = <T>() => {
  return {
    aggregate: <P extends MetricsProperty<T>>(property: P) => new MetricsManager<T, P>(property),
  };
};

export interface Metrics<T> {
  /**
   * Define the metrics to be returned based on a property when aggregating over a collection.

    Use this `aggregate` method to define the name to the property to be aggregated on.
    Then use the `text`, `integer`, `number`, `boolean`, `date_`, or `reference` methods to define the metrics to be returned.

    See [the docs](https://weaviate.io/developers/weaviate/search/aggregate) for more details!
   */
  aggregate: <P extends MetricsProperty<T>>(property: P) => MetricsManager<T, P>;
}

export class MetricsManager<T, P extends MetricsProperty<T>> {
  private propertyName: P;

  constructor(property: P) {
    this.propertyName = property;
  }

  private map<A>(metrics: (keyof A)[]): Option<A> {
    const out: any = {};
    metrics.forEach((metric) => {
      out[metric] = true;
    });
    return out as Option<A>;
  }

  /**
   * Define the metrics to be returned for a BOOL or BOOL_ARRAY property when aggregating over a collection.
   *
   * If none of the arguments are provided then all metrics will be returned.
   *
   * @param {('count' | 'percentageFalse' | 'percentageTrue' | 'totalFalse' | 'totalTrue')[]} metrics The metrics to return.
   * @returns {MetricsBoolean<P>} The metrics for the property.
   */
  public boolean(
    metrics?: ('count' | 'percentageFalse' | 'percentageTrue' | 'totalFalse' | 'totalTrue')[]
  ): MetricsBoolean<P> {
    if (metrics === undefined || metrics.length === 0) {
      metrics = ['count', 'percentageFalse', 'percentageTrue', 'totalFalse', 'totalTrue'];
    }
    return {
      ...this.map(metrics),
      kind: 'boolean',
      propertyName: this.propertyName,
    };
  }

  /**
   * Define the metrics to be returned for a DATE or DATE_ARRAY property when aggregating over a collection.
   *
   * If none of the arguments are provided then all metrics will be returned.
   *
   * @param {('count' | 'maximum' | 'median' | 'minimum' | 'mode')[]} metrics The metrics to return.
   * @returns {MetricsDate<P>} The metrics for the property.
   */
  public date(metrics?: ('count' | 'maximum' | 'median' | 'minimum' | 'mode')[]): MetricsDate<P> {
    if (metrics === undefined || metrics.length === 0) {
      metrics = ['count', 'maximum', 'median', 'minimum', 'mode'];
    }
    return {
      ...this.map(metrics),
      kind: 'date',
      propertyName: this.propertyName,
    };
  }

  /**
   * Define the metrics to be returned for an INT or INT_ARRAY property when aggregating over a collection.
   *
   * If none of the arguments are provided then all metrics will be returned.
   *
   * @param {('count' | 'maximum' | 'mean' | 'median' | 'minimum' | 'mode' | 'sum')[]} metrics The metrics to return.
   * @returns {MetricsInteger<P>} The metrics for the property.
   */
  public integer(
    metrics?: ('count' | 'maximum' | 'mean' | 'median' | 'minimum' | 'mode' | 'sum')[]
  ): MetricsInteger<P> {
    if (metrics === undefined || metrics.length === 0) {
      metrics = ['count', 'maximum', 'mean', 'median', 'minimum', 'mode', 'sum'];
    }
    return {
      ...this.map(metrics),
      kind: 'integer',
      propertyName: this.propertyName,
    };
  }

  /**
   * Define the metrics to be returned for a NUMBER or NUMBER_ARRAY property when aggregating over a collection.
   *
   * If none of the arguments are provided then all metrics will be returned.
   *
   * @param {('count' | 'maximum' | 'mean' | 'median' | 'minimum' | 'mode' | 'sum')[]} metrics The metrics to return.
   * @returns {MetricsNumber<P>} The metrics for the property.
   */
  public number(
    metrics?: ('count' | 'maximum' | 'mean' | 'median' | 'minimum' | 'mode' | 'sum')[]
  ): MetricsNumber<P> {
    if (metrics === undefined || metrics.length === 0) {
      metrics = ['count', 'maximum', 'mean', 'median', 'minimum', 'mode', 'sum'];
    }
    return {
      ...this.map(metrics),
      kind: 'number',
      propertyName: this.propertyName,
    };
  }

  // public reference(metrics: 'pointingTo'[]): MetricsReference<T> {
  //   return {
  //     ...this.map(metrics),
  //     kind: 'reference',
  //     propertyName: this.propertyName,
  //   };
  // }

  /**
   * Define the metrics to be returned for a TEXT or TEXT_ARRAY property when aggregating over a collection.
   *
   * If none of the arguments are provided then all metrics will be returned.
   *
   * @param {('count' | 'topOccurrencesOccurs' | 'topOccurrencesValue')[]} metrics The metrics to return.
   * @param {number} [minOccurrences] The how many top occurrences to return.
   * @returns {MetricsText<P>} The metrics for the property.
   */
  public text(
    metrics?: ('count' | 'topOccurrencesOccurs' | 'topOccurrencesValue')[],
    minOccurrences?: number
  ): MetricsText<P> {
    if (metrics === undefined || metrics.length === 0) {
      metrics = ['count', 'topOccurrencesOccurs', 'topOccurrencesValue'];
    }
    return {
      count: metrics.includes('count'),
      topOccurrences:
        metrics.includes('topOccurrencesOccurs') || metrics.includes('topOccurrencesValue')
          ? {
              occurs: metrics.includes('topOccurrencesOccurs'),
              value: metrics.includes('topOccurrencesValue'),
            }
          : undefined,
      minOccurrences,
      kind: 'text',
      propertyName: this.propertyName,
    };
  }
}

type KindToAggregateType<K> = K extends 'text'
  ? AggregateText
  : K extends 'date'
  ? AggregateDate
  : K extends 'integer'
  ? AggregateNumber
  : K extends 'number'
  ? AggregateNumber
  : K extends 'boolean'
  ? AggregateBoolean
  : K extends 'reference'
  ? AggregateReference
  : never;

export type AggregateType = AggregateBoolean | AggregateDate | AggregateNumber | AggregateText;

export type AggregateResult<T, M extends PropertiesMetrics<T> | undefined = undefined> = {
  properties: T extends undefined
    ? Record<string, AggregateType>
    : M extends MetricsInput<keyof T & string>[]
    ? {
        [K in M[number] as K['propertyName']]: KindToAggregateType<K['kind']>;
      }
    : M extends MetricsInput<keyof T & string>
    ? {
        [K in M as K['propertyName']]: KindToAggregateType<K['kind']>;
      }
    : undefined;
  totalCount: number;
};

export type AggregateGroupByResult<
  T,
  M extends PropertiesMetrics<T> | undefined = undefined
> = AggregateResult<T, M> & {
  groupedBy: {
    prop: string;
    value: string;
  };
};

class AggregateManager<T> implements Aggregate<T> {
  connection: Connection;
  groupBy: AggregateGroupBy<T>;
  name: string;
  dbVersionSupport: DbVersionSupport;
  consistencyLevel?: ConsistencyLevel;
  tenant?: string;

  private constructor(
    connection: Connection,
    name: string,
    dbVersionSupport: DbVersionSupport,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ) {
    this.connection = connection;
    this.name = name;
    this.dbVersionSupport = dbVersionSupport;
    this.consistencyLevel = consistencyLevel;
    this.tenant = tenant;

    this.groupBy = {
      nearImage: async <M extends PropertiesMetrics<T> | undefined = undefined>(
        image: string | Buffer,
        opts?: AggregateGroupByNearOptions<T, M>
      ): Promise<AggregateGroupByResult<T, M>[]> => {
        const builder = this.base(opts?.returnMetrics, opts?.filters, opts?.groupBy).withNearImage({
          image: await toBase64FromMedia(image),
          certainty: opts?.certainty,
          distance: opts?.distance,
          targetVectors: opts?.targetVector ? [opts.targetVector] : undefined,
        });
        if (opts?.objectLimit) {
          builder.withObjectLimit(opts?.objectLimit);
        }
        return this.doGroupBy(builder);
      },
      nearObject: <M extends PropertiesMetrics<T> | undefined = undefined>(
        id: string,
        opts?: AggregateGroupByNearOptions<T, M>
      ): Promise<AggregateGroupByResult<T, M>[]> => {
        const builder = this.base(opts?.returnMetrics, opts?.filters, opts?.groupBy).withNearObject({
          id: id,
          certainty: opts?.certainty,
          distance: opts?.distance,
          targetVectors: opts?.targetVector ? [opts.targetVector] : undefined,
        });
        if (opts?.objectLimit) {
          builder.withObjectLimit(opts.objectLimit);
        }
        return this.doGroupBy(builder);
      },
      nearText: <M extends PropertiesMetrics<T> | undefined = undefined>(
        query: string | string[],
        opts?: AggregateGroupByNearOptions<T, M>
      ): Promise<AggregateGroupByResult<T, M>[]> => {
        const builder = this.base(opts?.returnMetrics, opts?.filters, opts?.groupBy).withNearText({
          concepts: Array.isArray(query) ? query : [query],
          certainty: opts?.certainty,
          distance: opts?.distance,
          targetVectors: opts?.targetVector ? [opts.targetVector] : undefined,
        });
        if (opts?.objectLimit) {
          builder.withObjectLimit(opts.objectLimit);
        }
        return this.doGroupBy(builder);
      },
      nearVector: <M extends PropertiesMetrics<T> | undefined = undefined>(
        vector: number[],
        opts?: AggregateGroupByNearOptions<T, M>
      ): Promise<AggregateGroupByResult<T, M>[]> => {
        const builder = this.base(opts?.returnMetrics, opts?.filters, opts?.groupBy).withNearVector({
          vector: vector,
          certainty: opts?.certainty,
          distance: opts?.distance,
          targetVectors: opts?.targetVector ? [opts.targetVector] : undefined,
        });
        if (opts?.objectLimit) {
          builder.withObjectLimit(opts.objectLimit);
        }
        return this.doGroupBy(builder);
      },
      overAll: <M extends PropertiesMetrics<T> | undefined = undefined>(
        opts: AggregateGroupByOptions<T, M>
      ): Promise<AggregateGroupByResult<T, M>[]> => {
        const builder = this.base(opts?.returnMetrics, opts?.filters, opts?.groupBy);
        return this.doGroupBy(builder);
      },
    };
  }

  query() {
    return new Aggregator(this.connection);
  }

  base(
    metrics?: PropertiesMetrics<T>,
    filters?: FilterValue,
    groupBy?: (keyof T & string) | GroupByAggregate<T>
  ) {
    let fields = 'meta { count }';
    let builder = this.query().withClassName(this.name);
    if (metrics) {
      if (Array.isArray(metrics)) {
        fields += metrics.map((m) => this.metrics(m)).join(' ');
      } else {
        fields += this.metrics(metrics);
      }
    }
    if (groupBy) {
      builder = builder.withGroupBy(typeof groupBy === 'string' ? [groupBy] : [groupBy.property]);
      fields += 'groupedBy { path value }';
      if (typeof groupBy !== 'string' && groupBy?.limit) {
        builder = builder.withLimit(groupBy.limit);
      }
    }
    if (fields !== '') {
      builder = builder.withFields(fields);
    }
    if (filters) {
      builder = builder.withWhere(Serialize.filtersREST(filters));
    }
    if (this.tenant) {
      builder = builder.withTenant(this.tenant);
    }
    return builder;
  }

  metrics(metrics: MetricsInput<(keyof T & string) | string>) {
    let body = '';
    const { kind, propertyName, ...rest } = metrics;
    switch (kind) {
      case 'text': {
        const { minOccurrences, ...restText } = rest as MetricsText<string>;
        body = Object.entries(restText)
          .map(([key, value]) => {
            if (value) {
              return value instanceof Object
                ? `topOccurrences${minOccurrences ? `(limit: ${minOccurrences})` : ''} { ${
                    value.occurs ? 'occurs' : ''
                  } ${value.value ? 'value' : ''} }`
                : key;
            }
          })
          .join(' ');
        break;
      }
      default:
        body = Object.entries(rest)
          .map(([key, value]) => (value ? key : ''))
          .join(' ');
    }
    return `${propertyName} { ${body} }`;
  }

  static use<T>(
    connection: Connection,
    name: string,
    dbVersionSupport: DbVersionSupport,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ): AggregateManager<T> {
    return new AggregateManager<T>(connection, name, dbVersionSupport, consistencyLevel, tenant);
  }

  async nearImage<M extends PropertiesMetrics<T>>(
    image: string | Buffer,
    opts?: AggregateNearOptions<T, M>
  ): Promise<AggregateResult<T, M>> {
    const builder = this.base(opts?.returnMetrics, opts?.filters).withNearImage({
      image: await toBase64FromMedia(image),
      certainty: opts?.certainty,
      distance: opts?.distance,
      targetVectors: opts?.targetVector ? [opts.targetVector] : undefined,
    });
    if (opts?.objectLimit) {
      builder.withObjectLimit(opts?.objectLimit);
    }
    return this.do(builder);
  }

  nearObject<M extends PropertiesMetrics<T>>(
    id: string,
    opts?: AggregateNearOptions<T, M>
  ): Promise<AggregateResult<T, M>> {
    const builder = this.base(opts?.returnMetrics, opts?.filters).withNearObject({
      id: id,
      certainty: opts?.certainty,
      distance: opts?.distance,
      targetVectors: opts?.targetVector ? [opts.targetVector] : undefined,
    });
    if (opts?.objectLimit) {
      builder.withObjectLimit(opts.objectLimit);
    }
    return this.do(builder);
  }

  nearText<M extends PropertiesMetrics<T>>(
    query: string | string[],
    opts?: AggregateNearOptions<T, M>
  ): Promise<AggregateResult<T, M>> {
    const builder = this.base(opts?.returnMetrics, opts?.filters).withNearText({
      concepts: Array.isArray(query) ? query : [query],
      certainty: opts?.certainty,
      distance: opts?.distance,
      targetVectors: opts?.targetVector ? [opts.targetVector] : undefined,
    });
    if (opts?.objectLimit) {
      builder.withObjectLimit(opts.objectLimit);
    }
    return this.do(builder);
  }

  nearVector<M extends PropertiesMetrics<T>>(
    vector: number[],
    opts?: AggregateNearOptions<T, M>
  ): Promise<AggregateResult<T, M>> {
    const builder = this.base(opts?.returnMetrics, opts?.filters).withNearVector({
      vector: vector,
      certainty: opts?.certainty,
      distance: opts?.distance,
      targetVectors: opts?.targetVector ? [opts.targetVector] : undefined,
    });
    if (opts?.objectLimit) {
      builder.withObjectLimit(opts.objectLimit);
    }
    return this.do(builder);
  }

  overAll<M extends PropertiesMetrics<T>>(opts?: AggregateOptions<T, M>): Promise<AggregateResult<T, M>> {
    const builder = this.base(opts?.returnMetrics, opts?.filters);
    return this.do(builder);
  }

  do = <M extends PropertiesMetrics<T> | undefined = undefined>(
    query: Aggregator
  ): Promise<AggregateResult<T, M>> => {
    return query
      .do()
      .then(({ data }: any) => {
        const { meta, ...rest } = data.Aggregate[this.name][0];
        return {
          properties: rest,
          totalCount: meta?.count,
        };
      })
      .catch((err: Error) => {
        throw new WeaviateQueryError(err.message, 'GraphQL');
      });
  };

  doGroupBy = <M extends PropertiesMetrics<T> | undefined = undefined>(
    query: Aggregator
  ): Promise<AggregateGroupByResult<T, M>[]> => {
    return query
      .do()
      .then(({ data }: any) =>
        data.Aggregate[this.name].map((item: any) => {
          const { groupedBy, meta, ...rest } = item;
          return {
            groupedBy: {
              prop: groupedBy.path[0],
              value: groupedBy.value,
            },
            properties: rest.length > 0 ? rest : undefined,
            totalCount: meta?.count,
          };
        })
      )
      .catch((err: Error) => {
        throw new WeaviateQueryError(err.message, 'GraphQL');
      });
  };
}

export interface Aggregate<T> {
  /** This namespace contains methods perform a group by search while aggregating metrics. */
  groupBy: AggregateGroupBy<T>;
  /**
   * Aggregate metrics over the objects returned by a near image vector search on this collection.
   *
   * At least one of `certainty`, `distance`, or `object_limit` must be specified here for the vector search.
   *
   * This method requires a vectorizer capable of handling base64-encoded images, e.g. `img2vec-neural`, `multi2vec-clip`, and `multi2vec-bind`.
   *
   * @param {string | Buffer} image The image to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {AggregateNearOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateResult<T, M>[]>} The aggregated metrics for the objects returned by the vector search.
   */
  nearImage<M extends PropertiesMetrics<T>>(
    image: string | Buffer,
    opts?: AggregateNearOptions<T, M>
  ): Promise<AggregateResult<T, M>>;
  /**
   * Aggregate metrics over the objects returned by a near object search on this collection.
   *
   * At least one of `certainty`, `distance`, or `object_limit` must be specified here for the vector search.
   *
   * This method requires that the objects in the collection have associated vectors.
   *
   * @param {string} id The ID of the object to search for.
   * @param {AggregateNearOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateResult<T, M>[]>} The aggregated metrics for the objects returned by the vector search.
   */
  nearObject<M extends PropertiesMetrics<T>>(
    id: string,
    opts?: AggregateNearOptions<T, M>
  ): Promise<AggregateResult<T, M>>;
  /**
   * Aggregate metrics over the objects returned by a near vector search on this collection.
   *
   * At least one of `certainty`, `distance`, or `object_limit` must be specified here for the vector search.
   *
   * This method requires that the objects in the collection have associated vectors.
   *
   * @param {number[]} query The text query to search for.
   * @param {AggregateNearOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateResult<T, M>[]>} The aggregated metrics for the objects returned by the vector search.
   */
  nearText<M extends PropertiesMetrics<T>>(
    query: string | string[],
    opts?: AggregateNearOptions<T, M>
  ): Promise<AggregateResult<T, M>>;
  /**
   * Aggregate metrics over the objects returned by a near vector search on this collection.
   *
   * At least one of `certainty`, `distance`, or `object_limit` must be specified here for the vector search.
   *
   * This method requires that the objects in the collection have associated vectors.
   *
   * @param {number[]} vector The vector to search for.
   * @param {AggregateNearOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateResult<T, M>[]>} The aggregated metrics for the objects returned by the vector search.
   */
  nearVector<M extends PropertiesMetrics<T>>(
    vector: number[],
    opts?: AggregateNearOptions<T, M>
  ): Promise<AggregateResult<T, M>>;
  /**
   * Aggregate metrics over all the objects in this collection without any vector search.
   *
   * @param {AggregateOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateResult<T, M>[]>} The aggregated metrics for the objects in the collection.
   */
  overAll<M extends PropertiesMetrics<T>>(opts?: AggregateOptions<T, M>): Promise<AggregateResult<T, M>>;
}

export interface AggregateGroupBy<T> {
  /**
   * Aggregate metrics over the objects returned by a near image vector search on this collection.
   *
   * At least one of `certainty`, `distance`, or `object_limit` must be specified here for the vector search.
   *
   * This method requires a vectorizer capable of handling base64-encoded images, e.g. `img2vec-neural`, `multi2vec-clip`, and `multi2vec-bind`.
   *
   * @param {string | Buffer} image The image to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {AggregateGroupByNearOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateGroupByResult<T, M>[]>} The aggregated metrics for the objects returned by the vector search.
   */
  nearImage<M extends PropertiesMetrics<T>>(
    image: string | Buffer,
    opts?: AggregateGroupByNearOptions<T, M>
  ): Promise<AggregateGroupByResult<T, M>[]>;
  /**
   * Aggregate metrics over the objects returned by a near object search on this collection.
   *
   * At least one of `certainty`, `distance`, or `object_limit` must be specified here for the vector search.
   *
   * This method requires that the objects in the collection have associated vectors.
   *
   * @param {string} id The ID of the object to search for.
   * @param {AggregateGroupByNearOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateGroupByResult<T, M>[]>} The aggregated metrics for the objects returned by the vector search.
   */
  nearObject<M extends PropertiesMetrics<T>>(
    id: string,
    opts?: AggregateGroupByNearOptions<T, M>
  ): Promise<AggregateGroupByResult<T, M>[]>;
  /**
   * Aggregate metrics over the objects returned by a near text vector search on this collection.
   *
   * At least one of `certainty`, `distance`, or `object_limit` must be specified here for the vector search.
   *
   * This method requires a vectorizer capable of handling text, e.g. `text2vec-contextionary`, `text2vec-openai`, etc.
   *
   * @param {string | string[]} query The text to search for.
   * @param {AggregateGroupByNearOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateGroupByResult<T, M>[]>} The aggregated metrics for the objects returned by the vector search.
   */
  nearText<M extends PropertiesMetrics<T>>(
    query: string | string[],
    opts: AggregateGroupByNearOptions<T, M>
  ): Promise<AggregateGroupByResult<T, M>[]>;
  /**
   * Aggregate metrics over the objects returned by a near vector search on this collection.
   *
   * At least one of `certainty`, `distance`, or `object_limit` must be specified here for the vector search.
   *
   * This method requires that the objects in the collection have associated vectors.
   *
   * @param {number[]} vector The vector to search for.
   * @param {AggregateGroupByNearOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateGroupByResult<T, M>[]>} The aggregated metrics for the objects returned by the vector search.
   */
  nearVector<M extends PropertiesMetrics<T>>(
    vector: number[],
    opts?: AggregateGroupByNearOptions<T, M>
  ): Promise<AggregateGroupByResult<T, M>[]>;
  /**
   * Aggregate metrics over all the objects in this collection without any vector search.
   *
   * @param {AggregateGroupByOptions<T, M>} [opts] The options for the request.
   * @returns {Promise<AggregateGroupByResult<T, M>[]>} The aggregated metrics for the objects in the collection.
   */
  overAll<M extends PropertiesMetrics<T>>(
    opts?: AggregateGroupByOptions<T, M>
  ): Promise<AggregateGroupByResult<T, M>[]>;
}

export default AggregateManager.use;



---
File: /src/collections/aggregate/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
import { WeaviateQueryError, WeaviateUnsupportedFeatureError } from '../../errors.js';
import weaviate, { AggregateText, WeaviateClient } from '../../index.js';
import { Collection } from '../collection/index.js';
import { CrossReference } from '../references/index.js';
import { DataObject } from '../types/index.js';

describe('Testing of the collection.aggregate methods', () => {
  type TestCollectionAggregate = {
    text: string;
    texts: string[];
    int: number;
    ints: number[];
    number: number;
    numbers: number[];
    date: string;
    dates: string[];
    boolean: boolean;
    booleans: boolean[];
    ref?: CrossReference<TestCollectionAggregate>;
  };

  let client: WeaviateClient;
  let collection: Collection<TestCollectionAggregate, 'TestCollectionAggregate'>;
  const collectionName = 'TestCollectionAggregate';

  const date0 = '2023-01-01T00:00:00Z';
  const date1 = '2023-01-01T00:00:00Z';
  const date2 = '2023-01-02T00:00:00Z';
  const dateMid = '2023-01-01T12:00:00Z';

  afterAll(async () => {
    return (await client).collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    return client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'text',
            dataType: 'text',
          },
          {
            name: 'texts',
            dataType: 'text[]',
          },
          {
            name: 'int',
            dataType: 'int',
          },
          {
            name: 'ints',
            dataType: 'int[]',
          },
          {
            name: 'number',
            dataType: 'number',
          },
          {
            name: 'numbers',
            dataType: 'number[]',
          },
          {
            name: 'date',
            dataType: 'date',
          },
          {
            name: 'dates',
            dataType: 'date[]',
          },
          {
            name: 'boolean',
            dataType: 'boolean',
          },
          {
            name: 'booleans',
            dataType: 'boolean[]',
          },
          // {
          //   name: 'ref',
          //   dataType: [collectionName],
          // },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary({
          vectorizeCollectionName: false,
          vectorIndexConfig: weaviate.configure.vectorIndex.hnsw({ maxConnections: 64 }),
        }),
      })
      .then(async () => {
        const data: DataObject<TestCollectionAggregate>[] = [];
        for (let i = 0; i < 100; i++) {
          data.push({
            properties: {
              text: 'test',
              texts: ['tests', 'tests'],
              int: 1,
              ints: [1, 2],
              number: 1.0,
              numbers: [1.0, 2.0],
              date: date0,
              dates: [date1, date2],
              boolean: true,
              booleans: [true, false],
            },
          });
        }
        const res = (await collection).data.insertMany(data);
        return res;
      });
    // .then(async (res) => {
    //   const uuid1 = res.uuids[0];
    //   await collection.data.referenceAddMany({
    //     refs: Object.values(res.uuids).map((uuid) => {
    //       return {
    //         fromProperty: 'ref',
    //         fromUuid: uuid1,
    //         reference: Reference.to({ uuids: [uuid] })
    //       }
    //     })
    //   })
    // })
  });

  it('should aggregate data without a search and no property metrics', async () => {
    const result = await collection.aggregate.overAll();
    expect(result.totalCount).toEqual(100);
  });

  it('should aggregate grouped by data without a search and no property metrics', async () => {
    const result = await collection.aggregate.groupBy.overAll({ groupBy: 'text' });
    expect(result.length).toEqual(1);
    expect(result[0].totalCount).toEqual(100);
    expect(result[0].groupedBy.prop).toEqual('text');
    expect(result[0].groupedBy.value).toEqual('test');
    expect(result[0].properties).toBeUndefined();
  });

  it('should aggregate grouped by data with a near text search and no property metrics', async () => {
    const result = await collection.aggregate.groupBy.nearText('test', {
      groupBy: 'text',
      certainty: 0.01,
    });
    expect(result.length).toEqual(1);
    expect(result[0].totalCount).toEqual(100);
    expect(result[0].groupedBy.prop).toEqual('text');
    expect(result[0].groupedBy.value).toEqual('test');
    expect(result[0].properties).toBeUndefined();
  });

  it('should aggregate data without a search and one generic property metric', async () => {
    const result = await collection.aggregate.overAll({
      returnMetrics: collection.metrics
        .aggregate('text')
        .text(['count', 'topOccurrencesOccurs', 'topOccurrencesValue']),
    });
    expect(result.totalCount).toEqual(100);
    expect(result.properties.text.count).toEqual(100);
    expect(result.properties.text.topOccurrences![0].occurs).toEqual(100);
    expect(result.properties.text.topOccurrences![0].value).toEqual('test');
  });

  it('should aggregate data without a search and one non-generic property metric', async () => {
    const result = await (await client).collections.get(collectionName).aggregate.overAll({
      returnMetrics: collection.metrics
        .aggregate('text')
        .text(['count', 'topOccurrencesOccurs', 'topOccurrencesValue']),
    });
    expect(result.totalCount).toEqual(100);
    expect(result.properties.text.count).toEqual(100);
    expect((result.properties.text as AggregateText).topOccurrences![0].occurs).toEqual(100);
    expect((result.properties.text as AggregateText).topOccurrences![0].value).toEqual('test');
  });

  it('should aggregate data without a search and all property metrics', async () => {
    const result = await collection.aggregate.overAll({
      returnMetrics: [
        collection.metrics.aggregate('text').text(['count', 'topOccurrencesOccurs', 'topOccurrencesValue']),
        collection.metrics.aggregate('texts').text(['count', 'topOccurrencesOccurs', 'topOccurrencesValue']),
        collection.metrics
          .aggregate('int')
          .integer(['count', 'maximum', 'mean', 'median', 'minimum', 'mode', 'sum']),
        collection.metrics
          .aggregate('ints')
          .integer(['count', 'maximum', 'mean', 'median', 'minimum', 'mode', 'sum']),
        collection.metrics
          .aggregate('number')
          .number(['count', 'maximum', 'mean', 'median', 'minimum', 'mode', 'sum']),
        collection.metrics
          .aggregate('numbers')
          .number(['count', 'maximum', 'mean', 'median', 'minimum', 'mode', 'sum']),
        collection.metrics.aggregate('date').date(['count', 'maximum', 'median', 'minimum', 'mode']),
        collection.metrics.aggregate('dates').date(['count', 'maximum', 'median', 'minimum']), // 'mode' flakes between date1 and date2
        collection.metrics
          .aggregate('boolean')
          .boolean(['count', 'percentageFalse', 'percentageTrue', 'totalFalse', 'totalTrue']),
        collection.metrics
          .aggregate('booleans')
          .boolean(['count', 'percentageFalse', 'percentageTrue', 'totalFalse', 'totalTrue']),
        // Metrics.aggregate('ref').reference(['pointingTo'])
      ],
    });
    expect(result).toEqual({
      totalCount: 100,
      properties: {
        text: {
          count: 100,
          topOccurrences: [{ occurs: 100, value: 'test' }],
        },
        texts: {
          count: 200,
          topOccurrences: [{ occurs: 200, value: 'tests' }],
        },
        int: {
          count: 100,
          maximum: 1,
          mean: 1,
          median: 1,
          minimum: 1,
          mode: 1,
          sum: 100,
        },
        ints: {
          count: 200,
          maximum: 2,
          mean: 1.5,
          median: 1.5,
          minimum: 1,
          mode: 1,
          sum: 300,
        },
        number: {
          count: 100,
          maximum: 1,
          mean: 1,
          median: 1,
          minimum: 1,
          mode: 1,
          sum: 100,
        },
        numbers: {
          count: 200,
          maximum: 2,
          mean: 1.5,
          median: 1.5,
          minimum: 1,
          mode: 1,
          sum: 300,
        },
        date: {
          count: 100,
          maximum: date0,
          median: date0,
          minimum: date0,
          mode: date0,
        },
        dates: {
          count: 200,
          maximum: date2,
          median: dateMid,
          minimum: date1,
          // mode: date1, // randomly switches between date1 and date2
        },
        boolean: {
          count: 100,
          percentageFalse: 0,
          percentageTrue: 1,
          totalFalse: 0,
          totalTrue: 100,
        },
        booleans: {
          count: 200,
          percentageFalse: 0.5,
          percentageTrue: 0.5,
          totalFalse: 100,
          totalTrue: 100,
        },
        // ref: {
        //   pointingTo: collectionName
        // }
      },
    });
  });
});

describe('Testing of the collection.aggregate methods with named vectors', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionAggregateVectors, 'TestCollectionAggregateVectors'>;
  const collectionName = 'TestCollectionAggregateVectors';
  type TestCollectionAggregateVectors = {
    text: string;
  };

  afterAll(async () => {
    return (await client).collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    const query = () =>
      client.collections.create<TestCollectionAggregateVectors>({
        name: collectionName,
        properties: [
          {
            name: 'text',
            dataType: 'text',
          },
        ],
        vectorizers: [
          weaviate.configure.vectorizer.text2VecContextionary({
            name: 'text',
            sourceProperties: ['text'],
            vectorIndexConfig: weaviate.configure.vectorIndex.hnsw(),
          }),
        ],
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    return query();
  });

  it('should aggregate data with a near text search over a named vector', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      return;
    }
    const result = await collection.aggregate.nearText('test', { certainty: 0.9, targetVector: 'text' });
    expect(result.totalCount).toEqual(0);
  });
});

describe('Testing of collection.aggregate.overAll with a multi-tenancy collection', () => {
  let client: WeaviateClient;
  let collection: Collection;
  const collectionName = 'TestCollectionAggregate';

  afterAll(async () => {
    return (await client).collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    return client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'text',
            dataType: 'text',
          },
        ],
        multiTenancy: { enabled: true },
      })
      .then(async (created) => {
        const tenants = await created.tenants.create({ name: 'test' });
        collection = created.withTenant(tenants[0].name);
        const data: Array<any> = [];
        for (let i = 0; i < 100; i++) {
          data.push({
            properties: {
              text: 'test',
            },
          });
        }
        await collection.data.insertMany(data);
      });
  });

  it('should aggregate data without a search and no property metrics over the tenant', () =>
    collection.aggregate.overAll().then((result) => expect(result.totalCount).toEqual(100)));

  it('should throw an error for a non-existant tenant', () =>
    expect(collection.withTenant('non-existing-tenant').aggregate.overAll()).rejects.toThrow(
      WeaviateQueryError
    ));
});



---
File: /src/collections/backup/client.ts
---

import {
  Backend,
  BackupCreateStatusGetter,
  BackupCreator,
  BackupRestoreStatusGetter,
  BackupRestorer,
} from '../../backup/index.js';
import { validateBackend, validateBackupId } from '../../backup/validation.js';
import Connection from '../../connection/index.js';
import {
  WeaviateBackupCanceled,
  WeaviateBackupCancellationError,
  WeaviateBackupFailed,
  WeaviateInvalidInputError,
  WeaviateUnexpectedResponseError,
  WeaviateUnexpectedStatusCodeError,
} from '../../errors.js';
import {
  BackupCreateResponse,
  BackupCreateStatusResponse,
  BackupRestoreResponse,
} from '../../openapi/types.js';
import {
  BackupArgs,
  BackupCancelArgs,
  BackupConfigCreate,
  BackupConfigRestore,
  BackupReturn,
  BackupStatusArgs,
  BackupStatusReturn,
} from './types.js';

export const backup = (connection: Connection) => {
  const parseStatus = (res: BackupCreateStatusResponse | BackupRestoreResponse): BackupStatusReturn => {
    if (res.id === undefined) {
      throw new WeaviateUnexpectedResponseError('Backup ID is undefined in response');
    }
    if (res.path === undefined) {
      throw new WeaviateUnexpectedResponseError('Backup path is undefined in response');
    }
    if (res.status === undefined) {
      throw new WeaviateUnexpectedResponseError('Backup status is undefined in response');
    }
    return {
      id: res.id,
      error: res.error,
      path: res.path,
      status: res.status,
    };
  };
  const parseResponse = (res: BackupCreateResponse | BackupRestoreResponse): BackupReturn => {
    if (res.id === undefined) {
      throw new WeaviateUnexpectedResponseError('Backup ID is undefined in response');
    }
    if (res.backend === undefined) {
      throw new WeaviateUnexpectedResponseError('Backup backend is undefined in response');
    }
    if (res.path === undefined) {
      throw new WeaviateUnexpectedResponseError('Backup path is undefined in response');
    }
    if (res.status === undefined) {
      throw new WeaviateUnexpectedResponseError('Backup status is undefined in response');
    }
    return {
      id: res.id,
      backend: res.backend as Backend,
      collections: res.classes ? res.classes : [],
      error: res.error,
      path: res.path,
      status: res.status,
    };
  };
  const getCreateStatus = (args: BackupStatusArgs): Promise<BackupStatusReturn> => {
    return new BackupCreateStatusGetter(connection)
      .withBackupId(args.backupId)
      .withBackend(args.backend)
      .do()
      .then(parseStatus);
  };
  const getRestoreStatus = (args: BackupStatusArgs): Promise<BackupStatusReturn> => {
    return new BackupRestoreStatusGetter(connection)
      .withBackupId(args.backupId)
      .withBackend(args.backend)
      .do()
      .then(parseStatus);
  };
  return {
    cancel: async (args: BackupCancelArgs): Promise<boolean> => {
      let errors: string[] = [];
      errors = errors.concat(validateBackupId(args.backupId)).concat(validateBackend(args.backend));
      if (errors.length > 0) {
        throw new WeaviateInvalidInputError(errors.join(', '));
      }

      try {
        await connection.delete(`/backups/${args.backend}/${args.backupId}`, undefined, false);
      } catch (err) {
        if (err instanceof WeaviateUnexpectedStatusCodeError) {
          if (err.code === 404) {
            return false;
          }
          throw new WeaviateBackupCancellationError(err.message);
        }
      }

      return true;
    },
    create: async (args: BackupArgs<BackupConfigCreate>): Promise<BackupReturn> => {
      let builder = new BackupCreator(connection, new BackupCreateStatusGetter(connection))
        .withBackupId(args.backupId)
        .withBackend(args.backend);
      if (args.includeCollections) {
        builder = builder.withIncludeClassNames(...args.includeCollections);
      }
      if (args.excludeCollections) {
        builder = builder.withExcludeClassNames(...args.excludeCollections);
      }
      if (args.config) {
        builder = builder.withConfig({
          ChunkSize: args.config.chunkSize,
          CompressionLevel: args.config.compressionLevel,
          CPUPercentage: args.config.cpuPercentage,
        });
      }
      let res: BackupCreateResponse;
      try {
        res = await builder.do();
      } catch (err) {
        throw new WeaviateBackupFailed(`Backup creation failed: ${err}`, 'creation');
      }
      if (res.status === 'FAILED') {
        throw new WeaviateBackupFailed(`Backup creation failed: ${res.error}`, 'creation');
      }
      let status: BackupStatusReturn | undefined;
      if (args.waitForCompletion) {
        let wait = true;
        while (wait) {
          const ret = await getCreateStatus(args); // eslint-disable-line no-await-in-loop
          if (ret.status === 'SUCCESS') {
            wait = false;
            status = ret;
          }
          if (ret.status === 'FAILED') {
            throw new WeaviateBackupFailed(ret.error ? ret.error : '<unknown>', 'creation');
          }
          if (ret.status === 'CANCELED') {
            throw new WeaviateBackupCanceled('creation');
          }
          await new Promise((resolve) => setTimeout(resolve, 1000)); // eslint-disable-line no-await-in-loop
        }
      }
      return status ? { ...parseResponse(res), ...status } : parseResponse(res);
    },
    getCreateStatus: getCreateStatus,
    getRestoreStatus: getRestoreStatus,
    restore: async (args: BackupArgs<BackupConfigRestore>): Promise<BackupReturn> => {
      let builder = new BackupRestorer(connection, new BackupRestoreStatusGetter(connection))
        .withBackupId(args.backupId)
        .withBackend(args.backend);
      if (args.includeCollections) {
        builder = builder.withIncludeClassNames(...args.includeCollections);
      }
      if (args.excludeCollections) {
        builder = builder.withExcludeClassNames(...args.excludeCollections);
      }
      if (args.config) {
        builder = builder.withConfig({
          CPUPercentage: args.config.cpuPercentage,
        });
      }
      let res: BackupRestoreResponse;
      try {
        res = await builder.do();
      } catch (err) {
        throw new WeaviateBackupFailed(`Backup restoration failed: ${err}`, 'restoration');
      }
      if (res.status === 'FAILED') {
        throw new WeaviateBackupFailed(`Backup restoration failed: ${res.error}`, 'restoration');
      }
      let status: BackupStatusReturn | undefined;
      if (args.waitForCompletion) {
        let wait = true;
        while (wait) {
          const ret = await getRestoreStatus(args); // eslint-disable-line no-await-in-loop
          if (ret.status === 'SUCCESS') {
            wait = false;
            status = ret;
          }
          if (ret.status === 'FAILED') {
            throw new WeaviateBackupFailed(ret.error ? ret.error : '<unknown>', 'restoration');
          }
          if (ret.status === 'CANCELED') {
            throw new WeaviateBackupCanceled('restoration');
          }
          await new Promise((resolve) => setTimeout(resolve, 1000)); // eslint-disable-line no-await-in-loop
        }
      }
      return status
        ? {
            ...parseResponse(res),
            ...status,
          }
        : parseResponse(res);
    },
  };
};

export interface Backup {
  /**
   * Cancel a backup.
   *
   * @param {BackupCancelArgs} args The arguments for the request.
   * @returns {Promise<boolean>} Whether the backup was canceled.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   * @throws {WeaviateBackupCancellationError} If the backup cancellation fails.
   */
  cancel(args: BackupCancelArgs): Promise<boolean>;
  /**
   * Create a backup of the database.
   *
   * @param {BackupArgs} args The arguments for the request.
   * @returns {Promise<BackupReturn>} The response from Weaviate.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   * @throws {WeaviateBackupFailed} If the backup creation fails.
   * @throws {WeaviateBackupCanceled} If the backup creation is canceled.
   */
  create(args: BackupArgs<BackupConfigCreate>): Promise<BackupReturn>;
  /**
   * Get the status of a backup creation.
   *
   * @param {BackupStatusArgs} args The arguments for the request.
   * @returns {Promise<BackupStatusReturn>} The status of the backup creation.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   */
  getCreateStatus(args: BackupStatusArgs): Promise<BackupStatusReturn>;
  /**
   * Get the status of a backup restore.
   *
   * @param {BackupStatusArgs} args The arguments for the request.
   * @returns {Promise<BackupStatusReturn>} The status of the backup restore.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   */
  getRestoreStatus(args: BackupStatusArgs): Promise<BackupStatusReturn>;
  /**
   * Restore a backup of the database.
   *
   * @param {BackupArgs} args The arguments for the request.
   * @returns {Promise<BackupReturn>} The response from Weaviate.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   * @throws {WeaviateBackupFailed} If the backup restoration fails.
   * @throws {WeaviateBackupCanceled} If the backup restoration is canceled.
   */
  restore(args: BackupArgs<BackupConfigRestore>): Promise<BackupReturn>;
}



---
File: /src/collections/backup/collection.ts
---

import { Backend } from '../../backup/index.js';
import Connection from '../../connection/index.js';
import { WeaviateInvalidInputError } from '../../errors.js';
import { backup } from './client.js';
import { BackupReturn, BackupStatusArgs, BackupStatusReturn } from './types.js';

/** The arguments required to create and restore backups. */
export type BackupCollectionArgs = {
  /** The ID of the backup. */
  backupId: string;
  /** The backend to use for the backup. */
  backend: Backend;
  /** The collections to include in the backup. */
  waitForCompletion?: boolean;
};

export const backupCollection = (connection: Connection, name: string) => {
  const handler = backup(connection);
  return {
    create: (args: BackupCollectionArgs) =>
      handler.create({
        ...args,
        includeCollections: [name],
      }),
    getCreateStatus: handler.getCreateStatus,
    getRestoreStatus: handler.getRestoreStatus,
    restore: (args: BackupCollectionArgs) =>
      handler.restore({
        ...args,
        includeCollections: [name],
      }),
  };
};

export interface BackupCollection {
  /**
   * Create a backup of this collection.
   *
   * @param {BackupArgs} args The arguments for the request.
   * @returns {Promise<BackupReturn>} The response from Weaviate.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   * @throws {WeaviateBackupFailed} If the backup creation fails.
   * @throws {WeaviateBackupCanceled} If the backup creation is canceled.
   */
  create(args: BackupCollectionArgs): Promise<BackupReturn>;
  /**
   * Get the status of a backup.
   *
   * @param {BackupStatusArgs} args The arguments for the request.
   * @returns {Promise<BackupStatusReturn>} The status of the backup.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   */
  getCreateStatus(args: BackupStatusArgs): Promise<BackupStatusReturn>;
  /**
   * Get the status of a restore.
   *
   * @param {BackupStatusArgs} args The arguments for the request.
   * @returns {Promise<BackupStatusReturn>} The status of the restore.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   */
  getRestoreStatus(args: BackupStatusArgs): Promise<BackupStatusReturn>;
  /**
   * Restore a backup of this collection.
   *
   * @param {BackupArgs} args The arguments for the request.
   * @returns {Promise<BackupReturn>} The response from Weaviate.
   * @throws {WeaviateInvalidInputError} If the input is invalid.
   * @throws {WeaviateBackupFailed} If the backup restoration fails.
   * @throws {WeaviateBackupCanceled} If the backup restoration is canceled.
   */
  restore(args: BackupCollectionArgs): Promise<BackupReturn>;
}



---
File: /src/collections/backup/index.ts
---

export type { Backup } from './client.js';
export type { BackupCollection, BackupCollectionArgs } from './collection.js';
export type { BackupArgs, BackupConfigCreate, BackupConfigRestore, BackupStatusArgs } from './types.js';



---
File: /src/collections/backup/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
/* eslint-disable no-await-in-loop */
import { Backend } from '../../backup/index.js';
import weaviate, { Collection, WeaviateClient } from '../../index.js';

// These must run sequentially because Weaviate is not capable of running multiple backups at the same time
describe('Integration testing of backups', () => {
  const clientPromise = weaviate.connectToLocal({
    port: 8090,
    grpcPort: 50061,
  });

  const getCollection = (client: WeaviateClient) => client.collections.get('TestBackupCollection');

  beforeAll(() =>
    clientPromise.then((client) =>
      Promise.all([
        client.collections.create({ name: 'TestBackupClient' }).then((col) => col.data.insert()),
        client.collections.create({ name: 'TestBackupCollection' }).then((col) => col.data.insert()),
      ])
    )
  );

  afterAll(() => clientPromise.then((client) => client.collections.deleteAll()));

  const testClientWaitForCompletion = async (client: WeaviateClient) => {
    const res = await client.backup.create({
      backupId: `test-backup-${randomBackupId()}`,
      backend: 'filesystem',
      waitForCompletion: true,
    });
    expect(res.status).toBe('SUCCESS');
    return client;
  };

  const testClientNoWaitForCompletion = async (client: WeaviateClient) => {
    const res = await client.backup.create({
      backupId: `test-backup-${randomBackupId()}`,
      backend: 'filesystem',
    });
    expect(res.status).toBe('STARTED');
    const status = await client.backup.getCreateStatus({
      backupId: res.id as string,
      backend: res.backend as 'filesystem',
    });
    expect(status).not.toBe('SUCCESS'); // can be 'STARTED' or 'TRANSFERRING' depending on the speed of the test machine

    // wait to complete so that other tests can run without colliding with Weaviate's lack of simultaneous backups
    let wait = true;
    while (wait) {
      const { status, error } = await client.backup.getCreateStatus({
        backupId: res.id as string,
        backend: res.backend as Backend,
      });
      if (status === 'SUCCESS') {
        wait = false;
      }
      if (status === 'FAILED') {
        throw new Error(`Backup creation failed: ${error}`);
      }
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }

    return client;
  };

  const testCollectionWaitForCompletion = async (collection: Collection) => {
    const res = await collection.backup.create({
      backupId: `test-backup-${randomBackupId()}`,
      backend: 'filesystem',
      waitForCompletion: true,
    });
    expect(res.status).toBe('SUCCESS');
    expect(res.collections).toEqual(['TestBackupCollection']);
    return collection;
  };

  const testCollectionNoWaitForCompletion = async (collection: Collection) => {
    const res = await collection.backup.create({
      backupId: `test-backup-${randomBackupId()}`,
      backend: 'filesystem',
    });
    expect(res.status).toBe('STARTED');
    expect(res.collections).toEqual(['TestBackupCollection']);
    const status = await collection.backup.getCreateStatus({
      backupId: res.id as string,
      backend: res.backend as 'filesystem',
    });
    expect(status).not.toBe('SUCCESS'); // can be 'STARTED' or 'TRANSFERRING' depending on the speed of the test machine
    return collection;
  };

  it('run', () =>
    clientPromise
      .then(testClientWaitForCompletion)
      .then(testClientNoWaitForCompletion)
      .then(getCollection)
      .then(testCollectionWaitForCompletion)
      .then(testCollectionNoWaitForCompletion));
});

function randomBackupId() {
  return 'backup-id-' + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
}



---
File: /src/collections/backup/types.ts
---

import { Backend, BackupCompressionLevel } from '../../index.js';

/** The status of a backup operation */
export type BackupStatus = 'STARTED' | 'TRANSFERRING' | 'TRANSFERRED' | 'SUCCESS' | 'FAILED' | 'CANCELED';

/** The status of a backup operation */
export type BackupStatusReturn = {
  /** The ID of the backup */
  id: string;
  /** The error message if the backup failed */
  error?: string;
  /** The path to the backup */
  path: string;
  /** The status of the backup */
  status: BackupStatus;
};

/** The return type of a backup creation or restoration operation */
export type BackupReturn = BackupStatusReturn & {
  /** The backend to which the backup was created or restored */
  backend: Backend;
  /** The collections that were included in the backup */
  collections: string[];
};

/** Configuration options available when creating a backup */
export type BackupConfigCreate = {
  /** The size of the chunks to use for the backup. */
  chunkSize?: number;
  /** The standard of compression to use for the backup. */
  compressionLevel?: BackupCompressionLevel;
  /** The percentage of CPU to use for the backup creation job. */
  cpuPercentage?: number;
};

/** Configuration options available when restoring a backup */
export type BackupConfigRestore = {
  /** The percentage of CPU to use for the backuop restoration job. */
  cpuPercentage?: number;
};

/** The arguments required to create and restore backups. */
export type BackupArgs<C extends BackupConfigCreate | BackupConfigRestore> = {
  /** The ID of the backup. */
  backupId: string;
  /** The backend to use for the backup. */
  backend: Backend;
  /** The collections to include in the backup. */
  includeCollections?: string[];
  /** The collections to exclude from the backup. */
  excludeCollections?: string[];
  /** Whether to wait for the backup to complete. */
  waitForCompletion?: boolean;
  /** The configuration options for the backup. */
  config?: C;
};

/** The arguments required to get the status of a backup. */
export type BackupStatusArgs = {
  /** The ID of the backup. */
  backupId: string;
  /** The backend to use for the backup. */
  backend: Backend;
};

/** The arguments required to cancel a backup. */
export type BackupCancelArgs = {
  /** The ID of the backup. */
  backupId: string;
  /** The backend to use for the backup. */
  backend: Backend;
};



---
File: /src/collections/backup/unit.test.ts
---

import express, { Response } from 'express';
import { Server as HttpServer } from 'http';
import { Server as GrpcServer, createServer } from 'nice-grpc';
import { WeaviateBackupCanceled } from '../../errors';
import weaviate, { WeaviateClient } from '../../index.js';
import {
  HealthCheckRequest,
  HealthCheckResponse,
  HealthCheckResponse_ServingStatus,
  HealthDefinition,
  HealthServiceImplementation,
} from '../../proto/google/health/v1/health';
import { BackupCreateResponse, BackupCreateStatusResponse, BackupRestoreResponse } from '../../v2';
import { BackupStatus } from './types';

const BACKUP_ID = 'test-backup-123';
const BACKEND = 'filesystem';

class CancelMock {
  private grpc: GrpcServer;
  private http: HttpServer;
  static status: BackupStatus;

  constructor(grpc: GrpcServer, http: HttpServer) {
    this.grpc = grpc;
    this.http = http;
  }

  public static use = async (version: string, httpPort: number, grpcPort: number) => {
    const httpApp = express();
    // Meta endpoint required for client instantiation
    httpApp.get('/v1/meta', (req, res) => res.send({ version }));

    // Backup cancellation endpoint
    httpApp.delete(`/v1/backups/${BACKEND}/${BACKUP_ID}`, (req, res) => {
      CancelMock.status = 'CANCELED';
      res.send();
    });

    // Backup creation endpoint
    httpApp.post(`/v1/backups/${BACKEND}`, (req, res: Response<BackupCreateResponse, any>) => {
      CancelMock.status = 'STARTED';
      res.send({
        id: BACKUP_ID,
        backend: BACKEND,
        path: 'path/to/backup',
        status: CancelMock.status,
      });
    });
    // Backup creation status endpoint
    httpApp.get(
      `/v1/backups/${BACKEND}/${BACKUP_ID}`,
      (req, res: Response<BackupCreateStatusResponse, any>) =>
        res.send({
          id: BACKUP_ID,
          backend: BACKEND,
          path: 'path/to/backup',
          status: CancelMock.status,
        })
    );

    // Backup restoration endpoint
    httpApp.post(
      `/v1/backups/${BACKEND}/${BACKUP_ID}/restore`,
      (req, res: Response<BackupRestoreResponse, any>) => {
        CancelMock.status = 'STARTED';
        res.send({
          id: BACKUP_ID,
          backend: BACKEND,
          path: 'path/to/backup',
          status: CancelMock.status,
        });
      }
    );
    // Backup restoration status endpoint
    httpApp.get(
      `/v1/backups/${BACKEND}/${BACKUP_ID}/restore`,
      (req, res: Response<BackupRestoreResponse, any>) =>
        res.send({
          id: BACKUP_ID,
          backend: BACKEND,
          path: 'path/to/backup',
          status: CancelMock.status,
        })
    );

    // gRPC health check required for client instantiation
    const healthMockImpl: HealthServiceImplementation = {
      check: (request: HealthCheckRequest): Promise<HealthCheckResponse> =>
        Promise.resolve(HealthCheckResponse.create({ status: HealthCheckResponse_ServingStatus.SERVING })),
      watch: jest.fn(),
    };

    const grpc = createServer();
    grpc.add(HealthDefinition, healthMockImpl);

    httpApp.on('error', (error) => console.error('HTTP Server Error:', error));

    await grpc.listen(`localhost:${grpcPort}`);
    const http = await httpApp.listen(httpPort);
    return new CancelMock(grpc, http);
  };

  public close = () => Promise.all([this.http.close(), this.grpc.shutdown()]);
}

describe('Mock testing of backup cancellation', () => {
  let client: WeaviateClient;
  let mock: CancelMock;

  beforeAll(async () => {
    mock = await CancelMock.use('1.27.0', 8958, 8959);
    client = await weaviate.connectToLocal({ port: 8958, grpcPort: 8959 });
  });

  it('should throw while waiting for creation if backup is cancelled in the meantime', async () => {
    const promise = client.backup
      .create({
        backupId: BACKUP_ID,
        backend: BACKEND,
        waitForCompletion: true,
      })
      .catch((err) => expect(err).toBeInstanceOf(WeaviateBackupCanceled));
    await new Promise((resolve) => setTimeout(resolve, 1000)); // wait for backup creation to start before cancelling
    const deleted = await client.backup.cancel({ backupId: BACKUP_ID, backend: BACKEND });
    expect(deleted).toBe(true);
    return promise;
  });

  it('should return true if creation cancellation was successful', async () => {
    const success = await client.backup.cancel({ backupId: BACKUP_ID, backend: BACKEND });
    expect(success).toBe(true);
  });

  it('should return false if creation backup does not exist', async () => {
    const success = await client.backup.cancel({ backupId: `${BACKUP_ID}4`, backend: BACKEND });
    expect(success).toBe(false);
  });

  afterAll(() => mock.close());
});



---
File: /src/collections/cluster/index.ts
---

import { NodesStatusGetter } from '../../cluster/index.js';
import Connection from '../../connection/index.js';
import { BatchStats, NodeShardStatus, NodeStats } from '../../openapi/types.js';

export type Output = 'minimal' | 'verbose' | undefined;

export type NodesOptions<O extends Output> = {
  /** The name of the collection to get the status of. */
  collection?: string;
  /** Set the desired output verbosity level. Can be `minimal | verbose | undefined` with `undefined` defaulting to `minimal`. */
  output: O;
};

export type Node<O extends Output> = {
  name: string;
  status: 'HEALTHY' | 'UNHEALTHY' | 'UNAVAILABLE';
  version: string;
  gitHash: string;
  stats: O extends 'minimal' | undefined ? undefined : Required<NodeStats>;
  batchStats: Required<BatchStats>;
  shards: O extends 'minimal' | undefined ? null : Required<NodeShardStatus>[];
};

const cluster = (connection: Connection) => {
  return {
    nodes: <O extends Output = undefined>(opts?: NodesOptions<O>): Promise<Node<O>[]> => {
      let builder = new NodesStatusGetter(connection).withOutput(opts?.output ? opts.output : 'minimal');
      if (opts?.collection) {
        builder = builder.withClassName(opts.collection);
      }
      return builder.do().then((res) => res.nodes) as Promise<Node<O>[]>;
    },
  };
};

export default cluster;

export interface Cluster {
  /**
   * Get the status of all nodes in the cluster.
   *
   * @param {NodesOptions<O>} [opts] The options for the request.
   * @returns {Promise<Node<O>[]>} The status of all nodes in the cluster.
   */
  nodes: <O extends Output = undefined>(opts?: NodesOptions<O>) => Promise<Node<O>[]>;
}



---
File: /src/collections/cluster/integration.test.ts
---

import weaviate, { WeaviateClient } from '../../index.js';

describe('Testing of the client.cluster methods', () => {
  let client: WeaviateClient;

  const one = 'TestClusterCollectionOne';
  const two = 'TestClusterCollectionTwo';

  afterAll(async () => {
    await (await client).collections.delete(one);
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    return Promise.all([client.collections.create({ name: one }), client.collections.create({ name: two })]);
  });

  it('should return the default node statuses', async () => {
    const nodes = await client.cluster.nodes();
    expect(nodes).toBeDefined();
    expect(nodes.length).toBeGreaterThan(0);
    expect(nodes[0].gitHash).toBeDefined();
    expect(nodes[0].version).toBeDefined();
    expect(nodes[0].status).toEqual('HEALTHY');
    expect(nodes[0].stats).toBeUndefined();
    expect(nodes[0].shards).toBeNull();
    expect(nodes[0].batchStats.queueLength).toBeGreaterThanOrEqual(0);
    expect(nodes[0].batchStats.ratePerSecond).toBeGreaterThanOrEqual(0);
  });

  it('should return the minimal node statuses', async () => {
    const nodes = await client.cluster.nodes({ output: 'minimal' });
    expect(nodes).toBeDefined();
    expect(nodes.length).toBeGreaterThan(0);
    expect(nodes[0].gitHash).toBeDefined();
    expect(nodes[0].version).toBeDefined();
    expect(nodes[0].status).toEqual('HEALTHY');
    expect(nodes[0].stats).toBeUndefined();
    expect(nodes[0].shards).toBeNull();
    expect(nodes[0].batchStats.queueLength).toBeGreaterThanOrEqual(0);
    expect(nodes[0].batchStats.ratePerSecond).toBeGreaterThanOrEqual(0);
  });

  it('should return the verbose node statuses', async () => {
    const nodes = await client.cluster.nodes({ output: 'verbose' });
    expect(nodes).toBeDefined();
    expect(nodes.length).toBeGreaterThan(0);
    expect(nodes[0].gitHash).toBeDefined();
    expect(nodes[0].version).toBeDefined();
    expect(nodes[0].status).toEqual('HEALTHY');
    expect(nodes[0].stats.shardCount).toBeDefined();
    expect(nodes[0].stats.objectCount).toBeDefined();
    expect(nodes[0].shards.length).toBeGreaterThanOrEqual(0);
    expect(nodes[0].batchStats.queueLength).toBeGreaterThanOrEqual(0);
    expect(nodes[0].batchStats.ratePerSecond).toBeGreaterThanOrEqual(0);
  });

  it('should return the node statuses for a specific collection', async () => {
    const nodes = await client.cluster.nodes({ collection: one, output: 'verbose' });
    expect(nodes).toBeDefined();
    expect(nodes.length).toBeGreaterThan(0);
    expect(nodes[0].gitHash).toBeDefined();
    expect(nodes[0].version).toBeDefined();
    expect(nodes[0].status).toEqual('HEALTHY');
    expect(nodes[0].stats.shardCount).toBeDefined();
    expect(nodes[0].stats.objectCount).toBeDefined();
    expect(nodes[0].shards.length).toBeGreaterThanOrEqual(0);
    expect(nodes[0].batchStats.queueLength).toBeGreaterThanOrEqual(0);
    expect(nodes[0].batchStats.ratePerSecond).toBeGreaterThanOrEqual(0);
  });
});



---
File: /src/collections/collection/index.ts
---

import Connection from '../../connection/grpc.js';
import { ConsistencyLevel } from '../../data/index.js';
import { WeaviateInvalidInputError } from '../../errors.js';
import ClassExists from '../../schema/classExists.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';

import aggregate, { Aggregate, Metrics, metrics } from '../aggregate/index.js';
import { BackupCollection, backupCollection } from '../backup/collection.js';
import config, { Config } from '../config/index.js';
import data, { Data } from '../data/index.js';
import filter, { Filter } from '../filters/index.js';
import generate, { Generate } from '../generate/index.js';
import { Iterator } from '../iterator/index.js';
import query, { Query } from '../query/index.js';
import sort, { Sort } from '../sort/index.js';
import tenants, { TenantBase, Tenants } from '../tenants/index.js';
import { QueryMetadata, QueryProperty, QueryReference } from '../types/index.js';
import multiTargetVector, { MultiTargetVector } from '../vectors/multiTargetVector.js';

export interface Collection<T = undefined, N = string> {
  /** This namespace includes all the querying methods available to you when using Weaviate's standard aggregation capabilities. */
  aggregate: Aggregate<T>;
  /** This namespace includes all the backup methods available to you when backing up a collection in Weaviate. */
  backup: BackupCollection;
  /** This namespace includes all the CRUD methods available to you when modifying the configuration of the collection in Weaviate. */
  config: Config<T>;
  /** This namespace includes all the CUD methods available to you when modifying the data of the collection in Weaviate. */
  data: Data<T>;
  /** This namespace includes the methods by which you can create the `FilterValue<V>` values for use when filtering queries over your collection. */
  filter: Filter<T extends undefined ? any : T>;
  /** This namespace includes all the querying methods available to you when using Weaviate's generative capabilities. */
  generate: Generate<T>;
  /** This namespace includes the methods by which you can create the `MetricsX` values for use when aggregating over your collection. */
  metrics: Metrics<T>;
  /** The name of the collection. */
  name: N;
  /** This namespace includes all the querying methods available to you when using Weaviate's standard query capabilities. */
  query: Query<T>;
  /** This namespaces includes the methods by which you can create the `Sorting<T>` values for use when sorting queries over your collection. */
  sort: Sort<T>;
  /** This namespace includes all the CRUD methods available to you when modifying the tenants of a multi-tenancy-enabled collection in Weaviate. */
  tenants: Tenants;
  /** This namespaces includes the methods by which you cna create the `MultiTargetVectorJoin` values for use when performing multi-target vector searches over your collection. */
  multiTargetVector: MultiTargetVector;
  /**
   * Use this method to check if the collection exists in Weaviate.
   *
   * @returns {Promise<boolean>} A promise that resolves to `true` if the collection exists, and `false` otherwise.
   */
  exists: () => Promise<boolean>;
  /**
   * Use this method to return an iterator over the objects in the collection.
   *
   * This iterator keeps a record of the last object that it returned to be used in each subsequent call to Weaviate.
   * Once the collection is exhausted, the iterator exits.
   *
   * @param {IteratorOptions<T>} opts The options to use when fetching objects from Weaviate.
   * @returns {Iterator<T>} An iterator over the objects in the collection as an async generator.
   *
   * @description If `return_properties` is not provided, all the properties of each object will be
   * requested from Weaviate except for its vector as this is an expensive operation. Specify `include_vector`
   * to request the vector back as well. In addition, if `return_references=None` then none of the references
   * are returned. Use `wvc.QueryReference` to specify which references to return.
   */
  iterator: (opts?: IteratorOptions<T>) => Iterator<T>;
  /**
   * Use this method to return the total number of objects in the collection.
   *
   * This is a short-hand for calling `collection.aggregate.overAll().then(({ totalCount }) => totalCount)`.
   */
  length: () => Promise<number>;
  /**
   * Use this method to return a collection object specific to a single consistency level.
   *
   * If replication is not configured for this collection then Weaviate will throw an error.
   *
   * This method does not send a request to Weaviate. It only returns a new collection object that is specific to the consistency level you specify.
   *
   * @param {ConsistencyLevel} consistencyLevel The consistency level to use.
   * @returns {Collection<T, N>} A new collection object specific to the consistency level you specified.
   */
  withConsistency: (consistencyLevel: ConsistencyLevel) => Collection<T, N>;
  /**
   * Use this method to return a collection object specific to a single tenant.
   *
   * If multi-tenancy is not configured for this collection then Weaviate will throw an error.
   *
   * This method does not send a request to Weaviate. It only returns a new collection object that is specific to the tenant you specify.
   *
   * @typedef {TenantBase} TT A type that extends TenantBase.
   * @param {string | TT} tenant The tenant name or tenant object to use.
   * @returns {Collection<T, N>} A new collection object specific to the tenant you specified.
   */
  withTenant: <TT extends TenantBase>(tenant: string | TT) => Collection<T, N>;
}

export type IteratorOptions<T> = {
  includeVector?: boolean | string[];
  returnMetadata?: QueryMetadata;
  returnProperties?: QueryProperty<T>[];
  returnReferences?: QueryReference<T>[];
};

const isString = (value: any): value is string => typeof value === 'string';

const capitalizeCollectionName = <N extends string>(name: N): N =>
  (name.charAt(0).toUpperCase() + name.slice(1)) as N;

const collection = <T, N>(
  connection: Connection,
  name: N,
  dbVersionSupport: DbVersionSupport,
  consistencyLevel?: ConsistencyLevel,
  tenant?: string
): Collection<T, N> => {
  if (!isString(name)) {
    throw new WeaviateInvalidInputError(`The collection name must be a string, got: ${typeof name}`);
  }
  const capitalizedName = capitalizeCollectionName(name);
  const aggregateCollection = aggregate<T>(
    connection,
    capitalizedName,
    dbVersionSupport,
    consistencyLevel,
    tenant
  );
  const queryCollection = query<T>(connection, capitalizedName, dbVersionSupport, consistencyLevel, tenant);
  return {
    aggregate: aggregateCollection,
    backup: backupCollection(connection, capitalizedName),
    config: config<T>(connection, capitalizedName, dbVersionSupport, tenant),
    data: data<T>(connection, capitalizedName, dbVersionSupport, consistencyLevel, tenant),
    filter: filter<T extends undefined ? any : T>(),
    generate: generate<T>(connection, capitalizedName, dbVersionSupport, consistencyLevel, tenant),
    metrics: metrics<T>(),
    multiTargetVector: multiTargetVector(),
    name: name,
    query: queryCollection,
    sort: sort<T>(),
    tenants: tenants(connection, capitalizedName, dbVersionSupport),
    exists: () => new ClassExists(connection).withClassName(capitalizedName).do(),
    iterator: (opts?: IteratorOptions<T>) =>
      new Iterator<T>((limit: number, after?: string) =>
        queryCollection
          .fetchObjects({
            limit,
            after,
            includeVector: opts?.includeVector,
            returnMetadata: opts?.returnMetadata,
            returnProperties: opts?.returnProperties,
            returnReferences: opts?.returnReferences,
          })
          .then((res) => res.objects)
      ),
    length: () => aggregateCollection.overAll().then(({ totalCount }) => totalCount),
    withConsistency: (consistencyLevel: ConsistencyLevel) =>
      collection<T, N>(connection, capitalizedName, dbVersionSupport, consistencyLevel, tenant),
    withTenant: <TT extends TenantBase>(tenant: string | TT) =>
      collection<T, N>(
        connection,
        capitalizedName,
        dbVersionSupport,
        consistencyLevel,
        typeof tenant === 'string' ? tenant : tenant.name
      ),
  };
};

export default collection;



---
File: /src/collections/config/types/generative.ts
---

export type GenerativeOpenAIConfigBase = {
  baseURL?: string;
  frequencyPenaltyProperty?: number;
  maxTokensProperty?: number;
  presencePenaltyProperty?: number;
  temperatureProperty?: number;
  topPProperty?: number;
};

export type GenerativeAWSConfig = {
  region: string;
  service: string;
  model?: string;
  endpoint?: string;
};

export type GenerativeAnthropicConfig = {
  maxTokens?: number;
  model?: string;
  stopSequences?: string[];
  temperature?: number;
  topK?: number;
  topP?: number;
};

export type GenerativeAnyscaleConfig = {
  model?: string;
  temperature?: number;
};

export type GenerativeCohereConfig = {
  kProperty?: number;
  model?: string;
  maxTokensProperty?: number;
  returnLikelihoodsProperty?: string;
  stopSequencesProperty?: string[];
  temperatureProperty?: number;
};

export type GenerativeDatabricksConfig = {
  endpoint: string;
  maxTokens?: number;
  temperature?: number;
  topK?: number;
  topP?: number;
};

export type GenerativeFriendliAIConfig = {
  baseURL?: string;
  maxTokens?: number;
  model?: string;
  temperature?: number;
};

export type GenerativeMistralConfig = {
  maxTokens?: number;
  model?: string;
  temperature?: number;
};

export type GenerativeOllamaConfig = {
  apiEndpoint?: string;
  model?: string;
};

export type GenerativeOpenAIConfig = GenerativeOpenAIConfigBase & {
  model?: string;
};

export type GenerativeAzureOpenAIConfig = GenerativeOpenAIConfigBase & {
  resourceName: string;
  deploymentId: string;
};

/** @deprecated Use `GenerativeGoogleConfig` instead. */
export type GenerativePaLMConfig = GenerativeGoogleConfig;

export type GenerativeGoogleConfig = {
  apiEndpoint?: string;
  maxOutputTokens?: number;
  modelId?: string;
  projectId?: string;
  temperature?: number;
  topK?: number;
  topP?: number;
};

export type GenerativeConfig =
  | GenerativeAnthropicConfig
  | GenerativeAnyscaleConfig
  | GenerativeAWSConfig
  | GenerativeAzureOpenAIConfig
  | GenerativeCohereConfig
  | GenerativeDatabricksConfig
  | GenerativeGoogleConfig
  | GenerativeFriendliAIConfig
  | GenerativeMistralConfig
  | GenerativeOllamaConfig
  | GenerativeOpenAIConfig
  | GenerativePaLMConfig
  | Record<string, any>
  | undefined;

export type GenerativeConfigType<G> = G extends 'generative-anthropic'
  ? GenerativeAnthropicConfig
  : G extends 'generative-anyscale'
  ? GenerativeAnyscaleConfig
  : G extends 'generative-aws'
  ? GenerativeAWSConfig
  : G extends 'generative-azure-openai'
  ? GenerativeAzureOpenAIConfig
  : G extends 'generative-cohere'
  ? GenerativeCohereConfig
  : G extends 'generative-databricks'
  ? GenerativeDatabricksConfig
  : G extends 'generative-google'
  ? GenerativeGoogleConfig
  : G extends 'generative-friendliai'
  ? GenerativeFriendliAIConfig
  : G extends 'generative-mistral'
  ? GenerativeMistralConfig
  : G extends 'generative-ollama'
  ? GenerativeOllamaConfig
  : G extends 'generative-openai'
  ? GenerativeOpenAIConfig
  : G extends GenerativePalm
  ? GenerativePaLMConfig
  : G extends 'none'
  ? undefined
  : Record<string, any> | undefined;

/** @deprecated Use `generative-google` instead. */
type GenerativePalm = 'generative-palm';

export type GenerativeSearch =
  | 'generative-anthropic'
  | 'generative-anyscale'
  | 'generative-aws'
  | 'generative-azure-openai'
  | 'generative-cohere'
  | 'generative-databricks'
  | 'generative-google'
  | 'generative-friendliai'
  | 'generative-mistral'
  | 'generative-ollama'
  | 'generative-openai'
  | GenerativePalm
  | 'none'
  | string;



---
File: /src/collections/config/types/index.ts
---

export * from './generative.js';
export * from './reranker.js';
export * from './vectorIndex.js';
export * from './vectorizer.js';

import {
  InvertedIndexConfigUpdate,
  MultiTenancyConfigUpdate,
  ReplicationConfigUpdate,
  VectorConfigUpdate,
} from '../../configure/types/index.js';
import { GenerativeConfig } from './generative.js';
import { RerankerConfig } from './reranker.js';
import { VectorIndexType } from './vectorIndex.js';
import { VectorConfig } from './vectorizer.js';

export type ModuleConfig<N, C = undefined> = {
  name: N;
  config: C;
};

export type InvertedIndexConfig = {
  bm25: {
    k1: number;
    b: number;
  };
  cleanupIntervalSeconds: number;
  indexTimestamps: boolean;
  indexPropertyLength: boolean;
  indexNullState: boolean;
  stopwords: {
    preset: string;
    additions: string[];
    removals: string[];
  };
};

export type MultiTenancyConfig = {
  autoTenantActivation: boolean;
  autoTenantCreation: boolean;
  enabled: boolean;
};

export type ReplicationDeletionStrategy = 'DeleteOnConflict' | 'NoAutomatedResolution';

export type ReplicationConfig = {
  asyncEnabled: boolean;
  deletionStrategy: ReplicationDeletionStrategy;
  factor: number;
};

export type PropertyVectorizerConfig = Record<
  string,
  {
    skip: boolean;
    vectorizePropertyName: boolean;
  }
>;

export type PropertyConfig = {
  name: string;
  dataType: string;
  description?: string;
  indexInverted: boolean;
  indexFilterable: boolean;
  indexRangeFilters: boolean;
  indexSearchable: boolean;
  nestedProperties?: PropertyConfig[];
  tokenization: string;
  vectorizerConfig?: PropertyVectorizerConfig;
};

export type ReferenceConfig = {
  name: string;
  description?: string;
  targetCollections: string[];
};

export type ShardingConfig = {
  virtualPerPhysical: number;
  desiredCount: number;
  actualCount: number;
  desiredVirtualCount: number;
  actualVirtualCount: number;
  key: '_id';
  strategy: 'hash';
  function: 'murmur3';
};

export type CollectionConfig = {
  name: string;
  description?: string;
  generative?: GenerativeConfig;
  invertedIndex: InvertedIndexConfig;
  multiTenancy: MultiTenancyConfig;
  properties: PropertyConfig[];
  references: ReferenceConfig[];
  replication: ReplicationConfig;
  reranker?: RerankerConfig;
  sharding: ShardingConfig;
  vectorizers: VectorConfig;
};

export type CollectionConfigUpdate = {
  description?: string;
  invertedIndex?: InvertedIndexConfigUpdate;
  multiTenancy?: MultiTenancyConfigUpdate;
  replication?: ReplicationConfigUpdate;
  vectorizers?:
    | VectorConfigUpdate<undefined, VectorIndexType>
    | VectorConfigUpdate<string, VectorIndexType>[];
};



---
File: /src/collections/config/types/reranker.ts
---

export type RerankerTransformersConfig = {};

export type RerankerCohereConfig = {
  model?: 'rerank-english-v2.0' | 'rerank-multilingual-v2.0' | string;
};

export type RerankerVoyageAIConfig = {
  model?: 'rerank-lite-1' | string;
};

export type RerankerJinaAIConfig = {
  model?:
    | 'jina-reranker-v2-base-multilingual'
    | 'jina-reranker-v1-base-en'
    | 'jina-reranker-v1-turbo-en'
    | 'jina-reranker-v1-tiny-en'
    | 'jina-colbert-v1-en'
    | string;
};

export type RerankerConfig =
  | RerankerCohereConfig
  | RerankerJinaAIConfig
  | RerankerTransformersConfig
  | RerankerVoyageAIConfig
  | Record<string, any>
  | undefined;

export type Reranker =
  | 'reranker-cohere'
  | 'reranker-jinaai'
  | 'reranker-transformers'
  | 'reranker-voyageai'
  | 'none'
  | string;

export type RerankerConfigType<R> = R extends 'reranker-cohere'
  ? RerankerCohereConfig
  : R extends 'reranker-jinaai'
  ? RerankerJinaAIConfig
  : R extends 'reranker-transformers'
  ? RerankerTransformersConfig
  : R extends 'reranker-voyageai'
  ? RerankerVoyageAIConfig
  : R extends 'none'
  ? undefined
  : Record<string, any> | undefined;



---
File: /src/collections/config/types/vectorIndex.ts
---

export type VectorIndexConfigHNSW = {
  cleanupIntervalSeconds: number;
  distance: VectorDistance;
  dynamicEfMin: number;
  dynamicEfMax: number;
  dynamicEfFactor: number;
  efConstruction: number;
  ef: number;
  filterStrategy: VectorIndexFilterStrategy;
  flatSearchCutoff: number;
  maxConnections: number;
  quantizer: PQConfig | BQConfig | SQConfig | undefined;
  skip: boolean;
  vectorCacheMaxObjects: number;
  type: 'hnsw';
};

export type VectorIndexConfigFlat = {
  distance: VectorDistance;
  vectorCacheMaxObjects: number;
  quantizer: BQConfig | undefined;
  type: 'flat';
};

export type VectorIndexConfigDynamic = {
  distance: VectorDistance;
  threshold: number;
  hnsw: VectorIndexConfigHNSW;
  flat: VectorIndexConfigFlat;
  type: 'dynamic';
};

export type VectorIndexConfigType<I> = I extends 'hnsw'
  ? VectorIndexConfigHNSW
  : I extends 'flat'
  ? VectorIndexConfigFlat
  : I extends 'dynamic'
  ? VectorIndexConfigDynamic
  : I extends string
  ? Record<string, any>
  : never;

export type BQConfig = {
  cache: boolean;
  rescoreLimit: number;
  type: 'bq';
};

export type SQConfig = {
  rescoreLimit: number;
  trainingLimit: number;
  type: 'sq';
};

export type PQConfig = {
  bitCompression: boolean;
  centroids: number;
  encoder: PQEncoderConfig;
  segments: number;
  trainingLimit: number;
  type: 'pq';
};

export type PQEncoderConfig = {
  type: PQEncoderType;
  distribution: PQEncoderDistribution;
};

export type VectorDistance = 'cosine' | 'dot' | 'l2-squared' | 'hamming';

export type PQEncoderType = 'kmeans' | 'tile';
export type PQEncoderDistribution = 'log-normal' | 'normal';

export type VectorIndexType = 'hnsw' | 'flat' | 'dynamic' | string;

export type VectorIndexFilterStrategy = 'sweeping' | 'acorn';

export type VectorIndexConfig = VectorIndexConfigHNSW | VectorIndexConfigFlat | VectorIndexConfigDynamic;

export type QuantizerConfig = PQConfig | BQConfig | SQConfig;



---
File: /src/collections/config/types/vectorizer.ts
---

import { ModuleConfig } from './index.js';
import { VectorIndexConfig, VectorIndexType } from './vectorIndex.js';

export type VectorConfig = Record<
  string,
  {
    properties?: string[];
    vectorizer: ModuleConfig<Vectorizer, VectorizerConfig> | ModuleConfig<string, any>;
    indexConfig: VectorIndexConfig;
    indexType: VectorIndexType;
  }
>;

/** @deprecated Use `multi2vec-google` instead. */
type Multi2VecPalmVectorizer = 'multi2vec-palm';

/** @deprecated Use `text2vec-google` instead. */
type Text2VecPalmVectorizer = 'text2vec-palm';

export type Vectorizer =
  | 'img2vec-neural'
  | 'multi2vec-clip'
  | 'multi2vec-cohere'
  | 'multi2vec-bind'
  | Multi2VecPalmVectorizer
  | 'multi2vec-google'
  | 'multi2vec-voyageai'
  | 'ref2vec-centroid'
  | 'text2vec-aws'
  | 'text2vec-azure-openai'
  | 'text2vec-cohere'
  | 'text2vec-contextionary'
  | 'text2vec-databricks'
  | 'text2vec-gpt4all'
  | 'text2vec-huggingface'
  | 'text2vec-jina'
  | 'text2vec-mistral'
  | 'text2vec-ollama'
  | 'text2vec-openai'
  | Text2VecPalmVectorizer
  | 'text2vec-google'
  | 'text2vec-transformers'
  | 'text2vec-voyageai'
  | 'text2vec-weaviate'
  | 'none';

/** The configuration for image vectorization using a neural network module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/modules/img2vec-neural) for detailed usage.
 */
export type Img2VecNeuralConfig = {
  /** The image fields used when vectorizing. This is a required field and must match the property fields of the collection that are defined as `DataType.BLOB`. */
  imageFields: string[];
};

/** The field configuration for multi-media vectorization. */
export type Multi2VecField = {
  /** The name of the field to be used when performing multi-media vectorization. */
  name: string;
  /** The weight of the field when performing multi-media vectorization. */
  weight?: number;
};

/** The configuration for multi-media vectorization using the CLIP module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings-multimodal) for detailed usage.
 */
export type Multi2VecClipConfig = {
  /** The image fields used when vectorizing. */
  imageFields?: string[];
  /** The URL where inference requests are sent. */
  inferenceUrl?: string;
  /** The text fields used when vectorizing. */
  textFields?: string[];
  /** Whether the collection name is vectorized. */
  vectorizeCollectionName?: boolean;
  /** The weights of the fields used for vectorization. */
  weights?: {
    /** The weights of the image fields. */
    imageFields?: number[];
    /** The weights of the text fields. */
    textFields?: number[];
  };
};

/**
 * The configuration for multi-media vectorization using the Cohere module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/cohere/embeddings-multimodal) for detailed usage.
 */
export type Multi2VecCohereConfig = {
  /** The base URL to use where API requests should go. */
  baseURL?: string;
  /** The image fields used when vectorizing. */
  imageFields?: string[];
  /** The specific model to use. */
  model?: string;
  /** The text fields used when vectorizing. */
  textFields?: string[];
  /** The truncation strategy to use. */
  truncate?: string;
  /** Whether the collection name is vectorized. */
  vectorizeCollectionName?: boolean;
  /** The weights of the fields used for vectorization. */
  weights?: {
    /** The weights of the image fields. */
    imageFields?: number[];
    /** The weights of the text fields. */
    textFields?: number[];
  };
};

/** The configuration for multi-media vectorization using the Bind module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/imagebind/embeddings-multimodal) for detailed usage.
 */
export type Multi2VecBindConfig = {
  /** The audio fields used when vectorizing. */
  audioFields?: string[];
  /** The depth fields used when vectorizing. */
  depthFields?: string[];
  /** The image fields used when vectorizing. */
  imageFields?: string[];
  /** The IMU fields used when vectorizing. */
  IMUFields?: string[];
  /** The text fields used when vectorizing. */
  textFields?: string[];
  /** The thermal fields used when vectorizing. */
  thermalFields?: string[];
  /** The video fields used when vectorizing. */
  videoFields?: string[];
  /** Whether the collection name is vectorized. */
  vectorizeCollectionName?: boolean;
  /** The weights of the fields used for vectorization. */
  weights?: {
    /** The weights of the audio fields. */
    audioFields?: number[];
    /** The weights of the depth fields. */
    depthFields?: number[];
    /** The weights of the image fields. */
    imageFields?: number[];
    /** The weights of the IMU fields. */
    IMUFields?: number[];
    /** The weights of the text fields. */
    textFields?: number[];
    /** The weights of the thermal fields. */
    thermalFields?: number[];
    /** The weights of the video fields. */
    videoFields?: number[];
  };
};

/** @deprecated Use `Multi2VecGoogleConfig` instead. */
export type Multi2VecPalmConfig = Multi2VecGoogleConfig;

/** The configuration for multi-media vectorization using the Google module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/google/embeddings) for detailed usage.
 */
export type Multi2VecGoogleConfig = {
  /** The project ID of the model in GCP. */
  projectId: string;
  /** The location where the model runs. */
  location: string;
  /** The image fields used when vectorizing. */
  imageFields?: string[];
  /** The text fields used when vectorizing. */
  textFields?: string[];
  /** The video fields used when vectorizing. */
  videoFields?: string[];
  /** The model ID in use. */
  modelId?: string;
  /** The number of dimensions in use. */
  dimensions?: number;
  /** Whether the collection name is vectorized. */
  vectorizeCollectionName?: boolean;
  /** The weights of the fields used for vectorization. */
  weights?: {
    /** The weights of the image fields. */
    imageFields?: number[];
    /** The weights of the text fields. */
    textFields?: number[];
    /** The weights of the video fields. */
    videoFields?: number[];
  };
};

/** The configuration for multi-media vectorization using the VoyageAI module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings-multimodal) for detailed usage.
 */
export type Multi2VecVoyageAIConfig = {
  /** The image fields used when vectorizing. */
  imageFields?: string[];
  /** The text fields used when vectorizing. */
  textFields?: string[];
  /** The weights of the fields used for vectorization. */
  weights?: {
    /** The weights of the image fields. */
    imageFields?: number[];
    /** The weights of the text fields. */
    textFields?: number[];
  };
};

/** The configuration for reference-based vectorization using the centroid method.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/modules/ref2vec-centroid) for detailed usage.
 */
export type Ref2VecCentroidConfig = {
  /** The properties used as reference points for vectorization. */
  referenceProperties: string[];
  /** The method used to calculate the centroid. */
  method: 'mean' | string;
};

/** The configuration for text vectorization using the AWS module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/text2vec-aws) for detailed usage.
 */
export type Text2VecAWSConfig = {
  /** The model to use. REQUIRED for service `sagemaker`. */
  endpoint?: string;
  /** The model to use. REQUIRED for service `bedrock`. */
  model?: 'amazon.titan-embed-text-v1' | 'cohere.embed-english-v3' | 'cohere.embed-multilingual-v3' | string;
  /** The AWS region where the model runs. */
  region: string;
  /** The AWS service to use. */
  service: 'sagemaker' | 'bedrock' | string;
  /** Whether the collection name is vectorized. */
  vectorizeCollectionName?: boolean;
};

/** The configuration for text vectorization using the OpenAI module with Azure.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/openai/embeddings) for detailed usage.
 */
export type Text2VecAzureOpenAIConfig = {
  /** The base URL to use where API requests should go. */
  baseURL?: string;
  /** The deployment ID to use */
  deploymentId: string;
  /** The resource name to use. */
  resourceName: string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/** The configuration for text vectorization using the Cohere module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/cohere/embeddings) for detailed usage.
 */
export type Text2VecCohereConfig = {
  /** The base URL to use where API requests should go. */
  baseURL?: string;
  /** The model to use. */
  model?: string;
  /** The truncation strategy to use. */
  truncate?: boolean;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/** The configuration for text vectorization using the Contextionary module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/modules/text2vec-contextionary) for detailed usage.
 */
export type Text2VecContextionaryConfig = {
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/** The configuration for text vectorization using the Databricks module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/databricks/embeddings) for detailed usage.
 */
export type Text2VecDatabricksConfig = {
  endpoint: string;
  instruction?: string;
  vectorizeCollectionName?: boolean;
};

/** The configuration for text vectorization using the GPT-4-All module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/gpt4all/embeddings) for detailed usage.
 */
export type Text2VecGPT4AllConfig = {
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/**
 * The configuration for text vectorization using the HuggingFace module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/huggingface/embeddings) for detailed usage.
 */
export type Text2VecHuggingFaceConfig = {
  /** The endpoint URL to use. */
  endpointURL?: string;
  /** The model to use. */
  model?: string;
  /** The model to use for passage vectorization. */
  passageModel?: string;
  /** The model to use for query vectorization. */
  queryModel?: string;
  /** Whether to use the cache. */
  useCache?: boolean;
  /** Whether to use the GPU. */
  useGPU?: boolean;
  /** Whether to wait for the model. */
  waitForModel?: boolean;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/**
 * The configuration for text vectorization using the Jina module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/jinaai/embeddings) for detailed usage.
 */
export type Text2VecJinaConfig = {
  /** The model to use. */
  model?: 'jina-embeddings-v2-base-en' | 'jina-embeddings-v2-small-en' | string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/**
 * The configuration for text vectorization using the Mistral module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/mistral/embeddings) for detailed usage.
 */
export type Text2VecMistralConfig = {
  /** The model to use. */
  model?: 'mistral-embed' | string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/**
 * The configuration for text vectorization using the Ollama module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/ollama/embeddings) for detailed usage.
 */
export type Text2VecOllamaConfig = {
  /** The base URL to use where API requests should go. */
  apiEndpoint?: string;
  /** The model to use. */
  model?: string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/**
 * The configuration for text vectorization using the OpenAI module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/openai/embeddings) for detailed usage.
 */
export type Text2VecOpenAIConfig = {
  /** The base URL to use where API requests should go. */
  baseURL?: string;
  /** The dimensions to use. */
  dimensions?: number;
  /** The model to use. */
  model?: 'text-embedding-3-small' | 'text-embedding-3-large' | 'text-embedding-ada-002' | string;
  /** The model version to use. */
  modelVersion?: string;
  /** The type of model to use. */
  type?: 'text' | 'code' | string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/** @deprecated Use `Text2VecGoogleConfig` instead. */
export type Text2VecPalmConfig = Text2VecGoogleConfig;

/**
 * The configuration for text vectorization using the Google module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/google/embeddings) for detailed usage.
 */
export type Text2VecGoogleConfig = {
  /** The API endpoint to use without a leading scheme such as `http://`. */
  apiEndpoint?: string;
  /** The model ID to use. */
  modelId?: string;
  /** The project ID to use. */
  projectId?: string;
  /** The Weaviate property name for the `gecko-002` or `gecko-003` model to use as the title. */
  titleProperty?: string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/**
 * The configuration for text vectorization using the Transformers module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings) for detailed usage.
 */
export type Text2VecTransformersConfig = {
  /** The inference url to use where API requests should go. You can use either this OR (`passage_inference_url` & `query_inference_url`). */
  inferenceUrl?: string;
  /** The inference url to use where passage API requests should go. You can use either (this AND query_inference_url) OR `inference_url`. */
  passageInferenceUrl?: string;
  /** The inference url to use where query API requests should go. You can use either (this AND `passage_inference_url`) OR `inference_url`. */
  queryInferenceUrl?: string;
  /** The pooling strategy to use. */
  poolingStrategy?: 'masked_mean' | 'cls' | string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/**
 * The configuration for text vectorization using the VoyageAI module.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/voyageai/embeddings) for detailed usage.
 */
export type Text2VecVoyageAIConfig = {
  /** The base URL to use where API requests should go. */
  baseURL?: string;
  /** The model to use. */
  model?: string;
  /** Whether to truncate the input texts to fit within the context length. */
  truncate?: boolean;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/**
 * The configuration for text vectorization using Weaviate's self-hosted text-based embedding models.
 *
 * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/weaviate/embeddings) for detailed usage.
 */
export type Text2VecWeaviateConfig = {
  /** The base URL to use where API requests should go. */
  baseURL?: string;
  /** The dimensions to use. */
  dimensions?: number;
  /** The model to use. */
  model?: 'Snowflake/snowflake-arctic-embed-m-v1.5' | string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

export type NoVectorizerConfig = {};

export type VectorizerConfig =
  | Img2VecNeuralConfig
  | Multi2VecClipConfig
  | Multi2VecBindConfig
  | Multi2VecGoogleConfig
  | Multi2VecPalmConfig
  | Multi2VecVoyageAIConfig
  | Ref2VecCentroidConfig
  | Text2VecAWSConfig
  | Text2VecAzureOpenAIConfig
  | Text2VecContextionaryConfig
  | Text2VecCohereConfig
  | Text2VecDatabricksConfig
  | Text2VecGoogleConfig
  | Text2VecGPT4AllConfig
  | Text2VecHuggingFaceConfig
  | Text2VecJinaConfig
  | Text2VecOpenAIConfig
  | Text2VecPalmConfig
  | Text2VecTransformersConfig
  | Text2VecVoyageAIConfig
  | Text2VecWeaviateConfig
  | NoVectorizerConfig;

export type VectorizerConfigType<V> = V extends 'img2vec-neural'
  ? Img2VecNeuralConfig | undefined
  : V extends 'multi2vec-clip'
  ? Multi2VecClipConfig | undefined
  : V extends 'multi2vec-cohere'
  ? Multi2VecCohereConfig | undefined
  : V extends 'multi2vec-bind'
  ? Multi2VecBindConfig | undefined
  : V extends 'multi2vec-google'
  ? Multi2VecGoogleConfig
  : V extends Multi2VecPalmVectorizer
  ? Multi2VecPalmConfig
  : V extends 'multi2vec-voyageai'
  ? Multi2VecVoyageAIConfig | undefined
  : V extends 'ref2vec-centroid'
  ? Ref2VecCentroidConfig
  : V extends 'text2vec-aws'
  ? Text2VecAWSConfig
  : V extends 'text2vec-contextionary'
  ? Text2VecContextionaryConfig | undefined
  : V extends 'text2vec-cohere'
  ? Text2VecCohereConfig | undefined
  : V extends 'text2vec-databricks'
  ? Text2VecDatabricksConfig
  : V extends 'text2vec-google'
  ? Text2VecGoogleConfig | undefined
  : V extends 'text2vec-gpt4all'
  ? Text2VecGPT4AllConfig | undefined
  : V extends 'text2vec-huggingface'
  ? Text2VecHuggingFaceConfig | undefined
  : V extends 'text2vec-jina'
  ? Text2VecJinaConfig | undefined
  : V extends 'text2vec-mistral'
  ? Text2VecMistralConfig | undefined
  : V extends 'text2vec-ollama'
  ? Text2VecOllamaConfig | undefined
  : V extends 'text2vec-openai'
  ? Text2VecOpenAIConfig | undefined
  : V extends 'text2vec-azure-openai'
  ? Text2VecAzureOpenAIConfig
  : V extends Text2VecPalmVectorizer
  ? Text2VecPalmConfig | undefined
  : V extends 'text2vec-transformers'
  ? Text2VecTransformersConfig | undefined
  : V extends 'text2vec-voyageai'
  ? Text2VecVoyageAIConfig | undefined
  : V extends 'text2vec-weaviate'
  ? Text2VecWeaviateConfig | undefined
  : V extends 'none'
  ? {}
  : V extends undefined
  ? undefined
  : never;



---
File: /src/collections/config/classes.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { WeaviateInvalidInputError } from '../../errors.js';
import {
  WeaviateClass,
  WeaviateInvertedIndexConfig,
  WeaviateMultiTenancyConfig,
  WeaviateReplicationConfig,
  WeaviateVectorIndexConfig,
  WeaviateVectorsConfig,
} from '../../openapi/types.js';
import { QuantizerGuards } from '../configure/parsing.js';
import {
  InvertedIndexConfigUpdate,
  MultiTenancyConfigUpdate,
  ReplicationConfigUpdate,
  VectorConfigUpdate,
  VectorIndexConfigFlatUpdate,
  VectorIndexConfigHNSWUpdate,
} from '../configure/types/index.js';
import { CollectionConfigUpdate, VectorIndexType } from './types/index.js';

export class MergeWithExisting {
  static schema(
    current: WeaviateClass,
    supportsNamedVectors: boolean,
    update?: CollectionConfigUpdate
  ): WeaviateClass {
    if (update === undefined) return current;
    if (update.description !== undefined) current.description = update.description;
    if (update.invertedIndex !== undefined)
      current.invertedIndexConfig = MergeWithExisting.invertedIndex(
        current.invertedIndexConfig,
        update.invertedIndex
      );
    if (update.multiTenancy !== undefined)
      current.multiTenancyConfig = MergeWithExisting.multiTenancy(
        current.multiTenancyConfig,
        update.multiTenancy
      );
    if (update.replication !== undefined)
      current.replicationConfig = MergeWithExisting.replication(
        current.replicationConfig!,
        update.replication
      );
    if (update.vectorizers !== undefined) {
      if (Array.isArray(update.vectorizers)) {
        current.vectorConfig = MergeWithExisting.vectors(current.vectorConfig, update.vectorizers);
      } else if (supportsNamedVectors && current.vectorConfig !== undefined) {
        const updateVectorizers = {
          ...update.vectorizers,
          name: 'default',
        };
        current.vectorConfig = MergeWithExisting.vectors(current.vectorConfig, [updateVectorizers]);
      } else {
        current.vectorIndexConfig =
          update.vectorizers?.vectorIndex.name === 'hnsw'
            ? MergeWithExisting.hnsw(current.vectorIndexConfig, update.vectorizers.vectorIndex.config)
            : MergeWithExisting.flat(current.vectorIndexConfig, update.vectorizers.vectorIndex.config);
      }
    }
    return current;
  }

  static invertedIndex(
    current: WeaviateInvertedIndexConfig,
    update: InvertedIndexConfigUpdate
  ): WeaviateInvertedIndexConfig {
    if (current === undefined) throw Error('Inverted index config is missing from the class schema.');
    if (update === undefined) return current;
    const { bm25, stopwords, ...rest } = update;
    const merged = { ...current, ...rest };
    if (bm25 !== undefined) merged.bm25 = { ...current.bm25!, ...bm25 };
    if (stopwords !== undefined) merged.stopwords = { ...current.stopwords!, ...stopwords };
    return merged;
  }

  static multiTenancy(
    current: WeaviateMultiTenancyConfig,
    update: MultiTenancyConfigUpdate
  ): MultiTenancyConfigUpdate {
    if (current === undefined) throw Error('Multi-tenancy config is missing from the class schema.');
    return { ...current, ...update };
  }

  static replication(
    current: WeaviateReplicationConfig,
    update: ReplicationConfigUpdate
  ): WeaviateReplicationConfig {
    if (current === undefined) throw Error('Replication config is missing from the class schema.');
    return { ...current, ...update };
  }

  static vectors(
    current: WeaviateVectorsConfig,
    update: VectorConfigUpdate<string, VectorIndexType>[]
  ): WeaviateVectorsConfig {
    if (current === undefined) throw Error('Vector index config is missing from the class schema.');
    update.forEach((v) => {
      const existing = current[v.name];
      if (existing !== undefined) {
        current[v.name].vectorIndexConfig =
          v.vectorIndex.name === 'hnsw'
            ? MergeWithExisting.hnsw(existing.vectorIndexConfig, v.vectorIndex.config)
            : MergeWithExisting.flat(existing.vectorIndexConfig, v.vectorIndex.config);
      }
    });
    return current;
  }

  static flat(
    current: WeaviateVectorIndexConfig,
    update: VectorIndexConfigFlatUpdate
  ): WeaviateVectorIndexConfig {
    if (
      (QuantizerGuards.isPQUpdate(update.quantizer) && (current?.bq as any).enabled) ||
      (QuantizerGuards.isBQUpdate(update.quantizer) && (current?.pq as any).enabled)
    )
      throw Error(`Cannot update the quantizer type of an enabled vector index.`);
    const { quantizer, ...rest } = update;
    const merged: WeaviateVectorIndexConfig = { ...current, ...rest };
    if (QuantizerGuards.isBQUpdate(quantizer)) {
      const { type, ...quant } = quantizer;
      merged.bq = { ...current!.bq!, ...quant, enabled: true };
    }
    return merged;
  }

  static hnsw(
    current: WeaviateVectorIndexConfig,
    update: VectorIndexConfigHNSWUpdate
  ): WeaviateVectorIndexConfig {
    if (
      (QuantizerGuards.isBQUpdate(update.quantizer) &&
        (((current?.pq as any) || {}).enabled || ((current?.sq as any) || {}).enabled)) ||
      (QuantizerGuards.isPQUpdate(update.quantizer) &&
        (((current?.bq as any) || {}).enabled || ((current?.sq as any) || {}).enabled)) ||
      (QuantizerGuards.isSQUpdate(update.quantizer) &&
        (((current?.pq as any) || {}).enabled || ((current?.bq as any) || {}).enabled))
    )
      throw new WeaviateInvalidInputError(`Cannot update the quantizer type of an enabled vector index.`);
    const { quantizer, ...rest } = update;
    const merged: WeaviateVectorIndexConfig = { ...current, ...rest };
    if (QuantizerGuards.isBQUpdate(quantizer)) {
      const { type, ...quant } = quantizer;
      merged.bq = { ...current!.bq!, ...quant, enabled: true };
    }
    if (QuantizerGuards.isPQUpdate(quantizer)) {
      const { type, ...quant } = quantizer;
      merged.pq = { ...current!.pq!, ...quant, enabled: true };
    }
    if (QuantizerGuards.isSQUpdate(quantizer)) {
      const { type, ...quant } = quantizer;
      merged.sq = { ...current!.sq!, ...quant, enabled: true };
    }
    return merged;
  }
}



---
File: /src/collections/config/index.ts
---

import Connection from '../../connection/index.js';
import { WeaviateDeserializationError } from '../../errors.js';
import { WeaviateShardStatus } from '../../openapi/types.js';
import ClassUpdater from '../../schema/classUpdater.js';
import { ClassGetter, PropertyCreator, ShardUpdater } from '../../schema/index.js';
import ShardsGetter from '../../schema/shardsGetter.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';
import {
  PropertyConfigCreate,
  ReferenceMultiTargetConfigCreate,
  ReferenceSingleTargetConfigCreate,
} from '../configure/types/index.js';
import { MergeWithExisting } from './classes.js';
import {
  BQConfig,
  CollectionConfig,
  CollectionConfigUpdate,
  PQConfig,
  QuantizerConfig,
  SQConfig,
  VectorIndexConfig,
  VectorIndexConfigDynamic,
  VectorIndexConfigFlat,
  VectorIndexConfigHNSW,
} from './types/index.js';
import { classToCollection, resolveProperty, resolveReference } from './utils.js';

const config = <T>(
  connection: Connection,
  name: string,
  dbVersionSupport: DbVersionSupport,
  tenant?: string
): Config<T> => {
  const getRaw = new ClassGetter(connection).withClassName(name).do;
  return {
    addProperty: (property: PropertyConfigCreate<any>) =>
      new PropertyCreator(connection)
        .withClassName(name)
        .withProperty(resolveProperty<any>(property, []))
        .do()
        .then(() => {}),
    addReference: (
      reference: ReferenceSingleTargetConfigCreate<any> | ReferenceMultiTargetConfigCreate<any>
    ) =>
      new PropertyCreator(connection)
        .withClassName(name)
        .withProperty(resolveReference<any>(reference))
        .do()
        .then(() => {}),
    get: () => getRaw().then(classToCollection<T>),
    getShards: () => {
      let builder = new ShardsGetter(connection).withClassName(name);
      if (tenant) {
        builder = builder.withTenant(tenant);
      }
      return builder.do().then((shards) =>
        shards.map((shard) => {
          if (shard.name === undefined)
            throw new WeaviateDeserializationError('Shard name was not returned by Weaviate');
          if (shard.status === undefined)
            throw new WeaviateDeserializationError('Shard status was not returned by Weaviate');
          if (shard.vectorQueueSize === undefined)
            throw new WeaviateDeserializationError('Shard vector queue size was not returned by Weaviate');
          return { name: shard.name, status: shard.status, vectorQueueSize: shard.vectorQueueSize };
        })
      );
    },
    updateShards: async function (status: 'READY' | 'READONLY', names?: string | string[]) {
      let shardNames: string[];
      if (names === undefined) {
        shardNames = await this.getShards().then((shards) => shards.map((s) => s.name));
      } else if (typeof names === 'string') {
        shardNames = [names];
      } else {
        shardNames = names;
      }
      return Promise.all(
        shardNames.map((shardName) =>
          new ShardUpdater(connection).withClassName(name).withShardName(shardName).withStatus(status).do()
        )
      ).then(() => this.getShards());
    },
    update: (config?: CollectionConfigUpdate) => {
      return getRaw()
        .then(async (current) =>
          MergeWithExisting.schema(
            current,
            await dbVersionSupport.supportsNamedVectors().then((s) => s.supports),
            config
          )
        )
        .then((merged) => new ClassUpdater(connection).withClass(merged).do())
        .then(() => {});
    },
  };
};

export default config;

export interface Config<T> {
  /**
   * Add a property to the collection in Weaviate.
   *
   * @param {PropertyConfigCreate<any>} property The property configuration.
   * @returns {Promise<void>} A promise that resolves when the property has been added.
   */
  addProperty: (property: PropertyConfigCreate<any>) => Promise<void>;
  /**
   * Add a reference to the collection in Weaviate.
   *
   * @param {ReferenceSingleTargetConfigCreate<any> | ReferenceMultiTargetConfigCreate<any>} reference The reference configuration.
   * @returns {Promise<void>} A promise that resolves when the reference has been added.
   */
  addReference: (
    reference: ReferenceSingleTargetConfigCreate<T> | ReferenceMultiTargetConfigCreate<T>
  ) => Promise<void>;
  /**
   * Get the configuration for this collection from Weaviate.
   *
   * @returns {Promise<CollectionConfig<T>>} A promise that resolves with the collection configuration.
   */
  get: () => Promise<CollectionConfig>;
  /**
   * Get the statuses of the shards of this collection.
   *
   * If the collection is multi-tenancy and you did not call `.with_tenant` then you
   * will receive the statuses of all the tenants within the collection. Otherwise, call
   * `.with_tenant` on the collection first and you will receive only that single shard.
   *
   * @returns {Promise<Required<WeaviateShardStatus>[]>} A promise that resolves with the shard statuses.
   */
  getShards: () => Promise<Required<WeaviateShardStatus>[]>;
  /**
   * Update the status of one or all shards of this collection.
   *
   * @param {'READY' | 'READONLY'} status The new status of the shard(s).
   * @param {string | string[]} [names] The name(s) of the shard(s) to update. If not provided, all shards will be updated.
   * @returns {Promise<Required<WeaviateShardStatus>[]>} A promise that resolves with the updated shard statuses.
   */
  updateShards: (
    status: 'READY' | 'READONLY',
    names?: string | string[]
  ) => Promise<Required<WeaviateShardStatus>[]>;
  /**
   * Update the configuration for this collection in Weaviate.
   *
   * Use the `weaviate.classes.Reconfigure` class to generate the necessary configuration objects for this method.
   *
   * @param {CollectionConfigUpdate} [config] The configuration to update. Only a subset of the actual collection configuration can be updated.
   * @returns {Promise<void>} A promise that resolves when the collection has been updated.
   */
  update: (config?: CollectionConfigUpdate) => Promise<void>;
}

export class VectorIndex {
  static isHNSW(config?: VectorIndexConfig): config is VectorIndexConfigHNSW {
    return config?.type === 'hnsw';
  }
  static isFlat(config?: VectorIndexConfig): config is VectorIndexConfigFlat {
    return config?.type === 'flat';
  }
  static isDynamic(config?: VectorIndexConfig): config is VectorIndexConfigDynamic {
    return config?.type === 'dynamic';
  }
}

export class Quantizer {
  static isPQ(config?: QuantizerConfig): config is PQConfig {
    return config?.type === 'pq';
  }
  static isBQ(config?: QuantizerConfig): config is BQConfig {
    return config?.type === 'bq';
  }
  static isSQ(config?: QuantizerConfig): config is SQConfig {
    return config?.type === 'sq';
  }
}

export const configGuards = {
  quantizer: Quantizer,
  vectorIndex: VectorIndex,
};



---
File: /src/collections/config/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { WeaviateUnsupportedFeatureError } from '../../errors.js';
import weaviate, { WeaviateClient, weaviateV2 } from '../../index.js';
import {
  MultiTenancyConfig,
  PropertyConfig,
  VectorIndexConfigDynamic,
  VectorIndexConfigHNSW,
} from './types/index.js';

const fail = (msg: string) => {
  throw new Error(msg);
};

describe('Testing of the collection.config namespace', () => {
  let client: WeaviateClient;

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
  });

  afterAll(() => client.collections.deleteAll());

  it('should be able get the config of a collection without generics', async () => {
    const collectionName = 'TestCollectionConfigGetWithGenerics';
    type TestCollectionConfigGet = {
      testProp: string;
    };
    await client.collections.create<TestCollectionConfigGet>({
      name: collectionName,
      properties: [
        {
          name: 'testProp',
          dataType: 'text',
        },
      ],
      vectorizers: weaviate.configure.vectorizer.none(),
    });
    const collection = client.collections.get<TestCollectionConfigGet>(collectionName);
    const config = await collection.config.get();

    expect(config.name).toEqual(collectionName);
    expect(config.properties).toEqual<PropertyConfig[]>([
      {
        name: 'testProp',
        dataType: 'text',
        description: undefined,
        indexRangeFilters: false,
        indexSearchable: true,
        indexFilterable: true,
        indexInverted: false,
        vectorizerConfig: undefined,
        nestedProperties: undefined,
        tokenization: 'word',
      },
    ]);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(config.vectorizers.default.indexConfig).toEqual<VectorIndexConfigHNSW>({
      skip: false,
      cleanupIntervalSeconds: 300,
      maxConnections: (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) ? 64 : 32,
      efConstruction: 128,
      ef: -1,
      dynamicEfMin: 100,
      dynamicEfMax: 500,
      dynamicEfFactor: 8,
      vectorCacheMaxObjects: 1000000000000,
      filterStrategy: 'sweeping',
      flatSearchCutoff: 40000,
      distance: 'cosine',
      quantizer: undefined,
      type: 'hnsw',
    });
    expect(config.vectorizers.default.indexType).toEqual('hnsw');
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });

  it('should be able get the config of a collection with generics', async () => {
    const collectionName = 'TestCollectionConfigGetWithoutGenerics';
    type TestCollectionConfigGet = {
      testProp: string;
    };
    await client.collections.create<TestCollectionConfigGet>({
      name: collectionName,
      properties: [
        {
          name: 'testProp',
          dataType: 'text',
        },
      ],
      vectorizers: weaviate.configure.vectorizer.none(),
    });
    const collection = client.collections.get<TestCollectionConfigGet>(collectionName);
    const config = await collection.config.get();

    expect(config.name).toEqual(collectionName);
    expect(config.properties).toEqual<PropertyConfig[]>([
      {
        name: 'testProp',
        dataType: 'text',
        description: undefined,
        indexRangeFilters: false,
        indexSearchable: true,
        indexFilterable: true,
        indexInverted: false,
        vectorizerConfig: undefined,
        nestedProperties: undefined,
        tokenization: 'word',
      },
    ]);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(config.vectorizers.default.indexConfig).toEqual<VectorIndexConfigHNSW>({
      skip: false,
      cleanupIntervalSeconds: 300,
      maxConnections: (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) ? 64 : 32,
      efConstruction: 128,
      ef: -1,
      dynamicEfMin: 100,
      dynamicEfMax: 500,
      dynamicEfFactor: 8,
      vectorCacheMaxObjects: 1000000000000,
      filterStrategy: 'sweeping',
      flatSearchCutoff: 40000,
      distance: 'cosine',
      quantizer: undefined,
      type: 'hnsw',
    });
    expect(config.vectorizers.default.indexType).toEqual('hnsw');
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });

  it('should be able to get a collection with named vectors', async () => {
    const collectionName = 'TestCollectionConfigGetVectors';
    const query = () =>
      client.collections.create({
        name: collectionName,
        properties: [
          {
            name: 'title',
            dataType: 'text',
            skipVectorization: true,
            vectorizePropertyName: false,
          },
          {
            name: 'age',
            dataType: 'int',
          },
        ],
        vectorizers: [
          weaviate.configure.vectorizer.text2VecContextionary({
            name: 'title',
            sourceProperties: ['title'],
          }),
          weaviate.configure.vectorizer.text2VecContextionary({
            name: 'age',
            sourceProperties: ['age'],
          }),
        ],
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const config = await query().then((col) => col.config.get());

    expect(config.name).toEqual(collectionName);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(config.properties[0].vectorizerConfig?.['text2vec-contextionary'].vectorizePropertyName).toEqual(
      false
    );
    expect(config.properties[0].vectorizerConfig?.['text2vec-contextionary'].skip).toEqual(true);
    expect(config.properties[1].vectorizerConfig?.['text2vec-contextionary'].vectorizePropertyName).toEqual(
      true
    );
    expect(config.properties[1].vectorizerConfig?.['text2vec-contextionary'].skip).toEqual(false);
    expect(config.vectorizers.title.indexConfig).toBeDefined();
    expect(config.vectorizers.title.indexType).toEqual('hnsw');
    expect(config.vectorizers.title.properties).toEqual(['title']);
    expect(config.vectorizers.title.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to get the config of a collection with HNSW+PQ', async () => {
    const collectionName = 'TestCollectionConfigGetHNSWPlusPQ';
    const collection = await client.collections.create({
      name: collectionName,
      vectorizers: weaviate.configure.vectorizer.none({
        vectorIndexConfig: weaviate.configure.vectorIndex.hnsw({
          quantizer: weaviate.configure.vectorIndex.quantizer.pq(),
        }),
      }),
    });
    const config = await collection.config.get();

    const vectorIndexConfig = config.vectorizers.default.indexConfig as VectorIndexConfigHNSW;
    expect(config.name).toEqual(collectionName);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(vectorIndexConfig).toBeDefined();
    expect(vectorIndexConfig.quantizer).toBeDefined();
    expect(config.vectorizers.default.indexType).toEqual('hnsw');
    expect(config.vectorizers.default.properties).toBeUndefined();
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });

  it('should be able to get the config of a collection with HNSW+BQ', async () => {
    const collectionName = 'TestCollectionConfigGetHNSWPlusBQ';
    const query = () =>
      client.collections.create({
        name: collectionName,
        vectorizers: weaviate.configure.vectorizer.none({
          vectorIndexConfig: weaviate.configure.vectorIndex.hnsw({
            quantizer: weaviate.configure.vectorIndex.quantizer.bq(),
          }),
        }),
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const config = await query().then((col) => col.config.get());

    const vectorIndexConfig = config.vectorizers.default.indexConfig as VectorIndexConfigHNSW;
    expect(config.name).toEqual(collectionName);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(vectorIndexConfig).toBeDefined();
    expect(vectorIndexConfig.quantizer).toBeDefined();
    expect(config.vectorizers.default.indexType).toEqual('hnsw');
    expect(config.vectorizers.default.properties).toBeUndefined();
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });

  it('should be able to get the config of a collection with flat+BQ', async () => {
    const collectionName = 'TestCollectionConfigGetFlatPlusBQ';
    const collection = await client.collections.create({
      name: collectionName,
      vectorizers: weaviate.configure.vectorizer.none({
        vectorIndexConfig: weaviate.configure.vectorIndex.flat({
          quantizer: weaviate.configure.vectorIndex.quantizer.bq(),
        }),
      }),
    });
    const config = await collection.config.get();

    const vectorIndexConfig = config.vectorizers.default.indexConfig as VectorIndexConfigHNSW;
    expect(config.name).toEqual(collectionName);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(vectorIndexConfig).toBeDefined();
    expect(vectorIndexConfig.quantizer).toBeDefined();
    expect(config.vectorizers.default.indexType).toEqual('flat');
    expect(config.vectorizers.default.properties).toBeUndefined();
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });

  it('should be able to get the config of a single-vector collection with dynamic+BQ', async () => {
    const asyncIndexing = await weaviate.connectToLocal({ port: 8078, grpcPort: 50049 }); // need async indexing for dynamic vectorizer
    const collectionName = 'TestSVCollectionConfigGetDynamicPlusBQ';
    await asyncIndexing.collections.delete(collectionName);
    const query = () =>
      asyncIndexing.collections.create({
        name: collectionName,
        vectorizers: weaviate.configure.vectorizer.none({
          vectorIndexConfig: weaviate.configure.vectorIndex.dynamic({
            hnsw: weaviate.configure.vectorIndex.hnsw({
              quantizer: weaviate.configure.vectorIndex.quantizer.pq(),
            }),
            flat: weaviate.configure.vectorIndex.flat({
              quantizer: weaviate.configure.vectorIndex.quantizer.bq(),
            }),
          }),
        }),
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const config = await query().then((collection) => collection.config.get());

    const vectorIndexConfig = config.vectorizers.default.indexConfig as VectorIndexConfigDynamic;
    expect(config.name).toEqual(collectionName);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(vectorIndexConfig).toBeDefined();
    expect((vectorIndexConfig as any).quantizer).toBeUndefined();
    expect(vectorIndexConfig.hnsw).toBeDefined();
    expect(vectorIndexConfig.hnsw.quantizer).toBeDefined();
    expect(vectorIndexConfig.flat).toBeDefined();
    expect(vectorIndexConfig.flat.quantizer).toBeDefined();
    expect(config.vectorizers.default.indexType).toEqual('dynamic');
    expect(config.vectorizers.default.properties).toBeUndefined();
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });

  it('should be able to get the config of a multi-vector collection with dynamic+BQ', async () => {
    const asyncIndexing = await weaviate.connectToLocal({ port: 8078, grpcPort: 50049 }); // need async indexing for dynamic vectorizer
    const collectionName = 'TestMVCollectionConfigGetDynamicPlusBQ';
    await asyncIndexing.collections.delete(collectionName);
    const query = () =>
      asyncIndexing.collections.create({
        name: collectionName,
        vectorizers: weaviate.configure.vectorizer.none({
          vectorIndexConfig: weaviate.configure.vectorIndex.dynamic({
            hnsw: weaviate.configure.vectorIndex.hnsw({
              quantizer: weaviate.configure.vectorIndex.quantizer.pq(),
            }),
            flat: weaviate.configure.vectorIndex.flat({
              quantizer: weaviate.configure.vectorIndex.quantizer.bq(),
            }),
          }),
        }),
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const config = await query().then((collection) => collection.config.get());

    const vectorIndexConfig = config.vectorizers.default.indexConfig as VectorIndexConfigDynamic;
    expect(config.name).toEqual(collectionName);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(vectorIndexConfig).toBeDefined();
    expect((vectorIndexConfig as any).quantizer).toBeUndefined();
    expect(vectorIndexConfig.hnsw).toBeDefined();
    expect(vectorIndexConfig.hnsw.quantizer).toBeDefined();
    expect(vectorIndexConfig.flat).toBeDefined();
    expect(vectorIndexConfig.flat.quantizer).toBeDefined();
    expect(config.vectorizers.default.indexType).toEqual('dynamic');
    expect(config.vectorizers.default.properties).toBeUndefined();
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });

  it('should be able to add a property to a collection', async () => {
    const collectionName = 'TestCollectionConfigAddProperty';
    const collection = await client.collections.create({
      name: collectionName,
      vectorizers: weaviate.configure.vectorizer.none(),
    });
    const config = await collection.config
      .addProperty({
        name: 'testProp',
        dataType: 'text',
      })
      .then(() => collection.config.get());
    expect(config.properties).toEqual<PropertyConfig[]>([
      {
        name: 'testProp',
        dataType: 'text',
        description: undefined,
        indexRangeFilters: false,
        indexSearchable: true,
        indexFilterable: true,
        indexInverted: false,
        vectorizerConfig: undefined,
        nestedProperties: undefined,
        tokenization: 'word',
      },
    ]);
  });

  it('should be able to add a reference to a collection', async () => {
    const collectionName = 'TestCollectionConfigAddReference' as const;
    const collection = await client.collections.create({
      name: collectionName,
      vectorizers: weaviate.configure.vectorizer.none(),
    });
    const config = await collection.config
      .addReference({
        name: 'testProp',
        targetCollection: collection.name,
      })
      .then(() => collection.config.get());
    expect(config.references).toEqual([
      {
        name: 'testProp',
        targetCollections: [collectionName],
        description: undefined,
      },
    ]);
  });

  it('should get the shards of a sharded collection', async () => {
    const shards = await client.collections
      .create({
        name: 'TestCollectionConfigGetShards',
        sharding: {
          desiredCount: 2,
        },
      })
      .then((collection) => collection.config.getShards());

    expect(shards.length).toEqual(2);
    expect(shards[0].name).toBeDefined();
    expect(shards[0].status).toEqual('READY');
    expect(shards[0].vectorQueueSize).toEqual(0);
    expect(shards[1].name).toBeDefined();
    expect(shards[1].status).toEqual('READY');
    expect(shards[1].vectorQueueSize).toEqual(0);
  });

  it('should update all the shard statuses of a sharded collection', async () => {
    const shards = await client.collections
      .create({
        name: 'TestCollectionConfigUpdateAllShardStatuses',
        sharding: {
          desiredCount: 2,
        },
      })
      .then((collection) => collection.config.updateShards('READONLY'));

    expect(shards.length).toEqual(2);
    expect(shards[0].name).toBeDefined();
    expect(shards[0].status).toEqual('READONLY');
    expect(shards[0].vectorQueueSize).toEqual(0);
    expect(shards[1].name).toBeDefined();
    expect(shards[1].status).toEqual('READONLY');
    expect(shards[1].vectorQueueSize).toEqual(0);
  });

  it('should update all the shard statuses of a sharded collection', async () => {
    const { shards, shard } = await client.collections
      .create({
        name: 'TestCollectionConfigUpdateOneShardStatus',
        sharding: {
          desiredCount: 2,
        },
      })
      .then(async (collection) => {
        return { collection, shard: await collection.config.getShards().then((shards) => shards[0].name) };
      })
      .then(async ({ collection, shard }) => {
        return { shard, shards: await collection.config.updateShards('READONLY', shard) };
      });

    expect(shards.length).toEqual(2);
    const updated = shards.find((s) => s.name === shard);
    const notUpdated = shards.find((s) => s.name !== shard);
    expect(updated?.status).toEqual('READONLY');
    expect(notUpdated?.status).toEqual('READY');
  });

  it('should be able update the config of a collection', async () => {
    const collectionName = 'TestCollectionConfigUpdate';
    const collection = await client.collections.create({
      name: collectionName,
      properties: [
        {
          name: 'testProp',
          dataType: 'text',
        },
      ],
      vectorizers: weaviate.configure.vectorizer.none(),
    });
    const config = await collection.config
      .update({
        vectorizers: weaviate.reconfigure.vectorizer.update({
          vectorIndexConfig: weaviate.reconfigure.vectorIndex.hnsw({
            quantizer: weaviate.reconfigure.vectorIndex.quantizer.pq(),
            ef: 4,
          }),
        }),
      })
      .then(() => collection.config.get());

    expect(config.name).toEqual(collectionName);
    expect(config.properties).toEqual<PropertyConfig[]>([
      {
        name: 'testProp',
        dataType: 'text',
        description: undefined,
        indexRangeFilters: false,
        indexSearchable: true,
        indexFilterable: true,
        indexInverted: false,
        vectorizerConfig: undefined,
        nestedProperties: undefined,
        tokenization: 'word',
      },
    ]);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(config.vectorizers.default.indexConfig).toEqual<VectorIndexConfigHNSW>({
      skip: false,
      cleanupIntervalSeconds: 300,
      maxConnections: (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) ? 64 : 32,
      efConstruction: 128,
      ef: 4,
      dynamicEfMin: 100,
      dynamicEfMax: 500,
      dynamicEfFactor: 8,
      vectorCacheMaxObjects: 1000000000000,
      filterStrategy: 'sweeping',
      flatSearchCutoff: 40000,
      distance: 'cosine',
      quantizer: {
        bitCompression: false,
        segments: 0,
        centroids: 256,
        trainingLimit: 100000,
        encoder: {
          type: 'kmeans',
          distribution: 'log-normal',
        },
        type: 'pq',
      },
      type: 'hnsw',
    });
    expect(config.vectorizers.default.indexType).toEqual('hnsw');
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });

  it('should be able to create and get a collection with multi-tenancy enabled', async () => {
    const collectionName = 'TestCollectionConfigCreateGetMultiTenancy';
    const collection = await client.collections.create({
      name: collectionName,
      multiTenancy: weaviate.configure.multiTenancy({
        autoTenantActivation: true,
        autoTenantCreation: true,
      }),
    });
    const config = await collection.config.get();

    expect(config.name).toEqual(collectionName);
    expect(config.multiTenancy.autoTenantActivation).toEqual(
      await client.getWeaviateVersion().then((ver) => !ver.isLowerThan(1, 25, 2))
    );
    expect(config.multiTenancy.autoTenantCreation).toEqual(
      await client.getWeaviateVersion().then((ver) => !ver.isLowerThan(1, 25, 0))
    );
    expect(config.multiTenancy.enabled).toEqual(true);
  });

  it('should be able to create and update a collection with multi-tenancy enabled', async () => {
    const collectionName = 'TestCollectionConfigCreateUpdateMultiTenancy';
    const collection = await client.collections.create({
      name: collectionName,
      multiTenancy: weaviate.configure.multiTenancy(),
    });
    let config = await collection.config.get();
    expect(config.multiTenancy).toEqual<MultiTenancyConfig>({
      enabled: true,
      autoTenantActivation: false,
      autoTenantCreation: false,
    });

    await collection.config.update({
      multiTenancy: weaviate.reconfigure.multiTenancy({
        autoTenantActivation: true,
        autoTenantCreation: true,
      }),
    });
    config = await collection.config.get();

    expect(config.name).toEqual(collectionName);
    expect(config.multiTenancy.autoTenantActivation).toEqual(
      await client.getWeaviateVersion().then((ver) => !ver.isLowerThan(1, 25, 2))
    );
    expect(config.multiTenancy.autoTenantCreation).toEqual(
      await client.getWeaviateVersion().then((ver) => !ver.isLowerThan(1, 25, 0))
    );
    expect(config.multiTenancy.enabled).toEqual(true);
  });

  it('should be able update the config of a collection with legacy vectors', async () => {
    const clientV2 = weaviateV2.client({
      host: 'http://localhost:8080',
    });
    const collectionName = 'TestCollectionConfigUpdateLegacyVectors';
    await clientV2.schema
      .classCreator()
      .withClass({
        class: collectionName,
        vectorizer: 'none',
      })
      .do();
    const collection = client.collections.get(collectionName);
    const config = await collection.config
      .update({
        vectorizers: weaviate.reconfigure.vectorizer.update({
          vectorIndexConfig: weaviate.reconfigure.vectorIndex.hnsw({
            quantizer: weaviate.reconfigure.vectorIndex.quantizer.pq(),
            ef: 4,
          }),
        }),
      })
      .then(() => collection.config.get());

    expect(config.name).toEqual(collectionName);
    expect(config.generative).toBeUndefined();
    expect(config.reranker).toBeUndefined();
    expect(config.vectorizers.default.indexConfig).toEqual<VectorIndexConfigHNSW>({
      skip: false,
      cleanupIntervalSeconds: 300,
      maxConnections: (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) ? 64 : 32,
      efConstruction: 128,
      ef: 4,
      dynamicEfMin: 100,
      dynamicEfMax: 500,
      dynamicEfFactor: 8,
      vectorCacheMaxObjects: 1000000000000,
      filterStrategy: 'sweeping',
      flatSearchCutoff: 40000,
      distance: 'cosine',
      type: 'hnsw',
      quantizer: {
        bitCompression: false,
        segments: 0,
        centroids: 256,
        trainingLimit: 100000,
        encoder: {
          type: 'kmeans',
          distribution: 'log-normal',
        },
        type: 'pq',
      },
    });
    expect(config.vectorizers.default.indexType).toEqual('hnsw');
    expect(config.vectorizers.default.vectorizer.name).toEqual('none');
  });
});



---
File: /src/collections/config/unit.test.ts
---

import {
  WeaviateInvertedIndexConfig,
  WeaviateMultiTenancyConfig,
  WeaviateVectorsConfig,
} from '../../openapi/types';
import { MergeWithExisting } from './classes';

describe('Unit testing of the MergeWithExisting class', () => {
  const invertedIndex: WeaviateInvertedIndexConfig = {
    bm25: {
      b: 0.8,
      k1: 1.3,
    },
    cleanupIntervalSeconds: 61,
    indexPropertyLength: true,
    indexTimestamps: true,
    stopwords: {
      preset: 'en',
    },
  };

  const hnswVectorConfig: WeaviateVectorsConfig = {
    name: {
      vectorIndexConfig: {
        skip: false,
        cleanupIntervalSeconds: 300,
        maxConnections: 64,
        efConstruction: 128,
        ef: -1,
        dynamicEfMin: 100,
        dynamicEfMax: 500,
        dynamicEfFactor: 8,
        vectorCacheMaxObjects: 1000000000000,
        flatSearchCutoff: 40000,
        distance: 'cosine',
        pq: {
          enabled: false,
          bitCompression: false,
          segments: 0,
          centroids: 256,
          trainingLimit: 100000,
          encoder: {
            type: 'kmeans',
            distribution: 'log-normal',
          },
        },
        bq: {
          enabled: false,
        },
        sq: {
          enabled: false,
        },
      },
      vectorIndexType: 'hnsw',
      vectorizer: {
        'text2vec-contextionary': {
          properties: ['name'],
          vectorizeCollectionName: false,
        },
      },
    },
  };

  it('should merge a full invertedIndexUpdate with existing schema', () => {
    const merged = MergeWithExisting.invertedIndex(JSON.parse(JSON.stringify(invertedIndex)), {
      bm25: {
        b: 0.9,
        k1: 1.4,
      },
      cleanupIntervalSeconds: 62,
      stopwords: {
        additions: ['foo', 'bar'],
        preset: 'none',
        removals: ['baz'],
      },
    });
    expect(merged).toEqual({
      bm25: {
        b: 0.9,
        k1: 1.4,
      },
      cleanupIntervalSeconds: 62,
      indexPropertyLength: true,
      indexTimestamps: true,
      stopwords: {
        preset: 'none',
        additions: ['foo', 'bar'],
        removals: ['baz'],
      },
    });
  });

  const flatVectorConfig: WeaviateVectorsConfig = {
    name: {
      vectorIndexConfig: {
        distance: 'cosine',
        vectorCacheMaxObjects: 1000000000000,
        pq: {
          enabled: false,
          rescoreLimit: -1,
          cache: false,
        },
        bq: {
          enabled: false,
          rescoreLimit: -1,
          cache: false,
        },
      },
      vectorIndexType: 'flat',
      vectorizer: {
        'text2vec-contextionary': {
          properties: ['name'],
          vectorizeCollectionName: false,
        },
      },
    },
  };

  const multiTenancyConfig: WeaviateMultiTenancyConfig = {
    enabled: true,
    autoTenantActivation: false,
    autoTenantCreation: false,
  };

  it('should merge a partial invertedIndexUpdate with existing schema', () => {
    const merged = MergeWithExisting.invertedIndex(JSON.parse(JSON.stringify(invertedIndex)), {
      bm25: {
        b: 0.9,
      },
      stopwords: {
        removals: ['baz'],
      },
    });
    expect(merged).toEqual({
      bm25: {
        b: 0.9,
        k1: 1.3,
      },
      cleanupIntervalSeconds: 61,
      indexPropertyLength: true,
      indexTimestamps: true,
      stopwords: {
        preset: 'en',
        removals: ['baz'],
      },
    });
  });

  it('should merge a no quantizer HNSW vectorIndexConfig with existing schema', () => {
    const merged = MergeWithExisting.vectors(JSON.parse(JSON.stringify(hnswVectorConfig)), [
      {
        name: 'name',
        vectorIndex: {
          name: 'hnsw',
          config: {
            skip: true,
            cleanupIntervalSeconds: 301,
            maxConnections: 65,
            efConstruction: 129,
            ef: -2,
            dynamicEfMin: 101,
            dynamicEfMax: 501,
            dynamicEfFactor: 9,
            vectorCacheMaxObjects: 1000000000001,
            flatSearchCutoff: 40001,
            distance: 'euclidean',
          },
        },
      },
    ]);
    expect(merged).toEqual({
      name: {
        vectorIndexConfig: {
          ...hnswVectorConfig.name.vectorIndexConfig,
          skip: true,
          cleanupIntervalSeconds: 301,
          maxConnections: 65,
          efConstruction: 129,
          ef: -2,
          dynamicEfMin: 101,
          dynamicEfMax: 501,
          dynamicEfFactor: 9,
          vectorCacheMaxObjects: 1000000000001,
          flatSearchCutoff: 40001,
          distance: 'euclidean',
        },
        vectorIndexType: 'hnsw',
        vectorizer: {
          'text2vec-contextionary': {
            properties: ['name'],
            vectorizeCollectionName: false,
          },
        },
      },
    });
  });

  it('should merge a PQ quantizer HNSW vectorIndexConfig with existing schema', () => {
    const merged = MergeWithExisting.vectors(JSON.parse(JSON.stringify(hnswVectorConfig)), [
      {
        name: 'name',
        vectorIndex: {
          name: 'hnsw',
          config: {
            quantizer: {
              type: 'pq',
              bitCompression: true,
              segments: 1,
              centroids: 512,
              trainingLimit: 200000,
              encoder: {
                type: 'kmeans',
                distribution: 'normal',
              },
            },
          },
        },
      },
    ]);
    expect(merged).toEqual({
      name: {
        vectorIndexConfig: {
          ...hnswVectorConfig.name.vectorIndexConfig,
          pq: {
            enabled: true,
            bitCompression: true,
            segments: 1,
            centroids: 512,
            trainingLimit: 200000,
            encoder: {
              type: 'kmeans',
              distribution: 'normal',
            },
          },
        },
        vectorIndexType: 'hnsw',
        vectorizer: {
          'text2vec-contextionary': {
            properties: ['name'],
            vectorizeCollectionName: false,
          },
        },
      },
    });
  });

  it('should merge a BQ quantizer HNSW vectorIndexConfig with existing schema', () => {
    const merged = MergeWithExisting.vectors(JSON.parse(JSON.stringify(hnswVectorConfig)), [
      {
        name: 'name',
        vectorIndex: {
          name: 'hnsw',
          config: {
            quantizer: {
              type: 'bq',
              rescoreLimit: 1000,
            },
          },
        },
      },
    ]);
    expect(merged).toEqual({
      name: {
        vectorIndexConfig: {
          ...hnswVectorConfig.name.vectorIndexConfig,
          bq: {
            enabled: true,
            rescoreLimit: 1000,
          },
        },
        vectorIndexType: 'hnsw',
        vectorizer: {
          'text2vec-contextionary': {
            properties: ['name'],
            vectorizeCollectionName: false,
          },
        },
      },
    });
  });

  it('should merge a SQ quantizer HNSW vectorIndexConfig with existing schema', () => {
    const merged = MergeWithExisting.vectors(JSON.parse(JSON.stringify(hnswVectorConfig)), [
      {
        name: 'name',
        vectorIndex: {
          name: 'hnsw',
          config: {
            quantizer: {
              type: 'sq',
              rescoreLimit: 1000,
              trainingLimit: 10000,
            },
          },
        },
      },
    ]);
    expect(merged).toEqual({
      name: {
        vectorIndexConfig: {
          ...hnswVectorConfig.name.vectorIndexConfig,
          sq: {
            enabled: true,
            rescoreLimit: 1000,
            trainingLimit: 10000,
          },
        },
        vectorIndexType: 'hnsw',
        vectorizer: {
          'text2vec-contextionary': {
            properties: ['name'],
            vectorizeCollectionName: false,
          },
        },
      },
    });
  });

  it('should merge a BQ quantizer Flat vectorIndexConfig with existing schema', () => {
    const merged = MergeWithExisting.vectors(JSON.parse(JSON.stringify(flatVectorConfig)), [
      {
        name: 'name',
        vectorIndex: {
          name: 'hnsw',
          config: {
            quantizer: {
              type: 'bq',
              rescoreLimit: 1000,
            },
          },
        },
      },
    ]);
    expect(merged).toEqual({
      name: {
        vectorIndexConfig: {
          ...flatVectorConfig.name.vectorIndexConfig,
          bq: {
            cache: false,
            enabled: true,
            rescoreLimit: 1000,
          },
        },
        vectorIndexType: 'flat',
        vectorizer: {
          'text2vec-contextionary': {
            properties: ['name'],
            vectorizeCollectionName: false,
          },
        },
      },
    });
  });

  it('should merge full multi tenancy config with existing schema', () => {
    const merged = MergeWithExisting.multiTenancy(JSON.parse(JSON.stringify(multiTenancyConfig)), {
      autoTenantActivation: true,
      autoTenantCreation: true,
    });
    expect(merged).toEqual({
      enabled: true,
      autoTenantActivation: true,
      autoTenantCreation: true,
    });
  });
});



---
File: /src/collections/config/utils.ts
---

import { WeaviateDeserializationError } from '../../errors.js';
import {
  WeaviateBM25Config,
  WeaviateClass,
  WeaviateInvertedIndexConfig,
  WeaviateModuleConfig,
  WeaviateMultiTenancyConfig,
  WeaviateNestedProperty,
  WeaviateProperty,
  WeaviateReplicationConfig,
  WeaviateShardingConfig,
  WeaviateStopwordConfig,
  WeaviateVectorIndexConfig,
  WeaviateVectorsConfig,
} from '../../openapi/types.js';
import {
  PropertyConfigCreate,
  ReferenceConfigCreate,
  ReferenceMultiTargetConfigCreate,
  ReferenceSingleTargetConfigCreate,
} from '../configure/types/index.js';
import {
  BQConfig,
  CollectionConfig,
  GenerativeConfig,
  GenerativeSearch,
  InvertedIndexConfig,
  ModuleConfig,
  MultiTenancyConfig,
  PQConfig,
  PQEncoderConfig,
  PQEncoderDistribution,
  PQEncoderType,
  PropertyConfig,
  PropertyVectorizerConfig,
  ReferenceConfig,
  ReplicationConfig,
  Reranker,
  RerankerConfig,
  SQConfig,
  ShardingConfig,
  VectorConfig,
  VectorDistance,
  VectorIndexConfigDynamic,
  VectorIndexConfigFlat,
  VectorIndexConfigHNSW,
  VectorIndexConfigType,
  VectorIndexFilterStrategy,
  VectorizerConfig,
} from './types/index.js';

export class ReferenceTypeGuards {
  static isSingleTarget<T>(ref: ReferenceConfigCreate<T>): ref is ReferenceSingleTargetConfigCreate<T> {
    return (ref as ReferenceSingleTargetConfigCreate<T>).targetCollection !== undefined;
  }
  static isMultiTarget<T>(ref: ReferenceConfigCreate<T>): ref is ReferenceMultiTargetConfigCreate<T> {
    return (ref as ReferenceMultiTargetConfigCreate<T>).targetCollections !== undefined;
  }
}

export const resolveProperty = <T>(
  prop: PropertyConfigCreate<T>,
  vectorizers?: string[]
): WeaviateProperty => {
  const { dataType, nestedProperties, skipVectorization, vectorizePropertyName, ...rest } = prop;
  const moduleConfig: any = {};
  vectorizers?.forEach((vectorizer) => {
    moduleConfig[vectorizer] = {
      skip: skipVectorization === undefined ? false : skipVectorization,
      vectorizePropertyName: vectorizePropertyName === undefined ? true : vectorizePropertyName,
    };
  });
  return {
    ...rest,
    dataType: [dataType],
    nestedProperties: nestedProperties
      ? nestedProperties.map((prop) => resolveNestedProperty(prop))
      : undefined,
    moduleConfig: Object.keys(moduleConfig).length > 0 ? moduleConfig : undefined,
  };
};

const resolveNestedProperty = <T, D>(prop: any): WeaviateNestedProperty => {
  const { dataType, nestedProperties, ...rest } = prop;
  return {
    ...rest,
    dataType: [dataType],
    nestedProperties: nestedProperties ? nestedProperties.map(resolveNestedProperty) : undefined,
  };
};

export const resolveReference = <T>(
  ref: ReferenceSingleTargetConfigCreate<T> | ReferenceMultiTargetConfigCreate<T>
): WeaviateProperty => {
  if (ReferenceTypeGuards.isSingleTarget(ref)) {
    const { targetCollection, ...rest } = ref;
    return {
      ...rest,
      dataType: [targetCollection],
    };
  } else {
    const { targetCollections, ...rest } = ref;
    return {
      ...rest,
      dataType: targetCollections,
    };
  }
};

export const classToCollection = <T>(cls: WeaviateClass): CollectionConfig => {
  return {
    name: ConfigMapping._name(cls.class),
    description: cls.description,
    generative: ConfigMapping.generative(cls.moduleConfig),
    invertedIndex: ConfigMapping.invertedIndex(cls.invertedIndexConfig),
    multiTenancy: ConfigMapping.multiTenancy(cls.multiTenancyConfig),
    properties: ConfigMapping.properties(cls.properties),
    references: ConfigMapping.references(cls.properties),
    replication: ConfigMapping.replication(cls.replicationConfig),
    reranker: ConfigMapping.reranker(cls.moduleConfig),
    sharding: ConfigMapping.sharding(cls.shardingConfig),
    vectorizers: ConfigMapping.vectorizer(cls),
  };
};

function populated<T>(v: T | null | undefined): v is T {
  return v !== undefined && v !== null;
}

function exists<T>(v: any): v is T {
  return v !== undefined && v !== null;
}

class ConfigMapping {
  static _name(v?: string): string {
    if (v === undefined)
      throw new WeaviateDeserializationError('Collection name was not returned by Weaviate');
    return v;
  }
  static bm25(v?: WeaviateBM25Config): InvertedIndexConfig['bm25'] {
    if (v === undefined) throw new WeaviateDeserializationError('BM25 was not returned by Weaviate');
    if (!populated(v.b)) throw new WeaviateDeserializationError('BM25 b was not returned by Weaviate');
    if (!populated(v.k1)) throw new WeaviateDeserializationError('BM25 k1 was not returned by Weaviate');
    return {
      b: v.b,
      k1: v.k1,
    };
  }
  static stopwords(v?: WeaviateStopwordConfig): InvertedIndexConfig['stopwords'] {
    if (v === undefined) throw new WeaviateDeserializationError('Stopwords were not returned by Weaviate');
    return {
      additions: v.additions ? v.additions : [],
      preset: v.preset ? v.preset : 'none',
      removals: v.removals ? v.removals : [],
    };
  }
  static generative<G>(
    v?: WeaviateModuleConfig
  ): ModuleConfig<GenerativeSearch, GenerativeConfig> | undefined {
    if (!populated(v)) return undefined;
    const generativeKey = Object.keys(v).find((k) => k.includes('generative'));
    if (generativeKey === undefined) return undefined;
    if (!generativeKey)
      throw new WeaviateDeserializationError('Generative config was not returned by Weaviate');
    return {
      name: generativeKey,
      config: v[generativeKey] as GenerativeConfig,
    };
  }
  static reranker(v?: WeaviateModuleConfig): ModuleConfig<Reranker, RerankerConfig> | undefined {
    if (!populated(v)) return undefined;
    const rerankerKey = Object.keys(v).find((k) => k.includes('reranker'));
    if (rerankerKey === undefined) return undefined;
    return {
      name: rerankerKey,
      config: v[rerankerKey] as RerankerConfig,
    };
  }
  private static namedVectors(v: WeaviateVectorsConfig): VectorConfig {
    if (!populated(v)) throw new WeaviateDeserializationError('Vector config was not returned by Weaviate');
    const out: VectorConfig = {};
    Object.keys(v).forEach((key) => {
      const vectorizer = v[key].vectorizer;
      if (!populated(vectorizer))
        throw new WeaviateDeserializationError(
          `Vectorizer was not returned by Weaviate for ${key} named vector`
        );
      const vectorizerNames = Object.keys(vectorizer);
      if (vectorizerNames.length !== 1)
        throw new WeaviateDeserializationError(
          `Expected exactly one vectorizer for ${key} named vector, got ${vectorizerNames.length}`
        );
      const vectorizerName = vectorizerNames[0];
      const { properties, ...restA } = vectorizer[vectorizerName] as any;
      const { vectorizeClassName, ...restB } = restA;
      out[key] = {
        vectorizer: {
          name: vectorizerName,
          config: {
            vectorizeCollectionName: vectorizeClassName,
            ...restB,
          },
        },
        properties: properties,
        indexConfig: ConfigMapping.vectorIndex(v[key].vectorIndexConfig, v[key].vectorIndexType),
        indexType: ConfigMapping.vectorIndexType(v[key].vectorIndexType),
      };
    });
    return out;
  }
  static vectorizer(v?: WeaviateClass): VectorConfig {
    if (!populated(v)) throw new WeaviateDeserializationError('Schema was not returned by Weaviate');
    if (populated(v.vectorConfig)) {
      return ConfigMapping.namedVectors(v.vectorConfig);
    }
    if (!populated(v.vectorizer))
      throw new WeaviateDeserializationError('Vectorizer was not returned by Weaviate');
    return {
      default: {
        vectorizer:
          v.vectorizer === 'none'
            ? {
                name: 'none',
                config: undefined,
              }
            : {
                name: v.vectorizer,
                config: v.moduleConfig
                  ? ({
                      ...(v.moduleConfig[v.vectorizer] as any),
                      vectorizeCollectionName: (v.moduleConfig[v.vectorizer] as any).vectorizeClassName,
                    } as VectorizerConfig)
                  : undefined,
              },
        indexConfig: ConfigMapping.vectorIndex(v.vectorIndexConfig, v.vectorIndexType),
        indexType: ConfigMapping.vectorIndexType(v.vectorIndexType),
      },
    };
  }
  static invertedIndex(v?: WeaviateInvertedIndexConfig): InvertedIndexConfig {
    if (v === undefined)
      throw new WeaviateDeserializationError('Inverted index was not returned by Weaviate');
    if (!populated(v.cleanupIntervalSeconds))
      throw new WeaviateDeserializationError('Inverted index cleanup interval was not returned by Weaviate');
    return {
      bm25: ConfigMapping.bm25(v.bm25),
      cleanupIntervalSeconds: v.cleanupIntervalSeconds,
      stopwords: ConfigMapping.stopwords(v.stopwords),
      indexNullState: v.indexNullState ? v.indexNullState : false,
      indexPropertyLength: v.indexPropertyLength ? v.indexPropertyLength : false,
      indexTimestamps: v.indexTimestamps ? v.indexTimestamps : false,
    };
  }
  static multiTenancy(v?: WeaviateMultiTenancyConfig): MultiTenancyConfig {
    if (v === undefined) throw new WeaviateDeserializationError('Multi tenancy was not returned by Weaviate');
    return {
      autoTenantActivation: v.autoTenantActivation ? v.autoTenantActivation : false,
      autoTenantCreation: v.autoTenantCreation ? v.autoTenantCreation : false,
      enabled: v.enabled ? v.enabled : false,
    };
  }
  static replication(v?: WeaviateReplicationConfig): ReplicationConfig {
    if (v === undefined) throw new WeaviateDeserializationError('Replication was not returned by Weaviate');
    if (!populated(v.factor))
      throw new WeaviateDeserializationError('Replication factor was not returned by Weaviate');
    return {
      factor: v.factor,
      asyncEnabled: v.asyncEnabled ? v.asyncEnabled : false,
      deletionStrategy: v.deletionStrategy ? v.deletionStrategy : 'NoAutomatedResolution',
    };
  }
  static sharding(v?: WeaviateShardingConfig): ShardingConfig {
    if (v === undefined) throw new WeaviateDeserializationError('Sharding was not returned by Weaviate');
    if (!exists<number>(v.virtualPerPhysical))
      throw new WeaviateDeserializationError('Sharding enabled was not returned by Weaviate');
    if (!exists<number>(v.desiredCount))
      throw new WeaviateDeserializationError('Sharding desired count was not returned by Weaviate');
    if (!exists<number>(v.actualCount))
      throw new WeaviateDeserializationError('Sharding actual count was not returned by Weaviate');
    if (!exists<number>(v.desiredVirtualCount))
      throw new WeaviateDeserializationError('Sharding desired virtual count was not returned by Weaviate');
    if (!exists<number>(v.actualVirtualCount))
      throw new WeaviateDeserializationError('Sharding actual virtual count was not returned by Weaviate');
    if (!exists<'_id'>(v.key))
      throw new WeaviateDeserializationError('Sharding key was not returned by Weaviate');
    if (!exists<'hash'>(v.strategy))
      throw new WeaviateDeserializationError('Sharding strategy was not returned by Weaviate');
    if (!exists<'murmur3'>(v.function))
      throw new WeaviateDeserializationError('Sharding function was not returned by Weaviate');
    return {
      virtualPerPhysical: v.virtualPerPhysical,
      desiredCount: v.desiredCount,
      actualCount: v.actualCount,
      desiredVirtualCount: v.desiredVirtualCount,
      actualVirtualCount: v.actualVirtualCount,
      key: v.key,
      strategy: v.strategy,
      function: v.function,
    };
  }
  static pqEncoder(v?: Record<string, unknown>): PQEncoderConfig {
    if (v === undefined) throw new WeaviateDeserializationError('PQ encoder was not returned by Weaviate');
    if (!exists<PQEncoderType>(v.type))
      throw new WeaviateDeserializationError('PQ encoder name was not returned by Weaviate');
    if (!exists<PQEncoderDistribution>(v.distribution))
      throw new WeaviateDeserializationError('PQ encoder distribution was not returned by Weaviate');
    return {
      type: v.type,
      distribution: v.distribution,
    };
  }
  static pq(v?: Record<string, unknown>): PQConfig | undefined {
    if (v === undefined) throw new WeaviateDeserializationError('PQ was not returned by Weaviate');
    if (!exists<boolean>(v.enabled))
      throw new WeaviateDeserializationError('PQ enabled was not returned by Weaviate');
    if (v.enabled === false) return undefined;
    if (!exists<boolean>(v.bitCompression))
      throw new WeaviateDeserializationError('PQ bit compression was not returned by Weaviate');
    if (!exists<number>(v.segments))
      throw new WeaviateDeserializationError('PQ segments was not returned by Weaviate');
    if (!exists<number>(v.trainingLimit))
      throw new WeaviateDeserializationError('PQ training limit was not returned by Weaviate');
    if (!exists<number>(v.centroids))
      throw new WeaviateDeserializationError('PQ centroids was not returned by Weaviate');
    if (!exists<Record<string, unknown>>(v.encoder))
      throw new WeaviateDeserializationError('PQ encoder was not returned by Weaviate');
    return {
      bitCompression: v.bitCompression,
      segments: v.segments,
      centroids: v.centroids,
      trainingLimit: v.trainingLimit,
      encoder: ConfigMapping.pqEncoder(v.encoder),
      type: 'pq',
    };
  }
  static vectorIndexHNSW(v: WeaviateVectorIndexConfig): VectorIndexConfigHNSW {
    if (v === undefined) throw new WeaviateDeserializationError('Vector index was not returned by Weaviate');
    if (!exists<number>(v.cleanupIntervalSeconds))
      throw new WeaviateDeserializationError('Vector index cleanup interval was not returned by Weaviate');
    if (!exists<VectorDistance>(v.distance))
      throw new WeaviateDeserializationError('Vector index distance was not returned by Weaviate');
    if (!exists<number>(v.dynamicEfMin))
      throw new WeaviateDeserializationError('Vector index dynamic ef min was not returned by Weaviate');
    if (!exists<number>(v.dynamicEfMax))
      throw new WeaviateDeserializationError('Vector index dynamic ef max was not returned by Weaviate');
    if (!exists<number>(v.dynamicEfFactor))
      throw new WeaviateDeserializationError('Vector index dynamic ef factor was not returned by Weaviate');
    if (!exists<number>(v.ef))
      throw new WeaviateDeserializationError('Vector index ef was not returned by Weaviate');
    if (!exists<number>(v.efConstruction))
      throw new WeaviateDeserializationError('Vector index ef construction was not returned by Weaviate');
    if (!exists<number>(v.flatSearchCutoff))
      throw new WeaviateDeserializationError('Vector index flat search cut off was not returned by Weaviate');
    if (!exists<number>(v.maxConnections))
      throw new WeaviateDeserializationError('Vector index max connections was not returned by Weaviate');
    if (!exists<boolean>(v.skip))
      throw new WeaviateDeserializationError('Vector index skip was not returned by Weaviate');
    if (!exists<number>(v.vectorCacheMaxObjects))
      throw new WeaviateDeserializationError(
        'Vector index vector cache max objects was not returned by Weaviate'
      );
    let quantizer: PQConfig | BQConfig | SQConfig | undefined;
    if (exists<Record<string, any>>(v.pq) && v.pq.enabled === true) {
      quantizer = ConfigMapping.pq(v.pq);
    } else if (exists<Record<string, any>>(v.bq) && v.bq.enabled === true) {
      quantizer = ConfigMapping.bq(v.bq);
    } else if (exists<Record<string, any>>(v.sq) && v.sq.enabled === true) {
      quantizer = ConfigMapping.sq(v.sq);
    } else {
      quantizer = undefined;
    }
    return {
      cleanupIntervalSeconds: v.cleanupIntervalSeconds,
      distance: v.distance,
      dynamicEfMin: v.dynamicEfMin,
      dynamicEfMax: v.dynamicEfMax,
      dynamicEfFactor: v.dynamicEfFactor,
      ef: v.ef,
      efConstruction: v.efConstruction,
      filterStrategy: exists<VectorIndexFilterStrategy>(v.filterStrategy) ? v.filterStrategy : 'sweeping',
      flatSearchCutoff: v.flatSearchCutoff,
      maxConnections: v.maxConnections,
      quantizer: quantizer,
      skip: v.skip,
      vectorCacheMaxObjects: v.vectorCacheMaxObjects,
      type: 'hnsw',
    };
  }
  static bq(v?: Record<string, unknown>): BQConfig | undefined {
    if (v === undefined) throw new WeaviateDeserializationError('BQ was not returned by Weaviate');
    if (!exists<boolean>(v.enabled))
      throw new WeaviateDeserializationError('BQ enabled was not returned by Weaviate');
    if (v.enabled === false) return undefined;
    const cache = v.cache === undefined ? false : (v.cache as boolean);
    const rescoreLimit = v.rescoreLimit === undefined ? 1000 : (v.rescoreLimit as number);
    return {
      cache,
      rescoreLimit,
      type: 'bq',
    };
  }
  static sq(v?: Record<string, unknown>): SQConfig | undefined {
    if (v === undefined) throw new WeaviateDeserializationError('SQ was not returned by Weaviate');
    if (!exists<boolean>(v.enabled))
      throw new WeaviateDeserializationError('SQ enabled was not returned by Weaviate');
    if (v.enabled === false) return undefined;
    const rescoreLimit = v.rescoreLimit === undefined ? 1000 : (v.rescoreLimit as number);
    const trainingLimit = v.trainingLimit === undefined ? 100000 : (v.trainingLimit as number);
    return {
      rescoreLimit,
      trainingLimit,
      type: 'sq',
    };
  }
  static vectorIndexFlat(v: WeaviateVectorIndexConfig): VectorIndexConfigFlat {
    if (v === undefined) throw new WeaviateDeserializationError('Vector index was not returned by Weaviate');
    if (!exists<number>(v.vectorCacheMaxObjects))
      throw new WeaviateDeserializationError(
        'Vector index vector cache max objects was not returned by Weaviate'
      );
    if (!exists<VectorDistance>(v.distance))
      throw new WeaviateDeserializationError('Vector index distance was not returned by Weaviate');
    if (!exists<Record<string, unknown>>(v.bq))
      throw new WeaviateDeserializationError('Vector index bq was not returned by Weaviate');
    return {
      vectorCacheMaxObjects: v.vectorCacheMaxObjects,
      distance: v.distance,
      quantizer: ConfigMapping.bq(v.bq),
      type: 'flat',
    };
  }
  static vectorIndexDynamic(v: WeaviateVectorIndexConfig): VectorIndexConfigDynamic {
    if (v === undefined) throw new WeaviateDeserializationError('Vector index was not returned by Weaviate');
    if (!exists<number>(v.threshold))
      throw new WeaviateDeserializationError('Vector index threshold was not returned by Weaviate');
    if (!exists<VectorDistance>(v.distance))
      throw new WeaviateDeserializationError('Vector index distance was not returned by Weaviate');
    if (!exists<WeaviateVectorIndexConfig>(v.hnsw))
      throw new WeaviateDeserializationError('Vector index hnsw was not returned by Weaviate');
    if (!exists<WeaviateVectorIndexConfig>(v.flat))
      throw new WeaviateDeserializationError('Vector index flat was not returned by Weaviate');
    return {
      distance: v.distance,
      hnsw: ConfigMapping.vectorIndexHNSW(v.hnsw),
      flat: ConfigMapping.vectorIndexFlat(v.flat),
      threshold: v.threshold,
      type: 'dynamic',
    };
  }
  static vectorIndex<I>(v: WeaviateVectorIndexConfig, t?: string): VectorIndexConfigType<I> {
    if (t === 'hnsw') {
      return ConfigMapping.vectorIndexHNSW(v) as VectorIndexConfigType<I>;
    } else if (t === 'flat') {
      return ConfigMapping.vectorIndexFlat(v) as VectorIndexConfigType<I>;
    } else if (t === 'dynamic') {
      return ConfigMapping.vectorIndexDynamic(v) as VectorIndexConfigType<I>;
    } else {
      return v as VectorIndexConfigType<I>;
    }
  }
  static vectorIndexType<I>(v?: string): I {
    if (!populated(v))
      throw new WeaviateDeserializationError('Vector index type was not returned by Weaviate');
    return v as I;
  }
  static properties(v?: WeaviateProperty[]): PropertyConfig[] {
    if (v === undefined) throw new WeaviateDeserializationError('Properties were not returned by Weaviate');
    if (v === null) return [];
    return v
      .filter((prop) => {
        if (!populated(prop.dataType))
          throw new WeaviateDeserializationError('Property data type was not returned by Weaviate');
        return prop.dataType[0][0].toLowerCase() === prop.dataType[0][0]; // primitive property, e.g. text
      })
      .map((prop) => {
        if (!populated(prop.name))
          throw new WeaviateDeserializationError('Property name was not returned by Weaviate');
        if (!populated(prop.dataType))
          throw new WeaviateDeserializationError('Property data type was not returned by Weaviate');
        return {
          name: prop.name,
          dataType: prop.dataType[0],
          description: prop.description,
          indexFilterable: prop.indexFilterable ? prop.indexFilterable : false,
          indexInverted: prop.indexInverted ? prop.indexInverted : false,
          indexRangeFilters: prop.indexRangeFilters ? prop.indexRangeFilters : false,
          indexSearchable: prop.indexSearchable ? prop.indexSearchable : false,
          vectorizerConfig: prop.moduleConfig
            ? 'none' in prop.moduleConfig
              ? undefined
              : (prop.moduleConfig as PropertyVectorizerConfig)
            : undefined,
          nestedProperties: prop.nestedProperties
            ? ConfigMapping.properties(prop.nestedProperties)
            : undefined,
          tokenization: prop.tokenization ? prop.tokenization : 'none',
        };
      });
  }
  static references(v?: WeaviateProperty[]): ReferenceConfig[] {
    if (v === undefined) throw new WeaviateDeserializationError('Properties were not returned by Weaviate');
    if (v === null) return [];
    return v
      .filter((prop) => {
        if (!populated(prop.dataType))
          throw new WeaviateDeserializationError('Reference data type was not returned by Weaviate');
        return prop.dataType[0][0].toLowerCase() !== prop.dataType[0][0]; // reference property, e.g. Myclass
      })
      .map((prop) => {
        if (!populated(prop.name))
          throw new WeaviateDeserializationError('Reference name was not returned by Weaviate');
        if (!populated(prop.dataType))
          throw new WeaviateDeserializationError('Reference data type was not returned by Weaviate');
        return {
          name: prop.name,
          description: prop.description,
          targetCollections: prop.dataType,
        };
      });
  }
}



---
File: /src/collections/configure/types/base.ts
---

import { WeaviateNestedProperty, WeaviateProperty } from '../../../openapi/types.js';
import {
  InvertedIndexConfig,
  MultiTenancyConfig,
  ReplicationConfig,
  ReplicationDeletionStrategy,
} from '../../config/types/index.js';
import { DataType } from '../../types/index.js';
import { NonRefKeys, RefKeys } from '../../types/internal.js';

export type RecursivePartial<T> = T extends object
  ? {
      [P in keyof T]?: RecursivePartial<T[P]>;
    }
  : T;

export type InvertedIndexConfigCreate = RecursivePartial<InvertedIndexConfig>;

export type InvertedIndexConfigUpdate = {
  bm25?: {
    b?: number;
    k1?: number;
  };
  cleanupIntervalSeconds?: number;
  stopwords?: {
    preset?: string;
    additions?: string[];
    removals?: string[];
  };
};

export type MultiTenancyConfigCreate = RecursivePartial<MultiTenancyConfig>;

export type MultiTenancyConfigUpdate = {
  autoTenantActivation?: boolean;
  autoTenantCreation?: boolean;
};

export type ObjectDataType = 'object' | 'object[]';

export type PrimitiveDataType = Exclude<DataType, ObjectDataType>;

export type NestedDataTypeConfig<T> =
  | {
      dataType: ObjectDataType;
      /** only for object types */
      nestedProperties?: NestedPropertyCreate<T>[];
    }
  | {
      dataType: PrimitiveDataType;
      /** If not an object, or an array of objecs, this field should never be assigned. */
      nestedProperties?: never;
    };

export type NestedPropertyCreate<T = undefined> = T extends undefined
  ? {
      name: string;
      description?: string;
      indexInverted?: boolean;
      indexFilterable?: boolean;
      indexSearchable?: boolean;
      tokenization?: WeaviateNestedProperty['tokenization'];
    } & NestedDataTypeConfig<T>
  : {
      [K in NonRefKeys<T>]: RequiresNested<DataType<T[K]>> extends true
        ? {
            name: K;
            dataType: DataType<T[K]>;
            nestedProperties: NestedPropertyConfigCreate<T[K], DataType<T[K]>>[];
          } & NestedPropertyConfigCreateBase
        : {
            name: K;
            dataType: DataType<T[K]>;
            nestedProperties?: NestedPropertyConfigCreate<T[K], DataType<T[K]>>[];
          } & NestedPropertyConfigCreateBase;
    }[NonRefKeys<T>];

export type NestedPropertyConfigCreate<T, D> = D extends 'object' | 'object[]'
  ? T extends (infer U)[]
    ? NestedPropertyCreate<U>
    : NestedPropertyCreate<T>
  : never;

export type RequiresNested<T> = T extends 'object' | 'object[]' ? true : false;

export type PropertyConfigCreateBase = {
  description?: string;
  indexInverted?: boolean;
  indexFilterable?: boolean;
  indexRangeFilters?: boolean;
  indexSearchable?: boolean;
  tokenization?: WeaviateProperty['tokenization'];
  skipVectorization?: boolean;
  vectorizePropertyName?: boolean;
};

export type NestedPropertyConfigCreateBase = {
  description?: string;
  indexInverted?: boolean;
  indexFilterable?: boolean;
  indexRangeFilters?: boolean;
  indexSearchable?: boolean;
  tokenization?: WeaviateNestedProperty['tokenization'];
};

export type PropertyConfigCreate<T> = T extends undefined
  ? {
      name: string;
      description?: string;
      indexInverted?: boolean;
      indexFilterable?: boolean;
      indexRangeFilters?: boolean;
      indexSearchable?: boolean;
      tokenization?: WeaviateProperty['tokenization'];
      skipVectorization?: boolean;
      vectorizePropertyName?: boolean;
    } & NestedDataTypeConfig<T>
  : {
      [K in NonRefKeys<T>]: RequiresNested<DataType<T[K]>> extends true
        ? {
            name: K;
            dataType: DataType<T[K]>;
            nestedProperties: NestedPropertyConfigCreate<T[K], DataType<T[K]>>[];
          } & PropertyConfigCreateBase
        : {
            name: K;
            dataType: DataType<T[K]>;
            nestedProperties?: NestedPropertyConfigCreate<T[K], DataType<T[K]>>[];
          } & PropertyConfigCreateBase;
    }[NonRefKeys<T>];

/** The base class for creating a reference configuration. */
export type ReferenceConfigBaseCreate<T> = {
  /** The name of the reference. If no generic passed, the type is string. If a generic is passed, the type is a union of the keys labelled as CrossReference<T>. */
  name: T extends undefined ? string : RefKeys<T>;
  /** The description of the reference. */
  description?: string;
};

/** Use this type when defining a single-target reference for your collection. */
export type ReferenceSingleTargetConfigCreate<T> = ReferenceConfigBaseCreate<T> & {
  /** The collection that this reference points to. */
  targetCollection: string;
};

/** Use this type when defining a multi-target reference for your collection. */
export type ReferenceMultiTargetConfigCreate<T> = ReferenceConfigBaseCreate<T> & {
  /** The collection(s) that this reference points to. */
  targetCollections: string[];
};

export type ReferenceConfigCreate<T> =
  | ReferenceSingleTargetConfigCreate<T>
  | ReferenceMultiTargetConfigCreate<T>;

export type ReplicationConfigCreate = RecursivePartial<ReplicationConfig>;

export type ReplicationConfigUpdate = {
  asyncEnabled?: boolean;
  deletionStrategy?: ReplicationDeletionStrategy;
  factor?: number;
};

export type ShardingConfigCreate = {
  virtualPerPhysical?: number;
  desiredCount?: number;
  desiredVirtualCount?: number;
};



---
File: /src/collections/configure/types/generative.ts
---

import {
  GenerativeAWSConfig,
  GenerativeAnthropicConfig,
  GenerativeAnyscaleConfig,
  GenerativeDatabricksConfig,
  GenerativeFriendliAIConfig,
  GenerativeMistralConfig,
  GenerativeOllamaConfig,
  GenerativePaLMConfig,
} from '../../index.js';

export type GenerativeOpenAIConfigBaseCreate = {
  baseURL?: string;
  frequencyPenalty?: number;
  maxTokens?: number;
  presencePenalty?: number;
  temperature?: number;
  topP?: number;
};

export type GenerativeAnthropicConfigCreate = GenerativeAnthropicConfig;

export type GenerativeAnyscaleConfigCreate = GenerativeAnyscaleConfig;

export type GenerativeAWSConfigCreate = GenerativeAWSConfig;

export type GenerativeAzureOpenAIConfigCreate = GenerativeOpenAIConfigBaseCreate & {
  resourceName: string;
  deploymentId: string;
};

export type GenerativeCohereConfigCreate = {
  k?: number;
  maxTokens?: number;
  model?: string;
  returnLikelihoods?: string;
  stopSequences?: string[];
  temperature?: number;
};

export type GenerativeDatabricksConfigCreate = GenerativeDatabricksConfig;

export type GenerativeFriendliAIConfigCreate = GenerativeFriendliAIConfig;

export type GenerativeMistralConfigCreate = GenerativeMistralConfig;

export type GenerativeOllamaConfigCreate = GenerativeOllamaConfig;

export type GenerativeOpenAIConfigCreate = GenerativeOpenAIConfigBaseCreate & {
  model?: string;
};

export type GenerativePaLMConfigCreate = GenerativePaLMConfig;

export type GenerativeConfigCreate =
  | GenerativeAnthropicConfigCreate
  | GenerativeAnyscaleConfigCreate
  | GenerativeAWSConfigCreate
  | GenerativeAzureOpenAIConfigCreate
  | GenerativeCohereConfigCreate
  | GenerativeDatabricksConfigCreate
  | GenerativeFriendliAIConfigCreate
  | GenerativeMistralConfigCreate
  | GenerativeOllamaConfigCreate
  | GenerativeOpenAIConfigCreate
  | GenerativePaLMConfigCreate
  | Record<string, any>
  | undefined;

export type GenerativeConfigCreateType<G> = G extends 'generative-anthropic'
  ? GenerativeAnthropicConfigCreate
  : G extends 'generative-aws'
  ? GenerativeAWSConfigCreate
  : G extends 'generative-azure-openai'
  ? GenerativeAzureOpenAIConfigCreate
  : G extends 'generative-cohere'
  ? GenerativeCohereConfigCreate
  : G extends 'generative-databricks'
  ? GenerativeDatabricksConfigCreate
  : G extends 'generative-friendliai'
  ? GenerativeFriendliAIConfigCreate
  : G extends 'generative-mistral'
  ? GenerativeMistralConfigCreate
  : G extends 'generative-ollama'
  ? GenerativeOllamaConfigCreate
  : G extends 'generative-openai'
  ? GenerativeOpenAIConfigCreate
  : G extends 'generative-palm'
  ? GenerativePaLMConfigCreate
  : G extends 'none'
  ? undefined
  : Record<string, any> | undefined;



---
File: /src/collections/configure/types/index.ts
---

export * from './base.js';
export * from './generative.js';
export * from './vectorIndex.js';
export * from './vectorizer.js';



---
File: /src/collections/configure/types/vectorIndex.ts
---

import {
  BQConfig,
  ModuleConfig,
  PQConfig,
  PQEncoderDistribution,
  PQEncoderType,
  SQConfig,
  VectorDistance,
  VectorIndexConfigDynamic,
  VectorIndexConfigFlat,
  VectorIndexConfigHNSW,
  VectorIndexFilterStrategy,
} from '../../config/types/index.js';
import { RecursivePartial } from './base.js';

export type QuantizerRecursivePartial<T> = {
  [P in keyof T]: P extends 'type' ? T[P] : RecursivePartial<T[P]> | undefined;
};

export type PQConfigCreate = QuantizerRecursivePartial<PQConfig>;

export type PQConfigUpdate = {
  centroids?: number;
  enabled?: boolean;
  segments?: number;
  trainingLimit?: number;
  encoder?: {
    type?: PQEncoderType;
    distribution?: PQEncoderDistribution;
  };
  type: 'pq';
};

export type BQConfigCreate = QuantizerRecursivePartial<BQConfig>;

export type BQConfigUpdate = {
  rescoreLimit?: number;
  type: 'bq';
};

export type SQConfigCreate = QuantizerRecursivePartial<SQConfig>;

export type SQConfigUpdate = {
  rescoreLimit?: number;
  trainingLimit?: number;
  type: 'sq';
};

export type VectorIndexConfigHNSWCreate = RecursivePartial<VectorIndexConfigHNSW>;

export type VectorIndexConfigDynamicCreate = RecursivePartial<VectorIndexConfigDynamic>;

export type VectorIndexConfigDymamicUpdate = RecursivePartial<VectorIndexConfigDynamic>;

export type VectorIndexConfigHNSWUpdate = {
  dynamicEfMin?: number;
  dynamicEfMax?: number;
  dynamicEfFactor?: number;
  ef?: number;
  filterStrategy?: VectorIndexFilterStrategy;
  flatSearchCutoff?: number;
  quantizer?: PQConfigUpdate | BQConfigUpdate | SQConfigUpdate;
  vectorCacheMaxObjects?: number;
};

export type VectorIndexConfigCreateType<I> = I extends 'hnsw'
  ? VectorIndexConfigHNSWCreate | undefined
  : I extends 'flat'
  ? VectorIndexConfigFlatCreate | undefined
  : I extends 'dynamic'
  ? VectorIndexConfigDynamicCreate | undefined
  : I extends string
  ? Record<string, any>
  : never;

export type VectorIndexConfigFlatCreate = RecursivePartial<VectorIndexConfigFlat>;

export type VectorIndexConfigFlatUpdate = {
  quantizer?: BQConfigUpdate;
  vectorCacheMaxObjects?: number;
};

export type VectorIndexConfigCreate =
  | VectorIndexConfigFlatCreate
  | VectorIndexConfigHNSWCreate
  | VectorIndexConfigDynamicCreate
  | Record<string, any>
  | undefined;

export type VectorIndexConfigUpdate =
  | VectorIndexConfigFlatUpdate
  | VectorIndexConfigHNSWUpdate
  | VectorIndexConfigDymamicUpdate
  | Record<string, any>
  | undefined;

export type VectorIndexConfigUpdateType<I> = I extends 'hnsw'
  ? VectorIndexConfigHNSWUpdate
  : I extends 'flat'
  ? VectorIndexConfigFlatUpdate
  : I extends 'dynamic'
  ? VectorIndexConfigDymamicUpdate
  : I extends string
  ? Record<string, any>
  : never;

export type LegacyVectorizerConfigUpdate =
  | ModuleConfig<'flat', VectorIndexConfigFlatUpdate>
  | ModuleConfig<'hnsw', VectorIndexConfigHNSWUpdate>
  | ModuleConfig<string, Record<string, any>>;

export type VectorIndexConfigHNSWCreateOptions = {
  /** The interval in seconds at which to clean up the index. Default is 300. */
  cleanupIntervalSeconds?: number;
  /** The distance metric to use. Default is 'cosine'. */
  distanceMetric?: VectorDistance;
  /** The dynamic ef factor. Default is 8. */
  dynamicEfFactor?: number;
  /** The dynamic ef max. Default is 500. */
  dynamicEfMax?: number;
  /** The dynamic ef min. Default is 100. */
  dynamicEfMin?: number;
  /** The ef parameter. Default is -1. */
  ef?: number;
  /** The ef construction parameter. Default is 128. */
  efConstruction?: number;
  /** The flat search cutoff. Default is 40000. */
  flatSearchCutoff?: number;
  /** The filter strategy to use. Default is 'sweeping'. */
  filterStrategy?: VectorIndexFilterStrategy;
  /** The maximum number of connections. Default is 64. */
  maxConnections?: number;
  /** The quantizer configuration to use. Use `vectorIndex.quantizer.bq` or `vectorIndex.quantizer.pq` to make one. */
  quantizer?: PQConfigCreate | BQConfigCreate | SQConfigCreate;
  /** Whether to skip the index. Default is false. */
  skip?: boolean;
  /** The maximum number of objects to cache in the vector cache. Default is 1000000000000. */
  vectorCacheMaxObjects?: number;
};

export type VectorIndexConfigFlatCreateOptions = {
  /** The distance metric to use. Default is 'cosine'. */
  distanceMetric?: VectorDistance;
  /** The maximum number of objects to cache in the vector cache. Default is 1000000000000. */
  vectorCacheMaxObjects?: number;
  /** The quantizer configuration to use. Default is `bq`. */
  quantizer?: BQConfigCreate;
};

export type VectorIndexConfigDynamicCreateOptions = {
  /** The distance metric to use. Default is 'cosine'. */
  distanceMetric?: VectorDistance;
  /** The threshold at which to . Default is 0. */
  threshold?: number;
  /** The HNSW configuration of the dynamic index. Use `configure.vectorIndex.hnsw` to make one or supply the type directly. */
  hnsw?: ModuleConfig<'hnsw', VectorIndexConfigHNSWCreate | undefined> | VectorIndexConfigHNSWCreateOptions;
  /** The flat configuration of the dynamic index. Use `configure.vectorIndex.flat` to make one or supply the type directly. */
  flat?: ModuleConfig<'flat', VectorIndexConfigFlatCreate | undefined> | VectorIndexConfigFlatCreateOptions;
};



---
File: /src/collections/configure/types/vectorizer.ts
---

import {
  Img2VecNeuralConfig,
  ModuleConfig,
  Multi2VecField,
  Ref2VecCentroidConfig,
  Text2VecAWSConfig,
  Text2VecAzureOpenAIConfig,
  Text2VecCohereConfig,
  Text2VecContextionaryConfig,
  Text2VecDatabricksConfig,
  Text2VecGPT4AllConfig,
  Text2VecGoogleConfig,
  Text2VecHuggingFaceConfig,
  Text2VecJinaConfig,
  Text2VecMistralConfig,
  Text2VecOllamaConfig,
  Text2VecOpenAIConfig,
  Text2VecTransformersConfig,
  Text2VecVoyageAIConfig,
  Text2VecWeaviateConfig,
  VectorIndexType,
  Vectorizer,
  VectorizerConfigType,
} from '../../config/types/index.js';
import { PrimitiveKeys } from '../../types/internal.js';
import { VectorIndexConfigCreateType, VectorIndexConfigUpdateType } from './vectorIndex.js';

export type VectorizerCreateOptions<P, I, V> = {
  sourceProperties?: P;
  vectorIndexConfig?: ModuleConfig<I, VectorIndexConfigCreateType<I>>;
  vectorizerConfig?: ModuleConfig<V, VectorizerConfigType<V>>;
};

export type VectorizerUpdateOptions<N, I> = {
  name?: N;
  vectorIndexConfig: ModuleConfig<I, VectorIndexConfigUpdateType<I>>;
};

export type VectorConfigCreate<
  P,
  N extends string | undefined,
  I extends VectorIndexType,
  V extends Vectorizer
> = {
  name: N;
  properties?: P[];
  vectorizer: ModuleConfig<V, VectorizerConfigType<V>>;
  vectorIndex: ModuleConfig<I, VectorIndexConfigCreateType<I>>;
};

export type VectorConfigUpdate<N extends string | undefined, I extends VectorIndexType> = {
  name: N;
  vectorIndex: ModuleConfig<I, VectorIndexConfigUpdateType<I>>;
};

export type VectorizersConfigCreate<T> =
  | VectorConfigCreate<PrimitiveKeys<T>, undefined, VectorIndexType, Vectorizer>
  | VectorConfigCreate<PrimitiveKeys<T>, string, VectorIndexType, Vectorizer>[];

export type ConfigureNonTextVectorizerOptions<
  N extends string | undefined,
  I extends VectorIndexType,
  V extends Vectorizer
> = VectorizerConfigCreateType<V> & {
  name?: N;
  vectorIndexConfig?: ModuleConfig<I, VectorIndexConfigCreateType<I>>;
};

export type ConfigureTextVectorizerOptions<
  T,
  N extends string | undefined,
  I extends VectorIndexType,
  V extends Vectorizer
> = VectorizerConfigCreateType<V> & {
  name?: N;
  sourceProperties?: PrimitiveKeys<T>[];
  vectorIndexConfig?: ModuleConfig<I, VectorIndexConfigCreateType<I>>;
};

export type Img2VecNeuralConfigCreate = Img2VecNeuralConfig;

/** The configuration for the `multi2vec-clip` vectorizer. */
export type Multi2VecClipConfigCreate = {
  /** The image fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  imageFields?: string[] | Multi2VecField[];
  /** The inference url to use where API requests should go. */
  inferenceUrl?: string;
  /** The text fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  textFields?: string[] | Multi2VecField[];
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/** The configuration for the `multi2vec-bind` vectorizer. */
export type Multi2VecBindConfigCreate = {
  /** The audio fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  audioFields?: string[] | Multi2VecField[];
  /** The depth fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  depthFields?: string[] | Multi2VecField[];
  /** The image fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  imageFields?: string[] | Multi2VecField[];
  /** The IMU fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  IMUFields?: string[] | Multi2VecField[];
  /** The text fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  textFields?: string[] | Multi2VecField[];
  /** The thermal fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  thermalFields?: string[] | Multi2VecField[];
  /** The video fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  videoFields?: string[] | Multi2VecField[];
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/** The configuration for the `multi2vec-cohere` vectorizer. */
export type Multi2VecCohereConfigCreate = {
  /** The base URL to use where API requests should go. */
  baseURL?: string;
  /** The image fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  imageFields?: string[] | Multi2VecField[];
  /** The specific model to use. */
  model?: string;
  /** The text fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  textFields?: string[] | Multi2VecField[];
  /** The truncation strategy to use. */
  truncate?: string;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

/** @deprecated Use `Multi2VecGoogleConfigCreate` instead.*/
export type Multi2VecPalmConfigCreate = Multi2VecGoogleConfigCreate;

/** The configuration for the `multi2vec-google` vectorizer. */
export type Multi2VecGoogleConfigCreate = {
  /** The project id of the model in GCP. */
  projectId: string;
  /** Where the model runs */
  location: string;
  /** The image fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  imageFields?: string[] | Multi2VecField[];
  /** The text fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  textFields?: string[] | Multi2VecField[];
  /** The video fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  videoFields?: string[] | Multi2VecField[];
  /** The model ID to use. */
  modelId?: string;
  /** The number of dimensions to use. */
  dimensions?: number;
  /** Whether to vectorize the collection name. */
  vectorizeCollectionName?: boolean;
};

export type Multi2VecVoyageAIConfigCreate = {
  /** The image fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  imageFields?: string[] | Multi2VecField[];
  /** The text fields to use in vectorization. Can be string of `Multi2VecField` type. If string, weight 0 will be assumed. */
  textFields?: string[] | Multi2VecField[];
};

export type Ref2VecCentroidConfigCreate = Ref2VecCentroidConfig;

export type Text2VecAWSConfigCreate = Text2VecAWSConfig;

export type Text2VecAzureOpenAIConfigCreate = Text2VecAzureOpenAIConfig;

export type Text2VecCohereConfigCreate = Text2VecCohereConfig;

export type Text2VecContextionaryConfigCreate = Text2VecContextionaryConfig;

export type Text2VecDatabricksConfigCreate = Text2VecDatabricksConfig;

export type Text2VecGPT4AllConfigCreate = Text2VecGPT4AllConfig;

export type Text2VecHuggingFaceConfigCreate = Text2VecHuggingFaceConfig;

export type Text2VecJinaConfigCreate = Text2VecJinaConfig;

export type Text2VecMistralConfigCreate = Text2VecMistralConfig;

export type Text2VecOllamaConfigCreate = Text2VecOllamaConfig;

export type Text2VecOpenAIConfigCreate = Text2VecOpenAIConfig;

/** @deprecated Use `Text2VecGoogleConfigCreate` instead. */
export type Text2VecPalmConfigCreate = Text2VecGoogleConfig;

export type Text2VecGoogleConfigCreate = Text2VecGoogleConfig;

export type Text2VecTransformersConfigCreate = Text2VecTransformersConfig;

export type Text2VecVoyageAIConfigCreate = Text2VecVoyageAIConfig;

export type Text2VecWeaviateConfigCreate = Text2VecWeaviateConfig;

export type VectorizerConfigCreateType<V> = V extends 'img2vec-neural'
  ? Img2VecNeuralConfigCreate | undefined
  : V extends 'multi2vec-clip'
  ? Multi2VecClipConfigCreate | undefined
  : V extends 'multi2vec-cohere'
  ? Multi2VecCohereConfigCreate | undefined
  : V extends 'multi2vec-bind'
  ? Multi2VecBindConfigCreate | undefined
  : V extends 'multi2vec-palm'
  ? Multi2VecPalmConfigCreate
  : V extends 'multi2vec-google'
  ? Multi2VecGoogleConfigCreate
  : V extends 'multi2vec-voyageai'
  ? Multi2VecVoyageAIConfigCreate | undefined
  : V extends 'ref2vec-centroid'
  ? Ref2VecCentroidConfigCreate
  : V extends 'text2vec-aws'
  ? Text2VecAWSConfigCreate
  : V extends 'text2vec-contextionary'
  ? Text2VecContextionaryConfigCreate | undefined
  : V extends 'text2vec-cohere'
  ? Text2VecCohereConfigCreate | undefined
  : V extends 'text2vec-databricks'
  ? Text2VecDatabricksConfigCreate
  : V extends 'text2vec-gpt4all'
  ? Text2VecGPT4AllConfigCreate | undefined
  : V extends 'text2vec-huggingface'
  ? Text2VecHuggingFaceConfigCreate | undefined
  : V extends 'text2vec-jina'
  ? Text2VecJinaConfigCreate | undefined
  : V extends 'text2vec-mistral'
  ? Text2VecMistralConfigCreate | undefined
  : V extends 'text2vec-ollama'
  ? Text2VecOllamaConfigCreate | undefined
  : V extends 'text2vec-openai'
  ? Text2VecOpenAIConfigCreate | undefined
  : V extends 'text2vec-azure-openai'
  ? Text2VecAzureOpenAIConfigCreate
  : V extends 'text2vec-palm'
  ? Text2VecPalmConfigCreate | undefined
  : V extends 'text2vec-google'
  ? Text2VecGoogleConfigCreate | undefined
  : V extends 'text2vec-transformers'
  ? Text2VecTransformersConfigCreate | undefined
  : V extends 'text2vec-voyageai'
  ? Text2VecVoyageAIConfigCreate | undefined
  : V extends 'text2vec-weaviate'
  ? Text2VecWeaviateConfigCreate | undefined
  : V extends 'none'
  ? {}
  : V extends undefined
  ? undefined
  : never;



---
File: /src/collections/configure/generative.ts
---

import {
  GenerativeAWSConfig,
  GenerativeAnthropicConfig,
  GenerativeAnyscaleConfig,
  GenerativeAzureOpenAIConfig,
  GenerativeCohereConfig,
  GenerativeDatabricksConfig,
  GenerativeFriendliAIConfig,
  GenerativeGoogleConfig,
  GenerativeMistralConfig,
  GenerativeOllamaConfig,
  GenerativeOpenAIConfig,
  GenerativePaLMConfig,
  ModuleConfig,
} from '../config/types/index.js';
import {
  GenerativeAWSConfigCreate,
  GenerativeAnthropicConfigCreate,
  GenerativeAnyscaleConfigCreate,
  GenerativeAzureOpenAIConfigCreate,
  GenerativeCohereConfigCreate,
  GenerativeDatabricksConfigCreate,
  GenerativeFriendliAIConfigCreate,
  GenerativeMistralConfigCreate,
  GenerativeOllamaConfigCreate,
  GenerativeOpenAIConfigCreate,
  GenerativePaLMConfigCreate,
} from '../index.js';

export default {
  /**
   * Create a `ModuleConfig<'generative-anthropic', GenerativeAnthropicConfig | undefined>` object for use when performing AI generation using the `generative-anthropic` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/anthropic/generative) for detailed usage.
   *
   * @param {GenerativeAnthropicConfigCreate} [config] The configuration for the `generative-anthropic` module.
   * @returns {ModuleConfig<'generative-anthropic', GenerativeAnthropicConfig | undefined>} The configuration object.
   */
  anthropic(
    config?: GenerativeAnthropicConfigCreate
  ): ModuleConfig<'generative-anthropic', GenerativeAnthropicConfig | undefined> {
    return {
      name: 'generative-anthropic',
      config,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-anyscale', GenerativeAnyscaleConfig | undefined>` object for use when performing AI generation using the `generative-anyscale` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/anyscale/generative) for detailed usage.
   *
   * @param {GenerativeAnyscaleConfigCreate} [config] The configuration for the `generative-aws` module.
   * @returns {ModuleConfig<'generative-anyscale', GenerativeAnyscaleConfig | undefined>} The configuration object.
   */
  anyscale(
    config?: GenerativeAnyscaleConfigCreate
  ): ModuleConfig<'generative-anyscale', GenerativeAnyscaleConfig | undefined> {
    return {
      name: 'generative-anyscale',
      config,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-aws', GenerativeAWSConfig>` object for use when performing AI generation using the `generative-aws` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/aws/generative) for detailed usage.
   *
   * @param {GenerativeAWSConfigCreate} config The configuration for the `generative-aws` module.
   * @returns {ModuleConfig<'generative-aws', GenerativeAWSConfig>} The configuration object.
   */
  aws(config: GenerativeAWSConfigCreate): ModuleConfig<'generative-aws', GenerativeAWSConfig> {
    return {
      name: 'generative-aws',
      config,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-openai', GenerativeAzureOpenAIConfig>` object for use when performing AI generation using the `generative-openai` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/openai/generative) for detailed usage.
   *
   * @param {GenerativeAzureOpenAIConfigCreate} config The configuration for the `generative-openai` module.
   * @returns {ModuleConfig<'generative-openai', GenerativeAzureOpenAIConfig>} The configuration object.
   */
  azureOpenAI: (
    config: GenerativeAzureOpenAIConfigCreate
  ): ModuleConfig<'generative-openai', GenerativeAzureOpenAIConfig> => {
    return {
      name: 'generative-openai',
      config: {
        deploymentId: config.deploymentId,
        resourceName: config.resourceName,
        baseURL: config.baseURL,
        frequencyPenaltyProperty: config.frequencyPenalty,
        maxTokensProperty: config.maxTokens,
        presencePenaltyProperty: config.presencePenalty,
        temperatureProperty: config.temperature,
        topPProperty: config.topP,
      },
    };
  },
  /**
   * Create a `ModuleConfig<'generative-cohere', GenerativeCohereConfig>` object for use when performing AI generation using the `generative-cohere` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/cohere/generative) for detailed usage.
   *
   * @param {GenerativeCohereConfigCreate} [config] The configuration for the `generative-cohere` module.
   * @returns {ModuleConfig<'generative-cohere', GenerativeCohereConfig | undefined>} The configuration object.
   */
  cohere: (
    config?: GenerativeCohereConfigCreate
  ): ModuleConfig<'generative-cohere', GenerativeCohereConfig | undefined> => {
    return {
      name: 'generative-cohere',
      config: config
        ? {
            kProperty: config.k,
            maxTokensProperty: config.maxTokens,
            model: config.model,
            returnLikelihoodsProperty: config.returnLikelihoods,
            stopSequencesProperty: config.stopSequences,
            temperatureProperty: config.temperature,
          }
        : undefined,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-databricks', GenerativeDatabricksConfig>` object for use when performing AI generation using the `generative-databricks` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/databricks/generative) for detailed usage.
   *
   * @param {GenerativeDatabricksConfigCreate} config The configuration for the `generative-databricks` module.
   * @returns {ModuleConfig<'generative-databricks', GenerativeDatabricksConfig>} The configuration object.
   */
  databricks: (
    config: GenerativeDatabricksConfigCreate
  ): ModuleConfig<'generative-databricks', GenerativeDatabricksConfig> => {
    return {
      name: 'generative-databricks',
      config,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-friendliai', GenerativeFriendliAIConfig | undefined>` object for use when performing AI generation using the `generative-friendliai` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/friendliai/generative) for detailed usage.
   */
  friendliai(
    config?: GenerativeFriendliAIConfigCreate
  ): ModuleConfig<'generative-friendliai', GenerativeFriendliAIConfig | undefined> {
    return {
      name: 'generative-friendliai',
      config,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-mistral', GenerativeMistralConfig | undefined>` object for use when performing AI generation using the `generative-mistral` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/mistral/generative) for detailed usage.
   *
   * @param {GenerativeMistralConfigCreate} [config] The configuration for the `generative-mistral` module.
   * @returns {ModuleConfig<'generative-mistral', GenerativeMistralConfig | undefined>} The configuration object.
   */
  mistral(
    config?: GenerativeMistralConfigCreate
  ): ModuleConfig<'generative-mistral', GenerativeMistralConfig | undefined> {
    return {
      name: 'generative-mistral',
      config,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-ollama', GenerativeOllamaConfig | undefined>` object for use when performing AI generation using the `generative-ollama` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/ollama/generative) for detailed usage.
   *
   * @param {GenerativeOllamaConfigCreate} [config] The configuration for the `generative-openai` module.
   * @returns {ModuleConfig<'generative-ollama', GenerativeOllamaConfig | undefined>} The configuration object.
   */
  ollama(
    config?: GenerativeOllamaConfigCreate
  ): ModuleConfig<'generative-ollama', GenerativeOllamaConfig | undefined> {
    return {
      name: 'generative-ollama',
      config,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-openai', GenerativeOpenAIConfig | undefined>` object for use when performing AI generation using the `generative-openai` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/openai/generative) for detailed usage.
   *
   * @param {GenerativeOpenAIConfigCreate} [config] The configuration for the `generative-openai` module.
   * @returns {ModuleConfig<'generative-openai', GenerativeOpenAIConfig | undefined>} The configuration object.
   */
  openAI: (
    config?: GenerativeOpenAIConfigCreate
  ): ModuleConfig<'generative-openai', GenerativeOpenAIConfig | undefined> => {
    return {
      name: 'generative-openai',
      config: config
        ? {
            baseURL: config.baseURL,
            frequencyPenaltyProperty: config.frequencyPenalty,
            maxTokensProperty: config.maxTokens,
            model: config.model,
            presencePenaltyProperty: config.presencePenalty,
            temperatureProperty: config.temperature,
            topPProperty: config.topP,
          }
        : undefined,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-palm', GenerativePaLMConfig>` object for use when performing AI generation using the `generative-palm` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/google/generative) for detailed usage.
   *
   * @param {GenerativePaLMConfigCreate} [config] The configuration for the `generative-palm` module.
   * @returns {ModuleConfig<'generative-palm', GenerativePaLMConfig>} The configuration object.
   * @deprecated Use `google` instead.
   */
  palm: (
    config?: GenerativePaLMConfigCreate
  ): ModuleConfig<'generative-palm', GenerativePaLMConfig | undefined> => {
    console.warn('The `generative-palm` module is deprecated. Use `generative-google` instead.');
    return {
      name: 'generative-palm',
      config,
    };
  },
  /**
   * Create a `ModuleConfig<'generative-google', GenerativeGoogleConfig>` object for use when performing AI generation using the `generative-google` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/google/generative) for detailed usage.
   *
   * @param {GenerativePaLMConfigCreate} [config] The configuration for the `generative-palm` module.
   * @returns {ModuleConfig<'generative-palm', GenerativePaLMConfig>} The configuration object.
   */
  google: (
    config?: GenerativePaLMConfigCreate
  ): ModuleConfig<'generative-google', GenerativeGoogleConfig | undefined> => {
    return {
      name: 'generative-google',
      config,
    };
  },
};



---
File: /src/collections/configure/index.ts
---

import {
  InvertedIndexConfigCreate,
  InvertedIndexConfigUpdate,
  MultiTenancyConfigCreate,
  MultiTenancyConfigUpdate,
  ReplicationConfigCreate,
  ReplicationConfigUpdate,
  ReplicationDeletionStrategy,
  ShardingConfigCreate,
  VectorConfigUpdate,
  VectorIndexType,
  VectorizerUpdateOptions,
} from '../types/index.js';

import generative from './generative.js';
import reranker from './reranker.js';
import { configure as configureVectorIndex, reconfigure as reconfigureVectorIndex } from './vectorIndex.js';
import { vectorizer } from './vectorizer.js';

import { parseWithDefault } from './parsing.js';

const dataType = {
  INT: 'int' as const,
  INT_ARRAY: 'int[]' as const,
  NUMBER: 'number' as const,
  NUMBER_ARRAY: 'number[]' as const,
  TEXT: 'text' as const,
  TEXT_ARRAY: 'text[]' as const,
  UUID: 'uuid' as const,
  UUID_ARRAY: 'uuid[]' as const,
  BOOLEAN: 'boolean' as const,
  BOOLEAN_ARRAY: 'boolean[]' as const,
  DATE: 'date' as const,
  DATE_ARRAY: 'date[]' as const,
  OBJECT: 'object' as const,
  OBJECT_ARRAY: 'object[]' as const,
  BLOB: 'blob' as const,
  GEO_COORDINATES: 'geoCoordinates' as const,
  PHONE_NUMBER: 'phoneNumber' as const,
};

const tokenization = {
  WORD: 'word' as const,
  LOWERCASE: 'lowercase' as const,
  WHITESPACE: 'whitespace' as const,
  FIELD: 'field' as const,
  TRIGRAM: 'trigram' as const,
  GSE: 'gse' as const,
  KAGOME_KR: 'kagome_kr' as const,
};

const vectorDistances = {
  COSINE: 'cosine' as const,
  DOT: 'dot' as const,
  HAMMING: 'hamming' as const,
  L2_SQUARED: 'l2-squared' as const,
};

const configure = {
  generative,
  reranker,
  vectorizer,
  vectorIndex: configureVectorIndex,
  dataType,
  tokenization,
  vectorDistances,
  /**
   * Create an `InvertedIndexConfigCreate` object to be used when defining the configuration of the keyword searching algorithm of your collection.
   *
   * See [the docs](https://weaviate.io/developers/weaviate/configuration/indexes#configure-the-inverted-index) for details!
   *
   * @param {number} [options.bm25b] The BM25 b parameter.
   * @param {number} [options.bm25k1] The BM25 k1 parameter.
   * @param {number} [options.cleanupIntervalSeconds] The interval in seconds at which the inverted index is cleaned up.
   * @param {boolean} [options.indexTimestamps] Whether to index timestamps.
   * @param {boolean} [options.indexPropertyLength] Whether to index the length of properties.
   * @param {boolean} [options.indexNullState] Whether to index the null state of properties.
   * @param {'en' | 'none'} [options.stopwordsPreset] The stopwords preset to use.
   * @param {string[]} [options.stopwordsAdditions] Additional stopwords to add.
   * @param {string[]} [options.stopwordsRemovals] Stopwords to remove.
   */
  invertedIndex: (options: {
    bm25b?: number;
    bm25k1?: number;
    cleanupIntervalSeconds?: number;
    indexTimestamps?: boolean;
    indexPropertyLength?: boolean;
    indexNullState?: boolean;
    stopwordsPreset?: 'en' | 'none';
    stopwordsAdditions?: string[];
    stopwordsRemovals?: string[];
  }): InvertedIndexConfigCreate => {
    return {
      bm25: {
        b: options.bm25b,
        k1: options.bm25k1,
      },
      cleanupIntervalSeconds: options.cleanupIntervalSeconds,
      indexTimestamps: options.indexTimestamps,
      indexPropertyLength: options.indexPropertyLength,
      indexNullState: options.indexNullState,
      stopwords: {
        preset: options.stopwordsPreset,
        additions: options.stopwordsAdditions,
        removals: options.stopwordsRemovals,
      },
    };
  },
  /**
   * Create a `MultiTenancyConfigCreate` object to be used when defining the multi-tenancy configuration of your collection.
   *
   * @param {boolean} [options.autoTenantActivation] Whether auto-tenant activation is enabled. Default is false.
   * @param {boolean} [options.autoTenantCreation] Whether auto-tenant creation is enabled. Default is false.
   * @param {boolean} [options.enabled] Whether multi-tenancy is enabled. Default is true.
   */
  multiTenancy: (options?: {
    autoTenantActivation?: boolean;
    autoTenantCreation?: boolean;
    enabled?: boolean;
  }): MultiTenancyConfigCreate => {
    return options
      ? {
          autoTenantActivation: parseWithDefault(options.autoTenantActivation, false),
          autoTenantCreation: parseWithDefault(options.autoTenantCreation, false),
          enabled: parseWithDefault(options.enabled, true),
        }
      : { autoTenantActivation: false, autoTenantCreation: false, enabled: true };
  },
  /**
   * Create a `ReplicationConfigCreate` object to be used when defining the replication configuration of your collection.
   *
   * NOTE: You can only use one of Sharding or Replication, not both.
   *
   * See [the docs](https://weaviate.io/developers/weaviate/concepts/replication-architecture#replication-vs-sharding) for more details.
   *
   * @param {boolean} [options.asyncEnabled] Whether asynchronous replication is enabled. Default is false.
   * @param {ReplicationDeletionStrategy} [options.deletionStrategy] The deletion strategy when replication conflicts are detected between deletes and reads.
   * @param {number} [options.factor] The replication factor. Default is 1.
   */
  replication: (options: {
    asyncEnabled?: boolean;
    deletionStrategy?: ReplicationDeletionStrategy;
    factor?: number;
  }): ReplicationConfigCreate => {
    return {
      asyncEnabled: options.asyncEnabled,
      deletionStrategy: options.deletionStrategy,
      factor: options.factor,
    };
  },
  /**
   * Create a `ShardingConfigCreate` object to be used when defining the sharding configuration of your collection.
   *
   * NOTE: You can only use one of Sharding or Replication, not both.
   *
   * See [the docs](https://weaviate.io/developers/weaviate/concepts/replication-architecture#replication-vs-sharding) for more details.
   *
   * @param {number} [options.virtualPerPhysical] The number of virtual shards per physical shard.
   * @param {number} [options.desiredCount] The desired number of physical shards.
   * @param {number} [options.desiredVirtualCount] The desired number of virtual shards.
   */
  sharding: (options: {
    virtualPerPhysical?: number;
    desiredCount?: number;
    desiredVirtualCount?: number;
  }): ShardingConfigCreate => {
    return {
      virtualPerPhysical: options.virtualPerPhysical,
      desiredCount: options.desiredCount,
      desiredVirtualCount: options.desiredVirtualCount,
    };
  },
};

const reconfigure = {
  vectorIndex: reconfigureVectorIndex,
  /**
   * Create an `InvertedIndexConfigUpdate` object to be used when updating the configuration of the keyword searching algorithm of your collection.
   *
   * See [the docs](https://weaviate.io/developers/weaviate/configuration/indexes#configure-the-inverted-index) for details!
   *
   * @param {number} [options.bm25b] The BM25 b parameter.
   * @param {number} [options.bm25k1] The BM25 k1 parameter.
   * @param {number} [options.cleanupIntervalSeconds] The interval in seconds at which the inverted index is cleaned up.
   * @param {'en' | 'none'} [options.stopwordsPreset] The stopwords preset to use.
   * @param {string[]} [options.stopwordsAdditions] Additional stopwords to add.
   * @param {string[]} [options.stopwordsRemovals] Stopwords to remove.
   */
  invertedIndex: (options: {
    bm25b?: number;
    bm25k1?: number;
    cleanupIntervalSeconds?: number;
    stopwordsPreset?: 'en' | 'none';
    stopwordsAdditions?: string[];
    stopwordsRemovals?: string[];
  }): InvertedIndexConfigUpdate => {
    return {
      bm25: {
        b: options.bm25b,
        k1: options.bm25k1,
      },
      cleanupIntervalSeconds: options.cleanupIntervalSeconds,
      stopwords: {
        preset: options.stopwordsPreset,
        additions: options.stopwordsAdditions,
        removals: options.stopwordsRemovals,
      },
    };
  },
  vectorizer: {
    /**
     * Create a `VectorConfigUpdate` object to be used when updating the named vector configuration of Weaviate.
     *
     * @param {string} name The name of the vector.
     * @param {VectorizerOptions} options The options for the named vector.
     */
    update: <N extends string | undefined, I extends VectorIndexType>(
      options: VectorizerUpdateOptions<N, I>
    ): VectorConfigUpdate<N, I> => {
      return {
        name: options?.name as N,
        vectorIndex: options.vectorIndexConfig,
      };
    },
  },
  /**
   * Create a `ReplicationConfigUpdate` object to be used when updating the replication configuration of Weaviate.
   *
   * See [the docs](https://weaviate.io/developers/weaviate/concepts/replication-architecture#replication-vs-sharding) for more details.
   *
   * @param {boolean} [options.asyncEnabled] Whether to enable asynchronous replication.
   * @param {ReplicationDeletionStrategy} [options.deletionStrategy] The deletion strategy to update when replication conflicts are detected between deletes and reads.
   * @param {number} [options.factor] The replication factor to update.
   */
  replication: (options: {
    asyncEnabled?: boolean;
    deletionStrategy?: ReplicationDeletionStrategy;
    factor?: number;
  }): ReplicationConfigUpdate => {
    return {
      asyncEnabled: options.asyncEnabled,
      deletionStrategy: options.deletionStrategy,
      factor: options.factor,
    };
  },
  /**
   * Create a `MultiTenancyConfigUpdate` object to be used when updating the multi-tenancy configuration of Weaviate.
   *
   * Note: You cannot update a single-tenant collection to become a multi-tenant collection. You must instead create a new multi-tenant collection and migrate the data over manually.
   *
   * @param {boolean} [options.autoTenantActivation] Whether to enable auto-tenant activation.
   * @param {boolean} [options.autoTenantCreation] Whether to enable auto-tenant creation.
   *
   */
  multiTenancy: (options: {
    autoTenantActivation?: boolean;
    autoTenantCreation?: boolean;
  }): MultiTenancyConfigUpdate => {
    return {
      autoTenantActivation: options.autoTenantActivation,
      autoTenantCreation: options.autoTenantCreation,
    };
  },
};

export {
  configure,
  dataType,
  generative,
  reconfigure,
  reranker,
  tokenization,
  vectorDistances,
  configureVectorIndex as vectorIndex,
  vectorizer,
};



---
File: /src/collections/configure/parsing.ts
---

import {
  BQConfigCreate,
  BQConfigUpdate,
  PQConfigCreate,
  PQConfigUpdate,
  SQConfigCreate,
  SQConfigUpdate,
} from './types/index.js';

type QuantizerConfig =
  | PQConfigCreate
  | PQConfigUpdate
  | BQConfigCreate
  | BQConfigUpdate
  | SQConfigCreate
  | SQConfigUpdate;

export class QuantizerGuards {
  static isPQCreate(config?: QuantizerConfig): config is PQConfigCreate {
    return (config as PQConfigCreate)?.type === 'pq';
  }
  static isPQUpdate(config?: QuantizerConfig): config is PQConfigUpdate {
    return (config as PQConfigUpdate)?.type === 'pq';
  }
  static isBQCreate(config?: QuantizerConfig): config is BQConfigCreate {
    return (config as BQConfigCreate)?.type === 'bq';
  }
  static isBQUpdate(config?: QuantizerConfig): config is BQConfigUpdate {
    return (config as BQConfigUpdate)?.type === 'bq';
  }
  static isSQCreate(config?: QuantizerConfig): config is SQConfigCreate {
    return (config as SQConfigCreate)?.type === 'sq';
  }
  static isSQUpdate(config?: QuantizerConfig): config is SQConfigUpdate {
    return (config as SQConfigUpdate)?.type === 'sq';
  }
}

export function parseWithDefault<D>(value: D | undefined, defaultValue: D): D {
  return value !== undefined ? value : defaultValue;
}



---
File: /src/collections/configure/reranker.ts
---

import {
  ModuleConfig,
  RerankerCohereConfig,
  RerankerJinaAIConfig,
  RerankerVoyageAIConfig,
} from '../config/types/index.js';

export default {
  /**
   * Create a `ModuleConfig<'reranker-cohere', RerankerCohereConfig>` object for use when reranking using the `reranker-cohere` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/cohere/reranker) for detailed usage.
   *
   * @param {RerankerCohereConfig} [config] The configuration for the `reranker-cohere` module.
   * @returns {ModuleConfig<'reranker-cohere', RerankerCohereConfig>} The configuration object.
   */
  cohere: (
    config?: RerankerCohereConfig
  ): ModuleConfig<'reranker-cohere', RerankerCohereConfig | undefined> => {
    return {
      name: 'reranker-cohere',
      config: config,
    };
  },
  /**
   * Create a `ModuleConfig<'reranker-jinaai', RerankerJinaAIConfig>` object for use when reranking using the `reranker-jinaai` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/jinaai/reranker) for detailed usage.
   *
   * @param {RerankerJinaAIConfig} [config] The configuration for the `reranker-jinaai` module.
   * @returns {ModuleConfig<'reranker-jinaai', RerankerJinaAIConfig | undefined>} The configuration object.
   */
  jinaai: (
    config?: RerankerJinaAIConfig
  ): ModuleConfig<'reranker-jinaai', RerankerJinaAIConfig | undefined> => {
    return {
      name: 'reranker-jinaai',
      config: config,
    };
  },
  /**
   * Create a `ModuleConfig<'reranker-transformers', Record<string, never>>` object for use when reranking using the `reranker-transformers` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/transformers/reranker) for detailed usage.
   *
   * @returns {ModuleConfig<'reranker-transformers', Record<string, never>>} The configuration object.
   */
  transformers: (): ModuleConfig<'reranker-transformers', Record<string, never>> => {
    return {
      name: 'reranker-transformers',
      config: {},
    };
  },
  /**
   * Create a `ModuleConfig<'reranker-voyageai', RerankerVoyageAIConfig>` object for use when reranking using the `reranker-voyageai` module.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/voyageai/reranker) for detailed usage.
   *
   * @param {RerankerVoyageAIConfig} [config] The configuration for the `reranker-voyage-ai` module.
   * @returns {ModuleConfig<'reranker-voyage-ai', RerankerVoyageAIConfig | undefined>} The configuration object.
   */
  voyageAI: (
    config?: RerankerVoyageAIConfig
  ): ModuleConfig<'reranker-voyageai', RerankerVoyageAIConfig | undefined> => {
    return {
      name: 'reranker-voyageai',
      config: config,
    };
  },
};



---
File: /src/collections/configure/unit.test.ts
---

import {
  GenerativeAWSConfig,
  GenerativeAnthropicConfig,
  GenerativeAnyscaleConfig,
  GenerativeAzureOpenAIConfig,
  GenerativeCohereConfig,
  GenerativeDatabricksConfig,
  GenerativeFriendliAIConfig,
  GenerativeGoogleConfig,
  GenerativeMistralConfig,
  GenerativeOllamaConfig,
  GenerativeOpenAIConfig,
  ModuleConfig,
  VectorConfigCreate,
} from '../types/index.js';
import { configure, reconfigure } from './index.js';
import {
  InvertedIndexConfigCreate,
  MultiTenancyConfigCreate,
  ReplicationConfigCreate,
  ReplicationConfigUpdate,
  ShardingConfigCreate,
  VectorIndexConfigFlatCreate,
  VectorIndexConfigHNSWCreate,
} from './types/index.js';

describe('Unit testing of the configure & reconfigure factory classes', () => {
  it('should create the correct InvertedIndexConfig type with all values', () => {
    const config = configure.invertedIndex({
      bm25b: 0.5,
      bm25k1: 1.5,
      cleanupIntervalSeconds: 120,
      indexTimestamps: true,
      indexPropertyLength: true,
      indexNullState: true,
      stopwordsPreset: 'none',
      stopwordsAdditions: ['a', 'b'],
      stopwordsRemovals: ['c', 'd'],
    });
    expect(config).toEqual<InvertedIndexConfigCreate>({
      bm25: {
        b: 0.5,
        k1: 1.5,
      },
      cleanupIntervalSeconds: 120,
      indexTimestamps: true,
      indexPropertyLength: true,
      indexNullState: true,
      stopwords: {
        additions: ['a', 'b'],
        preset: 'none',
        removals: ['c', 'd'],
      },
    });
  });

  it('should create the correct MultiTenancyConfig type with defaults', () => {
    const config = configure.multiTenancy();
    expect(config).toEqual<MultiTenancyConfigCreate>({
      autoTenantActivation: false,
      autoTenantCreation: false,
      enabled: true,
    });
  });

  it('should create the correct MultiTenancyConfig type with all values', () => {
    const config = configure.multiTenancy({
      autoTenantActivation: true,
      autoTenantCreation: true,
      enabled: false,
    });
    expect(config).toEqual<MultiTenancyConfigCreate>({
      autoTenantActivation: true,
      autoTenantCreation: true,
      enabled: false,
    });
  });

  it('should create the correct ReplicationConfigCreate type with all values', () => {
    const config = configure.replication({
      asyncEnabled: true,
      deletionStrategy: 'DeleteOnConflict',
      factor: 2,
    });
    expect(config).toEqual<ReplicationConfigCreate>({
      asyncEnabled: true,
      deletionStrategy: 'DeleteOnConflict',
      factor: 2,
    });
  });

  it('should create the correct ReplicationConfigUpdate type with all values', () => {
    const config = reconfigure.replication({
      asyncEnabled: true,
      deletionStrategy: 'DeleteOnConflict',
      factor: 2,
    });
    expect(config).toEqual<ReplicationConfigUpdate>({
      asyncEnabled: true,
      deletionStrategy: 'DeleteOnConflict',
      factor: 2,
    });
  });

  it('should create the correct ShardingConfig type with all values', () => {
    const config = configure.sharding({
      virtualPerPhysical: 256,
      desiredCount: 2,
      desiredVirtualCount: 256,
    });
    expect(config).toEqual<ShardingConfigCreate>({
      virtualPerPhysical: 256,
      desiredCount: 2,
      desiredVirtualCount: 256,
    });
  });

  describe('using the vectorIndex namespace', () => {
    it('should create the correct HNSW VectorIndexConfig type with defaults', () => {
      const config = configure.vectorIndex.hnsw({ quantizer: configure.vectorIndex.quantizer.pq() });
      expect(config).toEqual<ModuleConfig<'hnsw', VectorIndexConfigHNSWCreate>>({
        name: 'hnsw',
        config: {
          quantizer: {
            type: 'pq',
          },
        },
      });
    });

    it('should create the correct HNSW VectorIndexConfig type with all values', () => {
      const config = configure.vectorIndex.hnsw({
        cleanupIntervalSeconds: 120,
        distanceMetric: 'dot',
        dynamicEfFactor: 16,
        dynamicEfMax: 1000,
        dynamicEfMin: 200,
        ef: 100,
        efConstruction: 256,
        flatSearchCutoff: 80000,
        filterStrategy: 'acorn',
        maxConnections: 128,
        quantizer: configure.vectorIndex.quantizer.pq({
          bitCompression: true,
          centroids: 512,
          encoder: {
            distribution: 'normal',
            type: 'tile',
          },
          segments: 1,
          trainingLimit: 200000,
        }),
        skip: true,
        vectorCacheMaxObjects: 2000000000000,
      });
      expect(config).toEqual<ModuleConfig<'hnsw', VectorIndexConfigHNSWCreate>>({
        name: 'hnsw',
        config: {
          cleanupIntervalSeconds: 120,
          distance: 'dot',
          dynamicEfFactor: 16,
          dynamicEfMax: 1000,
          dynamicEfMin: 200,
          ef: 100,
          efConstruction: 256,
          flatSearchCutoff: 80000,
          filterStrategy: 'acorn',
          maxConnections: 128,
          quantizer: {
            bitCompression: true,
            centroids: 512,
            encoder: {
              distribution: 'normal',
              type: 'tile',
            },
            segments: 1,
            trainingLimit: 200000,
            type: 'pq',
          },
          skip: true,
          vectorCacheMaxObjects: 2000000000000,
        },
      });
    });

    it('should create the correct flat VectorIndexConfig type with defaults', () => {
      const config = configure.vectorIndex.flat({ quantizer: configure.vectorIndex.quantizer.bq() });
      expect(config).toEqual<ModuleConfig<'flat', VectorIndexConfigFlatCreate | undefined>>({
        name: 'flat',
        config: {
          quantizer: {
            type: 'bq',
          },
        },
      });
    });
  });

  it('should create the correct flat VectorIndexConfig type with all values', () => {
    const config = configure.vectorIndex.flat({
      distanceMetric: 'cosine',
      vectorCacheMaxObjects: 1000000000,
      quantizer: configure.vectorIndex.quantizer.bq({
        cache: true,
        rescoreLimit: 100,
      }),
    });
    expect(config).toEqual<ModuleConfig<'flat', VectorIndexConfigFlatCreate>>({
      name: 'flat',
      config: {
        distance: 'cosine',
        vectorCacheMaxObjects: 1000000000,
        quantizer: {
          cache: true,
          rescoreLimit: 100,
          type: 'bq',
        },
      },
    });
  });

  it('should create an hnsw VectorIndexConfig type with SQ quantizer', () => {
    const config = configure.vectorIndex.hnsw({
      quantizer: configure.vectorIndex.quantizer.sq({
        rescoreLimit: 100,
        trainingLimit: 200,
      }),
    });
    expect(config).toEqual<ModuleConfig<'hnsw', VectorIndexConfigHNSWCreate>>({
      name: 'hnsw',
      config: {
        quantizer: {
          rescoreLimit: 100,
          trainingLimit: 200,
          type: 'sq',
        },
      },
    });
  });
});

describe('Unit testing of the vectorizer factory class', () => {
  it('should create the correct Img2VecNeuralConfig type with all values', () => {
    const config = configure.vectorizer.img2VecNeural({
      name: 'test',
      imageFields: ['field1', 'field2'],
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'img2vec-neural'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'img2vec-neural',
        config: {
          imageFields: ['field1', 'field2'],
        },
      },
    });
  });

  it('should create the correct Multi2VecCohereConfig type with defaults', () => {
    const config = configure.vectorizer.multi2VecCohere();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'multi2vec-cohere'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-cohere',
        config: undefined,
      },
    });
  });

  it('should create the correct Multi2VecCohereConfig type with all values', () => {
    const config = configure.vectorizer.multi2VecCohere({
      name: 'test',
      model: 'model',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-cohere'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-cohere',
        config: {
          model: 'model',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Multi2VecCohereConfig type with all values and weights', () => {
    const config = configure.vectorizer.multi2VecCohere({
      name: 'test',
      model: 'model',
      imageFields: [
        { name: 'field1', weight: 0.1 },
        { name: 'field2', weight: 0.2 },
      ],
      textFields: [
        { name: 'field3', weight: 0.3 },
        { name: 'field4', weight: 0.4 },
      ],
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-cohere'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-cohere',
        config: {
          model: 'model',
          imageFields: ['field1', 'field2'],
          textFields: ['field3', 'field4'],
          vectorizeCollectionName: true,
          weights: {
            imageFields: [0.1, 0.2],
            textFields: [0.3, 0.4],
          },
        },
      },
    });
  });

  it('should create the correct Multi2VecClipConfig type with defaults', () => {
    const config = configure.vectorizer.multi2VecClip();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'multi2vec-clip'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-clip',
        config: undefined,
      },
    });
  });

  it('should create the correct Multi2VecClipConfig type with all values', () => {
    const config = configure.vectorizer.multi2VecClip({
      name: 'test',
      imageFields: ['field1', 'field2'],
      textFields: ['field3', 'field4'],
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-clip'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-clip',
        config: {
          imageFields: ['field1', 'field2'],
          textFields: ['field3', 'field4'],
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Multi2VecClipConfig type with all values and weights', () => {
    const config = configure.vectorizer.multi2VecClip({
      name: 'test',
      imageFields: [
        { name: 'field1', weight: 0.1 },
        { name: 'field2', weight: 0.2 },
      ],
      textFields: [
        { name: 'field3', weight: 0.3 },
        { name: 'field4', weight: 0.4 },
      ],
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-clip'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-clip',
        config: {
          imageFields: ['field1', 'field2'],
          textFields: ['field3', 'field4'],
          vectorizeCollectionName: true,
          weights: {
            imageFields: [0.1, 0.2],
            textFields: [0.3, 0.4],
          },
        },
      },
    });
  });

  it('should create the correct Multi2VecBindConfig type with defaults', () => {
    const config = configure.vectorizer.multi2VecBind();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'multi2vec-bind'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-bind',
        config: undefined,
      },
    });
  });

  it('should create the correct Multi2VecBindConfig type with all values', () => {
    const config = configure.vectorizer.multi2VecBind({
      name: 'test',
      audioFields: ['field1', 'field2'],
      depthFields: ['field3', 'field4'],
      imageFields: ['field5', 'field6'],
      IMUFields: ['field7', 'field8'],
      textFields: ['field9', 'field10'],
      thermalFields: ['field11', 'field12'],
      videoFields: ['field13', 'field14'],
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-bind'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-bind',
        config: {
          audioFields: ['field1', 'field2'],
          depthFields: ['field3', 'field4'],
          imageFields: ['field5', 'field6'],
          IMUFields: ['field7', 'field8'],
          textFields: ['field9', 'field10'],
          thermalFields: ['field11', 'field12'],
          videoFields: ['field13', 'field14'],
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Multi2VecBindConfig type with all values and weights', () => {
    const config = configure.vectorizer.multi2VecBind({
      name: 'test',
      audioFields: [
        { name: 'field1', weight: 0.1 },
        { name: 'field2', weight: 0.2 },
      ],
      depthFields: [
        { name: 'field3', weight: 0.3 },
        { name: 'field4', weight: 0.4 },
      ],
      imageFields: [
        { name: 'field5', weight: 0.5 },
        { name: 'field6', weight: 0.6 },
      ],
      IMUFields: [
        { name: 'field7', weight: 0.7 },
        { name: 'field8', weight: 0.8 },
      ],
      textFields: [
        { name: 'field9', weight: 0.9 },
        { name: 'field10', weight: 1.0 },
      ],
      thermalFields: [
        { name: 'field11', weight: 1.1 },
        { name: 'field12', weight: 1.2 },
      ],
      videoFields: [
        { name: 'field13', weight: 1.3 },
        { name: 'field14', weight: 1.4 },
      ],
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-bind'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-bind',
        config: {
          audioFields: ['field1', 'field2'],
          depthFields: ['field3', 'field4'],
          imageFields: ['field5', 'field6'],
          IMUFields: ['field7', 'field8'],
          textFields: ['field9', 'field10'],
          thermalFields: ['field11', 'field12'],
          videoFields: ['field13', 'field14'],
          vectorizeCollectionName: true,
          weights: {
            audioFields: [0.1, 0.2],
            depthFields: [0.3, 0.4],
            imageFields: [0.5, 0.6],
            IMUFields: [0.7, 0.8],
            textFields: [0.9, 1.0],
            thermalFields: [1.1, 1.2],
            videoFields: [1.3, 1.4],
          },
        },
      },
    });
  });

  it('should create the correct Multi2VecGoogleConfig type with defaults', () => {
    const config = configure.vectorizer.multi2VecGoogle({
      projectId: 'project-id',
      location: 'location',
    });
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'multi2vec-google'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-google',
        config: {
          projectId: 'project-id',
          location: 'location',
        },
      },
    });
  });

  it('should create the correct Multi2VecGoogleonfig type with all values', () => {
    const config = configure.vectorizer.multi2VecGoogle({
      name: 'test',
      projectId: 'project-id',
      imageFields: ['field1', 'field2'],
      textFields: ['field3', 'field4'],
      videoFields: ['field5', 'field6'],
      location: 'location',
      modelId: 'model-id',
      dimensions: 256,
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-google'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-google',
        config: {
          projectId: 'project-id',
          imageFields: ['field1', 'field2'],
          textFields: ['field3', 'field4'],
          videoFields: ['field5', 'field6'],
          location: 'location',
          modelId: 'model-id',
          dimensions: 256,
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Multi2VecGoogleConfig type with all values and weights', () => {
    const config = configure.vectorizer.multi2VecGoogle({
      name: 'test',
      projectId: 'project-id',
      imageFields: [
        { name: 'field1', weight: 0.1 },
        { name: 'field2', weight: 0.2 },
      ],
      textFields: [
        { name: 'field3', weight: 0.3 },
        { name: 'field4', weight: 0.4 },
      ],
      videoFields: [
        { name: 'field5', weight: 0.5 },
        { name: 'field6', weight: 0.6 },
      ],
      location: 'location',
      modelId: 'model-id',
      dimensions: 256,
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-google'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-google',
        config: {
          projectId: 'project-id',
          imageFields: ['field1', 'field2'],
          textFields: ['field3', 'field4'],
          videoFields: ['field5', 'field6'],
          location: 'location',
          modelId: 'model-id',
          dimensions: 256,
          vectorizeCollectionName: true,
          weights: {
            imageFields: [0.1, 0.2],
            textFields: [0.3, 0.4],
            videoFields: [0.5, 0.6],
          },
        },
      },
    });
  });

  it('should create the correct Multi2VecPalmConfig type using deprecated method with defaults', () => {
    const config = configure.vectorizer.multi2VecPalm({
      projectId: 'project-id',
      location: 'location',
    });
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'multi2vec-palm'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-palm',
        config: {
          projectId: 'project-id',
          location: 'location',
        },
      },
    });
  });

  it('should create the correct Multi2VecPalmConfig type using deprecated method with all values', () => {
    const config = configure.vectorizer.multi2VecPalm({
      name: 'test',
      projectId: 'project-id',
      imageFields: ['field1', 'field2'],
      textFields: ['field3', 'field4'],
      videoFields: ['field5', 'field6'],
      location: 'location',
      modelId: 'model-id',
      dimensions: 256,
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-palm'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-palm',
        config: {
          projectId: 'project-id',
          imageFields: ['field1', 'field2'],
          textFields: ['field3', 'field4'],
          videoFields: ['field5', 'field6'],
          location: 'location',
          modelId: 'model-id',
          dimensions: 256,
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Multi2VecPalmConfig type using deprecated method with all values and weights', () => {
    const config = configure.vectorizer.multi2VecPalm({
      name: 'test',
      projectId: 'project-id',
      imageFields: [
        { name: 'field1', weight: 0.1 },
        { name: 'field2', weight: 0.2 },
      ],
      textFields: [
        { name: 'field3', weight: 0.3 },
        { name: 'field4', weight: 0.4 },
      ],
      videoFields: [
        { name: 'field5', weight: 0.5 },
        { name: 'field6', weight: 0.6 },
      ],
      location: 'location',
      modelId: 'model-id',
      dimensions: 256,
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'multi2vec-palm'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'multi2vec-palm',
        config: {
          projectId: 'project-id',
          imageFields: ['field1', 'field2'],
          textFields: ['field3', 'field4'],
          videoFields: ['field5', 'field6'],
          location: 'location',
          modelId: 'model-id',
          dimensions: 256,
          vectorizeCollectionName: true,
          weights: {
            imageFields: [0.1, 0.2],
            textFields: [0.3, 0.4],
            videoFields: [0.5, 0.6],
          },
        },
      },
    });
  });

  it('should create the correct Text2VecAWSConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecAWS({
      region: 'region',
      service: 'service',
    });
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-aws'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-aws',
        config: {
          region: 'region',
          service: 'service',
        },
      },
    });
  });

  it('should create the correct Text2VecAWSConfig type with all values', () => {
    const config = configure.vectorizer.text2VecAWS({
      name: 'test',
      endpoint: 'endpoint',
      model: 'model',
      region: 'region',
      service: 'service',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-aws'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-aws',
        config: {
          endpoint: 'endpoint',
          model: 'model',
          region: 'region',
          service: 'service',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecAzureOpenAIConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecAzureOpenAI({
      deploymentId: 'deployment-id',
      resourceName: 'resource-name',
    });
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-azure-openai'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-azure-openai',
        config: {
          deploymentId: 'deployment-id',
          resourceName: 'resource-name',
        },
      },
    });
  });

  it('should create the correct Text2VecAzureOpenAIConfig type with all values', () => {
    const config = configure.vectorizer.text2VecAzureOpenAI({
      name: 'test',
      baseURL: 'base-url',
      deploymentId: 'deployment-id',
      resourceName: 'resource-name',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-azure-openai'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-azure-openai',
        config: {
          baseURL: 'base-url',
          deploymentId: 'deployment-id',
          resourceName: 'resource-name',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecCohereConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecCohere();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-cohere'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-cohere',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecCohereConfig type with all values', () => {
    const config = configure.vectorizer.text2VecCohere({
      name: 'test',
      baseURL: 'base-url',
      model: 'model',
      truncate: true,
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-cohere'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-cohere',
        config: {
          baseURL: 'base-url',
          model: 'model',
          truncate: true,
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecContextionaryConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecContextionary();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-contextionary'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-contextionary',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecContextionaryConfig type with all values', () => {
    const config = configure.vectorizer.text2VecContextionary({
      name: 'test',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-contextionary'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-contextionary',
        config: {
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecDatabricksConfig type with required & defaults', () => {
    const config = configure.vectorizer.text2VecDatabricks({
      name: 'test',
      endpoint: 'endpoint',
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-databricks'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-databricks',
        config: {
          endpoint: 'endpoint',
        },
      },
    });
  });

  it('should create the correct Text2VecDatabricksConfig type with all values', () => {
    const config = configure.vectorizer.text2VecDatabricks({
      name: 'test',
      endpoint: 'endpoint',
      instruction: 'instruction',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-databricks'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-databricks',
        config: {
          endpoint: 'endpoint',
          instruction: 'instruction',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecGPT4AllConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecGPT4All();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-gpt4all'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-gpt4all',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecGPT4AllConfig type with all values', () => {
    const config = configure.vectorizer.text2VecGPT4All({
      name: 'test',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-gpt4all'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-gpt4all',
        config: {
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecHuggingFaceConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecHuggingFace();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-huggingface'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-huggingface',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecHuggingFaceConfig type with all values', () => {
    const config = configure.vectorizer.text2VecHuggingFace({
      name: 'test',
      endpointURL: 'endpoint-url',
      model: 'model',
      passageModel: 'passage-model',
      queryModel: 'query-model',
      useCache: true,
      useGPU: true,
      waitForModel: true,
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-huggingface'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-huggingface',
        config: {
          endpointURL: 'endpoint-url',
          model: 'model',
          passageModel: 'passage-model',
          queryModel: 'query-model',
          useCache: true,
          useGPU: true,
          waitForModel: true,
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecJinaConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecJina();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-jina'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-jina',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecJinaConfig type with all values', () => {
    const config = configure.vectorizer.text2VecJina({
      name: 'test',
      model: 'model',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-jina'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-jina',
        config: {
          model: 'model',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecMistralConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecMistral();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-mistral'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-mistral',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecMistralConfig type with all values', () => {
    const config = configure.vectorizer.text2VecMistral({
      name: 'test',
      model: 'model',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-mistral'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-mistral',
        config: {
          model: 'model',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecOllamaConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecOllama();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-ollama'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-ollama',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecOllamaConfig type with all values', () => {
    const config = configure.vectorizer.text2VecOllama({
      name: 'test',
      apiEndpoint: 'api-endpoint',
      model: 'model',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-ollama'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-ollama',
        config: {
          apiEndpoint: 'api-endpoint',
          model: 'model',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecOpenAIConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecOpenAI();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-openai'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-openai',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecOpenAIConfig type with all values', () => {
    const config = configure.vectorizer.text2VecOpenAI({
      name: 'test',
      baseURL: 'base-url',
      dimensions: 256,
      model: 'model',
      modelVersion: 'model-version',
      type: 'type',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-openai'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-openai',
        config: {
          baseURL: 'base-url',
          dimensions: 256,
          model: 'model',
          modelVersion: 'model-version',
          type: 'type',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecGoogleConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecGoogle();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-google'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-google',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecGoogleConfig type with all values', () => {
    const config = configure.vectorizer.text2VecGoogle({
      name: 'test',
      apiEndpoint: 'api-endpoint',
      modelId: 'model-id',
      projectId: 'project-id',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-google'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-google',
        config: {
          apiEndpoint: 'api-endpoint',
          modelId: 'model-id',
          projectId: 'project-id',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecPalmConfig type using deprecated method with defaults', () => {
    const config = configure.vectorizer.text2VecPalm();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-palm'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-palm',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecPalmConfig type using deprecated method with all values', () => {
    const config = configure.vectorizer.text2VecPalm({
      name: 'test',
      apiEndpoint: 'api-endpoint',
      modelId: 'model-id',
      projectId: 'project-id',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-palm'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-palm',
        config: {
          apiEndpoint: 'api-endpoint',
          modelId: 'model-id',
          projectId: 'project-id',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecTransformersConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecTransformers();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-transformers'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-transformers',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecTransformersConfig type with all values', () => {
    const config = configure.vectorizer.text2VecTransformers({
      name: 'test',
      poolingStrategy: 'pooling-strategy',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-transformers'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-transformers',
        config: {
          poolingStrategy: 'pooling-strategy',
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecVoyageAIConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecVoyageAI();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-voyageai'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-voyageai',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecVoyageConfig type with all values', () => {
    const config = configure.vectorizer.text2VecVoyageAI({
      name: 'test',
      baseURL: 'base-url',
      model: 'model',
      truncate: true,
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-voyageai'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-voyageai',
        config: {
          baseURL: 'base-url',
          model: 'model',
          truncate: true,
          vectorizeCollectionName: true,
        },
      },
    });
  });

  it('should create the correct Text2VecWeaviateConfig type with defaults', () => {
    const config = configure.vectorizer.text2VecWeaviate();
    expect(config).toEqual<VectorConfigCreate<never, undefined, 'hnsw', 'text2vec-weaviate'>>({
      name: undefined,
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-weaviate',
        config: undefined,
      },
    });
  });

  it('should create the correct Text2VecWeaviateConfig type with all values', () => {
    const config = configure.vectorizer.text2VecWeaviate({
      name: 'test',
      baseURL: 'base-url',
      dimensions: 256,
      model: 'model',
      vectorizeCollectionName: true,
    });
    expect(config).toEqual<VectorConfigCreate<never, 'test', 'hnsw', 'text2vec-weaviate'>>({
      name: 'test',
      vectorIndex: {
        name: 'hnsw',
        config: undefined,
      },
      vectorizer: {
        name: 'text2vec-weaviate',
        config: {
          baseURL: 'base-url',
          dimensions: 256,
          model: 'model',
          vectorizeCollectionName: true,
        },
      },
    });
  });
});

describe('Unit testing of the generative factory class', () => {
  it('should create the correct GenerativeAnthropicConfig type with required & default values', () => {
    const config = configure.generative.anthropic();
    expect(config).toEqual<ModuleConfig<'generative-anthropic', GenerativeAnthropicConfig | undefined>>({
      name: 'generative-anthropic',
      config: undefined,
    });
  });

  it('should create the correct GenerativeAnthropicConfig type with all values', () => {
    const config = configure.generative.anthropic({
      maxTokens: 100,
      model: 'model',
      stopSequences: ['stop1', 'stop2'],
      temperature: 0.5,
      topK: 10,
      topP: 0.8,
    });
    expect(config).toEqual<ModuleConfig<'generative-anthropic', GenerativeAnthropicConfig>>({
      name: 'generative-anthropic',
      config: {
        maxTokens: 100,
        model: 'model',
        stopSequences: ['stop1', 'stop2'],
        temperature: 0.5,
        topK: 10,
        topP: 0.8,
      },
    });
  });

  it('should create the correct GenerativeAnyscaleConfig type with required & default values', () => {
    const config = configure.generative.anyscale();
    expect(config).toEqual<ModuleConfig<'generative-anyscale', GenerativeAnyscaleConfig | undefined>>({
      name: 'generative-anyscale',
      config: undefined,
    });
  });

  it('should create the correct GenerativeAnyscaleConfig type with all values', () => {
    const config = configure.generative.anyscale({
      model: 'model',
      temperature: 0.5,
    });
    expect(config).toEqual<ModuleConfig<'generative-anyscale', GenerativeAnyscaleConfig | undefined>>({
      name: 'generative-anyscale',
      config: {
        model: 'model',
        temperature: 0.5,
      },
    });
  });

  it('should create the correct GenerativeAWSConfig type with required & default values', () => {
    const config = configure.generative.aws({
      region: 'region',
      service: 'service',
    });
    expect(config).toEqual<ModuleConfig<'generative-aws', GenerativeAWSConfig>>({
      name: 'generative-aws',
      config: {
        region: 'region',
        service: 'service',
      },
    });
  });

  it('should create the correct GenerativeAWSConfig type with all values', () => {
    const config = configure.generative.aws({
      endpoint: 'endpoint',
      model: 'model',
      region: 'region',
      service: 'service',
    });
    expect(config).toEqual<ModuleConfig<'generative-aws', GenerativeAWSConfig>>({
      name: 'generative-aws',
      config: {
        endpoint: 'endpoint',
        model: 'model',
        region: 'region',
        service: 'service',
      },
    });
  });

  it('should create the correct GenerativeAzureOpenAIConfig type with required & default values', () => {
    const config = configure.generative.azureOpenAI({
      resourceName: 'resource-name',
      deploymentId: 'deployment-id',
    });
    expect(config).toEqual<ModuleConfig<'generative-openai', GenerativeAzureOpenAIConfig>>({
      name: 'generative-openai',
      config: {
        resourceName: 'resource-name',
        deploymentId: 'deployment-id',
      },
    });
  });

  it('should create the correct GenerativeAzureOpenAIConfig type with all values', () => {
    const config = configure.generative.azureOpenAI({
      resourceName: 'resource-name',
      deploymentId: 'deployment-id',
      baseURL: 'base-url',
      frequencyPenalty: 0.5,
      maxTokens: 100,
      presencePenalty: 0.3,
      temperature: 0.7,
      topP: 0.8,
    });
    expect(config).toEqual<ModuleConfig<'generative-openai', GenerativeAzureOpenAIConfig>>({
      name: 'generative-openai',
      config: {
        resourceName: 'resource-name',
        deploymentId: 'deployment-id',
        baseURL: 'base-url',
        frequencyPenaltyProperty: 0.5,
        maxTokensProperty: 100,
        presencePenaltyProperty: 0.3,
        temperatureProperty: 0.7,
        topPProperty: 0.8,
      },
    });
  });

  it('should create the correct GenerativeCohereConfig type with required & default values', () => {
    const config = configure.generative.cohere();
    expect(config).toEqual<ModuleConfig<'generative-cohere', GenerativeCohereConfig | undefined>>({
      name: 'generative-cohere',
      config: undefined,
    });
  });

  it('should create the correct GenerativeCohereConfig type with all values', () => {
    const config = configure.generative.cohere({
      k: 5,
      maxTokens: 100,
      model: 'model',
      returnLikelihoods: 'return-likelihoods',
      stopSequences: ['stop1', 'stop2'],
      temperature: 0.5,
    });
    expect(config).toEqual<ModuleConfig<'generative-cohere', GenerativeCohereConfig | undefined>>({
      name: 'generative-cohere',
      config: {
        kProperty: 5,
        maxTokensProperty: 100,
        model: 'model',
        returnLikelihoodsProperty: 'return-likelihoods',
        stopSequencesProperty: ['stop1', 'stop2'],
        temperatureProperty: 0.5,
      },
    });
  });

  it('should create the correct GenerativeDatabricksConfig type with required & default values', () => {
    const config = configure.generative.databricks({
      endpoint: 'endpoint',
    });
    expect(config).toEqual<ModuleConfig<'generative-databricks', GenerativeDatabricksConfig>>({
      name: 'generative-databricks',
      config: {
        endpoint: 'endpoint',
      },
    });
  });

  it('should create the correct GenerativeDatabricksConfig type with all values', () => {
    const config = configure.generative.databricks({
      endpoint: 'endpoint',
      maxTokens: 100,
      temperature: 0.5,
      topK: 10,
      topP: 0.8,
    });
    expect(config).toEqual<ModuleConfig<'generative-databricks', GenerativeDatabricksConfig>>({
      name: 'generative-databricks',
      config: {
        endpoint: 'endpoint',
        maxTokens: 100,
        temperature: 0.5,
        topK: 10,
        topP: 0.8,
      },
    });
  });

  it('should create the correct GenerativeFriendliAIConfig type with required & default values', () => {
    const config = configure.generative.friendliai();
    expect(config).toEqual<ModuleConfig<'generative-friendliai', GenerativeFriendliAIConfig | undefined>>({
      name: 'generative-friendliai',
      config: undefined,
    });
  });

  it('should create the correct GenerativeFriendliAIConfig type with all values', () => {
    const config = configure.generative.friendliai({
      baseURL: 'base-url',
      maxTokens: 100,
      model: 'model',
      temperature: 0.5,
    });
    expect(config).toEqual<ModuleConfig<'generative-friendliai', GenerativeFriendliAIConfig | undefined>>({
      name: 'generative-friendliai',
      config: {
        baseURL: 'base-url',
        maxTokens: 100,
        model: 'model',
        temperature: 0.5,
      },
    });
  });

  it('should create the correct GenerativeMistralConfig type with required & default values', () => {
    const config = configure.generative.mistral();
    expect(config).toEqual<ModuleConfig<'generative-mistral', GenerativeMistralConfig | undefined>>({
      name: 'generative-mistral',
      config: undefined,
    });
  });

  it('should create the correct GenerativeMistralConfig type with all values', () => {
    const config = configure.generative.mistral({
      maxTokens: 100,
      model: 'model',
      temperature: 0.5,
    });
    expect(config).toEqual<ModuleConfig<'generative-mistral', GenerativeMistralConfig | undefined>>({
      name: 'generative-mistral',
      config: {
        maxTokens: 100,
        model: 'model',
        temperature: 0.5,
      },
    });
  });

  it('should create the correct GenerativeOllamaConfig type with required & default values', () => {
    const config = configure.generative.ollama();
    expect(config).toEqual<ModuleConfig<'generative-ollama', GenerativeOllamaConfig | undefined>>({
      name: 'generative-ollama',
      config: undefined,
    });
  });

  it('should create the correct GenerativeOllamaConfig type with all values', () => {
    const config = configure.generative.ollama({
      apiEndpoint: 'api-endpoint',
      model: 'model',
    });
    expect(config).toEqual<ModuleConfig<'generative-ollama', GenerativeOllamaConfig | undefined>>({
      name: 'generative-ollama',
      config: {
        apiEndpoint: 'api-endpoint',
        model: 'model',
      },
    });
  });

  it('should create the correct GenerativeOpenAIConfig type with required & default values', () => {
    const config = configure.generative.openAI();
    expect(config).toEqual<ModuleConfig<'generative-openai', GenerativeAzureOpenAIConfig | undefined>>({
      name: 'generative-openai',
      config: undefined,
    });
  });

  it('should create the correct GenerativeOpenAIConfig type with all values', () => {
    const config = configure.generative.openAI({
      baseURL: 'base-url',
      frequencyPenalty: 0.5,
      maxTokens: 100,
      model: 'model',
      presencePenalty: 0.3,
      temperature: 0.7,
      topP: 0.8,
    });
    expect(config).toEqual<ModuleConfig<'generative-openai', GenerativeOpenAIConfig | undefined>>({
      name: 'generative-openai',
      config: {
        baseURL: 'base-url',
        frequencyPenaltyProperty: 0.5,
        maxTokensProperty: 100,
        model: 'model',
        presencePenaltyProperty: 0.3,
        temperatureProperty: 0.7,
        topPProperty: 0.8,
      },
    });
  });

  it('should create the correct GeneratGoogleConfig type with required & default values', () => {
    const config = configure.generative.google();
    expect(config).toEqual<ModuleConfig<'generative-google', undefined>>({
      name: 'generative-google',
      config: undefined,
    });
  });

  it('should create the correct GeneratGoogleConfig type using deprecated method with required & default values', () => {
    const config = configure.generative.palm();
    expect(config).toEqual<ModuleConfig<'generative-palm', undefined>>({
      name: 'generative-palm',
      config: undefined,
    });
  });

  it('should create the correct GenerativeGoogleConfig type using deprecated method with all values', () => {
    const config = configure.generative.palm({
      apiEndpoint: 'api-endpoint',
      maxOutputTokens: 100,
      modelId: 'model-id',
      projectId: 'project-id',
      temperature: 0.5,
      topK: 5,
      topP: 0.8,
    });
    expect(config).toEqual<ModuleConfig<'generative-palm', GenerativeGoogleConfig>>({
      name: 'generative-palm',
      config: {
        apiEndpoint: 'api-endpoint',
        maxOutputTokens: 100,
        modelId: 'model-id',
        projectId: 'project-id',
        temperature: 0.5,
        topK: 5,
        topP: 0.8,
      },
    });
  });

  it('should create the correct GenerativeGoogleConfig type with all values', () => {
    const config = configure.generative.google({
      apiEndpoint: 'api-endpoint',
      maxOutputTokens: 100,
      modelId: 'model-id',
      projectId: 'project-id',
      temperature: 0.5,
      topK: 5,
      topP: 0.8,
    });
    expect(config).toEqual<ModuleConfig<'generative-google', GenerativeGoogleConfig>>({
      name: 'generative-google',
      config: {
        apiEndpoint: 'api-endpoint',
        maxOutputTokens: 100,
        modelId: 'model-id',
        projectId: 'project-id',
        temperature: 0.5,
        topK: 5,
        topP: 0.8,
      },
    });
  });
});



---
File: /src/collections/configure/vectorIndex.ts
---

import {
  ModuleConfig,
  PQEncoderDistribution,
  PQEncoderType,
  VectorIndexFilterStrategy,
} from '../config/types/index.js';
import {
  BQConfigCreate,
  BQConfigUpdate,
  PQConfigCreate,
  PQConfigUpdate,
  SQConfigCreate,
  SQConfigUpdate,
  VectorIndexConfigDynamicCreate,
  VectorIndexConfigDynamicCreateOptions,
  VectorIndexConfigFlatCreate,
  VectorIndexConfigFlatCreateOptions,
  VectorIndexConfigFlatUpdate,
  VectorIndexConfigHNSWCreate,
  VectorIndexConfigHNSWCreateOptions,
  VectorIndexConfigHNSWUpdate,
} from './types/index.js';

const isModuleConfig = <N, C>(config: ModuleConfig<N, C> | C): config is ModuleConfig<N, C> => {
  return config && typeof config === 'object' && 'name' in config && 'config' in config;
};

const configure = {
  /**
   * Create a `ModuleConfig<'flat', VectorIndexConfigFlatCreate | undefined>` object when defining the configuration of the FLAT vector index.
   *
   * Use this method when defining the `options.vectorIndexConfig` argument of the `configure.vectorizer` method.
   *
   * @param {VectorIndexConfigFlatCreateOptions} [opts] The options available for configuring the flat vector index.
   * @returns {ModuleConfig<'flat', VectorIndexConfigFlatCreate | undefined>} The configuration object.
   */
  flat: (
    opts?: VectorIndexConfigFlatCreateOptions
  ): ModuleConfig<'flat', VectorIndexConfigFlatCreate | undefined> => {
    const { distanceMetric: distance, vectorCacheMaxObjects, quantizer } = opts || {};
    return {
      name: 'flat',
      config: {
        distance,
        vectorCacheMaxObjects,
        quantizer: quantizer,
      },
    };
  },
  /**
   * Create a `ModuleConfig<'hnsw', VectorIndexConfigHNSWCreate | undefined>` object when defining the configuration of the HNSW vector index.
   *
   * Use this method when defining the `options.vectorIndexConfig` argument of the `configure.vectorizer` method.
   *
   * @param {VectorIndexConfigHNSWCreateOptions} [opts] The options available for configuring the HNSW vector index.
   * @returns {ModuleConfig<'hnsw', VectorIndexConfigHNSWCreate | undefined>} The configuration object.
   */
  hnsw: (
    opts?: VectorIndexConfigHNSWCreateOptions
  ): ModuleConfig<'hnsw', VectorIndexConfigHNSWCreate | undefined> => {
    const { distanceMetric, ...rest } = opts || {};
    return {
      name: 'hnsw',
      config: rest
        ? {
            ...rest,
            distance: distanceMetric,
            quantizer: rest.quantizer,
          }
        : undefined,
    };
  },
  /**
   * Create a `ModuleConfig<'dynamic', VectorIndexConfigDynamicCreate | undefined>` object when defining the configuration of the dynamic vector index.
   *
   * Use this method when defining the `options.vectorIndexConfig` argument of the `configure.vectorizer` method.
   *
   * @param {VectorIndexConfigDynamicCreateOptions} [opts] The options available for configuring the dynamic vector index.
   * @returns {ModuleConfig<'dynamic', VectorIndexConfigDynamicCreate | undefined>} The configuration object.
   */
  dynamic: (
    opts?: VectorIndexConfigDynamicCreateOptions
  ): ModuleConfig<'dynamic', VectorIndexConfigDynamicCreate | undefined> => {
    return {
      name: 'dynamic',
      config: opts
        ? {
            distance: opts.distanceMetric,
            threshold: opts.threshold,
            hnsw: isModuleConfig(opts.hnsw) ? opts.hnsw.config : configure.hnsw(opts.hnsw).config,
            flat: isModuleConfig(opts.flat) ? opts.flat.config : configure.flat(opts.flat).config,
          }
        : undefined,
    };
  },
  /**
   * Define the quantizer configuration to use when creating a vector index.
   */
  quantizer: {
    /**
     * Create an object of type `BQConfigCreate` to be used when defining the quantizer configuration of a vector index.
     *
     * @param {boolean} [options.cache] Whether to cache the quantizer. Default is false.
     * @param {number} [options.rescoreLimit] The rescore limit. Default is 1000.
     * @returns {BQConfigCreate} The object of type `BQConfigCreate`.
     */
    bq: (options?: { cache?: boolean; rescoreLimit?: number }): BQConfigCreate => {
      return {
        cache: options?.cache,
        rescoreLimit: options?.rescoreLimit,
        type: 'bq',
      };
    },
    /**
     * Create an object of type `PQConfigCreate` to be used when defining the quantizer configuration of a vector index.
     *
     * @param {boolean} [options.bitCompression] Whether to use bit compression.
     * @param {number} [options.centroids] The number of centroids[.
     * @param {PQEncoderDistribution} ]options.encoder.distribution The encoder distribution.
     * @param {PQEncoderType} [options.encoder.type] The encoder type.
     * @param {number} [options.segments] The number of segments.
     * @param {number} [options.trainingLimit] The training limit.
     * @returns {PQConfigCreate} The object of type `PQConfigCreate`.
     */
    pq: (options?: {
      bitCompression?: boolean;
      centroids?: number;
      encoder?: {
        distribution?: PQEncoderDistribution;
        type?: PQEncoderType;
      };
      segments?: number;
      trainingLimit?: number;
    }): PQConfigCreate => {
      return {
        bitCompression: options?.bitCompression,
        centroids: options?.centroids,
        encoder: options?.encoder
          ? {
              distribution: options.encoder.distribution,
              type: options.encoder.type,
            }
          : undefined,
        segments: options?.segments,
        trainingLimit: options?.trainingLimit,
        type: 'pq',
      };
    },
    /**
     * Create an object of type `SQConfigCreate` to be used when defining the quantizer configuration of a vector index.
     *
     * @param {number} [options.rescoreLimit] The rescore limit.
     * @param {number} [options.trainingLimit] The training limit.
     * @returns {SQConfigCreate} The object of type `SQConfigCreate`.
     */
    sq: (options?: { rescoreLimit?: number; trainingLimit?: number }): SQConfigCreate => {
      return {
        rescoreLimit: options?.rescoreLimit,
        trainingLimit: options?.trainingLimit,
        type: 'sq',
      };
    },
  },
};

const reconfigure = {
  /**
   * Create a `ModuleConfig<'flat', VectorIndexConfigFlatUpdate>` object to update the configuration of the FLAT vector index.
   *
   * Use this method when defining the `options.vectorIndexConfig` argument of the `reconfigure.vectorizer` method.
   *
   * @param {VectorDistance} [options.distanceMetric] The distance metric to use. Default is 'cosine'.
   * @param {number} [options.vectorCacheMaxObjects] The maximum number of objects to cache in the vector cache. Default is 1000000000000.
   * @param {BQConfigCreate} [options.quantizer] The quantizer configuration to use. Default is `bq`.
   * @returns {ModuleConfig<'flat', VectorIndexConfigFlatCreate>} The configuration object.
   */
  flat: (options: {
    vectorCacheMaxObjects?: number;
    quantizer?: BQConfigUpdate;
  }): ModuleConfig<'flat', VectorIndexConfigFlatUpdate> => {
    return {
      name: 'flat',
      config: options,
    };
  },
  /**
   * Create a `ModuleConfig<'hnsw', VectorIndexConfigHNSWCreate>` object to update the configuration of the HNSW vector index.
   *
   * Use this method when defining the `options.vectorIndexConfig` argument of the `reconfigure.vectorizer` method.
   *
   * @param {number} [options.dynamicEfFactor] The dynamic ef factor. Default is 8.
   * @param {number} [options.dynamicEfMax] The dynamic ef max. Default is 500.
   * @param {number} [options.dynamicEfMin] The dynamic ef min. Default is 100.
   * @param {number} [options.ef] The ef parameter. Default is -1.
   * @param {VectorIndexFilterStrategy} [options.filterStrategy] The filter strategy. Default is 'sweeping'.
   * @param {number} [options.flatSearchCutoff] The flat search cutoff. Default is 40000.
   * @param {PQConfigUpdate | BQConfigUpdate} [options.quantizer] The quantizer configuration to use. Use `vectorIndex.quantizer.bq` or `vectorIndex.quantizer.pq` to make one.
   * @param {number} [options.vectorCacheMaxObjects] The maximum number of objects to cache in the vector cache. Default is 1000000000000.
   * @returns {ModuleConfig<'hnsw', VectorIndexConfigHNSWUpdate>} The configuration object.
   */
  hnsw: (options: {
    dynamicEfFactor?: number;
    dynamicEfMax?: number;
    dynamicEfMin?: number;
    ef?: number;
    filterStrategy?: VectorIndexFilterStrategy;
    flatSearchCutoff?: number;
    quantizer?: PQConfigUpdate | BQConfigUpdate | SQConfigUpdate;
    vectorCacheMaxObjects?: number;
  }): ModuleConfig<'hnsw', VectorIndexConfigHNSWUpdate> => {
    return {
      name: 'hnsw',
      config: options,
    };
  },
  /**
   * Define the quantizer configuration to use when creating a vector index.
   */
  quantizer: {
    /**
     * Create an object of type `BQConfigUpdate` to be used when updating the quantizer configuration of a vector index.
     *
     * NOTE: If the vector index already has a quantizer configured, you cannot change its quantizer type; only its values.
     * So if you want to change the quantizer type, you must recreate the collection.
     *
     * @param {boolean} [options.cache] Whether to cache the quantizer.
     * @param {number} [options.rescoreLimit] The new rescore limit.
     * @returns {BQConfigCreate} The configuration object.
     */
    bq: (options?: { cache?: boolean; rescoreLimit?: number }): BQConfigUpdate => {
      return {
        ...options,
        type: 'bq',
      };
    },
    /**
     * Create an object of type `PQConfigUpdate` to be used when updating the quantizer configuration of a vector index.
     *
     * NOTE: If the vector index already has a quantizer configured, you cannot change its quantizer type; only its values.
     * So if you want to change the quantizer type, you must recreate the collection.
     *
     * @param {number} [options.centroids] The new number of centroids.
     * @param {PQEncoderDistribution} [options.pqEncoderDistribution] The new encoder distribution.
     * @param {PQEncoderType} [options.pqEncoderType] The new encoder type.
     * @param {number} [options.segments] The new number of segments.
     * @param {number} [options.trainingLimit] The new training limit.
     * @returns {PQConfigUpdate} The configuration object.
     */
    pq: (options?: {
      centroids?: number;
      pqEncoderDistribution?: PQEncoderDistribution;
      pqEncoderType?: PQEncoderType;
      segments?: number;
      trainingLimit?: number;
    }): PQConfigUpdate => {
      const { pqEncoderDistribution, pqEncoderType, ...rest } = options || {};
      return {
        ...rest,
        encoder:
          pqEncoderDistribution || pqEncoderType
            ? {
                distribution: pqEncoderDistribution,
                type: pqEncoderType,
              }
            : undefined,
        type: 'pq',
      };
    },
    /**
     * Create an object of type `SQConfigUpdate` to be used when updating the quantizer configuration of a vector index.
     *
     * NOTE: If the vector index already has a quantizer configured, you cannot change its quantizer type; only its values.
     * So if you want to change the quantizer type, you must recreate the collection.
     *
     * @param {number} [options.rescoreLimit] The rescore limit.
     * @param {number} [options.trainingLimit] The training limit.
     * @returns {SQConfigUpdate} The configuration object.
     */
    sq: (options?: { rescoreLimit?: number; trainingLimit?: number }): SQConfigUpdate => {
      return {
        ...options,
        type: 'sq',
      };
    },
  },
};

export { configure, reconfigure };



---
File: /src/collections/configure/vectorizer.ts
---

import {
  Multi2VecBindConfig,
  Multi2VecClipConfig,
  Multi2VecField,
  Multi2VecPalmConfig,
  Multi2VecVoyageAIConfig,
  VectorIndexType,
  Vectorizer,
  VectorizerConfigType,
} from '../config/types/index.js';
import { VectorConfigCreate, VectorIndexConfigCreateType, VectorizerCreateOptions } from '../index.js';
import { PrimitiveKeys } from '../types/internal.js';
import { ConfigureNonTextVectorizerOptions, ConfigureTextVectorizerOptions } from './types/index.js';

const makeVectorizer = <T, N extends string | undefined, I extends VectorIndexType, V extends Vectorizer>(
  name: N | undefined,
  options?: VectorizerCreateOptions<PrimitiveKeys<T>[], I, V>
) => {
  return {
    name: name as N,
    properties: options?.sourceProperties,
    vectorIndex: options?.vectorIndexConfig
      ? options.vectorIndexConfig
      : { name: 'hnsw' as I, config: undefined as VectorIndexConfigCreateType<I> },
    vectorizer: options?.vectorizerConfig
      ? options.vectorizerConfig
      : { name: 'none' as V, config: undefined as VectorizerConfigType<V> },
  };
};

const mapMulti2VecField = (field: string | Multi2VecField): Multi2VecField => {
  if (typeof field === 'string') {
    return { name: field };
  }
  return field;
};

const formatMulti2VecFields = (
  weights: Record<string, number[]>,
  key: string,
  fields?: Multi2VecField[]
): Record<string, number[]> => {
  if (fields !== undefined && fields.length > 0) {
    weights[key] = fields.filter((f) => f.weight !== undefined).map((f) => f.weight as number);
    if (weights[key].length === 0) {
      delete weights[key];
    }
  }
  return weights;
};

export const vectorizer = {
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'none'`.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'none'>} [opts] The configuration options for the `none` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>[], N, I, 'none'>} The configuration object.
   */
  none: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureNonTextVectorizerOptions<N, I, 'none'>
  ): VectorConfigCreate<never, N, I, 'none'> => {
    const { name, vectorIndexConfig } = opts || {};
    return makeVectorizer(name, { vectorIndexConfig });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'img2vec-neural'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/modules/img2vec-neural) for detailed usage.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'img2vec-neural'>} [opts] The configuration options for the `img2vec-neural` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>[], N, I, 'img2vec-neural'>} The configuration object.
   */
  img2VecNeural: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts: ConfigureNonTextVectorizerOptions<N, I, 'img2vec-neural'>
  ): VectorConfigCreate<never, N, I, 'img2vec-neural'> => {
    const { name, vectorIndexConfig, ...config } = opts;
    return makeVectorizer(name, {
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'img2vec-neural',
        config: config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'multi2vec-bind'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/imagebind/embeddings-multimodal) for detailed usage.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-bind'>} [opts] The configuration options for the `multi2vec-bind` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>[], N, I, 'multi2vec-bind'>} The configuration object.
   */
  multi2VecBind: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-bind'>
  ): VectorConfigCreate<never, N, I, 'multi2vec-bind'> => {
    const { name, vectorIndexConfig, ...config } = opts || {};
    const audioFields = config.audioFields?.map(mapMulti2VecField);
    const depthFields = config.depthFields?.map(mapMulti2VecField);
    const imageFields = config.imageFields?.map(mapMulti2VecField);
    const IMUFields = config.IMUFields?.map(mapMulti2VecField);
    const textFields = config.textFields?.map(mapMulti2VecField);
    const thermalFields = config.thermalFields?.map(mapMulti2VecField);
    const videoFields = config.videoFields?.map(mapMulti2VecField);
    let weights: Multi2VecClipConfig['weights'] = {};
    weights = formatMulti2VecFields(weights, 'audioFields', audioFields);
    weights = formatMulti2VecFields(weights, 'depthFields', depthFields);
    weights = formatMulti2VecFields(weights, 'imageFields', imageFields);
    weights = formatMulti2VecFields(weights, 'IMUFields', IMUFields);
    weights = formatMulti2VecFields(weights, 'textFields', textFields);
    weights = formatMulti2VecFields(weights, 'thermalFields', thermalFields);
    weights = formatMulti2VecFields(weights, 'videoFields', videoFields);
    return makeVectorizer(name, {
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'multi2vec-bind',
        config:
          Object.keys(config).length === 0
            ? undefined
            : {
                ...config,
                audioFields: audioFields?.map((f) => f.name),
                depthFields: depthFields?.map((f) => f.name),
                imageFields: imageFields?.map((f) => f.name),
                IMUFields: IMUFields?.map((f) => f.name),
                textFields: textFields?.map((f) => f.name),
                thermalFields: thermalFields?.map((f) => f.name),
                videoFields: videoFields?.map((f) => f.name),
                weights: Object.keys(weights).length === 0 ? undefined : weights,
              },
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'multi2vec-cohere'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/cohere/embeddings) for detailed usage.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-cohere'>} [opts] The configuration options for the `multi2vec-cohere` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>[], N, I, 'multi2vec-cohere'>} The configuration object.
   */
  multi2VecCohere: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-cohere'>
  ): VectorConfigCreate<never, N, I, 'multi2vec-cohere'> => {
    const { name, vectorIndexConfig, ...config } = opts || {};
    const imageFields = config.imageFields?.map(mapMulti2VecField);
    const textFields = config.textFields?.map(mapMulti2VecField);
    let weights: Multi2VecBindConfig['weights'] = {};
    weights = formatMulti2VecFields(weights, 'imageFields', imageFields);
    weights = formatMulti2VecFields(weights, 'textFields', textFields);
    return makeVectorizer(name, {
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'multi2vec-cohere',
        config:
          Object.keys(config).length === 0
            ? undefined
            : {
                ...config,
                imageFields: imageFields?.map((f) => f.name),
                textFields: textFields?.map((f) => f.name),
                weights: Object.keys(weights).length === 0 ? undefined : weights,
              },
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'multi2vec-clip'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings-multimodal) for detailed usage.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-clip'>} [opts] The configuration options for the `multi2vec-clip` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>[], N, I, 'multi2vec-clip'>} The configuration object.
   */
  multi2VecClip: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-clip'>
  ): VectorConfigCreate<never, N, I, 'multi2vec-clip'> => {
    const { name, vectorIndexConfig, ...config } = opts || {};
    const imageFields = config.imageFields?.map(mapMulti2VecField);
    const textFields = config.textFields?.map(mapMulti2VecField);
    let weights: Multi2VecBindConfig['weights'] = {};
    weights = formatMulti2VecFields(weights, 'imageFields', imageFields);
    weights = formatMulti2VecFields(weights, 'textFields', textFields);
    return makeVectorizer(name, {
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'multi2vec-clip',
        config:
          Object.keys(config).length === 0
            ? undefined
            : {
                ...config,
                imageFields: imageFields?.map((f) => f.name),
                textFields: textFields?.map((f) => f.name),
                weights: Object.keys(weights).length === 0 ? undefined : weights,
              },
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'multi2vec-palm'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/google/embeddings-multimodal) for detailed usage.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-palm'>} opts The configuration options for the `multi2vec-palm` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>[], N, I, 'multi2vec-palm'>} The configuration object.
   * @deprecated Use `multi2VecGoogle` instead.
   */
  multi2VecPalm: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts: ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-palm'>
  ): VectorConfigCreate<never, N, I, 'multi2vec-palm'> => {
    console.warn('The `multi2vec-palm` vectorizer is deprecated. Use `multi2vec-google` instead.');
    const { name, vectorIndexConfig, ...config } = opts;
    const imageFields = config.imageFields?.map(mapMulti2VecField);
    const textFields = config.textFields?.map(mapMulti2VecField);
    const videoFields = config.videoFields?.map(mapMulti2VecField);
    let weights: Multi2VecPalmConfig['weights'] = {};
    weights = formatMulti2VecFields(weights, 'imageFields', imageFields);
    weights = formatMulti2VecFields(weights, 'textFields', textFields);
    weights = formatMulti2VecFields(weights, 'videoFields', videoFields);
    return makeVectorizer(name, {
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'multi2vec-palm',
        config: {
          ...config,
          imageFields: imageFields?.map((f) => f.name),
          textFields: textFields?.map((f) => f.name),
          videoFields: videoFields?.map((f) => f.name),
          weights: Object.keys(weights).length === 0 ? undefined : weights,
        },
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'multi2vec-google'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/google/embeddings-multimodal) for detailed usage.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-google'>} opts The configuration options for the `multi2vec-google` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>[], N, I, 'multi2vec-google'>} The configuration object.
   */
  multi2VecGoogle: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts: ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-google'>
  ): VectorConfigCreate<never, N, I, 'multi2vec-google'> => {
    const { name, vectorIndexConfig, ...config } = opts;
    const imageFields = config.imageFields?.map(mapMulti2VecField);
    const textFields = config.textFields?.map(mapMulti2VecField);
    const videoFields = config.videoFields?.map(mapMulti2VecField);
    let weights: Multi2VecPalmConfig['weights'] = {};
    weights = formatMulti2VecFields(weights, 'imageFields', imageFields);
    weights = formatMulti2VecFields(weights, 'textFields', textFields);
    weights = formatMulti2VecFields(weights, 'videoFields', videoFields);
    return makeVectorizer(name, {
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'multi2vec-google',
        config: {
          ...config,
          imageFields: imageFields?.map((f) => f.name),
          textFields: textFields?.map((f) => f.name),
          videoFields: videoFields?.map((f) => f.name),
          weights: Object.keys(weights).length === 0 ? undefined : weights,
        },
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'multi2vec-clip'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings-multimodal) for detailed usage.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-voyageai'>} [opts] The configuration options for the `multi2vec-voyageai` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>[], N, I, 'multi2vec-voyageai'>} The configuration object.
   */
  multi2VecVoyageAI: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureNonTextVectorizerOptions<N, I, 'multi2vec-voyageai'>
  ): VectorConfigCreate<never, N, I, 'multi2vec-voyageai'> => {
    const { name, vectorIndexConfig, ...config } = opts || {};
    const imageFields = config.imageFields?.map(mapMulti2VecField);
    const textFields = config.textFields?.map(mapMulti2VecField);
    let weights: Multi2VecVoyageAIConfig['weights'] = {};
    weights = formatMulti2VecFields(weights, 'imageFields', imageFields);
    weights = formatMulti2VecFields(weights, 'textFields', textFields);
    return makeVectorizer(name, {
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'multi2vec-voyageai',
        config: {
          ...config,
          imageFields: imageFields?.map((f) => f.name),
          textFields: textFields?.map((f) => f.name),
          weights: Object.keys(weights).length === 0 ? undefined : weights,
        },
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'ref2vec-centroid'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/modules/ref2vec-centroid) for detailed usage.
   *
   * @param {ConfigureNonTextVectorizerOptions<N, I, 'ref2vec-centroid'>} opts The configuration options for the `ref2vec-centroid` vectorizer.
   * @returns {VectorConfigCreate<never, N, I, 'ref2vec-centroid'>} The configuration object.
   */
  ref2VecCentroid: <N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts: ConfigureNonTextVectorizerOptions<N, I, 'ref2vec-centroid'>
  ): VectorConfigCreate<never, N, I, 'ref2vec-centroid'> => {
    const { name, vectorIndexConfig, ...config } = opts;
    return makeVectorizer(name, {
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'ref2vec-centroid',
        config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-aws'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/aws/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<N, T, I, 'text2vec-aws'>} opts The configuration options for the `text2vec-aws` vectorizer.
   * @returns { VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-aws'>} The configuration object.
   */
  text2VecAWS: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-aws'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-aws'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts;
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-aws',
        config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-azure-openai'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/openai/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-azure-openai'>} opts The configuration options for the `text2vec-azure-openai` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-azure-openai'>} The configuration object.
   */
  text2VecAzureOpenAI: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-azure-openai'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-azure-openai'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts;
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-azure-openai',
        config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-cohere'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/cohere/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-cohere'>} [opts] The configuration options for the `text2vec-cohere` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-cohere'>} The configuration object.
   */
  text2VecCohere: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-cohere'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-cohere'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-cohere',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-contextionary'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/modules/text2vec-contextionary) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-contextionary'>} [opts] The configuration for the `text2vec-contextionary` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-contextionary'>} The configuration object.
   */
  text2VecContextionary: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-contextionary'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-contextionary'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-contextionary',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-databricks'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/databricks/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-databricks'>} opts The configuration for the `text2vec-databricks` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-databricks'>} The configuration object.
   */
  text2VecDatabricks: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-databricks'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-databricks'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts;
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-databricks',
        config: config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-gpt4all'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/gpt4all/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-gpt4all'>} [opts] The configuration for the `text2vec-contextionary` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-gpt4all'>} The configuration object.
   */
  text2VecGPT4All: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-gpt4all'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-gpt4all'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-gpt4all',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-huggingface'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/huggingface/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-huggingface'>} [opts] The configuration for the `text2vec-contextionary` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-huggingface'>} The configuration object.
   */
  text2VecHuggingFace: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-huggingface'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-huggingface'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-huggingface',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-jina'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/jinaai/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-jina'>} [opts] The configuration for the `text2vec-jina` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-jina'>} The configuration object.
   */
  text2VecJina: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-jina'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-jina'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-jina',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-mistral'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/mistral/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-mistral'>} [opts] The configuration for the `text2vec-mistral` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-mistral'>} The configuration object.
   */
  text2VecMistral: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-mistral'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-mistral'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-mistral',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-openai'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/openai/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-openai'>} [opts] The configuration for the `text2vec-openai` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-openai'>} The configuration object.
   */
  text2VecOpenAI: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-openai'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-openai'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-openai',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-ollama'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/ollama/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-ollama'>} [opts] The configuration for the `text2vec-ollama` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-ollama'>} The configuration object.
   */
  text2VecOllama: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-ollama'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-ollama'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-ollama',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-palm'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/google/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-palm'>} opts The configuration for the `text2vec-palm` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-palm'>} The configuration object.
   * @deprecated Use `text2VecGoogle` instead.
   */
  text2VecPalm: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-palm'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-palm'> => {
    console.warn('The `text2VecPalm` vectorizer is deprecated. Use `text2VecGoogle` instead.');
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-palm',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-google'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/google/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-google'>} opts The configuration for the `text2vec-palm` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-google'>} The configuration object.
   */
  text2VecGoogle: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-google'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-google'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-google',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-transformers'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/transformers/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-transformers'>} [opts] The configuration for the `text2vec-transformers` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-transformers'>} The configuration object.
   */
  text2VecTransformers: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-transformers'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-transformers'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-transformers',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-voyageai'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/voyageai/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-voyageai'>} [opts] The configuration for the `text2vec-voyageai` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-voyageai'>} The configuration object.
   */
  text2VecVoyageAI: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-voyageai'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-voyageai'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-voyageai',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },

  /**
   * Create a `VectorConfigCreate` object with the vectorizer set to `'text2vec-weaviate'`.
   *
   * See the [documentation](https://weaviate.io/developers/weaviate/model-providers/weaviate/embeddings) for detailed usage.
   *
   * @param {ConfigureTextVectorizerOptions<T, N, I, 'text2vec-weaviate'>} [opts] The configuration for the `text2vec-weaviate` vectorizer.
   * @returns {VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-weaviate'>} The configuration object.
   */
  text2VecWeaviate: <T, N extends string | undefined = undefined, I extends VectorIndexType = 'hnsw'>(
    opts?: ConfigureTextVectorizerOptions<T, N, I, 'text2vec-weaviate'>
  ): VectorConfigCreate<PrimitiveKeys<T>, N, I, 'text2vec-weaviate'> => {
    const { name, sourceProperties, vectorIndexConfig, ...config } = opts || {};
    return makeVectorizer(name, {
      sourceProperties,
      vectorIndexConfig,
      vectorizerConfig: {
        name: 'text2vec-weaviate',
        config: Object.keys(config).length === 0 ? undefined : config,
      },
    });
  },
};



---
File: /src/collections/data/index.ts
---

import Connection from '../../connection/grpc.js';

import { buildRefsPath } from '../../batch/path.js';
import { Checker, ConsistencyLevel } from '../../data/index.js';
import { ObjectsPath, ReferencesPath } from '../../data/path.js';
import { BatchReference, BatchReferenceResponse, WeaviateObject } from '../../openapi/types.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';
import { Deserialize } from '../deserialize/index.js';
import { FilterValue } from '../filters/index.js';
import { referenceToBeacons } from '../references/utils.js';
import { DataGuards, Serialize } from '../serialize/index.js';
import {
  BatchObjectsReturn,
  BatchReferencesReturn,
  DataObject,
  DeleteManyReturn,
  ErrorReference,
  NonReferenceInputs,
  Properties,
  ReferenceInput,
  ReferenceInputs,
  Vectors,
} from '../types/index.js';

/** The available options to the `data.deleteMany` method.  */
export type DeleteManyOptions<V> = {
  /** Whether to return verbose information about the operation */
  verbose?: V;
  /** Whether to perform a dry run of the operation */
  dryRun?: boolean;
};

/** The available options to the `data.insert` method. */
export type InsertObject<T> = {
  /** The ID of the object to be inserted. If not provided, a new ID will be generated. */
  id?: string;
  /** The properties of the object to be inserted */
  properties?: NonReferenceInputs<T>;
  /** The references of the object to be inserted */
  references?: ReferenceInputs<T>;
  /** The vector(s) of the object to be inserted */
  vectors?: number[] | Vectors;
};

/** The arguments of the `data.referenceX` methods */
export type ReferenceArgs<T> = {
  /** The ID of the object that will have the reference */
  fromUuid: string;
  /** The property of the object that will have the reference */
  fromProperty: string;
  /** The object(s) to reference */
  to: ReferenceInput<T>;
};

/** The available options to the `data.replace` method. */
export type ReplaceObject<T> = {
  /** The ID of the object to be replaced */
  id: string;
  /** The properties of the object to be replaced */
  properties?: NonReferenceInputs<T>;
  /** The references of the object to be replaced */
  references?: ReferenceInputs<T>;
  //* The vector(s) to replace in the object */
  vectors?: number[] | Vectors;
};

/** The available options to the `data.update` method. */
export type UpdateObject<T> = {
  /** The ID of the object to be updated */
  id: string;
  /** The properties of the object to be updated */
  properties?: NonReferenceInputs<T>;
  /** The references of the object to be updated */
  references?: ReferenceInputs<T>;
  //* The vector(s) to update in the object */
  vectors?: number[] | Vectors;
};

export interface Data<T> {
  deleteById: (id: string) => Promise<boolean>;
  deleteMany: <V extends boolean = false>(
    where: FilterValue,
    opts?: DeleteManyOptions<V>
  ) => Promise<DeleteManyReturn<V>>;
  exists: (id: string) => Promise<boolean>;
  /**
   * Insert a single object into the collection.
   *
   * If you don't provide any options to the function, then an empty object will be created.
   *
   * @param {InsertArgs<T> | NonReferenceInputs<T>} [args] The object to insert. If an `id` is provided, it will be used as the object's ID. If not, a new ID will be generated.
   * @returns {Promise<string>} The ID of the inserted object.
   */
  insert: (obj?: InsertObject<T> | NonReferenceInputs<T>) => Promise<string>;
  /**
   * Insert multiple objects into the collection.
   *
   * This object does not perform any batching for you. It sends all objects in a single request to Weaviate.
   *
   * @param {(DataObject<T> | NonReferenceInputs<T>)[]} objects The objects to insert.
   * @returns {Promise<BatchObjectsReturn<T>>} The result of the batch insert.
   */
  insertMany: (objects: (DataObject<T> | NonReferenceInputs<T>)[]) => Promise<BatchObjectsReturn<T>>;
  /**
   * Create a reference between an object in this collection and any other object in Weaviate.
   *
   * @param {ReferenceArgs<P>} args The reference to create.
   * @returns {Promise<void>}
   */
  referenceAdd: <P extends Properties>(args: ReferenceArgs<P>) => Promise<void>;
  /**
   * Create multiple references between an object in this collection and any other object in Weaviate.
   *
   * This method is optimized for performance and sends all references in a single request.
   *
   * @param {ReferenceArgs<P>[]} refs The references to create.
   * @returns {Promise<BatchReferencesReturn>} The result of the batch reference creation.
   */
  referenceAddMany: <P extends Properties>(refs: ReferenceArgs<P>[]) => Promise<BatchReferencesReturn>;
  /**
   * Delete a reference between an object in this collection and any other object in Weaviate.
   *
   * @param {ReferenceArgs<P>} args The reference to delete.
   * @returns {Promise<void>}
   */
  referenceDelete: <P extends Properties>(args: ReferenceArgs<P>) => Promise<void>;
  /**
   * Replace a reference between an object in this collection and any other object in Weaviate.
   *
   * @param {ReferenceArgs<P>} args The reference to replace.
   * @returns {Promise<void>}
   */
  referenceReplace: <P extends Properties>(args: ReferenceArgs<P>) => Promise<void>;
  /**
   * Replace an object in the collection.
   *
   * This is equivalent to a PUT operation.
   *
   * @param {ReplaceOptions<T>} [opts] The object attributes to replace.
   * @returns {Promise<void>}
   */
  replace: (obj: ReplaceObject<T>) => Promise<void>;
  /**
   * Update an object in the collection.
   *
   * This is equivalent to a PATCH operation.
   *
   * @param {UpdateArgs<T>} [opts] The object attributes to replace.
   * @returns {Promise<void>}
   */
  update: (obj: UpdateObject<T>) => Promise<void>;
}

interface IBuilder {
  withConsistencyLevel(consistencyLevel: ConsistencyLevel): this;
  withTenant(tenant: string): this;
}

const addContext = <B extends IBuilder>(
  builder: B,
  consistencyLevel?: ConsistencyLevel,
  tenant?: string
): B => {
  if (consistencyLevel) {
    builder = builder.withConsistencyLevel(consistencyLevel);
  }
  if (tenant) {
    builder = builder.withTenant(tenant);
  }
  return builder;
};

const data = <T>(
  connection: Connection,
  name: string,
  dbVersionSupport: DbVersionSupport,
  consistencyLevel?: ConsistencyLevel,
  tenant?: string
): Data<T> => {
  const objectsPath = new ObjectsPath(dbVersionSupport);
  const referencesPath = new ReferencesPath(dbVersionSupport);

  const parseObject = async (object?: InsertObject<any>): Promise<WeaviateObject<T>> => {
    if (!object) {
      return {} as WeaviateObject<T>;
    }
    const obj: WeaviateObject<T> = {
      id: object.id,
      properties: object.properties
        ? (Serialize.restProperties(object.properties, object.references) as T)
        : undefined,
    };
    if (Array.isArray(object.vectors)) {
      const requiresNamedVectorsInsertFix = await dbVersionSupport.requiresNamedVectorsInsertFix();
      if (requiresNamedVectorsInsertFix.supports) {
        obj.vector = object.vectors;
        obj.vectors = { default: object.vectors };
      } else {
        obj.vector = object.vectors;
      }
    } else if (object.vectors) {
      obj.vectors = object.vectors;
    }
    return obj;
  };

  return {
    deleteById: (id: string): Promise<boolean> =>
      objectsPath
        .buildDelete(id, name, consistencyLevel, tenant)
        .then((path) => connection.delete(path, undefined, false))
        .then(() => true),
    deleteMany: <V extends boolean>(
      where: FilterValue,
      opts?: DeleteManyOptions<V>
    ): Promise<DeleteManyReturn<V>> =>
      connection
        .batch(name, consistencyLevel, tenant)
        .then((batch) =>
          batch.withDelete({
            filters: Serialize.filtersGRPC(where),
            dryRun: opts?.dryRun,
            verbose: opts?.verbose,
          })
        )
        .then((reply) => Deserialize.deleteMany(reply, opts?.verbose)),
    exists: (id: string): Promise<boolean> =>
      addContext(
        new Checker(connection, objectsPath).withId(id).withClassName(name),
        consistencyLevel,
        tenant
      ).do(),
    insert: (obj?: InsertObject<T> | NonReferenceInputs<T>): Promise<string> =>
      Promise.all([
        objectsPath.buildCreate(consistencyLevel),
        parseObject(
          obj ? (DataGuards.isDataObject(obj) ? obj : ({ properties: obj } as InsertObject<T>)) : obj
        ),
      ]).then(([path, object]) =>
        connection
          .postReturn<WeaviateObject<T>, Required<WeaviateObject<T>>>(path, {
            class: name,
            tenant: tenant,
            ...object,
          })
          .then((obj) => obj.id)
      ),
    insertMany: (objects: (DataObject<T> | NonReferenceInputs<T>)[]): Promise<BatchObjectsReturn<T>> =>
      connection.batch(name, consistencyLevel).then(async (batch) => {
        const requiresNamedVectorsInsertFix = await dbVersionSupport.requiresNamedVectorsInsertFix();
        const serialized = await Serialize.batchObjects(
          name,
          objects,
          requiresNamedVectorsInsertFix.supports,
          tenant
        );
        const start = Date.now();
        const reply = await batch.withObjects({ objects: serialized.mapped });
        const end = Date.now();
        return Deserialize.batchObjects<T>(reply, serialized.batch, serialized.mapped, end - start);
      }),
    referenceAdd: <P extends Properties>(args: ReferenceArgs<P>): Promise<void> =>
      referencesPath
        .build(args.fromUuid, name, args.fromProperty, consistencyLevel, tenant)
        .then((path) =>
          Promise.all(referenceToBeacons(args.to).map((beacon) => connection.postEmpty(path, beacon)))
        )
        .then(() => {}),
    referenceAddMany: <P extends Properties>(refs: ReferenceArgs<P>[]): Promise<BatchReferencesReturn> => {
      const path = buildRefsPath(
        new URLSearchParams(consistencyLevel ? { consistency_level: consistencyLevel } : {})
      );
      const references: BatchReference[] = [];
      refs.forEach((ref) => {
        referenceToBeacons(ref.to).forEach((beacon) => {
          references.push({
            from: `weaviate://localhost/${name}/${ref.fromUuid}/${ref.fromProperty}`,
            to: beacon.beacon,
            tenant: tenant,
          });
        });
      });
      const start = Date.now();
      return connection
        .postReturn<BatchReference[], BatchReferenceResponse[]>(path, references)
        .then((res) => {
          const end = Date.now();
          const errors: Record<number, ErrorReference> = {};
          res.forEach((entry, idx) => {
            if (entry.result?.status === 'FAILED') {
              errors[idx] = {
                message: entry.result?.errors?.error?.[0].message
                  ? entry.result?.errors?.error?.[0].message
                  : 'unknown error',
                reference: references[idx],
              };
            }
          });
          return {
            elapsedSeconds: end - start,
            errors: errors,
            hasErrors: Object.keys(errors).length > 0,
          };
        });
    },
    referenceDelete: <P extends Properties>(args: ReferenceArgs<P>): Promise<void> =>
      referencesPath
        .build(args.fromUuid, name, args.fromProperty, consistencyLevel, tenant)
        .then((path) =>
          Promise.all(referenceToBeacons(args.to).map((beacon) => connection.delete(path, beacon, false)))
        )
        .then(() => {}),
    referenceReplace: <P extends Properties>(args: ReferenceArgs<P>): Promise<void> =>
      referencesPath
        .build(args.fromUuid, name, args.fromProperty, consistencyLevel, tenant)
        .then((path) => connection.put(path, referenceToBeacons(args.to), false)),
    replace: (obj: ReplaceObject<T>): Promise<void> =>
      Promise.all([objectsPath.buildUpdate(obj.id, name, consistencyLevel), parseObject(obj)]).then(
        ([path, object]) =>
          connection.put(path, {
            class: name,
            tenant: tenant,
            ...object,
          })
      ),
    update: (obj: UpdateObject<T>): Promise<void> =>
      Promise.all([objectsPath.buildUpdate(obj.id, name, consistencyLevel), parseObject(obj)]).then(
        ([path, object]) =>
          connection.patch(path, {
            class: name,
            tenant: tenant,
            ...object,
          })
      ),
  };
};

export default data;



---
File: /src/collections/data/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
import { v4 } from 'uuid';
import { WeaviateUnsupportedFeatureError } from '../../errors.js';
import weaviate, { WeaviateClient, weaviateV2 } from '../../index.js';
import { GeoCoordinate, PhoneNumber } from '../../proto/v1/properties.js';
import { Collection } from '../collection/index.js';
import { CrossReference, CrossReferences, Reference } from '../references/index.js';
import { DataObject, WeaviateObject } from '../types/index.js';

type TestCollectionData = {
  testProp: string;
  testProps?: string[];
  testProp2?: number;
  ref?: CrossReference<TestCollectionData>;
  geo?: GeoCoordinate;
  phone?: PhoneNumber;
  nested?: {
    testProp: string;
  };
};

describe('Testing of the collection.data methods with a single target reference', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionData, 'TestCollectionData'>;
  const collectionName = 'TestCollectionData';

  const existingID = v4();
  const toBeReplacedID = v4();
  const toBeUpdatedID = v4();
  const toBeDeletedID = v4();
  const nonExistingID = v4();

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    await client.collections
      .create<TestCollectionData>({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
            tokenization: 'field',
          },
          {
            name: 'testProp2',
            dataType: 'int',
          },
          {
            name: 'testProps',
            dataType: 'text[]',
          },
          {
            name: 'geo',
            dataType: 'geoCoordinates',
          },
          {
            name: 'phone',
            dataType: 'phoneNumber',
          },
        ],
        references: [
          {
            name: 'ref',
            targetCollection: collectionName,
          },
        ],
      })
      .then(async (collection) => {
        await collection.data.insert({
          properties: {
            testProp: 'Gon get delet',
          },
          id: toBeDeletedID,
        });
        return collection.data.insertMany([
          { properties: { testProp: 'DELETE ME' } },
          { properties: { testProp: 'DELETE ME' } },
          { properties: { testProp: 'DELETE ME' } },
          {
            properties: {
              testProp: 'EXISTING',
              testProp2: 1,
            },
            id: existingID,
          },
          {
            properties: {
              testProp: 'REPLACE ME',
              testProp2: 1,
            },
            id: toBeReplacedID,
          },
          {
            properties: {
              testProp: 'UPDATE ME',
              testProp2: 1,
            },
            id: toBeUpdatedID,
          },
        ]);
      })
      .then(() => {
        const one = collection.data.referenceAdd({
          fromProperty: 'ref',
          fromUuid: toBeReplacedID,
          to: Reference.to(toBeUpdatedID),
        });
        const two = collection.data.referenceAdd({
          fromProperty: 'ref',
          fromUuid: toBeUpdatedID,
          to: Reference.to(toBeReplacedID),
        });
        return Promise.all([one, two]);
      })
      .catch((err) => {
        throw err;
      });
  });

  it('should be able to insert an object without an id', async () => {
    const insert = await collection.data.insert({
      properties: {
        testProp: 'test',
      },
    });
    expect(insert).toBeDefined();
  });

  it('should be able to insert an object with an id', async () => {
    const id = v4();
    const insert = await collection.data.insert({
      properties: {
        testProp: 'test',
      },
      id: id,
    });
    expect(insert).toEqual(id);
  });

  it('should be able to delete an object by id', async () => {
    const result = await collection.data.deleteById(toBeDeletedID);
    expect(result).toBeTruthy();
    const obj = await collection.query.fetchObjectById(toBeDeletedID);
    expect(obj).toBeNull();
  });

  it('should be able to delete many objects with a filter', async () => {
    const result = await collection.data.deleteMany(
      collection.filter.byProperty('testProp').equal('DELETE ME')
    );
    expect(result.failed).toEqual(0);
    expect(result.matches).toEqual(3);
    expect(result.successful).toEqual(3);
  });

  it('should be able to replace an object', async () => {
    const obj = await collection.query.fetchObjectById(toBeReplacedID);
    expect(obj?.properties.testProp).toEqual('REPLACE ME');
    expect(obj?.properties.testProp2).toEqual(1);
    return collection.data
      .replace({
        id: toBeReplacedID,
        properties: {
          testProp: 'REPLACED',
        },
      })
      .then(async () => {
        const obj = await collection.query.fetchObjectById(toBeReplacedID);
        expect(obj?.properties.testProp).toEqual('REPLACED');
        expect(obj?.properties.testProp2).toBeUndefined();
      });
  });

  it('should be able to update an object', async () => {
    const obj = await collection.query.fetchObjectById(toBeUpdatedID);
    expect(obj?.properties.testProp).toEqual('UPDATE ME');
    expect(obj?.properties.testProp2).toEqual(1);
    return collection.data
      .update({
        id: toBeUpdatedID,
        properties: {
          testProp: 'UPDATED',
        },
      })
      .then(async () => {
        const obj = await collection.query.fetchObjectById(toBeUpdatedID);
        expect(obj?.properties.testProp).toEqual('UPDATED');
        expect(obj?.properties.testProp2).toEqual(1);
      });
  });

  it('should be able to insert many (10) objects at once', () => {
    const objects: DataObject<TestCollectionData>[] = [];
    for (let j = 0; j < 10; j++) {
      objects.push({
        properties: {
          testProp: 'testInsertMany10',
          testProps: [], // test empty array
        },
      });
    }
    return collection.data.insertMany(objects).then(async (insert) => {
      expect(insert.hasErrors).toBeFalsy();
      expect(insert.allResponses.length).toEqual(10);
      expect(Object.values(insert.errors).length).toEqual(0);
      expect(Object.values(insert.uuids).length).toEqual(10);
      const query = await collection.query.fetchObjects({ limit: 100 });
      expect(query.objects.filter((obj) => Object.values(insert.uuids).includes(obj.uuid)).length).toEqual(
        10
      );
      expect(query.objects.filter((obj) => obj.properties.testProp === 'testInsertMany10').length).toEqual(
        10
      );
      expect(query.objects.filter((obj) => obj.properties.testProps?.length === 0).length).toEqual(10);
    });
  });

  it('should be able to insert many (100) objects at once', () => {
    const objects: DataObject<TestCollectionData>[] = [];
    for (let j = 0; j < 100; j++) {
      objects.push({
        properties: {
          testProp: 'testInsertMany100',
        },
        references: {
          ref: existingID,
        },
      });
    }
    return collection.data.insertMany(objects).then(async (insert) => {
      expect(insert.hasErrors).toBeFalsy();
      expect(insert.allResponses.length).toEqual(100);
      expect(Object.values(insert.errors).length).toEqual(0);
      expect(Object.values(insert.uuids).length).toEqual(100);
      const query = await collection.query.fetchObjects({ limit: 1000 });
      expect(query.objects.filter((obj) => Object.values(insert.uuids).includes(obj.uuid)).length).toEqual(
        100
      );
      expect(query.objects.filter((obj) => obj.properties.testProp === 'testInsertMany100').length).toEqual(
        100
      );
    });
  });

  it('should be able to insert many (1000) objects at once', () => {
    const objects: any[] = [];
    for (let j = 0; j < 1000; j++) {
      objects.push({
        testProp: 'testInsertMany1000',
      });
    }
    return collection.data.insertMany(objects).then(async (insert) => {
      expect(insert.hasErrors).toBeFalsy();
      expect(insert.allResponses.length).toEqual(1000);
      expect(Object.values(insert.errors).length).toEqual(0);
      expect(Object.values(insert.uuids).length).toEqual(1000);
      const query = await collection.query.fetchObjects({ limit: 2000 });
      expect(query.objects.filter((obj) => Object.values(insert.uuids).includes(obj.uuid)).length).toEqual(
        1000
      );
      expect(query.objects.filter((obj) => obj.properties.testProp === 'testInsertMany1000').length).toEqual(
        1000
      );
    });
  });

  it('should be able to insert a reference between two objects', () => {
    return Promise.all([
      collection.data.referenceAdd({
        fromProperty: 'ref',
        fromUuid: existingID,
        to: Reference.to(existingID), // add using Reference.to syntax
      }),
      collection.data.referenceAdd({
        fromProperty: 'ref',
        fromUuid: existingID,
        to: toBeUpdatedID, // add using string syntax
      }),
      collection.data.referenceAdd({
        fromProperty: 'ref',
        fromUuid: existingID,
        to: [toBeReplacedID], // add using string array syntax
      }),
    ])
      .then(() =>
        collection.query.fetchObjectById(existingID, {
          returnReferences: [{ linkOn: 'ref' }],
        })
      )
      .then((obj) => {
        const ids = obj?.references?.ref?.objects.map((o) => o.uuid);
        expect(obj).not.toBeNull();
        expect(ids).toContain(existingID);
        expect(ids).toContain(toBeUpdatedID);
        expect(ids).toContain(toBeReplacedID);
      });
  });

  it('should be able to replace a reference between two objects', () => {
    const replaceOne = () =>
      collection.data.referenceReplace({
        fromProperty: 'ref',
        fromUuid: toBeReplacedID,
        to: Reference.to(existingID), // replace using Reference.to syntax
      });
    const replaceTwo = () =>
      collection.data.referenceReplace({
        fromProperty: 'ref',
        fromUuid: toBeReplacedID,
        to: toBeUpdatedID, // replace using string syntax
      });
    const replaceThree = () =>
      collection.data.referenceReplace({
        fromProperty: 'ref',
        fromUuid: toBeReplacedID,
        to: [toBeReplacedID], // replace using string array syntax
      });
    const get = () =>
      collection.query.fetchObjectById(toBeReplacedID, {
        returnReferences: [{ linkOn: 'ref' }],
      });
    const assert = (obj: WeaviateObject<TestCollectionData> | null, id: string) => {
      expect(obj).not.toBeNull();
      expect(obj?.references?.ref?.objects[0].uuid).toEqual(id);
    };
    return replaceOne()
      .then(get)
      .then((obj) => assert(obj, existingID))
      .then(replaceTwo)
      .then(get)
      .then((obj) => assert(obj, toBeUpdatedID))
      .then(replaceThree)
      .then(get)
      .then((obj) => assert(obj, toBeReplacedID));
  });

  it('should be able to delete a reference between two objects', () => {
    return Promise.all([
      collection.data.referenceDelete({
        fromProperty: 'ref',
        fromUuid: toBeUpdatedID,
        to: Reference.to(existingID),
      }),
      collection.data.referenceDelete({
        fromProperty: 'ref',
        fromUuid: toBeUpdatedID,
        to: toBeUpdatedID,
      }),
      collection.data.referenceDelete({
        fromProperty: 'ref',
        fromUuid: toBeUpdatedID,
        to: [toBeReplacedID],
      }),
    ])
      .then(() =>
        collection.query.fetchObjectById(toBeUpdatedID, {
          returnReferences: [{ linkOn: 'ref' }],
        })
      )
      .then((obj) => {
        expect(obj).not.toBeNull();
        expect(obj?.references?.ref?.objects).toEqual([]);
      });
  });

  it('should be able to add many references in batch', () => {
    return collection.data
      .referenceAddMany([
        {
          fromProperty: 'ref',
          fromUuid: existingID,
          to: Reference.to([toBeReplacedID]),
        },
        {
          fromProperty: 'ref',
          fromUuid: existingID,
          to: [toBeUpdatedID],
        },
        // {
        //   fromProperty: 'ref',
        //   fromUuid: toBeUpdatedID,
        //   reference: Reference.to({ uuids: existingID }),
        // },
        // currently causes bug in Weaviate due to first deleting last reference in above test and then adding new one
      ])
      .then(async (res) => {
        if (res.hasErrors) console.error(res.errors);
        expect(res.hasErrors).toEqual(false);
        const obj1 = await collection.query.fetchObjectById(existingID, {
          returnReferences: [{ linkOn: 'ref' }],
        });
        expect(obj1).not.toBeNull();
        expect(obj1?.references?.ref?.objects.map((o) => o.uuid)).toContain(toBeReplacedID);
        expect(obj1?.references?.ref?.objects.map((o) => o.uuid)).toContain(toBeUpdatedID);
        // const obj2 = await collection.query.fetchObjectById({
        //   id: toBeUpdatedID
        // });
        // expect(obj2.properties.ref?.objects).toEqual([]);
        // expect(obj2.properties.ref?.targetCollection).toEqual(collectionName);
        // expect(obj2.properties.ref?.uuids?.includes(existingID)).toEqual(true);
      });
  });

  it.skip('should return appropriate errors from add many references in batch', () => {
    // skipped because Weaviate doesn't error if the to UUID doesn't exist
    // it does in referenceAdd, but not in referenceAddMany, due to the /batch implementation
    // difference on the server, needs fixing
    return collection.data
      .referenceAddMany([
        {
          fromProperty: 'ref',
          fromUuid: existingID,
          to: Reference.to([nonExistingID]),
        },
      ])
      .then((res) => {
        expect(res.hasErrors).toEqual(true);
        expect(Object.keys(res.errors).length).toEqual(1);
      });
  });

  it('should be able to add objects with a geo coordinate', async () => {
    const obj = {
      testProp: 'test',
      geo: {
        latitude: 1,
        longitude: 1,
      },
    };
    const id = await collection.data.insert(obj);
    const res = await collection.data.insertMany([obj]);
    const obj1 = await collection.query.fetchObjectById(id, {
      returnProperties: ['geo'],
    });
    const obj2 = await collection.query.fetchObjectById(res.uuids[0], {
      returnProperties: ['geo'],
    });
    expect(obj1?.properties.geo).toEqual({
      latitude: 1,
      longitude: 1,
    });
    expect(obj2?.properties.geo).toEqual({
      latitude: 1,
      longitude: 1,
    });
  });

  it('should be able to add objects with a phone number', async () => {
    const obj = {
      testProp: 'test',
      phone: {
        number: '+441612345000',
      },
    };
    const id = await collection.data.insert(obj);
    const res = await collection.data.insertMany([obj]);
    const obj1 = await collection.query.fetchObjectById(id, {
      returnProperties: ['phone'],
    });
    const obj2 = await collection.query.fetchObjectById(res.uuids[0], {
      returnProperties: ['phone'],
    });
    expect(obj1?.properties.phone?.input).toEqual('+441612345000');
    expect(obj2?.properties.phone?.input).toEqual('+441612345000');
  });

  it('should be able to verify that an object exists', async () => {
    const exists = await collection.data.exists(existingID);
    expect(exists).toBeTruthy();
  });
});

describe('Testing of the collection.data methods with a multi target reference', () => {
  let client: WeaviateClient;
  let collectionOne: Collection<TestCollectionDataMultiOne, 'TestCollectionDataMultiOne'>;
  let collectionTwo: Collection<TestCollectionDataMultiTwo, 'TestCollectionDataMultiTwo'>;

  const classNameOne = 'TestCollectionDataMultiOne';
  const classNameTwo = 'TestCollectionDataMultiTwo';

  type TestCollectionDataMultiOne = {
    one: string;
  };
  type TestCollectionDataMultiTwo = {
    two: string;
    refs: CrossReferences<[TestCollectionDataMultiOne, TestCollectionDataMultiTwo]>;
  };

  let oneId: string;
  let twoId: string;

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collectionOne = client.collections.get(classNameOne);
    collectionTwo = client.collections.get(classNameTwo);
    oneId = await client.collections
      .create({
        name: classNameOne,
        properties: [
          {
            name: 'one',
            dataType: 'text',
            tokenization: 'field',
          },
        ],
      })
      .then(() => collectionOne.data.insert({ one: 'one' }));
    twoId = await client.collections
      .create({
        name: classNameTwo,
        properties: [
          {
            name: 'two',
            dataType: 'text',
            tokenization: 'field',
          },
        ],
        references: [
          {
            name: 'refs',
            targetCollections: [classNameOne, classNameTwo],
          },
        ],
      })
      .then(() => collectionTwo.data.insert({ two: 'two' }));
  });

  afterAll(() => client.collections.deleteAll());

  it('should be able to insert an object with a multi target reference', async () => {
    const id = await collectionTwo.data.insert({
      properties: { two: 'multi1' },
      references: {
        refs: [
          Reference.toMultiTarget(oneId, classNameOne),
          { targetCollection: classNameTwo, uuids: twoId },
        ],
      },
    });
    await collectionTwo.data.insertMany([
      {
        properties: { two: 'multi2' },
        references: {
          refs: [
            Reference.toMultiTarget([twoId], classNameTwo),
            { targetCollection: classNameOne, uuids: [oneId] },
          ],
        },
      },
    ]);
    await collectionTwo.query
      .fetchObjectById(id, { returnReferences: [{ linkOn: 'refs', targetCollection: classNameOne }] })
      .then((obj) => expect(obj!.references!.refs.objects[0].uuid).toEqual(oneId));
    await collectionTwo.query
      .fetchObjectById(id, { returnReferences: [{ linkOn: 'refs', targetCollection: classNameTwo }] })
      .then((obj) => expect(obj!.references!.refs.objects[0].uuid).toEqual(twoId));
  });
});

describe('Testing of the collection.data.insertMany method with all possible types', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionData, 'TestCollectionData'>;
  const collectionName = 'TestCollectionData';
  let id: string;

  type Primitives = {
    text?: string;
    textArr?: string[];
    int?: number;
    intArr?: number[];
    number?: number;
    numberArr?: number[];
    bool?: boolean;
    boolArr?: boolean[];
    date?: Date;
    dateArr?: Date[];
  };

  type A = Primitives;

  type B = {
    child: A;
  };

  type TestCollectionData = Primitives & {
    self?: CrossReference<TestCollectionData>;
    geo?: GeoCoordinate;
    phone?: PhoneNumber;
    child?: A;
    children?: B[];
  };

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    const primitives = [
      {
        name: 'text' as const,
        dataType: 'text' as const,
      },
      {
        name: 'textArr' as const,
        dataType: 'text[]' as const,
      },
      {
        name: 'int' as const,
        dataType: 'int' as const,
      },
      {
        name: 'intArr' as const,
        dataType: 'int[]' as const,
      },
      {
        name: 'number' as const,
        dataType: 'number' as const,
      },
      {
        name: 'numberArr' as const,
        dataType: 'number[]' as const,
      },
      {
        name: 'bool' as const,
        dataType: 'boolean' as const,
      },
      {
        name: 'boolArr' as const,
        dataType: 'boolean[]' as const,
      },
      {
        name: 'date' as const,
        dataType: 'date' as const,
      },
      {
        name: 'dateArr' as const,
        dataType: 'date[]' as const,
      },
    ];
    collection = await client.collections.create({
      name: collectionName,
      properties: [
        ...primitives,
        {
          name: 'geo' as const,
          dataType: 'geoCoordinates' as const,
        },
        {
          name: 'phone' as const,
          dataType: 'phoneNumber' as const,
        },
        {
          name: 'child',
          dataType: 'object',
          nestedProperties: primitives,
        },
        {
          name: 'children',
          dataType: 'object[]',
          nestedProperties: [
            {
              name: 'child',
              dataType: 'object',
              nestedProperties: primitives,
            },
          ],
        },
      ],
      references: [
        {
          name: 'self',
          targetCollection: collectionName,
        },
      ],
    });
    id = await collection.data.insert();
  });

  it('should insert many objects with all possible types', async () => {
    const date1 = new Date();
    const date2 = new Date();
    const primitives = {
      text: 'text',
      textArr: ['textArr'],
      int: 1,
      intArr: [1],
      number: 1.1,
      numberArr: [1.1],
      bool: true,
      boolArr: [true],
      date: date1,
      dateArr: [date2],
    };
    const objects: DataObject<TestCollectionData>[] = [
      {
        properties: {
          ...primitives,
          geo: {
            latitude: 1,
            longitude: 1,
          },
          phone: {
            number: '+441612345000',
          },
          child: primitives,
          children: [{ child: primitives }],
        },
        references: {
          self: id,
        },
      },
    ];
    const insert = await collection.data.insertMany(objects);
    if (insert.hasErrors) console.error(JSON.stringify(insert.errors));
    expect(insert.hasErrors).toBeFalsy();
    expect(insert.allResponses.length).toEqual(1);
    expect(Object.values(insert.errors).length).toEqual(0);
    expect(Object.values(insert.uuids).length).toEqual(1);
    const obj = await collection.query.fetchObjectById(insert.uuids[0], {
      returnReferences: [{ linkOn: 'self' }],
    });
    expect(obj?.properties).toEqual({
      text: 'text',
      textArr: ['textArr'],
      int: 1,
      intArr: [1],
      number: 1.1,
      numberArr: [1.1],
      bool: true,
      boolArr: [true],
      date: date1,
      dateArr: [date2],
      geo: {
        latitude: 1,
        longitude: 1,
      },
      phone: {
        countryCode: 44,
        defaultCountry: '',
        input: '+441612345000',
        internationalFormatted: '+44 161 234 5000',
        national: 1612345000,
        nationalFormatted: '0161 234 5000',
        valid: true,
      },
      child: {
        text: 'text',
        textArr: ['textArr'],
        int: 1,
        intArr: [1],
        number: 1.1,
        numberArr: [1.1],
        bool: true,
        boolArr: [true],
        date: date1,
        dateArr: [date2],
      },
      children: [
        {
          child: {
            text: 'text',
            textArr: ['textArr'],
            int: 1,
            intArr: [1],
            number: 1.1,
            numberArr: [1.1],
            bool: true,
            boolArr: [true],
            date: date1,
            dateArr: [date2],
          },
        },
      ],
    });
    expect(obj?.references?.self?.objects[0].uuid).toEqual(id);
  });
});

describe('Testing of the collection.data methods with bring your own multi vectors', () => {
  let client: WeaviateClient;
  let collection: Collection;
  let uuid: string;
  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    const query = () =>
      client.collections.create({
        name: 'TestCollectionDataMultiVectors',
        properties: [
          {
            name: 'text',
            dataType: 'text',
          },
        ],
        vectorizers: [
          weaviate.configure.vectorizer.none({ name: 'one' }),
          weaviate.configure.vectorizer.none({ name: 'two' }),
        ],
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    collection = await query();
  });

  afterAll(() => client.collections.delete('TestCollectionDataMultiVectors'));

  it('should be able to insert an object with multi vectors', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      return;
    }
    uuid = await collection.data.insert({
      properties: {
        text: 'test',
      },
      vectors: {
        one: [1, 2, 3],
        two: [4, 5, 6],
      },
    });
  });

  it('should be able to fetch the object with multi vectors', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      return;
    }
    const obj = await collection.query.fetchObjectById(uuid, {
      includeVector: true,
    });
    expect(obj?.vectors?.one).toEqual([1, 2, 3]);
    expect(obj?.vectors?.two).toEqual([4, 5, 6]);
  });

  it('should be able to update the vectors of an object', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      return;
    }
    await collection.data.update({
      id: uuid,
      vectors: {
        one: [7, 8, 9],
        two: [10, 11, 12],
      },
    });
    const obj = await collection.query.fetchObjectById(uuid, {
      includeVector: true,
    });
    expect(obj?.vectors?.one).toEqual([7, 8, 9]);
    expect(obj?.vectors?.two).toEqual([10, 11, 12]);
  });

  it('should be able to replace the vectors of an object', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      return;
    }
    await collection.data.replace({
      id: uuid,
      vectors: {
        one: [7, 8, 9],
        two: [10, 11, 12],
      },
    });
    const obj = await collection.query.fetchObjectById(uuid, {
      includeVector: true,
    });
    expect(obj?.vectors?.one).toEqual([7, 8, 9]);
    expect(obj?.vectors?.two).toEqual([10, 11, 12]);
  });

  it('should be able to insert many objects with multi vectors', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      return;
    }
    const objects = [
      {
        properties: {
          text: 'test',
        },
        vectors: {
          one: [1, 2, 3],
          two: [4, 5, 6],
        },
      },
      {
        properties: {
          text: 'test',
        },
        vectors: {
          one: [7, 8, 9],
          two: [10, 11, 12],
        },
      },
    ];
    const insert = await collection.data.insertMany(objects);
    expect(insert.hasErrors).toBeFalsy();
    expect(insert.allResponses.length).toEqual(2);
    expect(Object.values(insert.errors).length).toEqual(0);
    expect(Object.values(insert.uuids).length).toEqual(2);
    const obj1 = await collection.query.fetchObjectById(insert.uuids[0], {
      includeVector: true,
    });
    expect(obj1?.vectors?.one).toEqual([1, 2, 3]);
    expect(obj1?.vectors?.two).toEqual([4, 5, 6]);
    const obj2 = await collection.query.fetchObjectById(insert.uuids[1], {
      includeVector: true,
    });
    expect(obj2?.vectors?.one).toEqual([7, 8, 9]);
    expect(obj2?.vectors?.two).toEqual([10, 11, 12]);
  });
});

describe('Testing of the collection.data methods with a vector index', () => {
  let client: WeaviateClient;
  let collection: Collection;
  let uuid: string;
  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = await client.collections.create({
      name: 'TestCollectionDataVectorizer',
      properties: [
        {
          name: 'text',
          dataType: 'text',
        },
      ],
      vectorizers: weaviate.configure.vectorizer.none(),
    });
  });

  afterAll(() => client.collections.delete('TestCollectionDataVectorizer'));

  it('should be able to insert an object with a vector without specifying the name', async () => {
    uuid = await collection.data.insert({
      properties: {
        text: 'test',
      },
      vectors: [1, 2, 3, 4],
    });
    const obj = await collection.query.fetchObjectById(uuid, {
      includeVector: true,
    });
    expect(obj?.vectors.default).toEqual([1, 2, 3, 4]);
  });

  it('should be able to update the vector of an object without specifying the name', async () => {
    await collection.data.update({
      id: uuid,
      vectors: [5, 6, 7, 8],
    });
    const obj = await collection.query.fetchObjectById(uuid, {
      includeVector: true,
    });
    expect(obj?.vectors.default).toEqual([5, 6, 7, 8]);
  });

  it('should be able to replace the vector of an object without specifying the name', async () => {
    await collection.data.replace({
      id: uuid,
      vectors: [9, 10, 11, 12],
    });
    const obj = await collection.query.fetchObjectById(uuid, {
      includeVector: true,
    });
    expect(obj?.vectors.default).toEqual([9, 10, 11, 12]);
  });

  it('should be able to insert many objects with a vector without specifying the name', async () => {
    const objects = [
      {
        properties: {
          text: 'test',
        },
        vectors: [1, 2, 3, 4],
      },
      {
        properties: {
          text: 'test',
        },
        vectors: [5, 6, 7, 8],
      },
    ];
    const insert = await collection.data.insertMany(objects);
    expect(insert.hasErrors).toBeFalsy();
    expect(insert.allResponses.length).toEqual(2);
    expect(Object.values(insert.errors).length).toEqual(0);
    expect(Object.values(insert.uuids).length).toEqual(2);
    const obj1 = await collection.query.fetchObjectById(insert.uuids[0], {
      includeVector: true,
    });
    expect(obj1?.vectors.default).toEqual([1, 2, 3, 4]);
    const obj2 = await collection.query.fetchObjectById(insert.uuids[1], {
      includeVector: true,
    });
    expect(obj2?.vectors.default).toEqual([5, 6, 7, 8]);
  });
});

describe('Testing of BYOV insertion with legacy vectorizer', () => {
  const collectionName = 'TestBYOVEdgeCase';
  const oldClient = weaviateV2.client({ scheme: 'http', host: 'localhost:8080' });

  beforeAll(() =>
    oldClient.schema
      .classCreator()
      .withClass({
        class: collectionName,
        vectorizer: 'none',
      })
      .do()
  );

  afterAll(() => oldClient.schema.classDeleter().withClassName(collectionName).do());

  it('should insert and retrieve many vectors using the new client', async () => {
    const client = await weaviate.connectToLocal();
    const collection = client.collections.get(collectionName);
    const { uuids, hasErrors } = await collection.data.insertMany([
      { vectors: [1, 2, 3] },
      { vectors: [4, 5, 6] },
    ]);
    expect(hasErrors).toBeFalsy();
    await collection.query
      .fetchObjectById(uuids[0], { includeVector: true })
      .then((res) => expect(res?.vectors.default).toEqual([1, 2, 3]));
    await collection.query
      .fetchObjectById(uuids[1], { includeVector: true })
      .then((res) => expect(res?.vectors.default).toEqual([4, 5, 6]));
  });

  it('should insert and retrieve single vectors using the new client', async () => {
    const client = await weaviate.connectToLocal();
    const collection = client.collections.get(collectionName);
    const id = await collection.data.insert({ vectors: [7, 8, 9] });
    const object = await collection.query.fetchObjectById(id, { includeVector: true });
    expect(object?.vectors.default).toEqual([7, 8, 9]);
  });
});



---
File: /src/collections/deserialize/index.ts
---

import { WeaviateDeserializationError } from '../../errors.js';
import { Tenant as TenantREST } from '../../openapi/types.js';
import { BatchObject as BatchObjectGRPC, BatchObjectsReply } from '../../proto/v1/batch.js';
import { BatchDeleteReply } from '../../proto/v1/batch_delete.js';
import { ListValue, Properties as PropertiesGrpc, Value } from '../../proto/v1/properties.js';
import { MetadataResult, PropertiesResult, SearchReply } from '../../proto/v1/search_get.js';
import { TenantActivityStatus, TenantsGetReply } from '../../proto/v1/tenants.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';
import { referenceFromObjects } from '../references/utils.js';
import { Tenant } from '../tenants/index.js';
import {
  BatchObject,
  BatchObjectsReturn,
  DeleteManyReturn,
  ErrorObject,
  GenerativeGroupByResult,
  GenerativeGroupByReturn,
  GenerativeReturn,
  GroupByObject,
  GroupByResult,
  GroupByReturn,
  Properties,
  ReturnMetadata,
  WeaviateReturn,
} from '../types/index.js';

export class Deserialize {
  private supports125ListValue: boolean;

  private constructor(supports125ListValue: boolean) {
    this.supports125ListValue = supports125ListValue;
  }

  public static async use(support: DbVersionSupport): Promise<Deserialize> {
    const supports125ListValue = await support.supports125ListValue().then((res) => res.supports);
    return new Deserialize(supports125ListValue);
  }

  public query<T>(reply: SearchReply): WeaviateReturn<T> {
    return {
      objects: reply.results.map((result) => {
        return {
          metadata: Deserialize.metadata(result.metadata),
          properties: this.properties(result.properties),
          references: this.references(result.properties),
          uuid: Deserialize.uuid(result.metadata),
          vectors: Deserialize.vectors(result.metadata),
        } as any;
      }),
    };
  }

  public generate<T>(reply: SearchReply): GenerativeReturn<T> {
    return {
      objects: reply.results.map((result) => {
        return {
          generated: result.metadata?.generativePresent ? result.metadata?.generative : undefined,
          metadata: Deserialize.metadata(result.metadata),
          properties: this.properties(result.properties),
          references: this.references(result.properties),
          uuid: Deserialize.uuid(result.metadata),
          vectors: Deserialize.vectors(result.metadata),
        } as any;
      }),
      generated: reply.generativeGroupedResult,
    };
  }

  public groupBy<T>(reply: SearchReply): GroupByReturn<T> {
    const objects: GroupByObject<T>[] = [];
    const groups: Record<string, GroupByResult<T>> = {};
    reply.groupByResults.forEach((result) => {
      const objs = result.objects.map((object) => {
        return {
          belongsToGroup: result.name,
          metadata: Deserialize.metadata(object.metadata),
          properties: this.properties(object.properties),
          references: this.references(object.properties),
          uuid: Deserialize.uuid(object.metadata),
          vectors: Deserialize.vectors(object.metadata),
        } as any;
      });
      groups[result.name] = {
        maxDistance: result.maxDistance,
        minDistance: result.minDistance,
        name: result.name,
        numberOfObjects: result.numberOfObjects,
        objects: objs,
      };
      objects.push(...objs);
    });
    return {
      objects: objects,
      groups: groups,
    };
  }

  public generateGroupBy<T>(reply: SearchReply): GenerativeGroupByReturn<T> {
    const objects: GroupByObject<T>[] = [];
    const groups: Record<string, GenerativeGroupByResult<T>> = {};
    reply.groupByResults.forEach((result) => {
      const objs = result.objects.map((object) => {
        return {
          belongsToGroup: result.name,
          metadata: Deserialize.metadata(object.metadata),
          properties: this.properties(object.properties),
          references: this.references(object.properties),
          uuid: Deserialize.uuid(object.metadata),
          vectors: Deserialize.vectors(object.metadata),
        } as any;
      });
      groups[result.name] = {
        maxDistance: result.maxDistance,
        minDistance: result.minDistance,
        name: result.name,
        numberOfObjects: result.numberOfObjects,
        objects: objs,
        generated: result.generative?.result,
      };
      objects.push(...objs);
    });
    return {
      objects: objects,
      groups: groups,
      generated: reply.generativeGroupedResult,
    };
  }

  private properties(properties?: PropertiesResult) {
    if (!properties) return {};
    return this.objectProperties(properties.nonRefProps);
  }

  private references(properties?: PropertiesResult) {
    if (!properties) return undefined;
    if (properties.refProps.length === 0) return properties.refPropsRequested ? {} : undefined;
    const out: any = {};
    properties.refProps.forEach((property) => {
      const uuids: string[] = [];
      out[property.propName] = referenceFromObjects(
        property.properties.map((property) => {
          const uuid = Deserialize.uuid(property.metadata);
          uuids.push(uuid);
          return {
            metadata: Deserialize.metadata(property.metadata),
            properties: this.properties(property),
            references: this.references(property),
            uuid: uuid,
            vectors: Deserialize.vectors(property.metadata),
          };
        }),
        property.properties.length > 0 ? property.properties[0].targetCollection : '',
        uuids
      );
    });
    return out;
  }

  private parsePropertyValue(value: Value): any {
    if (value.boolValue !== undefined) return value.boolValue;
    if (value.dateValue !== undefined) return new Date(value.dateValue);
    if (value.intValue !== undefined) return value.intValue;
    if (value.listValue !== undefined)
      return this.supports125ListValue
        ? this.parseListValue(value.listValue)
        : value.listValue.values.map((v) => this.parsePropertyValue(v));
    if (value.numberValue !== undefined) return value.numberValue;
    if (value.objectValue !== undefined) return this.objectProperties(value.objectValue);
    if (value.stringValue !== undefined) return value.stringValue;
    if (value.textValue !== undefined) return value.textValue;
    if (value.uuidValue !== undefined) return value.uuidValue;
    if (value.blobValue !== undefined) return value.blobValue;
    if (value.geoValue !== undefined) return value.geoValue;
    if (value.phoneValue !== undefined) return value.phoneValue;
    if (value.nullValue !== undefined) return undefined;
    throw new WeaviateDeserializationError(`Unknown value type: ${JSON.stringify(value, null, 2)}`);
  }

  private parseListValue(value: ListValue): string[] | number[] | boolean[] | Date[] | Properties[] {
    if (value.boolValues !== undefined) return value.boolValues.values;
    if (value.dateValues !== undefined) return value.dateValues.values.map((date) => new Date(date));
    if (value.intValues !== undefined) return Deserialize.intsFromBytes(value.intValues.values);
    if (value.numberValues !== undefined) return Deserialize.numbersFromBytes(value.numberValues.values);
    if (value.objectValues !== undefined)
      return value.objectValues.values.map((v) => this.objectProperties(v));
    if (value.textValues !== undefined) return value.textValues.values;
    if (value.uuidValues !== undefined) return value.uuidValues.values;
    throw new Error(`Unknown list value type: ${JSON.stringify(value, null, 2)}`);
  }

  private objectProperties(properties?: PropertiesGrpc): Properties {
    const out: Properties = {};
    if (properties) {
      Object.entries(properties.fields).forEach(([key, value]) => {
        out[key] = this.parsePropertyValue(value);
      });
    }
    return out;
  }

  private static metadata(metadata?: MetadataResult): ReturnMetadata | undefined {
    const out: ReturnMetadata = {};
    if (!metadata) return undefined;
    if (metadata.creationTimeUnixPresent) out.creationTime = new Date(metadata.creationTimeUnix);
    if (metadata.lastUpdateTimeUnixPresent) out.updateTime = new Date(metadata.lastUpdateTimeUnix);
    if (metadata.distancePresent) out.distance = metadata.distance;
    if (metadata.certaintyPresent) out.certainty = metadata.certainty;
    if (metadata.scorePresent) out.score = metadata.score;
    if (metadata.explainScorePresent) out.explainScore = metadata.explainScore;
    if (metadata.rerankScorePresent) out.rerankScore = metadata.rerankScore;
    if (metadata.isConsistent) out.isConsistent = metadata.isConsistent;
    return out;
  }

  private static uuid(metadata?: MetadataResult) {
    if (!metadata || !(metadata.id.length > 0))
      throw new WeaviateDeserializationError('No uuid returned from server');
    return metadata.id;
  }

  private static vectorFromBytes(bytes: Uint8Array) {
    const buffer = Buffer.from(bytes);
    const view = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 4); // vector is float32 in weaviate
    return Array.from(view);
  }

  private static intsFromBytes(bytes: Uint8Array) {
    const buffer = Buffer.from(bytes);
    const view = new BigInt64Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 8); // ints are float64 in weaviate
    return Array.from(view).map(Number);
  }

  private static numbersFromBytes(bytes: Uint8Array) {
    const buffer = Buffer.from(bytes);
    const view = new Float64Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 8); // numbers are float64 in weaviate
    return Array.from(view);
  }

  private static vectors(metadata?: MetadataResult): Record<string, number[]> {
    if (!metadata) return {};
    if (metadata.vectorBytes.length === 0 && metadata.vector.length === 0 && metadata.vectors.length === 0)
      return {};
    if (metadata.vectorBytes.length > 0)
      return { default: Deserialize.vectorFromBytes(metadata.vectorBytes) };
    return Object.fromEntries(
      metadata.vectors.map((vector) => [vector.name, Deserialize.vectorFromBytes(vector.vectorBytes)])
    );
  }

  public static batchObjects<T>(
    reply: BatchObjectsReply,
    originalObjs: BatchObject<T>[],
    mappedObjs: BatchObjectGRPC[],
    elapsed: number
  ): BatchObjectsReturn<T> {
    const allResponses = [];
    const errors: Record<number, ErrorObject<T>> = {};
    const successes: Record<number, string> = {};

    const batchErrors: Record<number, string> = {};
    reply.errors.forEach((error) => {
      batchErrors[error.index] = error.error;
    });

    for (const [index, object] of originalObjs.entries()) {
      if (index in batchErrors) {
        const error: ErrorObject<T> = {
          message: batchErrors[index],
          object: object,
          originalUuid: object.id,
        };
        errors[index] = error;
        allResponses[index] = error;
      } else {
        const mappedObj = mappedObjs[index];
        successes[index] = mappedObj.uuid;
        allResponses[index] = mappedObj.uuid;
      }
    }

    return {
      uuids: successes,
      errors: errors,
      hasErrors: reply.errors.length > 0,
      allResponses: allResponses,
      elapsedSeconds: elapsed,
    };
  }

  public static deleteMany<V extends boolean>(reply: BatchDeleteReply, verbose?: V): DeleteManyReturn<V> {
    return {
      ...reply,
      objects: verbose
        ? reply.objects.map((obj) => {
            return {
              id: obj.uuid.toString(),
              successful: obj.successful,
              error: obj.error,
            };
          })
        : (undefined as any),
    };
  }

  private static activityStatusGRPC(status: TenantActivityStatus): Tenant['activityStatus'] {
    switch (status) {
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_COLD:
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_INACTIVE:
        return 'INACTIVE';
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_HOT:
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_ACTIVE:
        return 'ACTIVE';
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_FROZEN:
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_OFFLOADED:
        return 'OFFLOADED';
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_FREEZING:
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_OFFLOADING:
        return 'OFFLOADING';
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_UNFREEZING:
      case TenantActivityStatus.TENANT_ACTIVITY_STATUS_ONLOADING:
        return 'ONLOADING';
      default:
        throw new Error(`Unsupported tenant activity status: ${status}`);
    }
  }

  public static activityStatusREST(status: TenantREST['activityStatus']): Tenant['activityStatus'] {
    switch (status) {
      case 'COLD':
        return 'INACTIVE';
      case 'HOT':
        return 'ACTIVE';
      case 'FROZEN':
        return 'OFFLOADED';
      case 'FREEZING':
        return 'OFFLOADING';
      case 'UNFREEZING':
        return 'ONLOADING';
      case undefined:
        return 'ACTIVE';
      default:
        return status;
    }
  }

  public static tenantsGet(reply: TenantsGetReply) {
    const tenants: Record<string, Tenant> = {};
    reply.tenants.forEach((t) => {
      tenants[t.name] = {
        name: t.name,
        activityStatus: Deserialize.activityStatusGRPC(t.activityStatus),
      };
    });
    return tenants;
  }
}



---
File: /src/collections/filters/classes.ts
---

import { WeaviateInvalidInputError } from '../../errors.js';
import {
  FilterReferenceCount,
  FilterReferenceMultiTarget,
  FilterReferenceSingleTarget,
  FilterTarget,
} from '../../proto/v1/base.js';
import { ExtractCrossReferenceType, NonRefKeys, RefKeys } from '../types/internal.js';
import {
  ContainsValue,
  CountRef,
  Filter,
  FilterByProperty,
  FilterTargetInternal,
  FilterValue,
  GeoRangeFilter,
  TargetRefs,
} from './types.js';
import { TargetGuards } from './utils.js';

/**
 * Use this class when you want to chain filters together using logical operators.
 *
 * Since JS/TS has no native support for & and | as logical operators, you must use these methods and nest
 * the filters you want to combine.
 *
 * ANDs and ORs can be nested an arbitrary number of times.
 *
 * @example
 * ```ts
 * const filter = Filters.and(
 *   collection.filter.byProperty('name').equal('John'),
 *   collection.filter.byProperty('age').greaterThan(18),
 * );
 * ```
 */
export class Filters {
  /**
   * Combine filters using the logical AND operator.
   *
   * @param {FilterValue[]} filters The filters to combine.
   */
  static and(...filters: FilterValue[]): FilterValue<null> {
    return {
      operator: 'And',
      filters: filters,
      value: null,
    };
  }
  /**
   * Combine filters using the logical OR operator.
   *
   * @param {FilterValue[]} filters The filters to combine.
   */
  static or(...filters: FilterValue[]): FilterValue<null> {
    return {
      operator: 'Or',
      filters: filters,
      value: null,
    };
  }
}

export class FilterBase {
  protected target?: TargetRefs;
  protected property: string | CountRef;

  constructor(property: string | CountRef, target?: TargetRefs) {
    this.property = property;
    this.target = target;
  }

  protected targetPath(): FilterTarget {
    if (!this.target) {
      return FilterTarget.fromPartial({
        property: TargetGuards.isProperty(this.property) ? this.property : undefined,
        count: TargetGuards.isCountRef(this.property)
          ? FilterReferenceCount.fromPartial({
              on: this.property.linkOn,
            })
          : undefined,
      });
    }

    let target = this.target;
    while (target.target !== undefined) {
      if (TargetGuards.isTargetRef(target.target)) {
        target = target.target;
      } else {
        throw new WeaviateInvalidInputError('Invalid target reference');
      }
    }
    target.target = this.property;
    return this.resolveTargets(this.target);
  }

  private resolveTargets(internal?: FilterTargetInternal): FilterTarget {
    return FilterTarget.fromPartial({
      property: TargetGuards.isProperty(internal) ? internal : undefined,
      singleTarget: TargetGuards.isSingleTargetRef(internal)
        ? FilterReferenceSingleTarget.fromPartial({
            on: internal.linkOn,
            target: this.resolveTargets(internal.target),
          })
        : undefined,
      multiTarget: TargetGuards.isMultiTargetRef(internal)
        ? FilterReferenceMultiTarget.fromPartial({
            on: internal.linkOn,
            targetCollection: internal.targetCollection,
            target: this.resolveTargets(internal.target),
          })
        : undefined,
      count: TargetGuards.isCountRef(internal)
        ? FilterReferenceCount.fromPartial({
            on: internal.linkOn,
          })
        : undefined,
    });
  }
}

export class FilterProperty<V> extends FilterBase implements FilterByProperty<V> {
  constructor(property: string, length: boolean, target?: TargetRefs) {
    super(length ? `len(${property})` : property, target);
  }

  public isNull(value: boolean): FilterValue<boolean> {
    return {
      operator: 'IsNull',
      target: this.targetPath(),
      value: value,
    };
  }

  public containsAny<U extends ContainsValue<V>>(value: U[]): FilterValue<U[]> {
    return {
      operator: 'ContainsAny',
      target: this.targetPath(),
      value: value,
    };
  }

  public containsAll<U extends ContainsValue<V>>(value: U[]): FilterValue<U[]> {
    return {
      operator: 'ContainsAll',
      target: this.targetPath(),
      value: value,
    };
  }

  public equal(value: V): FilterValue<V> {
    return {
      operator: 'Equal',
      target: this.targetPath(),
      value: value,
    };
  }

  public notEqual(value: V): FilterValue<V> {
    return {
      operator: 'NotEqual',
      target: this.targetPath(),
      value: value,
    };
  }

  public lessThan<U extends number | Date>(value: U): FilterValue<U> {
    return {
      operator: 'LessThan',
      target: this.targetPath(),
      value: value,
    };
  }

  public lessOrEqual<U extends number | Date>(value: U): FilterValue<U> {
    return {
      operator: 'LessThanEqual',
      target: this.targetPath(),
      value: value,
    };
  }

  public greaterThan<U extends number | Date>(value: U): FilterValue<U> {
    return {
      operator: 'GreaterThan',
      target: this.targetPath(),
      value: value,
    };
  }

  public greaterOrEqual<U extends number | Date>(value: U): FilterValue<U> {
    return {
      operator: 'GreaterThanEqual',
      target: this.targetPath(),
      value: value,
    };
  }

  public like(value: string): FilterValue<string> {
    return {
      operator: 'Like',
      target: this.targetPath(),
      value: value,
    };
  }

  public withinGeoRange(value: GeoRangeFilter): FilterValue<GeoRangeFilter> {
    return {
      operator: 'WithinGeoRange',
      target: this.targetPath(),
      value: value,
    };
  }
}

export class FilterRef<T> implements Filter<T> {
  private target: TargetRefs;

  constructor(target: TargetRefs) {
    this.target = target;
  }

  public byRef<K extends RefKeys<T> & string>(linkOn: K): Filter<ExtractCrossReferenceType<T[K]>> {
    this.target.target = { type_: 'single', linkOn: linkOn };
    return new FilterRef<ExtractCrossReferenceType<T[K]>>(this.target);
  }

  public byRefMultiTarget<K extends RefKeys<T> & string>(linkOn: K, targetCollection: string) {
    this.target.target = { type_: 'multi', linkOn: linkOn, targetCollection: targetCollection };
    return new FilterRef<ExtractCrossReferenceType<T[K]>>(this.target);
  }

  public byProperty<K extends NonRefKeys<T> & string>(name: K, length = false) {
    return new FilterProperty<T[K]>(name, length, this.target);
  }

  public byRefCount<K extends RefKeys<T> & string>(linkOn: K) {
    return new FilterCount(linkOn, this.target);
  }

  public byId() {
    return new FilterId(this.target);
  }

  public byCreationTime() {
    return new FilterCreationTime(this.target);
  }

  public byUpdateTime() {
    return new FilterUpdateTime(this.target);
  }
}

export class FilterCount extends FilterBase {
  constructor(linkOn: string, target?: TargetRefs) {
    super({ type_: 'count', linkOn }, target);
  }

  public equal(value: number): FilterValue<number> {
    return {
      operator: 'Equal',
      target: this.targetPath(),
      value: value,
    };
  }

  public notEqual(value: number): FilterValue<number> {
    return {
      operator: 'NotEqual',
      target: this.targetPath(),
      value: value,
    };
  }

  public lessThan(value: number): FilterValue<number> {
    return {
      operator: 'LessThan',
      target: this.targetPath(),
      value: value,
    };
  }

  public lessOrEqual(value: number): FilterValue<number> {
    return {
      operator: 'LessThanEqual',
      target: this.targetPath(),
      value: value,
    };
  }

  public greaterThan(value: number): FilterValue<number> {
    return {
      operator: 'GreaterThan',
      target: this.targetPath(),
      value: value,
    };
  }

  public greaterOrEqual(value: number): FilterValue<number> {
    return {
      operator: 'GreaterThanEqual',
      target: this.targetPath(),
      value: value,
    };
  }
}

export class FilterId extends FilterBase {
  constructor(target?: TargetRefs) {
    super('_id', target);
  }

  public equal(value: string): FilterValue<string> {
    return {
      operator: 'Equal',
      target: this.targetPath(),
      value: value,
    };
  }

  public notEqual(value: string): FilterValue<string> {
    return {
      operator: 'NotEqual',
      target: this.targetPath(),
      value: value,
    };
  }

  public containsAny(value: string[]): FilterValue<string[]> {
    return {
      operator: 'ContainsAny',
      target: this.targetPath(),
      value: value,
    };
  }
}

export class FilterTime extends FilterBase {
  public containsAny(value: (string | Date)[]): FilterValue<string[]> {
    return {
      operator: 'ContainsAny',
      target: this.targetPath(),
      value: value.map(this.toValue),
    };
  }

  public equal(value: string | Date): FilterValue<string> {
    return {
      operator: 'Equal',
      target: this.targetPath(),
      value: this.toValue(value),
    };
  }

  public notEqual(value: string | Date): FilterValue<string> {
    return {
      operator: 'NotEqual',
      target: this.targetPath(),
      value: this.toValue(value),
    };
  }

  public lessThan(value: string | Date): FilterValue<string> {
    return {
      operator: 'LessThan',
      target: this.targetPath(),
      value: this.toValue(value),
    };
  }

  public lessOrEqual(value: string | Date): FilterValue<string> {
    return {
      operator: 'LessThanEqual',
      target: this.targetPath(),
      value: this.toValue(value),
    };
  }

  public greaterThan(value: string | Date): FilterValue<string> {
    return {
      operator: 'GreaterThan',
      target: this.targetPath(),
      value: this.toValue(value),
    };
  }

  public greaterOrEqual(value: string | Date): FilterValue<string> {
    return {
      operator: 'GreaterThanEqual',
      target: this.targetPath(),
      value: this.toValue(value),
    };
  }

  private toValue(value: string | Date): string {
    return value instanceof Date ? value.toISOString() : value;
  }
}

export class FilterCreationTime extends FilterTime {
  constructor(target?: TargetRefs) {
    super('_creationTimeUnix', target);
  }
}

export class FilterUpdateTime extends FilterTime {
  constructor(target?: TargetRefs) {
    super('_lastUpdateTimeUnix', target);
  }
}



---
File: /src/collections/filters/index.ts
---

export { Filters } from './classes.js';
export type {
  Filter,
  FilterByCount,
  FilterById,
  FilterByProperty,
  FilterByTime,
  FilterValue,
  GeoRangeFilter,
  Operator,
} from './types.js';

import { ExtractCrossReferenceType, NonRefKeys, RefKeys } from '../types/internal.js';

import {
  FilterCount,
  FilterCreationTime,
  FilterId,
  FilterProperty,
  FilterRef,
  FilterUpdateTime,
} from './classes.js';
import { Filter } from './types.js';

const filter = <T>(): Filter<T> => {
  return {
    byProperty: <K extends NonRefKeys<T> & string>(name: K, length = false) => {
      return new FilterProperty<T[K]>(name, length);
    },
    byRef: <K extends RefKeys<T> & string>(linkOn: K) => {
      return new FilterRef<ExtractCrossReferenceType<T[K]>>({ type_: 'single', linkOn: linkOn });
    },
    byRefMultiTarget: <K extends RefKeys<T> & string>(linkOn: K, targetCollection: string) => {
      return new FilterRef<ExtractCrossReferenceType<T[K]>>({
        type_: 'multi',
        linkOn: linkOn,
        targetCollection: targetCollection,
      });
    },
    byRefCount: <K extends RefKeys<T> & string>(linkOn: K) => {
      return new FilterCount(linkOn);
    },
    byId: () => {
      return new FilterId();
    },
    byCreationTime: () => {
      return new FilterCreationTime();
    },
    byUpdateTime: () => {
      return new FilterUpdateTime();
    },
  };
};

export default filter;



---
File: /src/collections/filters/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
import weaviate, { WeaviateClient } from '../../index.js';
import { Collection } from '../collection/index.js';
import { CrossReference, Reference } from '../references/index.js';
import { GeoCoordinate } from '../types/index.js';
import { Filters } from './index.js';

describe('Testing of the filter class with a simple collection', () => {
  let client: WeaviateClient;
  let collection: Collection<TestType, 'TestCollectionFilterSimple'>;

  const collectionName = 'TestCollectionFilterSimple';
  let ids: string[];
  let vector: number[];

  type TestType = {
    text: string;
    int: number;
    float: number;
    self?: CrossReference<TestType>;
  };

  const startTime = new Date();

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    ids = await client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'text',
            dataType: 'text',
          },
          {
            name: 'int',
            dataType: 'int',
          },
          {
            name: 'float',
            dataType: 'number',
          },
        ],
        references: [
          {
            name: 'self',
            targetCollection: collectionName,
          },
        ],
        invertedIndex: weaviate.configure.invertedIndex({ indexTimestamps: true }),
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary({
          vectorizeCollectionName: false,
        }),
      })
      .then(() =>
        collection.data.insertMany([
          {
            text: 'one',
            int: 1,
            float: 1.1,
          },
          {
            text: 'two',
            int: 2,
            float: 2.2,
          },
          {
            text: 'three',
            int: 3,
            float: 3.3,
          },
          {
            text: 'one',
            int: 4,
            float: 4.4,
          },
        ])
      )
      .then(async (res) => {
        const uuids = Object.values(res.uuids);
        await collection.data.referenceAdd({
          fromUuid: res.uuids[2],
          fromProperty: 'self',
          to: Reference.to(uuids[3]),
        });
        return uuids;
      });
    const res = await collection.query.fetchObjectById(ids[0], { includeVector: true });
    vector = res?.vectors.default!;
  });

  it('should filter a fetch objects query with a single filter and generic collection', async () => {
    const res = await collection.query.fetchObjects({
      filters: collection.filter.byProperty('text').equal('two'),
    });
    expect(res.objects.length).toEqual(1);
    const obj = res.objects[0];
    expect(obj.properties.text).toEqual('two');
    expect(obj.properties.int).toEqual(2);
    expect(obj.properties.float).toEqual(2.2);
    expect(obj.uuid).toEqual(ids[1]);
  });

  it('should filter a fetch objects query with a single filter and non-generic collection', async () => {
    const res = await client.collections.get(collectionName).query.fetchObjects({
      filters: client.collections.get(collectionName).filter.byProperty('text').equal('two'),
    });
    expect(res.objects.length).toEqual(1);
    const obj = res.objects[0];
    expect(obj.properties.text).toEqual('two');
    expect(obj.properties.int).toEqual(2);
    expect(obj.properties.float).toEqual(2.2);
    expect(obj.uuid).toEqual(ids[1]);
  });

  it('should filter a fetch objects query with an AND filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: Filters.and(
        collection.filter.byProperty('text').equal('one'),
        collection.filter.byProperty('int').equal(1)
      ),
    });
    expect(res.objects.length).toEqual(1);
    const obj = res.objects[0];
    expect(obj.properties.text).toEqual('one');
    expect(obj.properties.int).toEqual(1);
    expect(obj.properties.float).toEqual(1.1);
    expect(obj.uuid).toEqual(ids[0]);
  });

  it('should filter a fetch objects query with an OR filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: Filters.or(
        collection.filter.byProperty('text').equal('three'),
        collection.filter.byProperty('int').equal(2)
      ),
    });
    expect(res.objects.length).toEqual(2);

    // Return of fetch not necessarily in order due to filter
    expect(res.objects.map((o) => o.properties.text)).toContain('two');
    expect(res.objects.map((o) => o.properties.text)).toContain('three');

    expect(res.objects.map((o) => o.properties.int)).toContain(2);
    expect(res.objects.map((o) => o.properties.int)).toContain(3);

    expect(res.objects.map((o) => o.properties.float)).toContain(2.2);
    expect(res.objects.map((o) => o.properties.float)).toContain(3.3);

    expect(res.objects.map((o) => o.uuid)).toContain(ids[1]);
    expect(res.objects.map((o) => o.uuid)).toContain(ids[2]);
  });

  it('should filter a fetch objects query with a reference filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: collection.filter.byRef('self').byProperty('text').equal('one'),
    });
    expect(res.objects.length).toEqual(1);
    const obj = res.objects[0];
    expect(obj.properties.text).toEqual('three');
    expect(obj.properties.int).toEqual(3);
    expect(obj.properties.float).toEqual(3.3);
    expect(obj.uuid).toEqual(ids[2]);
  });

  it('should filter a fetch objects query with a greater than reference count filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: collection.filter.byRefCount('self').greaterThan(0),
    });
    expect(res.objects.length).toEqual(1);
    const obj = res.objects[0];
    expect(obj.properties.text).toEqual('three');
    expect(obj.properties.int).toEqual(3);
    expect(obj.properties.float).toEqual(3.3);
    expect(obj.uuid).toEqual(ids[2]);
  });

  it('should filter a fetch objects query with a greater than or equal reference count filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: collection.filter.byRefCount('self').greaterOrEqual(1),
    });
    expect(res.objects.length).toEqual(1);
    const obj = res.objects[0];
    expect(obj.properties.text).toEqual('three');
    expect(obj.properties.int).toEqual(3);
    expect(obj.properties.float).toEqual(3.3);
    expect(obj.uuid).toEqual(ids[2]);
  });

  it('should filter a fetch objects query with an equal reference count filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: collection.filter.byRefCount('self').equal(1),
    });
    expect(res.objects.length).toEqual(1);
    const obj = res.objects[0];
    expect(obj.properties.text).toEqual('three');
    expect(obj.properties.int).toEqual(3);
    expect(obj.properties.float).toEqual(3.3);
    expect(obj.uuid).toEqual(ids[2]);
  });

  it('should filter a fetch objects query with an equal ID filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: collection.filter.byId().equal(ids[0]),
    });
    expect(res.objects.length).toEqual(1);
    const obj = res.objects[0];
    expect(obj.properties.text).toEqual('one');
    expect(obj.properties.int).toEqual(1);
    expect(obj.properties.float).toEqual(1.1);
    expect(obj.uuid).toEqual(ids[0]);
  });

  it('should filter a fetch objects query with a less than creation time filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: collection.filter.byCreationTime().lessThan(startTime),
    });
    expect(res.objects.length).toEqual(0);
  });

  it('should filter a fetch objects query with a greater than last updated time filter', async () => {
    const now = new Date();
    const vec = Array.from({ length: 300 }, () => Math.floor(Math.random() * 10));
    await collection.data
      .update({
        id: ids[0],
        vectors: vec,
      })
      .then(async () => {
        const res = await collection.query.fetchObjects({
          filters: collection.filter.byUpdateTime().greaterOrEqual(now),
          includeVector: true,
        });
        expect(res.objects.length).toEqual(1);
        const obj = res.objects[0];
        expect(obj.properties.text).toEqual('one');
        expect(obj.properties.int).toEqual(1);
        expect(obj.properties.float).toEqual(1.1);
        expect(obj.uuid).toEqual(ids[0]);
        expect(obj.vectors.default).toEqual(vec);
      });
  });

  it('should filter an aggregate query with a single filter', async () => {
    const res = await collection.aggregate.overAll({
      filters: collection.filter.byProperty('text').equal('one'),
      returnMetrics: collection.metrics.aggregate('text').text(['count']),
    });
    expect(res.properties.text.count).toEqual(2);
  });

  it('should filter an aggregate query with an AND filter', async () => {
    const res = await collection.aggregate.overAll({
      filters: Filters.and(
        collection.filter.byProperty('text').equal('one'),
        collection.filter.byProperty('int').equal(1)
      ),
      returnMetrics: collection.metrics.aggregate('text').text(['count']),
    });
    expect(res.properties.text.count).toEqual(1);
  });

  it('should filter an aggregate query with an OR filter', async () => {
    const res = await collection.aggregate.overAll({
      filters: Filters.or(
        collection.filter.byProperty('text').equal('one'),
        collection.filter.byProperty('int').equal(2)
      ),
      returnMetrics: collection.metrics.aggregate('text').text(['count']),
    });
    expect(res.properties.text.count).toEqual(3);
  });
});

describe('Testing of the filter class with complex data types', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionFilterComplex, 'TestCollectionFilterComplex'>;

  const collectionName = 'TestCollectionFilterComplex';
  type TestCollectionFilterComplex = {
    name: string;
    location: GeoCoordinate;
    date?: Date;
    personId: string;
  };

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    await client.collections
      .create<TestCollectionFilterComplex>({
        name: collectionName,
        invertedIndex: {
          indexNullState: true,
        },
        properties: [
          {
            name: 'name',
            dataType: 'text',
          },
          {
            name: 'location',
            dataType: 'geoCoordinates',
          },
          {
            name: 'date',
            dataType: 'date',
          },
          {
            name: 'personId',
            dataType: 'uuid',
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary(),
      })
      .then(() =>
        collection.data.insertMany([
          {
            name: 'Tim',
            location: {
              latitude: 52.52,
              longitude: 13.405,
            },
            date: new Date('2021-01-01T00:00:00Z'),
            personId: '00000000-0000-0000-0000-000000000000',
          },
          {
            name: 'Tom',
            location: {
              latitude: 53.55,
              longitude: 10.0,
            },
            personId: '00000000-0000-0000-0000-000000000001',
          },
        ])
      );
  });

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  it('should filter a fetch objects query with a geo filter', async () => {
    const res = await collection.query.fetchObjects({
      filters: collection.filter.byProperty('location').withinGeoRange({
        latitude: 52.52,
        longitude: 13.405,
        distance: 1,
      }),
    });
    expect(res.objects.length).toEqual(1);
  });

  it('should filter a fetch objects query with a date filter', async () => {
    const res = await collection.query.nearText(['Tom'], {
      filters: Filters.and(
        collection.filter.byProperty('date').isNull(true),
        collection.filter.byProperty('personId').equal('00000000-0000-0000-0000-000000000001')
      ),
    });
    expect(res.objects.length).toEqual(1);
    expect(res.objects[0].properties.name).toEqual('Tom');
  });
});



---
File: /src/collections/filters/types.ts
---

import { FilterTarget } from '../../proto/v1/base.js';
import { ExtractCrossReferenceType, NonRefKeys, RefKeys } from '../types/internal.js';

export type Operator =
  | 'Equal'
  | 'NotEqual'
  | 'GreaterThan'
  | 'GreaterThanEqual'
  | 'LessThan'
  | 'LessThanEqual'
  | 'Like'
  | 'IsNull'
  | 'WithinGeoRange'
  | 'ContainsAny'
  | 'ContainsAll'
  | 'And'
  | 'Or';

export type FilterValue<V = any> = {
  filters?: FilterValue[];
  operator: Operator;
  target?: FilterTarget;
  value: V;
};

export type SingleTargetRef = {
  type_: 'single';
  linkOn: string;
  target?: FilterTargetInternal;
};

export type MultiTargetRef = {
  type_: 'multi';
  linkOn: string;
  targetCollection: string;
  target?: FilterTargetInternal;
};

export type CountRef = {
  type_: 'count';
  linkOn: string;
};

export type FilterTargetInternal = SingleTargetRef | MultiTargetRef | CountRef | string;
export type TargetRefs = SingleTargetRef | MultiTargetRef;

export type GeoRangeFilter = {
  latitude: number;
  longitude: number;
  distance: number;
};

export type FilterValueType = PrimitiveFilterValueType | PrimitiveListFilterValueType;

export type PrimitiveFilterValueType = number | string | boolean | Date | GeoRangeFilter;
export type PrimitiveListFilterValueType = number[] | string[] | boolean[] | Date[];

export type ContainsValue<V> = V extends (infer U)[] ? U : V;

export interface Filter<T> {
  /**
   * Define a filter based on a property to be used when querying and deleting from a collection.
   *
   * @param {K} name The name of the property to filter on.
   * @param {boolean} [length] Whether to filter on the length of the property or not, defaults to false.
   * @returns {FilterByProperty<T[K]>} An interface exposing methods to filter on the property.
   */
  byProperty: <K extends NonRefKeys<T> & string>(name: K, length?: boolean) => FilterByProperty<T[K]>;
  /**
   * Define a filter based on a single-target reference to be used when querying and deleting from a collection.
   *
   * @param {K} linkOn The name of the property to filter on.
   * @returns {Filter<ExtractCrossReferenceType<T[K]>>} An interface exposing methods to filter on the reference.
   */
  byRef: <K extends RefKeys<T> & string>(linkOn: K) => Filter<ExtractCrossReferenceType<T[K]>>;
  /**
   * Define a filter based on a multi-target reference to be used when querying and deleting from a collection.
   *
   * @param {K} linkOn The name of the property to filter on.
   * @param {string} targetCollection The name of the target collection to filter on.
   * @returns {Filter<ExtractCrossReferenceType<T[K]>>} An interface exposing methods to filter on the reference.
   */
  byRefMultiTarget: <K extends RefKeys<T> & string>(
    linkOn: K,
    targetCollection: string
  ) => Filter<ExtractCrossReferenceType<T[K]>>;
  /**
   * Define a filter based on the number of objects in a cross-reference to be used when querying and deleting from a collection.
   *
   * @param {K} linkOn The name of the property to filter on.
   * @returns {FilterByCount} An interface exposing methods to filter on the count.
   */
  byRefCount: <K extends RefKeys<T> & string>(linkOn: K) => FilterByCount;
  /**
   * Define a filter based on the ID to be used when querying and deleting from a collection.
   *
   * @returns {FilterById} An interface exposing methods to filter on the ID.
   */
  byId: () => FilterById;
  /**
   * Define a filter based on the creation time to be used when querying and deleting from a collection.
   *
   * @returns {FilterByTime} An interface exposing methods to filter on the creation time.
   */
  byCreationTime: () => FilterByTime;
  /**
   * Define a filter based on the update time to be used when querying and deleting from a collection.
   *
   * @returns {FilterByTime} An interface exposing methods to filter on the update time.
   */
  byUpdateTime: () => FilterByTime;
}

export interface FilterByProperty<T> {
  /**
   * Filter on whether the property is `null`.
   *
   * @param {boolean} value The value to filter on.
   * @returns {FilterValue<boolean>} The filter value.
   */
  isNull: (value: boolean) => FilterValue<boolean>;
  /**
   * Filter on whether the property contains any of the given values.
   *
   * @param {U[]} value The values to filter on.
   * @returns {FilterValue<U[]>} The filter value.
   */
  containsAny: <U extends ContainsValue<T>>(value: U[]) => FilterValue<U[]>;
  /**
   * Filter on whether the property contains all of the given values.
   *
   * @param {U[]} value The values to filter on.
   * @returns {FilterValue<U[]>} The filter value.
   */
  containsAll: <U extends ContainsValue<T>>(value: U[]) => FilterValue<U[]>;
  /**
   * Filter on whether the property is equal to the given value.
   *
   * @param {V} value The value to filter on.
   * @returns {FilterValue<V>} The filter value.
   */
  equal: (value: T) => FilterValue<T>;
  /**
   * Filter on whether the property is not equal to the given value.
   *
   * @param {V} value The value to filter on.
   * @returns {FilterValue<V>} The filter value.
   * */
  notEqual: (value: T) => FilterValue<T>;
  /**
   * Filter on whether the property is less than the given value.
   *
   * @param {number | Date} value The value to filter on.
   * @returns {FilterValue<number> | FilterValue<Date>} The filter value.
   */
  lessThan: <U extends number | Date>(value: U) => FilterValue<U>;
  /**
   * Filter on whether the property is less than or equal to the given value.
   *
   * @param {number | Date} value The value to filter on.
   * @returns {FilterValue<number> | FilterValue<Date>} The filter value.
   */
  lessOrEqual: <U extends number | Date>(value: U) => FilterValue<U>;
  /**
   * Filter on whether the property is greater than the given value.
   *
   * @param {number | Date} value The value to filter on.
   * @returns {FilterValue<number> | FilterValue<Date>} The filter value.
   */
  greaterThan: <U extends number | Date>(value: U) => FilterValue<U>;
  /**
   * Filter on whether the property is greater than or equal to the given value.
   *
   * @param {number | Date} value The value to filter on.
   * @returns {FilterValue<number> | FilterValue<Date>} The filter value.
   */
  greaterOrEqual: <U extends number | Date>(value: U) => FilterValue<U>;
  /**
   * Filter on whether the property is like the given value.
   *
   * This filter can make use of `*` and `?` as wildcards.
   * See [the docs](https://weaviate.io/developers/weaviate/search/filters#by-partial-matches-text) for more details.
   *
   * @param {string} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  like: (value: string) => FilterValue<string>;
  /**
   * Filter on whether the property is within a given range of a geo-coordinate.
   *
   * See [the docs](https://weaviate.io/developers/weaviate/search/filters##by-geo-coordinates) for more details.
   *
   * @param {GeoRangeFilter} value The geo-coordinate range to filter on.
   * @returns {FilterValue<GeoRangeFilter>} The filter value.
   */
  withinGeoRange: (value: GeoRangeFilter) => FilterValue<GeoRangeFilter>;
}

export interface FilterByCount {
  /**
   * Filter on whether the number of references is equal to the given integer.
   *
   * @param {number} value The value to filter on.
   * @returns {FilterValue<number>} The filter value.
   */
  equal: (value: number) => FilterValue<number>;
  /**
   * Filter on whether the number of references is not equal to the given integer.
   *
   * @param {number} value The value to filter on.
   * @returns {FilterValue<number>} The filter value.
   */
  notEqual: (value: number) => FilterValue<number>;
  /**
   * Filter on whether the number of references is less than the given integer.
   *
   * @param {number} value The value to filter on.
   * @returns {FilterValue<number>} The filter value.
   */
  lessThan: (value: number) => FilterValue<number>;
  /**
   * Filter on whether the number of references is less than or equal to the given integer.
   *
   * @param {number} value The value to filter on.
   * @returns {FilterValue<number>} The filter value.
   */
  lessOrEqual: (value: number) => FilterValue<number>;
  /**
   * Filter on whether the number of references is greater than the given integer.
   *
   * @param {number} value The value to filter on.
   * @returns {FilterValue<number>} The filter value.
   */
  greaterThan: (value: number) => FilterValue<number>;
  /**
   * Filter on whether the number of references is greater than or equal to the given integer.
   *
   * @param {number} value The value to filter on.
   * @returns {FilterValue<number>} The filter value.
   */
  greaterOrEqual: (value: number) => FilterValue<number>;
}

export interface FilterById {
  /**
   * Filter on whether the ID is equal to the given string.
   *
   * @param {string} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  equal: (value: string) => FilterValue<string>;
  /**
   * Filter on whether the ID is not equal to the given string.
   *
   * @param {string} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  notEqual: (value: string) => FilterValue<string>;
  /**
   * Filter on whether the ID is any one of the given strings.
   *
   * @param {string[]} value The values to filter on.
   * @returns {FilterValue<string[]>} The filter value.
   */
  containsAny: (value: string[]) => FilterValue<string[]>;
}

export interface FilterByTime {
  /**
   * Filter on whether the time is any one of the given strings or Dates.
   *
   * @param {(string | Date)[]} value The values to filter on.
   * @returns {FilterValue<string[]>} The filter value.
   */
  containsAny: (value: (string | Date)[]) => FilterValue<string[]>;
  /**
   * Filter on whether the time is equal to the given string or Date.
   *
   * @param {string | Date} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  equal: (value: string | Date) => FilterValue<string>;
  /**
   * Filter on whether the time is not equal to the given string or Date.
   *
   * @param {string | Date} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  notEqual: (value: string | Date) => FilterValue<string>;
  /**
   * Filter on whether the time is less than the given string or Date.
   *
   * @param {string | Date} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  lessThan: (value: string | Date) => FilterValue<string>;
  /**
   * Filter on whether the time is less than or equal to the given string or Date.
   *
   * @param {string | Date} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  lessOrEqual: (value: string | Date) => FilterValue<string>;
  /**
   * Filter on whether the time is greater than the given string or Date.
   *
   * @param {string | Date} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  greaterThan: (value: string | Date) => FilterValue<string>;
  /**
   * Filter on whether the time is greater than or equal to the given string or Date.
   *
   * @param {string | Date} value The value to filter on.
   * @returns {FilterValue<string>} The filter value.
   */
  greaterOrEqual: (value: string | Date) => FilterValue<string>;
}



---
File: /src/collections/filters/unit.test.ts
---

import { WhereFilter } from '../../openapi/types.js';
import { CrossReference } from '../references/index.js';
import { Serialize } from '../serialize/index.js';
import maker, { FilterValue, Filters } from './index.js';
import { GeoRangeFilter } from './types.js';

describe('Unit testing of filters', () => {
  type Person = {
    name: string;
    age: number;
    friends: string[];
    self: CrossReference<Person>;
  };
  const filter = maker<Person>();

  describe('for properties', () => {
    it('should create an is null filter', () => {
      const f = filter.byProperty('name').isNull(true);
      expect(f).toEqual<FilterValue<boolean>>({
        operator: 'IsNull',
        target: {
          property: 'name',
        },
        value: true,
      });
    });

    it('should create a contains all filter with a primitive type', () => {
      const f = filter.byProperty('name').containsAll(['John', 'Doe']);
      expect(f).toEqual<FilterValue<string[]>>({
        operator: 'ContainsAll',
        target: {
          property: 'name',
        },
        value: ['John', 'Doe'],
      });
    });

    it('should create a contains all filter with an array type', () => {
      const f = filter.byProperty('friends').containsAll(['John', 'Doe']);
      expect(f).toEqual<FilterValue<string[]>>({
        operator: 'ContainsAll',
        target: {
          property: 'friends',
        },
        value: ['John', 'Doe'],
      });
    });

    it('should create a contains any filter with a primitive type', () => {
      const f = filter.byProperty('name').containsAny(['John', 'Doe']);
      expect(f).toEqual<FilterValue<string[]>>({
        operator: 'ContainsAny',
        target: {
          property: 'name',
        },
        value: ['John', 'Doe'],
      });
    });

    it('should create a contains any filter with an array type', () => {
      const f = filter.byProperty('friends').containsAny(['John', 'Doe']);
      expect(f).toEqual<FilterValue<string[]>>({
        operator: 'ContainsAny',
        target: {
          property: 'friends',
        },
        value: ['John', 'Doe'],
      });
    });

    it('should create an equal filter', () => {
      const f = filter.byProperty('name').equal('John');
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          property: 'name',
        },
        value: 'John',
      });
    });

    it('should create an not equal filter', () => {
      const f = filter.byProperty('name').notEqual('John');
      expect(f).toEqual<FilterValue<string>>({
        operator: 'NotEqual',
        target: {
          property: 'name',
        },
        value: 'John',
      });
    });

    it('should create a less than filter', () => {
      const f = filter.byProperty('age').lessThan(18);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'LessThan',
        target: {
          property: 'age',
        },
        value: 18,
      });
    });

    it('should create a less than or equal filter', () => {
      const f = filter.byProperty('age').lessOrEqual(18);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'LessThanEqual',
        target: {
          property: 'age',
        },
        value: 18,
      });
    });

    it('should create a greater than filter', () => {
      const f = filter.byProperty('age').greaterThan(18);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'GreaterThan',
        target: {
          property: 'age',
        },
        value: 18,
      });
    });

    it('should create a greater than or equal filter', () => {
      const f = filter.byProperty('age').greaterOrEqual(18);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'GreaterThanEqual',
        target: {
          property: 'age',
        },
        value: 18,
      });
    });

    it('should create a like filter', () => {
      const f = filter.byProperty('name').like('John');
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Like',
        target: {
          property: 'name',
        },
        value: 'John',
      });
    });

    it('should create a geo range filter', () => {
      const f = filter.byProperty<any>('location').withinGeoRange({
        latitude: 1,
        longitude: 2,
        distance: 3,
      });
      expect(f).toEqual<FilterValue<GeoRangeFilter>>({
        operator: 'WithinGeoRange',
        target: {
          property: 'location',
        },
        value: {
          latitude: 1,
          longitude: 2,
          distance: 3,
        },
      });
    });
  });

  describe('for reference counts', () => {
    it('should create an equal filter', () => {
      const f = filter.byRefCount('self').equal(2);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'Equal',
        target: {
          count: {
            on: 'self',
          },
        },
        value: 2,
      });
    });

    it('should create a not equal than filter', () => {
      const f = filter.byRefCount('self').notEqual(2);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'NotEqual',
        target: {
          count: {
            on: 'self',
          },
        },
        value: 2,
      });
    });

    it('should create a less than filter', () => {
      const f = filter.byRefCount('self').lessThan(2);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'LessThan',
        target: {
          count: {
            on: 'self',
          },
        },
        value: 2,
      });
    });

    it('should create a less than or equal filter', () => {
      const f = filter.byRefCount('self').lessOrEqual(2);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'LessThanEqual',
        target: {
          count: {
            on: 'self',
          },
        },
        value: 2,
      });
    });

    it('should create a greater than filter', () => {
      const f = filter.byRefCount('self').greaterThan(2);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'GreaterThan',
        target: {
          count: {
            on: 'self',
          },
        },
        value: 2,
      });
    });

    it('should create a greater than or equal filter', () => {
      const f = filter.byRefCount('self').greaterOrEqual(2);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'GreaterThanEqual',
        target: {
          count: {
            on: 'self',
          },
        },
        value: 2,
      });
    });
  });

  describe('for single target references', () => {
    it('should create a property filter', () => {
      const f = filter.byRef('self').byProperty('name').isNull(true);
      expect(f).toEqual<FilterValue<boolean>>({
        operator: 'IsNull',
        target: {
          singleTarget: {
            on: 'self',
            target: {
              property: 'name',
            },
          },
        },
        value: true,
      });
    });

    it('should create an ID filter', () => {
      const f = filter.byRef('self').byId().equal('123');
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          singleTarget: {
            on: 'self',
            target: {
              property: '_id',
            },
          },
        },
        value: '123',
      });
    });

    it('should create a creation time filter', () => {
      const now = new Date();
      const f = filter.byRef('self').byCreationTime().equal(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          singleTarget: {
            on: 'self',
            target: {
              property: '_creationTimeUnix',
            },
          },
        },
        value: now.toISOString(),
      });
    });

    it('should create a update time filter', () => {
      const now = new Date();
      const f = filter.byRef('self').byUpdateTime().equal(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          singleTarget: {
            on: 'self',
            target: {
              property: '_lastUpdateTimeUnix',
            },
          },
        },
        value: now.toISOString(),
      });
    });

    it('should create a nested reference filter', () => {
      const f = filter.byRef('self').byRef('self').byProperty('name').isNull(true);
      expect(f).toEqual<FilterValue<boolean>>({
        operator: 'IsNull',
        target: {
          singleTarget: {
            on: 'self',
            target: {
              singleTarget: {
                on: 'self',
                target: {
                  property: 'name',
                },
              },
            },
          },
        },
        value: true,
      });
    });
  });

  it('should create a nested reference count filter', () => {
    const f = filter.byRef('self').byRefCount('self').equal(2);
    expect(f).toEqual<FilterValue<number>>({
      operator: 'Equal',
      target: {
        singleTarget: {
          on: 'self',
          target: {
            count: {
              on: 'self',
            },
          },
        },
      },
      value: 2,
    });
  });

  describe('for multiple target references', () => {
    it('should create a property filter', () => {
      const f = filter.byRefMultiTarget('self', 'Person').byProperty('name').isNull(true);
      expect(f).toEqual<FilterValue<boolean>>({
        operator: 'IsNull',
        target: {
          multiTarget: {
            on: 'self',
            targetCollection: 'Person',
            target: {
              property: 'name',
            },
          },
        },
        value: true,
      });
    });

    it('should create an ID filter', () => {
      const f = filter.byRefMultiTarget('self', 'Person').byId().equal('123');
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          multiTarget: {
            on: 'self',
            targetCollection: 'Person',
            target: {
              property: '_id',
            },
          },
        },
        value: '123',
      });
    });

    it('should create a creation time filter', () => {
      const now = new Date();
      const f = filter.byRefMultiTarget('self', 'Person').byCreationTime().equal(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          multiTarget: {
            on: 'self',
            targetCollection: 'Person',
            target: {
              property: '_creationTimeUnix',
            },
          },
        },
        value: now.toISOString(),
      });
    });

    it('should create a update time filter', () => {
      const now = new Date();
      const f = filter.byRefMultiTarget('self', 'Person').byUpdateTime().equal(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          multiTarget: {
            on: 'self',
            targetCollection: 'Person',
            target: {
              property: '_lastUpdateTimeUnix',
            },
          },
        },
        value: now.toISOString(),
      });
    });

    it('should create a nested single target reference filter', () => {
      const f = filter.byRefMultiTarget('self', 'Person').byRef('self').byProperty('name').isNull(true);
      expect(f).toEqual<FilterValue<boolean>>({
        operator: 'IsNull',
        target: {
          multiTarget: {
            on: 'self',
            targetCollection: 'Person',
            target: {
              singleTarget: {
                on: 'self',
                target: {
                  property: 'name',
                },
              },
            },
          },
        },
        value: true,
      });
    });

    it('should create a nested multi target reference filter', () => {
      const f = filter
        .byRefMultiTarget('self', 'Person')
        .byRefMultiTarget('self', 'Person')
        .byProperty('name')
        .isNull(true);
      expect(f).toEqual<FilterValue<boolean>>({
        operator: 'IsNull',
        target: {
          multiTarget: {
            on: 'self',
            targetCollection: 'Person',
            target: {
              multiTarget: {
                on: 'self',
                targetCollection: 'Person',
                target: {
                  property: 'name',
                },
              },
            },
          },
        },
        value: true,
      });
    });

    it('should create a nested multi target reference count filter', () => {
      const f = filter.byRefMultiTarget('self', 'Person').byRefCount('self').equal(2);
      expect(f).toEqual<FilterValue<number>>({
        operator: 'Equal',
        target: {
          multiTarget: {
            on: 'self',
            targetCollection: 'Person',
            target: {
              count: {
                on: 'self',
              },
            },
          },
        },
        value: 2,
      });
    });
  });

  describe('for ID', () => {
    it('should create an equal filter', () => {
      const f = filter.byId().equal('123');
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          property: '_id',
        },
        value: '123',
      });
    });

    it('should create a not equal filter', () => {
      const f = filter.byId().notEqual('123');
      expect(f).toEqual<FilterValue<string>>({
        operator: 'NotEqual',
        target: {
          property: '_id',
        },
        value: '123',
      });
    });

    it('should create a contains any filter', () => {
      const f = filter.byId().containsAny(['123', '456']);
      expect(f).toEqual<FilterValue<string[]>>({
        operator: 'ContainsAny',
        target: {
          property: '_id',
        },
        value: ['123', '456'],
      });
    });
  });

  describe('for creation time', () => {
    it('should create a contains any filter', () => {
      const now = new Date();
      const f = filter.byCreationTime().containsAny([now]);
      expect(f).toEqual<FilterValue<string[]>>({
        operator: 'ContainsAny',
        target: {
          property: '_creationTimeUnix',
        },
        value: [now.toISOString()],
      });
    });

    it('should create an equal filter', () => {
      const now = new Date();
      const f = filter.byCreationTime().equal(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          property: '_creationTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a not equal filter', () => {
      const now = new Date();
      const f = filter.byCreationTime().notEqual(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'NotEqual',
        target: {
          property: '_creationTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a less than filter', () => {
      const now = new Date();
      const f = filter.byCreationTime().lessThan(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'LessThan',
        target: {
          property: '_creationTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a less than or equal filter', () => {
      const now = new Date();
      const f = filter.byCreationTime().lessOrEqual(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'LessThanEqual',
        target: {
          property: '_creationTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a greater than filter', () => {
      const now = new Date();
      const f = filter.byCreationTime().greaterThan(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'GreaterThan',
        target: {
          property: '_creationTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a greater than or equal filter', () => {
      const now = new Date();
      const f = filter.byCreationTime().greaterOrEqual(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'GreaterThanEqual',
        target: {
          property: '_creationTimeUnix',
        },
        value: now.toISOString(),
      });
    });
  });

  describe('for update time', () => {
    it('should create a contains any filter', () => {
      const now = new Date();
      const f = filter.byUpdateTime().containsAny([now]);
      expect(f).toEqual<FilterValue<string[]>>({
        operator: 'ContainsAny',
        target: {
          property: '_lastUpdateTimeUnix',
        },
        value: [now.toISOString()],
      });
    });

    it('should create an equal filter', () => {
      const now = new Date();
      const f = filter.byUpdateTime().equal(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'Equal',
        target: {
          property: '_lastUpdateTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a not equal filter', () => {
      const now = new Date();
      const f = filter.byUpdateTime().notEqual(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'NotEqual',
        target: {
          property: '_lastUpdateTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a less than filter', () => {
      const now = new Date();
      const f = filter.byUpdateTime().lessThan(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'LessThan',
        target: {
          property: '_lastUpdateTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a less than or equal filter', () => {
      const now = new Date();
      const f = filter.byUpdateTime().lessOrEqual(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'LessThanEqual',
        target: {
          property: '_lastUpdateTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a greater than filter', () => {
      const now = new Date();
      const f = filter.byUpdateTime().greaterThan(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'GreaterThan',
        target: {
          property: '_lastUpdateTimeUnix',
        },
        value: now.toISOString(),
      });
    });

    it('should create a greater than or equal filter', () => {
      const now = new Date();
      const f = filter.byUpdateTime().greaterOrEqual(now);
      expect(f).toEqual<FilterValue<string>>({
        operator: 'GreaterThanEqual',
        target: {
          property: '_lastUpdateTimeUnix',
        },
        value: now.toISOString(),
      });
    });
  });

  describe('for the REST schema', () => {
    const anyFilter = maker<any>();
    it('should map a text property filter', () => {
      const f = filter.byProperty('name').equal('John');
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['name'],
        valueText: 'John',
      });
    });

    it('should map an int property filter', () => {
      const f = filter.byProperty('age').equal(18);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['age'],
        valueInt: 18,
      });
    });

    it('should map a boolean property filter', () => {
      const f = anyFilter.byProperty('isAdult').equal(true);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['isAdult'],
        valueBoolean: true,
      });
    });

    it('should map a float property filter', () => {
      const f = anyFilter.byProperty('age').equal(18.5);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['age'],
        valueNumber: 18.5,
      });
    });

    it('should map a date property filter', () => {
      const now = new Date();
      const f = anyFilter.byProperty('date').equal(now);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['date'],
        valueDate: now.toISOString(),
      });
    });

    it('should map a text array property filter', () => {
      const f = anyFilter.byProperty('names').equal(['John', 'Doe']);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['names'],
        valueTextArray: ['John', 'Doe'],
      });
    });

    it('should map an int array property filter', () => {
      const f = anyFilter.byProperty('ages').equal([18, 19]);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['ages'],
        valueIntArray: [18, 19],
      });
    });

    it('should map a boolean array property filter', () => {
      const f = anyFilter.byProperty('bools').equal([true, false]);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['bools'],
        valueBooleanArray: [true, false],
      });
    });

    it('should map a float array property filter', () => {
      const f = anyFilter.byProperty('ages').equal([18.5, 19.5]);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['ages'],
        valueNumberArray: [18.5, 19.5],
      });
    });

    it('should map a date array property filter', () => {
      const now1 = new Date();
      const now2 = new Date();
      const f = anyFilter.byProperty('dates').equal([now1, now2]);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['dates'],
        valueDateArray: [now1.toISOString(), now2.toISOString()],
      });
    });

    it('should map a geo range property filter', () => {
      const f = anyFilter.byProperty('location').withinGeoRange({
        latitude: 1,
        longitude: 2,
        distance: 3,
      });
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'WithinGeoRange',
        path: ['location'],
        valueGeoRange: {
          geoCoordinates: {
            latitude: 1,
            longitude: 2,
          },
          distance: {
            max: 3,
          },
        },
      });
    });

    it('should map a single target reference filter', () => {
      const f = filter.byRef('self').byProperty('name').isNull(true);
      expect(() => Serialize.filtersREST(f)).toThrow(
        'Cannot use Filter.byRef() in the aggregate API currently. Instead use Filter.byRefMultiTarget() and specify the target collection explicitly.'
      );
    });

    it('should map a multi target reference filter', () => {
      const f = filter.byRefMultiTarget('self', 'Person').byProperty('name').isNull(true);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'IsNull',
        path: ['self', 'Person', 'name'],
        valueBoolean: true,
      });
    });

    it('should map a reference count filter', () => {
      const f = filter.byRefCount('self').equal(2);
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Equal',
        path: ['self'],
        valueInt: 2,
      });
    });

    it('should map an AND filter', () => {
      const f = Filters.and(filter.byProperty('name').equal('John'), filter.byProperty('age').equal(18));
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'And',
        operands: [
          {
            operator: 'Equal',
            path: ['name'],
            valueText: 'John',
          },
          {
            operator: 'Equal',
            path: ['age'],
            valueInt: 18,
          },
        ],
      });
    });

    it('should map an OR filter', () => {
      const f = Filters.or(filter.byProperty('name').equal('John'), filter.byProperty('age').equal(18));
      const s = Serialize.filtersREST(f);
      expect(s).toEqual<WhereFilter>({
        operator: 'Or',
        operands: [
          {
            operator: 'Equal',
            path: ['name'],
            valueText: 'John',
          },
          {
            operator: 'Equal',
            path: ['age'],
            valueInt: 18,
          },
        ],
      });
    });
  });
});



---
File: /src/collections/filters/utils.ts
---

import { CountRef, FilterTargetInternal, MultiTargetRef, SingleTargetRef } from './types.js';

export class TargetGuards {
  public static isSingleTargetRef(target?: FilterTargetInternal): target is SingleTargetRef {
    if (!target) return false;
    return (target as SingleTargetRef).type_ === 'single';
  }

  public static isMultiTargetRef(target?: FilterTargetInternal): target is MultiTargetRef {
    if (!target) return false;
    return (target as MultiTargetRef).type_ === 'multi';
  }

  public static isCountRef(target?: FilterTargetInternal): target is CountRef {
    if (!target) return false;
    return (target as CountRef).type_ === 'count';
  }

  public static isProperty(target?: FilterTargetInternal): target is string {
    if (!target) return false;
    return typeof target === 'string';
  }

  public static isTargetRef(target?: FilterTargetInternal): target is SingleTargetRef | MultiTargetRef {
    if (!target) return false;
    return TargetGuards.isSingleTargetRef(target) || TargetGuards.isMultiTargetRef(target);
  }
}



---
File: /src/collections/generate/index.ts
---

import Connection from '../../connection/grpc.js';

import { ConsistencyLevel } from '../../data/index.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';

import { WeaviateInvalidInputError } from '../../errors.js';
import { toBase64FromMedia } from '../../index.js';
import { SearchReply } from '../../proto/v1/search_get.js';
import { Deserialize } from '../deserialize/index.js';
import { Check } from '../query/check.js';
import {
  BaseBm25Options,
  BaseHybridOptions,
  BaseNearOptions,
  BaseNearTextOptions,
  Bm25Options,
  FetchObjectsOptions,
  GroupByBm25Options,
  GroupByHybridOptions,
  GroupByNearOptions,
  GroupByNearTextOptions,
  HybridOptions,
  NearMediaType,
  NearOptions,
  SearchOptions,
} from '../query/types.js';
import { Serialize } from '../serialize/index.js';
import {
  GenerateOptions,
  GenerateReturn,
  GenerativeGroupByReturn,
  GenerativeReturn,
  GroupByOptions,
} from '../types/index.js';
import { Generate } from './types.js';

class GenerateManager<T> implements Generate<T> {
  private check: Check<T>;

  private constructor(check: Check<T>) {
    this.check = check;
  }

  public static use<T>(
    connection: Connection,
    name: string,
    dbVersionSupport: DbVersionSupport,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ): GenerateManager<T> {
    return new GenerateManager<T>(new Check<T>(connection, name, dbVersionSupport, consistencyLevel, tenant));
  }

  private async parseReply(reply: SearchReply) {
    const deserialize = await Deserialize.use(this.check.dbVersionSupport);
    return deserialize.generate<T>(reply);
  }

  private async parseGroupByReply(
    opts: SearchOptions<T> | GroupByOptions<T> | undefined,
    reply: SearchReply
  ) {
    const deserialize = await Deserialize.use(this.check.dbVersionSupport);
    return Serialize.isGroupBy(opts) ? deserialize.generateGroupBy<T>(reply) : deserialize.generate<T>(reply);
  }

  public fetchObjects(
    generate: GenerateOptions<T>,
    opts?: FetchObjectsOptions<T>
  ): Promise<GenerativeReturn<T>> {
    return this.check
      .fetchObjects(opts)
      .then(({ search }) =>
        search.withFetch({
          ...Serialize.fetchObjects(opts),
          generative: Serialize.generative(generate),
        })
      )
      .then((reply) => this.parseReply(reply));
  }

  public bm25(
    query: string,
    generate: GenerateOptions<T>,
    opts?: BaseBm25Options<T>
  ): Promise<GenerativeReturn<T>>;
  public bm25(
    query: string,
    generate: GenerateOptions<T>,
    opts: GroupByBm25Options<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  public bm25(query: string, generate: GenerateOptions<T>, opts?: Bm25Options<T>): GenerateReturn<T> {
    return this.check
      .bm25(opts)
      .then(({ search }) =>
        search.withBm25({
          ...Serialize.bm25({ query, ...opts }),
          generative: Serialize.generative(generate),
          groupBy: Serialize.isGroupBy<GroupByBm25Options<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public hybrid(
    query: string,
    generate: GenerateOptions<T>,
    opts?: BaseHybridOptions<T>
  ): Promise<GenerativeReturn<T>>;
  public hybrid(
    query: string,
    generate: GenerateOptions<T>,
    opts: GroupByHybridOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  public hybrid(query: string, generate: GenerateOptions<T>, opts?: HybridOptions<T>): GenerateReturn<T> {
    return this.check
      .hybridSearch(opts)
      .then(({ search, supportsTargets, supportsVectorsForTargets, supportsWeightsForTargets }) =>
        search.withHybrid({
          ...Serialize.hybrid({
            query,
            supportsTargets,
            supportsVectorsForTargets,
            supportsWeightsForTargets,
            ...opts,
          }),
          generative: Serialize.generative(generate),
          groupBy: Serialize.isGroupBy<GroupByHybridOptions<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearImage(
    image: string | Buffer,
    generate: GenerateOptions<T>,
    opts?: BaseNearOptions<T>
  ): Promise<GenerativeReturn<T>>;
  public nearImage(
    image: string | Buffer,
    generate: GenerateOptions<T>,
    opts: GroupByNearOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  public nearImage(
    image: string | Buffer,
    generate: GenerateOptions<T>,
    opts?: NearOptions<T>
  ): GenerateReturn<T> {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) =>
        toBase64FromMedia(image).then((image) =>
          search.withNearImage({
            ...Serialize.nearImage({
              image,
              supportsTargets,
              supportsWeightsForTargets,
              ...(opts ? opts : {}),
            }),
            generative: Serialize.generative(generate),
            groupBy: Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
              ? Serialize.groupBy(opts.groupBy)
              : undefined,
          })
        )
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearObject(
    id: string,
    generate: GenerateOptions<T>,
    opts?: BaseNearOptions<T>
  ): Promise<GenerativeReturn<T>>;
  public nearObject(
    id: string,
    generate: GenerateOptions<T>,
    opts: GroupByNearOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  public nearObject(id: string, generate: GenerateOptions<T>, opts?: NearOptions<T>): GenerateReturn<T> {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) =>
        search.withNearObject({
          ...Serialize.nearObject({
            id,
            supportsTargets,
            supportsWeightsForTargets,
            ...(opts ? opts : {}),
          }),
          generative: Serialize.generative(generate),
          groupBy: Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearText(
    query: string | string[],
    generate: GenerateOptions<T>,
    opts?: BaseNearTextOptions<T>
  ): Promise<GenerativeReturn<T>>;
  public nearText(
    query: string | string[],
    generate: GenerateOptions<T>,
    opts: GroupByNearTextOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  public nearText(
    query: string | string[],
    generate: GenerateOptions<T>,
    opts?: NearOptions<T>
  ): GenerateReturn<T> {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) =>
        search.withNearText({
          ...Serialize.nearText({
            query,
            supportsTargets,
            supportsWeightsForTargets,
            ...(opts ? opts : {}),
          }),
          generative: Serialize.generative(generate),
          groupBy: Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearVector(
    vector: number[],
    generate: GenerateOptions<T>,
    opts?: BaseNearOptions<T>
  ): Promise<GenerativeReturn<T>>;
  public nearVector(
    vector: number[],
    generate: GenerateOptions<T>,
    opts: GroupByNearOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  public nearVector(
    vector: number[],
    generate: GenerateOptions<T>,
    opts?: NearOptions<T>
  ): GenerateReturn<T> {
    return this.check
      .nearVector(vector, opts)
      .then(({ search, supportsTargets, supportsVectorsForTargets, supportsWeightsForTargets }) =>
        search.withNearVector({
          ...Serialize.nearVector({
            vector,
            supportsTargets,
            supportsVectorsForTargets,
            supportsWeightsForTargets,
            ...(opts ? opts : {}),
          }),
          generative: Serialize.generative(generate),
          groupBy: Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    generate: GenerateOptions<T>,
    opts?: BaseNearOptions<T>
  ): Promise<GenerativeReturn<T>>;
  public nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    generate: GenerateOptions<T>,
    opts: GroupByNearOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  public nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    generate: GenerateOptions<T>,
    opts?: NearOptions<T>
  ): GenerateReturn<T> {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) => {
        let reply: Promise<SearchReply>;
        const args = {
          supportsTargets,
          supportsWeightsForTargets,
          ...(opts ? opts : {}),
        };
        const generative = Serialize.generative(generate);
        const groupBy = Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
          ? Serialize.groupBy(opts.groupBy)
          : undefined;
        switch (type) {
          case 'audio':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearAudio({
                ...Serialize.nearAudio({ audio: media, ...args }),
                generative,
                groupBy,
              })
            );
            break;
          case 'depth':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearDepth({
                ...Serialize.nearDepth({ depth: media, ...args }),
                generative,
                groupBy,
              })
            );
            break;
          case 'image':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearImage({
                ...Serialize.nearImage({ image: media, ...args }),
                generative,
                groupBy,
              })
            );
            break;
          case 'imu':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearIMU({
                ...Serialize.nearIMU({ imu: media, ...args }),
                generative,
                groupBy,
              })
            );
            break;
          case 'thermal':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearThermal({
                ...Serialize.nearThermal({ thermal: media, ...args }),
                generative,
                groupBy,
              })
            );
            break;
          case 'video':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearVideo({
                ...Serialize.nearVideo({ video: media, ...args }),
                generative,
                groupBy,
              })
            );
            break;
          default:
            throw new WeaviateInvalidInputError(`Invalid media type: ${type}`);
        }
        return reply;
      })
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
}

export default GenerateManager.use;

export { Generate } from './types.js';



---
File: /src/collections/generate/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
import { WeaviateUnsupportedFeatureError } from '../../errors.js';
import weaviate, { WeaviateClient } from '../../index.js';
import { Collection } from '../collection/index.js';
import { GenerateOptions, GroupByOptions } from '../types/index.js';

const maybe = process.env.OPENAI_APIKEY ? describe : describe.skip;

const makeOpenAIClient = () =>
  weaviate.connectToLocal({
    port: 8086,
    grpcPort: 50057,
    headers: {
      'X-Openai-Api-Key': process.env.OPENAI_APIKEY!,
    },
  });

maybe('Testing of the collection.generate methods with a simple collection', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionGenerateSimple, 'TestCollectionGenerateSimple'>;
  const collectionName = 'TestCollectionGenerateSimple';
  let id: string;
  let vector: number[];

  type TestCollectionGenerateSimple = {
    testProp: string;
  };

  const generateOpts: GenerateOptions<TestCollectionGenerateSimple> = {
    singlePrompt: 'Write a haiku about ducks for {testProp}',
    groupedTask: 'What is the value of testProp here?',
    groupedProperties: ['testProp'],
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await makeOpenAIClient();
    collection = client.collections.get(collectionName);
    id = await client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
        generative: weaviate.configure.generative.openAI(),
        vectorizers: weaviate.configure.vectorizer.text2VecOpenAI({
          vectorizeCollectionName: false,
        }),
      })
      .then(() => {
        return collection.data.insert({
          properties: {
            testProp: 'test',
          },
        });
      });
    const res = await collection.query.fetchObjectById(id, { includeVector: true });
    vector = res?.vectors.default!;
  });

  describe('using a non-generic collection', () => {
    it('should generate without search', async () => {
      const ret = await client.collections.get(collectionName).generate.fetchObjects({
        singlePrompt: 'Write a haiku about ducks for {testProp}',
        groupedTask: 'What is the value of testProp here?',
        groupedProperties: ['testProp'],
      });
      expect(ret.objects.length).toEqual(1);
      expect(ret.generated).toBeDefined();
      expect(ret.objects[0].properties.testProp).toEqual('test');
      expect(ret.objects[0].uuid).toEqual(id);
      expect(ret.objects[0].generated).toBeDefined();
    });
  });

  describe('using a generic collection', () => {
    it('should generate without search', async () => {
      const ret = await collection.generate.fetchObjects(generateOpts);
      expect(ret.objects.length).toEqual(1);
      expect(ret.generated).toBeDefined();
      expect(ret.objects[0].properties.testProp).toEqual('test');
      expect(ret.objects[0].uuid).toEqual(id);
      expect(ret.objects[0].generated).toBeDefined();
    });

    it('should generate without search specifying return properties', async () => {
      const ret = await collection.generate.fetchObjects(generateOpts, {
        returnProperties: ['testProp'],
      });
      expect(ret.objects.length).toEqual(1);
      expect(ret.generated).toBeDefined();
      expect(ret.objects[0].properties.testProp).toEqual('test');
      expect(ret.objects[0].uuid).toEqual(id);
      expect(ret.objects[0].generated).toBeDefined();
    });

    it('should generate with bm25', async () => {
      const ret = await collection.generate.bm25('test', generateOpts);
      expect(ret.objects.length).toEqual(1);
      expect(ret.generated).toBeDefined();
      expect(ret.objects[0].properties.testProp).toEqual('test');
      expect(ret.objects[0].uuid).toEqual(id);
      expect(ret.objects[0].generated).toBeDefined();
    });

    it('should generate with hybrid', async () => {
      const ret = await collection.generate.hybrid('test', generateOpts);
      expect(ret.objects.length).toEqual(1);
      expect(ret.generated).toBeDefined();
      expect(ret.objects[0].properties.testProp).toEqual('test');
      expect(ret.objects[0].uuid).toEqual(id);
      expect(ret.objects[0].generated).toBeDefined();
    });

    it.skip('should generate with nearObject', async () => {
      const ret = await collection.generate.nearObject(id, generateOpts);
      expect(ret.objects.length).toEqual(1);
      expect(ret.generated).toBeDefined();
      expect(ret.objects[0].properties.testProp).toEqual('test');
      expect(ret.objects[0].uuid).toEqual(id);
      expect(ret.objects[0].generated).toBeDefined();
    });

    it('should generate with nearText', async () => {
      const ret = await collection.generate.nearText(['test'], generateOpts);
      expect(ret.objects.length).toEqual(1);
      expect(ret.generated).toBeDefined();
      expect(ret.objects[0].properties.testProp).toEqual('test');
      expect(ret.objects[0].uuid).toEqual(id);
      expect(ret.objects[0].generated).toBeDefined();
    });

    it('should generate with nearVector', async () => {
      const ret = await collection.generate.nearVector(vector, generateOpts);
      expect(ret.objects.length).toEqual(1);
      expect(ret.generated).toBeDefined();
      expect(ret.objects[0].properties.testProp).toEqual('test');
      expect(ret.objects[0].uuid).toEqual(id);
      expect(ret.objects[0].generated).toBeDefined();
    });
  });
});

maybe('Testing of the groupBy collection.generate methods with a simple collection', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionGenerateGroupBySimple, 'TestCollectionGenerateGroupBySimple'>;
  const collectionName = 'TestCollectionGenerateGroupBySimple';
  let id: string;
  let vector: number[];

  type TestCollectionGenerateGroupBySimple = {
    testProp: string;
  };

  const generateOpts: GenerateOptions<TestCollectionGenerateGroupBySimple> = {
    singlePrompt: 'Write a haiku about ducks for {testProp}',
    groupedTask: 'What is the value of testProp here?',
    groupedProperties: ['testProp'],
  };

  const groupByArgs: GroupByOptions<TestCollectionGenerateGroupBySimple> = {
    numberOfGroups: 1,
    objectsPerGroup: 1,
    property: 'testProp',
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await makeOpenAIClient();
    collection = client.collections.get(collectionName);
    id = await client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
        generative: weaviate.configure.generative.openAI(),
        vectorizers: weaviate.configure.vectorizer.text2VecOpenAI({
          vectorizeCollectionName: false,
        }),
      })
      .then(() => {
        return collection.data.insert({
          properties: {
            testProp: 'test',
          },
        });
      });
    const res = await collection.query.fetchObjectById(id, { includeVector: true });
    vector = res?.vectors.default!;
  });

  // it('should groupBy without search', async () => {
  //   const ret = await collection.groupBy.fetchObjects(groupByArgs);
  //   expect(ret.objects.length).toEqual(1);
  //   expect(ret.groups).toBeDefined();
  //   expect(Object.keys(ret.groups)).toEqual(['test']);
  //   expect(ret.objects[0].properties.testProp).toEqual('test');
  //   expect(ret.objects[0].metadata.uuid).toEqual(id);
  //   expect(ret.objects[0].belongsToGroup).toEqual('test');
  // });

  // it('should groupBy without search specifying return properties', async () => {
  //   const ret = await collection.groupBy.fetchObjects({
  //     returnProperties: ['testProp'],
  //     returnMetadata: ['uuid'],
  //     ...groupByArgs,
  //   });
  //   expect(ret.objects.length).toEqual(1);
  //   expect(ret.groups).toBeDefined();
  //   expect(Object.keys(ret.groups)).toEqual(['test']);
  //   expect(ret.objects[0].properties.testProp).toEqual('test');
  //   expect(ret.objects[0].metadata.uuid).toEqual(id);
  //   expect(ret.objects[0].belongsToGroup).toEqual('test');
  // });

  it('should groupBy with bm25', async () => {
    const query = () =>
      collection.generate.bm25('test', generateOpts, {
        groupBy: groupByArgs,
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it('should groupBy with hybrid', async () => {
    const query = () =>
      collection.generate.hybrid('test', generateOpts, {
        groupBy: groupByArgs,
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it.skip('should groupBy with nearObject', async () => {
    const ret = await collection.generate.nearObject(id, generateOpts, {
      groupBy: groupByArgs,
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(ret.generated).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.groups.test.generated).toBeDefined();
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it('should groupBy with nearText', async () => {
    const ret = await collection.generate.nearText(['test'], generateOpts, {
      groupBy: groupByArgs,
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(ret.generated).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.groups.test.generated).toBeDefined();
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it('should groupBy with nearVector', async () => {
    const ret = await collection.generate.nearVector(vector, generateOpts, {
      groupBy: groupByArgs,
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(ret.generated).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.groups.test.generated).toBeDefined();
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });
});

maybe('Testing of the collection.generate methods with a multi vector collection', () => {
  let client: WeaviateClient;
  let collection: Collection;
  const collectionName = 'TestCollectionQueryWithMultiVector';

  let id1: string;
  let id2: string;
  let titleVector: number[];
  let title2Vector: number[];

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await makeOpenAIClient();
    collection = client.collections.get(collectionName);
    const query = () =>
      client.collections
        .create({
          name: collectionName,
          properties: [
            {
              name: 'title',
              dataType: 'text',
              vectorizePropertyName: false,
            },
          ],
          vectorizers: [
            weaviate.configure.vectorizer.text2VecOpenAI({
              name: 'title',
              sourceProperties: ['title'],
            }),
            weaviate.configure.vectorizer.text2VecOpenAI({
              name: 'title2',
              sourceProperties: ['title'],
            }),
          ],
        })
        .then(async () => {
          id1 = await collection.data.insert({
            properties: {
              title: 'test',
            },
          });
          id2 = await collection.data.insert({
            properties: {
              title: 'other',
            },
          });
          const res = await collection.query.fetchObjectById(id1, { includeVector: true });
          titleVector = res!.vectors.title!;
          title2Vector = res!.vectors.title2!;
        });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    return query();
  });

  it('should generate with a near vector search on multi vectors', async () => {
    const query = () =>
      collection.generate.nearVector(
        { title: titleVector, title2: title2Vector },
        {
          groupedTask: 'What is the value of title here? {title}',
          groupedProperties: ['title'],
          singlePrompt: 'Write a haiku about ducks for {title}',
        }
      );
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.generated).toBeDefined();
    expect(ret.objects[0].generated).toBeDefined();
    expect(ret.objects[1].generated).toBeDefined();
  });

  it('should generate with a near vector search on multi vectors', async () => {
    const query = () =>
      collection.generate.nearVector(
        { title: titleVector, title2: title2Vector },
        {
          groupedTask: 'What is the value of title here? {title}',
          groupedProperties: ['title'],
          singlePrompt: 'Write a haiku about ducks for {title}',
        },
        {
          targetVector: ['title', 'title2'],
        }
      );
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.generated).toBeDefined();
    expect(ret.objects[0].generated).toBeDefined();
    expect(ret.objects[1].generated).toBeDefined();
  });
});



---
File: /src/collections/generate/types.ts
---

import {
  BaseBm25Options,
  BaseHybridOptions,
  BaseNearOptions,
  BaseNearTextOptions,
  Bm25Options,
  FetchObjectsOptions,
  GroupByBm25Options,
  GroupByHybridOptions,
  GroupByNearOptions,
  GroupByNearTextOptions,
  HybridOptions,
  NearMediaType,
  NearOptions,
  NearTextOptions,
  NearVectorInputType,
} from '../query/types.js';
import {
  GenerateOptions,
  GenerateReturn,
  GenerativeGroupByReturn,
  GenerativeReturn,
} from '../types/index.js';

interface Bm25<T> {
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a keyword-based BM25 search of objects in this collection.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/bm25) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {BaseBm25Options<T>} [opts] - The available options for performing the BM25 search.
   * @return {Promise<GenerativeReturn<T>>} - The results of the search including the generated data.
   */
  bm25(query: string, generate: GenerateOptions<T>, opts?: BaseBm25Options<T>): Promise<GenerativeReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a keyword-based BM25 search of objects in this collection.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/bm25) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {GroupByBm25Options<T>} opts - The available options for performing the BM25 search.
   * @return {Promise<GenerativeGroupByReturn<T>>} - The results of the search including the generated data grouped by the specified properties.
   */
  bm25(
    query: string,
    generate: GenerateOptions<T>,
    opts: GroupByBm25Options<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a keyword-based BM25 search of objects in this collection.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/bm25) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {Bm25Options<T>} [opts] - The available options for performing the BM25 search.
   * @return {GenerateReturn<T>} - The results of the search including the generated data.
   */
  bm25(query: string, generate: GenerateOptions<T>, opts?: Bm25Options<T>): GenerateReturn<T>;
}

interface Hybrid<T> {
  /**
   * Perform retrieval-augmented generation (RaG) on the results of an object search in this collection using the hybrid algorithm blending keyword-based BM25 and vector-based similarity.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/hybrid) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {BaseHybridOptions<T>} [opts] - The available options for performing the hybrid search.
   * @return {Promise<GenerativeReturn<T>>} - The results of the search including the generated data.
   */
  hybrid(
    query: string,
    generate: GenerateOptions<T>,
    opts?: BaseHybridOptions<T>
  ): Promise<GenerativeReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of an object search in this collection using the hybrid algorithm blending keyword-based BM25 and vector-based similarity.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/hybrid) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {GroupByHybridOptions<T>} opts - The available options for performing the hybrid search.
   * @return {Promise<GenerativeGroupByReturn<T>>} - The results of the search including the generated data grouped by the specified properties.
   */
  hybrid(
    query: string,
    generate: GenerateOptions<T>,
    opts: GroupByHybridOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of an object search in this collection using the hybrid algorithm blending keyword-based BM25 and vector-based similarity.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/hybrid) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {HybridOptions<T>} [opts] - The available options for performing the hybrid search.
   * @return {GenerateReturn<T>} - The results of the search including the generated data.
   */
  hybrid(query: string, generate: GenerateOptions<T>, opts?: HybridOptions<T>): GenerateReturn<T>;
}

interface NearMedia<T> {
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-audio object search in this collection using an audio-capable vectorization module and vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind) for a more detailed explanation.
   *
   * NOTE: You must have a multi-media-capable vectorization module installed in order to use this method, e.g. `multi2vec-bind`.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string | Buffer} media - The media file to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {NearMediaType} type - The type of media to search on.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {BaseNearOptions<T>} [opts] - The available options for performing the near-media search.
   * @return {Promise<GenerativeReturn<T>>} - The results of the search including the generated data.
   */
  nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    generate: GenerateOptions<T>,
    opts?: BaseNearOptions<T>
  ): Promise<GenerativeReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-audio object search in this collection using an audio-capable vectorization module and vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind) for a more detailed explanation.
   *
   * NOTE: You must have a multi-media-capable vectorization module installed in order to use this method, e.g. `multi2vec-bind`.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string | Buffer} media - The media file to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {NearMediaType} type - The type of media to search on.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {GroupByNearOptions<T>} opts - The available options for performing the near-media search.
   * @return {Promise<GenerativeGroupByReturn<T>>} - The results of the search including the generated data grouped by the specified properties.
   */
  nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    generate: GenerateOptions<T>,
    opts: GroupByNearOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-audio object search in this collection using an audio-capable vectorization module and vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind) for a more detailed explanation.
   *
   * NOTE: You must have a multi-media-capable vectorization module installed in order to use this method, e.g. `multi2vec-bind`.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string | Buffer} media - The media to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {NearMediaType} type - The type of media to search on.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {NearOptions<T>} [opts] - The available options for performing the near-media search.
   * @return {GenerateReturn<T>} - The results of the search including the generated data.
   */
  nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    generate: GenerateOptions<T>,
    opts?: NearOptions<T>
  ): GenerateReturn<T>;
}

interface NearObject<T> {
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-object object search in this collection using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#nearobject) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string} id - The ID of the object to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {BaseNearOptions<T>} [opts] - The available options for performing the near-object search.
   * @return {Promise<GenerativeReturn<T>>} - The results of the search including the generated data.
   */
  nearObject(
    id: string,
    generate: GenerateOptions<T>,
    opts?: BaseNearOptions<T>
  ): Promise<GenerativeReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-object object search in this collection using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#nearobject) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string} id - The ID of the object to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {GroupByNearOptions<T>} opts - The available options for performing the near-object search.
   * @return {Promise<GenerativeGroupByReturn<T>>} - The results of the search including the generated data grouped by the specified properties.
   */
  nearObject(
    id: string,
    generate: GenerateOptions<T>,
    opts: GroupByNearOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-object object search in this collection using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#nearobject) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string} id - The ID of the object to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {NearOptions<T>} [opts] - The available options for performing the near-object search.
   * @return {GenerateReturn<T>} - The results of the search including the generated data.
   */
  nearObject(id: string, generate: GenerateOptions<T>, opts?: NearOptions<T>): GenerateReturn<T>;
}

interface NearText<T> {
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-image object search in this collection using the image-capable vectorization module and vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#neartext) for a more detailed explanation.
   *
   * NOTE: You must have a text-capable vectorization module installed in order to use this method, e.g. any of the `text2vec-` and `multi2vec-` modules.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string | string[]} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {BaseNearTextOptions<T>} [opts] - The available options for performing the near-text search.
   * @return {Promise<GenerativeReturn<T>>} - The results of the search including the generated data.
   */
  nearText(
    query: string | string[],
    generate: GenerateOptions<T>,
    opts?: BaseNearTextOptions<T>
  ): Promise<GenerativeReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-image object search in this collection using the image-capable vectorization module and vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#neartext) for a more detailed explanation.
   *
   * NOTE: You must have a text-capable vectorization module installed in order to use this method, e.g. any of the `text2vec-` and `multi2vec-` modules.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string | string[]} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {GroupByNearTextOptions<T>} opts - The available options for performing the near-text search.
   * @return {Promise<GenerativeGroupByReturn<T>>} - The results of the search including the generated data grouped by the specified properties.
   */
  nearText(
    query: string | string[],
    generate: GenerateOptions<T>,
    opts: GroupByNearTextOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-image object search in this collection using the image-capable vectorization module and vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#neartext) for a more detailed explanation.
   *
   * NOTE: You must have a text-capable vectorization module installed in order to use this method, e.g. any of the `text2vec-` and `multi2vec-` modules.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string | string[]} query - The query to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {NearTextOptions<T>} [opts] - The available options for performing the near-text search.
   * @return {GenerateReturn<T>} - The results of the search including the generated data.
   */
  nearText(
    query: string | string[],
    generate: GenerateOptions<T>,
    opts?: NearTextOptions<T>
  ): GenerateReturn<T>;
}

interface NearVector<T> {
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-vector object search in this collection using vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {NearVectorInputType} vector - The vector(s) to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {BaseNearOptions<T>} [opts] - The available options for performing the near-vector search.
   * @return {Promise<GenerativeReturn<T>>} - The results of the search including the generated data.
   */
  nearVector(
    vector: NearVectorInputType,
    generate: GenerateOptions<T>,
    opts?: BaseNearOptions<T>
  ): Promise<GenerativeReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-vector object search in this collection using vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {NearVectorInputType} vector - The vector(s) to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {GroupByNearOptions<T>} opts - The available options for performing the near-vector search.
   * @return {Promise<GenerativeGroupByReturn<T>>} - The results of the search including the generated data grouped by the specified properties.
   */
  nearVector(
    vector: NearVectorInputType,
    generate: GenerateOptions<T>,
    opts: GroupByNearOptions<T>
  ): Promise<GenerativeGroupByReturn<T>>;
  /**
   * Perform retrieval-augmented generation (RaG) on the results of a by-vector object search in this collection using vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {NearVectorInputType} vector - The vector(s) to search for.
   * @param {GenerateOptions<T>} generate - The available options for performing the generation.
   * @param {NearOptions<T>} [opts] - The available options for performing the near-vector search.
   * @return {GenerateReturn<T>} - The results of the search including the generated data.
   */
  nearVector(
    vector: NearVectorInputType,
    generate: GenerateOptions<T>,
    opts?: NearOptions<T>
  ): GenerateReturn<T>;
}

export interface Generate<T>
  extends Bm25<T>,
    Hybrid<T>,
    NearMedia<T>,
    NearObject<T>,
    NearText<T>,
    NearVector<T> {
  fetchObjects: (generate: GenerateOptions<T>, opts?: FetchObjectsOptions<T>) => Promise<GenerativeReturn<T>>;
}



---
File: /src/collections/iterator/index.ts
---

import { WeaviateDeserializationError } from '../../errors.js';
import { WeaviateObject } from '../types/index.js';

const ITERATOR_CACHE_SIZE = 100;

export class Iterator<T> {
  private cache: WeaviateObject<T>[] = [];
  private last: string | undefined = undefined;
  constructor(private query: (limit: number, after?: string) => Promise<WeaviateObject<T>[]>) {
    this.query = query;
  }

  [Symbol.asyncIterator]() {
    return {
      next: async (): Promise<IteratorResult<WeaviateObject<T>>> => {
        const objects = await this.query(ITERATOR_CACHE_SIZE, this.last);
        this.cache = objects;
        if (this.cache.length == 0) {
          return {
            done: true,
            value: undefined,
          };
        }
        const obj = this.cache.shift();
        if (obj === undefined) {
          throw new WeaviateDeserializationError('Object iterator returned an object that is undefined');
        }
        this.last = obj?.uuid;
        if (this.last === undefined) {
          throw new WeaviateDeserializationError('Object iterator returned an object without a UUID');
        }
        return {
          done: false,
          value: obj,
        };
      },
    };
  }
}



---
File: /src/collections/iterator/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
import weaviate, { WeaviateClient } from '../../index.js';
import { Collection } from '../collection/index.js';

describe('Testing of the collection.iterator method with a simple collection', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionIterator, 'TestCollectionIterator'>;
  const collectionName = 'TestCollectionIterator';
  let id: string;
  let vector: number[];

  type TestCollectionIterator = {
    testProp: string;
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal({ port: 8080, grpcPort: 50051 });
    collection = client.collections.get(collectionName);
    id = await client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary({
          vectorizeCollectionName: false,
        }),
      })
      .then(() => {
        return collection.data.insert({
          properties: {
            testProp: 'test',
          },
        });
      });
    const res = await collection.query.fetchObjectById(id, { includeVector: true });
    vector = res?.vectors.default!;
  });

  it('should iterate through the collection with no options returning the objects', async () => {
    let count = 0;
    for await (const obj of collection.iterator()) {
      expect(obj.properties.testProp).toBe('test');
      expect(obj.uuid).toBe(id);
      expect(obj.vectors.default).toBeUndefined();
      count++; // eslint-disable-line no-plusplus
    }
    expect(count).toBe(1);
  });

  it('should iterate through the collection specifying return properties', async () => {
    let count = 0;
    for await (const obj of collection.iterator({ returnProperties: ['testProp'] })) {
      expect(obj.properties.testProp).toBe('test');
      expect(obj.uuid).toBe(id);
      expect(obj.vectors.default).toBeUndefined();
      count++; // eslint-disable-line no-plusplus
    }
    expect(count).toBe(1);
  });

  it('should iterate through the collection specifying return metadata', async () => {
    let count = 0;
    for await (const obj of collection.iterator({ returnMetadata: ['creationTime'] })) {
      expect(obj.properties.testProp).toBe('test');
      expect(obj.uuid).toBe(id);
      expect(obj.vectors.default).toBeUndefined();
      expect(obj.metadata?.creationTime).toBeDefined();
      count++; // eslint-disable-line no-plusplus
    }
    expect(count).toBe(1);
  });

  it('should iterate through the collection specifying include vector', async () => {
    let count = 0;
    for await (const obj of collection.iterator({ includeVector: true })) {
      expect(obj.properties.testProp).toBe('test');
      expect(obj.uuid).toBe(id);
      expect(obj.vectors.default).toEqual(vector);
      count++; // eslint-disable-line no-plusplus
    }
    expect(count).toBe(1);
  });
});



---
File: /src/collections/query/check.ts
---

import Connection from '../../connection/grpc.js';
import { WeaviateUnsupportedFeatureError } from '../../errors.js';
import { ConsistencyLevel } from '../../index.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';
import { GroupByOptions } from '../index.js';
import { Serialize } from '../serialize/index.js';
import {
  BaseBm25Options,
  BaseHybridOptions,
  BaseNearOptions,
  FetchObjectByIdOptions,
  FetchObjectsOptions,
  HybridNearTextSubSearch,
  HybridNearVectorSubSearch,
  HybridOptions,
  NearVectorInputType,
  SearchOptions,
} from './types.js';

export class Check<T> {
  private connection: Connection;
  private name: string;
  public dbVersionSupport: DbVersionSupport;
  private consistencyLevel?: ConsistencyLevel;
  private tenant?: string;

  public constructor(
    connection: Connection,
    name: string,
    dbVersionSupport: DbVersionSupport,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ) {
    this.connection = connection;
    this.name = name;
    this.dbVersionSupport = dbVersionSupport;
    this.consistencyLevel = consistencyLevel;
    this.tenant = tenant;
  }

  private getSearcher = () => this.connection.search(this.name, this.consistencyLevel, this.tenant);

  private checkSupportForNamedVectors = async (opts?: BaseNearOptions<T>) => {
    if (!Serialize.isNamedVectors(opts)) return;
    const check = await this.dbVersionSupport.supportsNamedVectors();
    if (!check.supports) throw new WeaviateUnsupportedFeatureError(check.message);
  };

  private checkSupportForBm25AndHybridGroupByQueries = async (
    query: 'Bm25' | 'Hybrid',
    opts?: SearchOptions<T> | GroupByOptions<T>
  ) => {
    if (!Serialize.isGroupBy(opts)) return;
    const check = await this.dbVersionSupport.supportsBm25AndHybridGroupByQueries();
    if (!check.supports) throw new WeaviateUnsupportedFeatureError(check.message(query));
  };

  private checkSupportForHybridNearTextAndNearVectorSubSearches = async (opts?: HybridOptions<T>) => {
    if (opts?.vector === undefined || Array.isArray(opts.vector)) return;
    const check = await this.dbVersionSupport.supportsHybridNearTextAndNearVectorSubsearchQueries();
    if (!check.supports) throw new WeaviateUnsupportedFeatureError(check.message);
  };

  private checkSupportForMultiTargetSearch = async (opts?: BaseNearOptions<T>) => {
    if (!Serialize.isMultiTarget(opts)) return false;
    const check = await this.dbVersionSupport.supportsMultiTargetVectorSearch();
    if (!check.supports) throw new WeaviateUnsupportedFeatureError(check.message);
    return check.supports;
  };

  private checkSupportForMultiVectorSearch = async (
    vec?: NearVectorInputType | HybridNearVectorSubSearch | HybridNearTextSubSearch
  ) => {
    if (vec === undefined || Serialize.isHybridNearTextSearch(vec)) return false;
    if (Serialize.isHybridNearVectorSearch(vec) && !Serialize.isMultiVector(vec.vector)) return false;
    if (Serialize.isHybridVectorSearch(vec) && !Serialize.isMultiVector(vec)) return false;
    const check = await this.dbVersionSupport.supportsMultiVectorSearch();
    if (!check.supports) throw new WeaviateUnsupportedFeatureError(check.message);
    return check.supports;
  };

  private checkSupportForMultiWeightPerTargetSearch = async (opts?: BaseNearOptions<T>) => {
    if (!Serialize.isMultiWeightPerTarget(opts)) return false;
    const check = await this.dbVersionSupport.supportsMultiWeightsPerTargetSearch();
    if (!check.supports) throw new WeaviateUnsupportedFeatureError(check.message);
    return check.supports;
  };

  private checkSupportForMultiVectorPerTargetSearch = async (
    vec?: NearVectorInputType | HybridNearVectorSubSearch | HybridNearTextSubSearch
  ) => {
    if (vec === undefined || Serialize.isHybridNearTextSearch(vec)) return false;
    if (Serialize.isHybridNearVectorSearch(vec) && !Serialize.isMultiVectorPerTarget(vec.vector))
      return false;
    if (Serialize.isHybridVectorSearch(vec) && !Serialize.isMultiVectorPerTarget(vec)) return false;
    const check = await this.dbVersionSupport.supportsMultiVectorPerTargetSearch();
    if (!check.supports) throw new WeaviateUnsupportedFeatureError(check.message);
    return check.supports;
  };

  public nearSearch = (opts?: BaseNearOptions<T>) => {
    return Promise.all([
      this.getSearcher(),
      this.checkSupportForMultiTargetSearch(opts),
      this.checkSupportForMultiWeightPerTargetSearch(opts),
      this.checkSupportForNamedVectors(opts),
    ]).then(([search, supportsTargets, supportsWeightsForTargets]) => {
      const is126 = supportsTargets;
      const is127 = supportsWeightsForTargets;
      return { search, supportsTargets: is126 || is127, supportsWeightsForTargets: is127 };
    });
  };

  public nearVector = (vec: NearVectorInputType, opts?: BaseNearOptions<T>) => {
    return Promise.all([
      this.getSearcher(),
      this.checkSupportForMultiTargetSearch(opts),
      this.checkSupportForMultiVectorSearch(vec),
      this.checkSupportForMultiVectorPerTargetSearch(vec),
      this.checkSupportForMultiWeightPerTargetSearch(opts),
      this.checkSupportForNamedVectors(opts),
    ]).then(
      ([
        search,
        supportsMultiTarget,
        supportsMultiVector,
        supportsVectorsForTargets,
        supportsWeightsForTargets,
      ]) => {
        const is126 = supportsMultiTarget || supportsMultiVector;
        const is127 = supportsVectorsForTargets || supportsWeightsForTargets;
        return {
          search,
          supportsTargets: is126 || is127,
          supportsVectorsForTargets: is127,
          supportsWeightsForTargets: is127,
        };
      }
    );
  };

  public hybridSearch = (opts?: BaseHybridOptions<T>) => {
    return Promise.all([
      this.getSearcher(),
      this.checkSupportForMultiTargetSearch(opts),
      this.checkSupportForMultiVectorSearch(opts?.vector),
      this.checkSupportForMultiVectorPerTargetSearch(opts?.vector),
      this.checkSupportForMultiWeightPerTargetSearch(opts),
      this.checkSupportForNamedVectors(opts),
      this.checkSupportForBm25AndHybridGroupByQueries('Hybrid', opts),
      this.checkSupportForHybridNearTextAndNearVectorSubSearches(opts),
    ]).then(
      ([
        search,
        supportsMultiTarget,
        supportsMultiVector,
        supportsWeightsForTargets,
        supportsVectorsForTargets,
      ]) => {
        const is126 = supportsMultiTarget || supportsMultiVector;
        const is127 = supportsVectorsForTargets || supportsWeightsForTargets;
        return {
          search,
          supportsTargets: is126 || is127,
          supportsWeightsForTargets: is127,
          supportsVectorsForTargets: is127,
        };
      }
    );
  };

  public fetchObjects = (opts?: FetchObjectsOptions<T>) => {
    return Promise.all([this.getSearcher(), this.checkSupportForNamedVectors(opts)]).then(([search]) => {
      return { search };
    });
  };

  public fetchObjectById = (opts?: FetchObjectByIdOptions<T>) => {
    return Promise.all([this.getSearcher(), this.checkSupportForNamedVectors(opts)]).then(([search]) => {
      return { search };
    });
  };

  public bm25 = (opts?: BaseBm25Options<T>) => {
    return Promise.all([
      this.getSearcher(),
      this.checkSupportForNamedVectors(opts),
      this.checkSupportForBm25AndHybridGroupByQueries('Bm25', opts),
    ]).then(([search]) => {
      return { search };
    });
  };
}



---
File: /src/collections/query/index.ts
---

import Connection from '../../connection/grpc.js';

import { toBase64FromMedia } from '../../utils/base64.js';

import { ConsistencyLevel } from '../../data/index.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';

import { SearchReply } from '../../proto/v1/search_get.js';
import { Deserialize } from '../deserialize/index.js';
import { Serialize } from '../serialize/index.js';
import { GroupByOptions, GroupByReturn, WeaviateObject, WeaviateReturn } from '../types/index.js';

import { WeaviateInvalidInputError } from '../../errors.js';
import { Check } from './check.js';
import {
  BaseBm25Options,
  BaseHybridOptions,
  BaseNearOptions,
  BaseNearTextOptions,
  Bm25Options,
  FetchObjectByIdOptions,
  FetchObjectsOptions,
  GroupByBm25Options,
  GroupByHybridOptions,
  GroupByNearOptions,
  GroupByNearTextOptions,
  HybridOptions,
  NearMediaType,
  NearOptions,
  NearTextOptions,
  NearVectorInputType,
  Query,
  QueryReturn,
  SearchOptions,
} from './types.js';

class QueryManager<T> implements Query<T> {
  private check: Check<T>;

  private constructor(check: Check<T>) {
    this.check = check;
  }

  public static use<T>(
    connection: Connection,
    name: string,
    dbVersionSupport: DbVersionSupport,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ): QueryManager<T> {
    return new QueryManager<T>(new Check<T>(connection, name, dbVersionSupport, consistencyLevel, tenant));
  }

  private async parseReply(reply: SearchReply) {
    const deserialize = await Deserialize.use(this.check.dbVersionSupport);
    return deserialize.query<T>(reply);
  }

  private async parseGroupByReply(
    opts: SearchOptions<T> | GroupByOptions<T> | undefined,
    reply: SearchReply
  ) {
    const deserialize = await Deserialize.use(this.check.dbVersionSupport);
    return Serialize.isGroupBy(opts) ? deserialize.groupBy<T>(reply) : deserialize.query<T>(reply);
  }

  public fetchObjectById(id: string, opts?: FetchObjectByIdOptions<T>): Promise<WeaviateObject<T> | null> {
    return this.check
      .fetchObjectById(opts)
      .then(({ search }) => search.withFetch(Serialize.fetchObjectById({ id, ...opts })))
      .then((reply) => this.parseReply(reply))
      .then((ret) => (ret.objects.length === 1 ? ret.objects[0] : null));
  }

  public fetchObjects(opts?: FetchObjectsOptions<T>): Promise<WeaviateReturn<T>> {
    return this.check
      .fetchObjects(opts)
      .then(({ search }) => search.withFetch(Serialize.fetchObjects(opts)))
      .then((reply) => this.parseReply(reply));
  }

  public bm25(query: string, opts?: BaseBm25Options<T>): Promise<WeaviateReturn<T>>;
  public bm25(query: string, opts: GroupByBm25Options<T>): Promise<GroupByReturn<T>>;
  public bm25(query: string, opts?: Bm25Options<T>): QueryReturn<T> {
    return this.check
      .bm25(opts)
      .then(({ search }) =>
        search.withBm25({
          ...Serialize.bm25({ query, ...opts }),
          groupBy: Serialize.isGroupBy<GroupByBm25Options<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public hybrid(query: string, opts?: BaseHybridOptions<T>): Promise<WeaviateReturn<T>>;
  public hybrid(query: string, opts: GroupByHybridOptions<T>): Promise<GroupByReturn<T>>;
  public hybrid(query: string, opts?: HybridOptions<T>): QueryReturn<T> {
    return this.check
      .hybridSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets, supportsVectorsForTargets }) =>
        search.withHybrid({
          ...Serialize.hybrid({
            query,
            supportsTargets,
            supportsVectorsForTargets,
            supportsWeightsForTargets,
            ...opts,
          }),
          groupBy: Serialize.isGroupBy<GroupByHybridOptions<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearImage(image: string | Buffer, opts?: BaseNearOptions<T>): Promise<WeaviateReturn<T>>;
  public nearImage(image: string | Buffer, opts: GroupByNearOptions<T>): Promise<GroupByReturn<T>>;
  public nearImage(image: string | Buffer, opts?: NearOptions<T>): QueryReturn<T> {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) => {
        return toBase64FromMedia(image).then((image) =>
          search.withNearImage({
            ...Serialize.nearImage({
              image,
              supportsTargets,
              supportsWeightsForTargets,
              ...(opts ? opts : {}),
            }),
            groupBy: Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
              ? Serialize.groupBy(opts.groupBy)
              : undefined,
          })
        );
      })
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    opts?: BaseNearOptions<T>
  ): Promise<WeaviateReturn<T>>;
  public nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    opts: GroupByNearOptions<T>
  ): Promise<GroupByReturn<T>>;
  public nearMedia(media: string | Buffer, type: NearMediaType, opts?: NearOptions<T>): QueryReturn<T> {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) => {
        const args = {
          supportsTargets,
          supportsWeightsForTargets,
          ...(opts ? opts : {}),
        };
        let reply: Promise<SearchReply>;
        switch (type) {
          case 'audio':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearAudio(Serialize.nearAudio({ audio: media, ...args }))
            );
            break;
          case 'depth':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearDepth(Serialize.nearDepth({ depth: media, ...args }))
            );
            break;
          case 'image':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearImage(Serialize.nearImage({ image: media, ...args }))
            );
            break;
          case 'imu':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearIMU(Serialize.nearIMU({ imu: media, ...args }))
            );
            break;
          case 'thermal':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearThermal(Serialize.nearThermal({ thermal: media, ...args }))
            );
            break;
          case 'video':
            reply = toBase64FromMedia(media).then((media) =>
              search.withNearVideo(Serialize.nearVideo({ video: media, ...args }))
            );
            break;
          default:
            throw new WeaviateInvalidInputError(`Invalid media type: ${type}`);
        }
        return reply;
      })
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearObject(id: string, opts?: BaseNearOptions<T>): Promise<WeaviateReturn<T>>;
  public nearObject(id: string, opts: GroupByNearOptions<T>): Promise<GroupByReturn<T>>;
  public nearObject(id: string, opts?: NearOptions<T>): QueryReturn<T> {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) =>
        search.withNearObject({
          ...Serialize.nearObject({
            id,
            supportsTargets,
            supportsWeightsForTargets,
            ...(opts ? opts : {}),
          }),
          groupBy: Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearText(query: string | string[], opts?: BaseNearTextOptions<T>): Promise<WeaviateReturn<T>>;
  public nearText(query: string | string[], opts: GroupByNearTextOptions<T>): Promise<GroupByReturn<T>>;
  public nearText(query: string | string[], opts?: NearTextOptions<T>): QueryReturn<T> {
    return this.check
      .nearSearch(opts)
      .then(({ search, supportsTargets, supportsWeightsForTargets }) =>
        search.withNearText({
          ...Serialize.nearText({
            query,
            supportsTargets,
            supportsWeightsForTargets,
            ...(opts ? opts : {}),
          }),
          groupBy: Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }

  public nearVector(vector: NearVectorInputType, opts?: BaseNearOptions<T>): Promise<WeaviateReturn<T>>;
  public nearVector(vector: NearVectorInputType, opts: GroupByNearOptions<T>): Promise<GroupByReturn<T>>;
  public nearVector(vector: NearVectorInputType, opts?: NearOptions<T>): QueryReturn<T> {
    return this.check
      .nearVector(vector, opts)
      .then(({ search, supportsTargets, supportsVectorsForTargets, supportsWeightsForTargets }) =>
        search.withNearVector({
          ...Serialize.nearVector({
            vector,
            supportsTargets,
            supportsVectorsForTargets,
            supportsWeightsForTargets,
            ...(opts ? opts : {}),
          }),
          groupBy: Serialize.isGroupBy<GroupByNearOptions<T>>(opts)
            ? Serialize.groupBy(opts.groupBy)
            : undefined,
        })
      )
      .then((reply) => this.parseGroupByReply(opts, reply));
  }
}

export default QueryManager.use;

export {
  BaseBm25Options,
  BaseHybridOptions,
  BaseNearOptions,
  BaseNearTextOptions,
  Bm25Options,
  FetchObjectByIdOptions,
  FetchObjectsOptions,
  GroupByBm25Options,
  GroupByHybridOptions,
  GroupByNearOptions,
  GroupByNearTextOptions,
  HybridNearTextSubSearch,
  HybridNearVectorSubSearch,
  HybridOptions,
  HybridSubSearchBase,
  MoveOptions,
  NearMediaType,
  NearOptions,
  NearTextOptions,
  Query,
  QueryReturn,
  SearchOptions,
} from './types.js';



---
File: /src/collections/query/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
import { WeaviateUnsupportedFeatureError } from '../../errors.js';
import weaviate, { WeaviateClient } from '../../index.js';
import { Collection } from '../collection/index.js';
import { CrossReference, Reference } from '../references/index.js';
import { GroupByOptions } from '../types/index.js';

describe('Testing of the collection.query methods with a simple collection', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionQueryMinimalOptions, 'TestCollectionQueryMinimalOptions'>;
  const collectionName = 'TestCollectionQueryMinimalOptions';
  let id: string;
  let vector: number[];

  type TestCollectionQueryMinimalOptions = {
    testProp: string;
    testProp2: string;
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    id = await client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
            vectorizePropertyName: false,
          },
          {
            name: 'testProp2',
            dataType: 'text',
            vectorizePropertyName: false,
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary({
          vectorizeCollectionName: false,
        }),
      })
      .then(async () => {
        await collection.data.insert({
          properties: {
            testProp: 'apple',
            testProp2: 'banana',
          },
        });
        return collection.data.insert({
          properties: {
            testProp: 'carrot',
            testProp2: 'parsnip',
          },
        });
      });
    const res = await collection.query.fetchObjectById(id, { includeVector: true });
    vector = res?.vectors.default!;
  });

  it('should fetch an object by its id', async () => {
    const object = await collection.query.fetchObjectById(id);
    expect(object?.properties.testProp).toEqual('carrot');
    expect(object?.uuid).toEqual(id);
  });

  it('should query without search', async () => {
    const ret = await collection.query.fetchObjects();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.testProp).toBeDefined();
    expect(ret.objects[0].uuid).toBeDefined();
  });

  it('should query without search specifying return properties', async () => {
    const ret = await collection.query.fetchObjects({
      returnProperties: ['testProp'],
    });
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.testProp).toBeDefined();
    expect(ret.objects[0].properties.testProp2).toBeUndefined();
    expect(ret.objects[0].uuid).toBeDefined();
  });

  it('should query with bm25', async () => {
    const ret = await collection.query.bm25('carrot');
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
    expect(ret.objects[0].uuid).toEqual(id);
  });

  it('should query with bm25 and weighted query properties', async () => {
    const ret = await collection.query.bm25('carrot', {
      queryProperties: [
        {
          name: 'testProp',
          weight: 2,
        },
        'testProp2',
      ],
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
    expect(ret.objects[0].uuid).toEqual(id);
  });

  it('should query with bm25 and weighted query properties with a non-generic collection', async () => {
    const ret = await client.collections.get(collectionName).query.bm25('carrot', {
      queryProperties: [
        {
          name: 'testProp',
          weight: 2,
        },
        'testProp2',
      ],
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
    expect(ret.objects[0].uuid).toEqual(id);
  });

  it('should query with hybrid', async () => {
    const ret = await collection.query.hybrid('carrot', { limit: 1 });
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
    expect(ret.objects[0].uuid).toEqual(id);
  });

  it('should query with hybrid and vector', async () => {
    const ret = await collection.query.hybrid('carrot', {
      limit: 1,
      vector: vector,
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
    expect(ret.objects[0].uuid).toEqual(id);
  });

  it('should query with hybrid and near text subsearch', async () => {
    const query = () =>
      collection.query.hybrid('carrot', {
        limit: 1,
        vector: {
          query: 'apple',
          distance: 0.9,
          moveTo: {
            concepts: ['banana'],
            force: 0.9,
          },
          moveAway: {
            concepts: ['carrot'],
            force: 0.1,
          },
        },
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('apple');
  });

  it('should query with hybrid and near vector subsearch', async () => {
    const query = () =>
      collection.query.hybrid('carrot', {
        limit: 1,
        vector: {
          vector: vector,
          distance: 0.9,
        },
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
  });

  it('should query with nearObject', async () => {
    const ret = await collection.query.nearObject(id, { limit: 1 });
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
    expect(ret.objects[0].uuid).toEqual(id);
  });

  it('should query with nearText', async () => {
    const ret = await collection.query.nearText(['carrot'], { limit: 1 });
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
    expect(ret.objects[0].uuid).toEqual(id);
  });

  it('should query with nearVector', async () => {
    const ret = await collection.query.nearVector(vector, { limit: 1 });
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.testProp).toEqual('carrot');
    expect(ret.objects[0].uuid).toEqual(id);
  });
});

describe('Testing of the collection.query methods with a collection with a reference property', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionQueryWithRefProp, 'TestCollectionQueryWithRefProp'>;
  const collectionName = 'TestCollectionQueryWithRefProp';

  let id1: string;
  let id2: string;

  type TestCollectionQueryWithRefProp = {
    testProp: string;
    refProp?: CrossReference<TestCollectionQueryWithRefProp>;
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    return client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
            vectorizePropertyName: false,
          },
        ],
        references: [
          {
            name: 'refProp',
            targetCollection: collectionName,
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary({
          vectorizeCollectionName: false,
        }),
      })
      .then(async () => {
        id1 = await collection.data.insert({
          properties: {
            testProp: 'test',
          },
        });
        id2 = await collection.data.insert({
          properties: {
            testProp: 'other',
          },
          references: {
            refProp: Reference.to<TestCollectionQueryWithRefProp>(id1),
          },
        });
      });
  });

  describe('using a non-generic collection', () => {
    it('should query without searching returning the referenced object', async () => {
      const ret = await client.collections.get(collectionName).query.fetchObjects({
        returnProperties: ['testProp'],
        returnReferences: [
          {
            linkOn: 'refProp',
            returnProperties: ['testProp'],
            returnReferences: [
              {
                linkOn: 'refProp',
                returnProperties: ['testProp'],
              },
            ],
          },
        ],
      });
      ret.objects.sort((a, b) =>
        (a.properties.testProp as string).localeCompare(b.properties.testProp as string)
      );
      expect(ret.objects.length).toEqual(2);
      expect(ret.objects[0].properties.testProp).toEqual('other');
      expect(ret.objects[0].references?.refProp?.objects[0].properties?.testProp).toEqual('test');
      expect(ret.objects[0].references?.refProp?.objects[0].references).toBeUndefined();
      expect(ret.objects[1].properties.testProp).toEqual('test');
      expect(ret.objects[1].references?.refProp).toBeUndefined();
    });
  });

  describe('using a generic collection', () => {
    it('should query without searching returning the referenced object', async () => {
      const ret = await collection.query.fetchObjects({
        returnProperties: ['testProp'],
        returnReferences: [
          {
            linkOn: 'refProp',
            returnProperties: ['testProp'],
            returnReferences: [
              {
                linkOn: 'refProp',
                returnProperties: ['testProp'],
              },
            ],
          },
        ],
      });
      ret.objects.sort((a, b) => a.properties.testProp.localeCompare(b.properties.testProp));
      expect(ret.objects.length).toEqual(2);
      expect(ret.objects[0].properties.testProp).toEqual('other');
      expect(ret.objects[0].references?.refProp?.objects[0].properties?.testProp).toEqual('test');
      expect(ret.objects[0].references?.refProp?.objects[0].references).toBeUndefined();
      expect(ret.objects[1].properties.testProp).toEqual('test');
      expect(ret.objects[1].references?.refProp).toBeUndefined();
    });

    it('should query with bm25 returning the referenced object', async () => {
      const ret = await collection.query.bm25('other', {
        returnProperties: ['testProp'],
        returnReferences: [
          {
            linkOn: 'refProp',
            returnProperties: ['testProp'],
          },
        ],
      });
      expect(ret.objects.length).toEqual(1);
      expect(ret.objects.map((obj) => obj.properties.testProp).includes('other')).toEqual(true);
      expect(
        ret.objects.find((obj) => obj.properties.testProp === 'other')?.references?.refProp?.objects.length
      ).toEqual(1);
      expect(
        ret.objects.find((obj) => obj.properties.testProp === 'other')?.references?.refProp?.objects[0]
          .properties?.testProp
      ).toEqual('test');
    });

    it('should query with hybrid returning the referenced object', async () => {
      const ret = await collection.query.hybrid('other', {
        returnProperties: ['testProp'],
        returnReferences: [
          {
            linkOn: 'refProp',
            returnProperties: ['testProp'],
          },
        ],
      });
      expect(ret.objects.length).toEqual(2);
      expect(ret.objects.map((obj) => obj.properties.testProp).includes('other')).toEqual(true);
      expect(
        ret.objects.find((obj) => obj.properties.testProp === 'other')?.references?.refProp?.objects.length
      ).toEqual(1);
      expect(
        ret.objects.find((obj) => obj.properties.testProp === 'other')?.references?.refProp?.objects[0]
          .properties?.testProp
      ).toEqual('test');
    });

    it('should query with nearObject returning the referenced object', async () => {
      const ret = await collection.query.nearObject(id2, {
        returnProperties: ['testProp'],
        returnReferences: [
          {
            linkOn: 'refProp',
            returnProperties: ['testProp'],
          },
        ],
      });
      expect(ret.objects.length).toEqual(2);
      expect(ret.objects.map((obj) => obj.properties.testProp).includes('other')).toEqual(true);
      expect(
        ret.objects.find((obj) => obj.properties.testProp === 'other')?.references?.refProp?.objects.length
      ).toEqual(1);
      expect(
        ret.objects.find((obj) => obj.properties.testProp === 'other')?.references?.refProp?.objects[0]
          .properties?.testProp
      ).toEqual('test');
    });

    it('should fetch an object by its ID returning its references', async () => {
      const res = await collection.query.fetchObjectById(id2, {
        returnReferences: [{ linkOn: 'refProp' }],
      });
      expect(res?.properties.testProp).toEqual('other');
      expect(res?.references?.refProp?.objects.length).toEqual(1);
      expect(res?.references?.refProp?.objects[0].properties?.testProp).toEqual('test');
    });

    it('should query with nearVector returning the referenced object', async () => {
      const res = await collection.query.fetchObjectById(id2, { includeVector: true });
      const ret = await collection.query.nearVector(res?.vectors.default!, {
        returnProperties: ['testProp'],
        returnReferences: [
          {
            linkOn: 'refProp',
            returnProperties: ['testProp'],
          },
        ],
      });
      expect(ret.objects.length).toEqual(2);
      expect(ret.objects.map((obj) => obj.properties.testProp).includes('other')).toEqual(true);
      expect(
        ret.objects.find((obj) => obj.properties.testProp === 'other')?.references?.refProp?.objects.length
      ).toEqual(1);
      expect(
        ret.objects.find((obj) => obj.properties.testProp === 'other')?.references?.refProp?.objects[0]
          .properties?.testProp
      ).toEqual('test');
    });
  });
});

describe('Testing of the collection.query methods with a collection with a nested property', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionQueryWithNestedProps, 'TestCollectionQueryWithNestedProps'>;
  const collectionName = 'TestCollectionQueryWithNestedProps';

  let id1: string;
  let id2: string;

  type TestCollectionQueryWithNestedProps = {
    testProp: string;
    nestedProp?: {
      one: string;
      two: string;
      again?: {
        three: string;
      };
      onceMore?: {
        four: string;
      };
    };
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    return client.collections
      .create<TestCollectionQueryWithNestedProps>({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
            vectorizePropertyName: false,
          },
          {
            name: 'nestedProp',
            dataType: 'object',
            vectorizePropertyName: false,
            nestedProperties: [
              {
                name: 'one',
                dataType: 'text',
              },
              {
                name: 'two',
                dataType: 'text',
              },
              {
                name: 'again',
                dataType: 'object',
                nestedProperties: [
                  {
                    name: 'three',
                    dataType: 'text',
                  },
                ],
              },
              {
                name: 'onceMore',
                dataType: 'object',
                nestedProperties: [
                  {
                    name: 'four',
                    dataType: 'text',
                  },
                ],
              },
            ],
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary(),
      })
      .then(async () => {
        id1 = await collection.data.insert({
          properties: {
            testProp: 'test',
          },
        });
        id2 = await collection.data.insert({
          properties: {
            testProp: 'other',
            nestedProp: {
              one: 'test',
              two: 'test',
              again: {
                three: 'test',
              },
              onceMore: {
                four: 'test',
              },
            },
          },
        });
      });
  });

  it('should query without searching returning the nested object', async () => {
    const ret = await collection.query.fetchObjects({
      returnProperties: [
        'testProp',
        {
          name: 'nestedProp',
          properties: [
            'one',
            {
              name: 'again',
              properties: ['three'],
            },
            {
              name: 'onceMore',
              properties: ['four'],
            },
          ],
        },
      ],
    });
    ret.objects.sort((a, b) => a.properties.testProp.localeCompare(b.properties.testProp));
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.testProp).toEqual('other');
    expect(ret.objects[0].properties.nestedProp?.one).toEqual('test');
    expect(ret.objects[0].properties.nestedProp?.two).toBeUndefined();
    expect(ret.objects[0].properties.nestedProp?.again?.three).toEqual('test');
    expect(ret.objects[0].properties.nestedProp?.onceMore?.four).toEqual('test');
    expect(ret.objects[1].properties.testProp).toEqual('test');
    expect(ret.objects[1].properties.nestedProp).toBeUndefined();
  });
});

describe('Testing of the collection.query methods with a collection with a multiple vectors', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionQueryWithMultiVector, 'TestCollectionQueryWithMultiVector'>;
  const collectionName = 'TestCollectionQueryWithMultiVector';

  let id1: string;
  let id2: string;

  type TestCollectionQueryWithMultiVector = {
    title: string;
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    const query = () =>
      client.collections
        .create<TestCollectionQueryWithMultiVector>({
          name: collectionName,
          properties: [
            {
              name: 'title',
              dataType: 'text',
              vectorizePropertyName: false,
            },
          ],
          vectorizers: [
            weaviate.configure.vectorizer.text2VecContextionary({
              name: 'title',
              sourceProperties: ['title'],
            }),
            weaviate.configure.vectorizer.text2VecContextionary({
              name: 'title2',
              sourceProperties: ['title'],
            }),
          ],
        })
        .then(async () => {
          id1 = await collection.data.insert({
            properties: {
              title: 'test',
            },
          });
          id2 = await collection.data.insert({
            properties: {
              title: 'other',
            },
          });
        });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    return query();
  });

  it('should query returning a named vector', async () => {
    const query = () =>
      collection.query.fetchObjects({
        returnProperties: ['title'],
        includeVector: ['title'],
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    ret.objects.sort((a, b) => a.properties.title.localeCompare(b.properties.title));
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[0].vectors.title).toBeDefined();
    expect(ret.objects[1].properties.title).toEqual('test');
    expect(ret.objects[1].vectors.title).toBeDefined();
  });

  it('should query without searching returning a named vector', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      return;
    }
    const ret = await collection.query.fetchObjects({
      returnProperties: ['title'],
      includeVector: ['title'],
    });
    ret.objects.sort((a, b) => a.properties.title.localeCompare(b.properties.title));
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[0].vectors.title).toBeDefined();
    expect(ret.objects[1].properties.title).toEqual('test');
    expect(ret.objects[1].vectors.title).toBeDefined();
  });

  it('should query with a vector search over the named vector space', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 24, 0))) {
      return;
    }
    const ret = await collection.query.nearObject(id1, {
      returnProperties: ['title'],
      targetVector: 'title',
    });
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('test');
    expect(ret.objects[1].properties.title).toEqual('other');
  });

  it('should query a nearObject multi-target vector search over the named vector spaces', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      return;
    }
    const ret = await collection.query.nearObject(id1, {
      returnProperties: ['title'],
      targetVector: ['title', 'title2'],
    });
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('test');
    expect(ret.objects[1].properties.title).toEqual('other');
  });

  it('should group-by query a nearObject multi-target vector search over the named vector spaces', async () => {
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      return;
    }
    const ret = await collection.query.nearObject(id1, {
      returnProperties: ['title'],
      targetVector: ['title', 'title2'],
      groupBy: {
        numberOfGroups: 2,
        objectsPerGroup: 1,
        property: 'title',
      },
    });
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
    expect(ret.objects[1].belongsToGroup).toEqual('other');
  });

  it('should query a weighted multi-target nearObject vector search over the named vector spaces', async () => {
    const query = () =>
      collection.query.nearObject(id1, {
        distance: 0.01,
        returnProperties: ['title'],
        targetVector: collection.multiTargetVector.manualWeights({
          title: 5,
          title2: 0.1,
        }),
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.title).toEqual('test');
  });

  it('should query a weighted multi-target nearObject vector search with multiple weights over the named vector spaces', async () => {
    const query = () =>
      collection.query.nearObject(id1, {
        distance: 0.01,
        returnProperties: ['title'],
        targetVector: collection.multiTargetVector.manualWeights({
          title: 5,
          title2: [0.1, 0.2],
        }),
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 27, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(1);
    expect(ret.objects[0].properties.title).toEqual('test');
  });

  it('should group-by query a weighted multi-target nearObject vector search over the named vector spaces', async () => {
    const query = () =>
      collection.query.nearObject(id1, {
        returnProperties: ['title'],
        targetVector: collection.multiTargetVector.sum(['title', 'title2']),
        groupBy: {
          numberOfGroups: 2,
          objectsPerGroup: 1,
          property: 'title',
        },
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
    expect(ret.objects[1].belongsToGroup).toEqual('other');
  });

  it('should perform a hybrid query over the named vector spaces', async () => {
    const query = () =>
      collection.query.hybrid('test', {
        returnProperties: ['title'],
        targetVector: ['title', 'title2'],
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('test');
    expect(ret.objects[1].properties.title).toEqual('other');
  });

  it('should perform a group-by hybrid query over the named vector spaces', async () => {
    const query = () =>
      collection.query.hybrid('test', {
        returnProperties: ['title'],
        targetVector: ['title', 'title2'],
        groupBy: {
          numberOfGroups: 2,
          objectsPerGroup: 1,
          property: 'title',
        },
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
    expect(ret.objects[1].belongsToGroup).toEqual('other');
  });

  it('should perform a weighted sum hybrid query over the named vector spaces', async () => {
    const query = () =>
      collection.query.hybrid('test', {
        returnProperties: ['title'],
        targetVector: collection.multiTargetVector.sum(['title', 'title2']),
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('test');
    expect(ret.objects[1].properties.title).toEqual('other');
  });

  it('should perform a multi-vector hybrid search over the named vector spaces', async () => {
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.hybrid('', {
        alpha: 1,
        returnProperties: ['title'],
        vector: {
          title: two?.vectors.title!,
          title2: two?.vectors.title2!,
        },
      });

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[1].properties.title).toEqual('test');
  });

  it('should perform a multi-vector hybrid search over the named vector spaces with a combination', async () => {
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.hybrid('', {
        alpha: 1,
        returnProperties: ['title'],
        vector: {
          title: two?.vectors.title!,
          title2: two?.vectors.title2!,
        },
        targetVector: collection.multiTargetVector.sum(['title', 'title2']),
      });

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[1].properties.title).toEqual('test');
  });

  it('should perform a multi-vector hybrid nearVector subsearch over the named vector spaces', async () => {
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.hybrid('', {
        alpha: 1,
        returnProperties: ['title'],
        vector: {
          vector: {
            title: two?.vectors.title!,
            title2: two?.vectors.title2!,
          },
        },
      });

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[1].properties.title).toEqual('test');
  });

  it('should perform a multi-vector hybrid nearVector subsearch over the named vector spaces with combination', async () => {
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.hybrid('', {
        alpha: 1,
        returnProperties: ['title'],
        vector: {
          vector: {
            title: two?.vectors.title!,
            title2: two?.vectors.title2!,
          },
        },
        targetVector: collection.multiTargetVector.sum(['title', 'title2']),
      });

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[1].properties.title).toEqual('test');
  });

  it('should perform a multi-vector-per-target hybrid nearVector subsearch over the named vector spaces without weights', async () => {
    const one = await collection.query.fetchObjectById(id1, { includeVector: true });
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.hybrid('', {
        alpha: 1,
        returnProperties: ['title'],
        vector: {
          vector: {
            title: [one?.vectors.title!, two?.vectors.title!],
          },
        },
      });

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 27, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
  });

  it('should perform a multi-vector-per-target hybrid nearVector subsearch over the named vector spaces with weights', async () => {
    const one = await collection.query.fetchObjectById(id1, { includeVector: true });
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.hybrid('', {
        alpha: 1,
        returnProperties: ['title'],
        vector: {
          vector: {
            title: [one?.vectors.title!, two?.vectors.title!],
          },
        },
        targetVector: collection.multiTargetVector.manualWeights({
          title: [0.1, 0.9],
        }),
      });

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 27, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[1].properties.title).toEqual('test');
  });

  it('should perform a multi-vector-per-target hybrid search over the named vector spaces', async () => {
    const one = await collection.query.fetchObjectById(id1, { includeVector: true });
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.hybrid('', {
        alpha: 1,
        returnProperties: ['title'],
        vector: {
          title: [one?.vectors.title!, two?.vectors.title!],
        },
      });

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 27, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
  });

  it('should perform a multi-vector-per-target hybrid search with weights over the named vector spaces', async () => {
    const one = await collection.query.fetchObjectById(id1, { includeVector: true });
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.hybrid('', {
        alpha: 1,
        returnProperties: ['title'],
        vector: {
          title: [one?.vectors.title!, two?.vectors.title!],
        },
        targetVector: collection.multiTargetVector.manualWeights({
          title: [0.1, 0.9],
        }),
      });

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 27, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    // We are weighted the second vector higher, so we expect the second object to be returned first
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[1].properties.title).toEqual('test');
  });

  it('should perform a nearVector vector search over two named vector spaces', async () => {
    const one = await collection.query.fetchObjectById(id1, { includeVector: true });

    const query = () =>
      collection.query.nearVector(
        {
          title: one?.vectors.title!,
          title2: one?.vectors.title2!,
        },
        {
          returnProperties: ['title'],
        }
      );

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    // Since no bm25, the order is not guaranteed since we're searching on both vectors equally
    expect(ret.objects[0].properties.title).toEqual('test');
    expect(ret.objects[1].properties.title).toEqual('other');
  });

  it('should perform a multi-vector-per-target nearVector search over one named vector with weights', async () => {
    const one = await collection.query.fetchObjectById(id1, { includeVector: true });
    const two = await collection.query.fetchObjectById(id2, { includeVector: true });

    const query = () =>
      collection.query.nearVector(
        {
          title: [one?.vectors.title!, two?.vectors.title!],
        },
        {
          returnProperties: ['title'],
          targetVector: collection.multiTargetVector.manualWeights({
            title: [0.1, 0.9],
          }),
        }
      );

    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 27, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(2);
    // We are weighted the second vector higher, so we expect the second object to be returned first
    expect(ret.objects[0].properties.title).toEqual('other');
    expect(ret.objects[1].properties.title).toEqual('test');
  });
});

describe('Testing of the groupBy collection.query methods with a simple collection', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionGroupBySimple, 'TestCollectionGroupBySimple'>;
  const collectionName = 'TestCollectionGroupBySimple';
  let id: string;
  let vector: number[];

  type TestCollectionGroupBySimple = {
    testProp: string;
  };

  const groupByArgs: GroupByOptions<TestCollectionGroupBySimple> = {
    numberOfGroups: 1,
    objectsPerGroup: 1,
    property: 'testProp',
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    id = await client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary({
          vectorizeCollectionName: false,
        }),
      })
      .then(() => {
        return collection.data.insert({
          properties: {
            testProp: 'test',
          },
        });
      });
    const res = await collection.query.fetchObjectById(id, { includeVector: true });
    vector = res?.vectors.default!;
  });

  // it('should groupBy without search', async () => {
  //   const ret = await collection.groupBy.fetchObjects(groupByArgs);
  //   expect(ret.objects.length).toEqual(1);
  //   expect(ret.groups).toBeDefined();
  //   expect(Object.keys(ret.groups)).toEqual(['test']);
  //   expect(ret.objects[0].properties.testProp).toEqual('test');
  //   expect(ret.objects[0].metadata.uuid).toEqual(id);
  //   expect(ret.objects[0].belongsToGroup).toEqual('test');
  // });

  // it('should groupBy without search specifying return properties', async () => {
  //   const ret = await collection.groupBy.fetchObjects({
  //     returnProperties: ['testProp'],
  //     returnMetadata: ['uuid'],
  //     ...groupByArgs,
  //   });
  //   expect(ret.objects.length).toEqual(1);
  //   expect(ret.groups).toBeDefined();
  //   expect(Object.keys(ret.groups)).toEqual(['test']);
  //   expect(ret.objects[0].properties.testProp).toEqual('test');
  //   expect(ret.objects[0].metadata.uuid).toEqual(id);
  //   expect(ret.objects[0].belongsToGroup).toEqual('test');
  // });

  it('should groupBy with bm25', async () => {
    const query = () =>
      collection.query.bm25('test', {
        groupBy: groupByArgs,
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it('should groupBy with hybrid', async () => {
    const query = () =>
      collection.query.hybrid('test', {
        groupBy: groupByArgs,
      });
    if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
      await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
      return;
    }
    const ret = await query();
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it('should groupBy with nearObject', async () => {
    const ret = await collection.query.nearObject(id, {
      groupBy: groupByArgs,
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it('should groupBy with nearText', async () => {
    const ret = await collection.query.nearText(['test'], {
      groupBy: groupByArgs,
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it('should groupBy with nearVector', async () => {
    const ret = await collection.query.nearVector(vector, {
      groupBy: groupByArgs,
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });

  it('should groupBy with nearVector and a non-generic collection', async () => {
    const ret = await client.collections.get(collectionName).query.nearVector(vector, {
      groupBy: {
        numberOfGroups: 1,
        objectsPerGroup: 1,
        property: 'testProp',
      },
    });
    expect(ret.objects.length).toEqual(1);
    expect(ret.groups).toBeDefined();
    expect(Object.keys(ret.groups)).toEqual(['test']);
    expect(ret.objects[0].properties.testProp).toEqual('test');
    expect(ret.objects[0].uuid).toEqual(id);
    expect(ret.objects[0].belongsToGroup).toEqual('test');
  });
});

describe('Testing of the collection.query methods with a multi-tenancy collection', () => {
  let client: WeaviateClient;
  let collection: Collection<TestCollectionMultiTenancy, 'TestCollectionMultiTenancy'>;
  const collectionName = 'TestCollectionMultiTenancy';
  let id1: string;
  let id2: string;

  const tenantOne = { name: 'one' };
  const tenantTwo = { name: 'two' };

  type TestCollectionMultiTenancy = {
    testProp: string;
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    [id1, id2] = await client.collections
      .create<TestCollectionMultiTenancy>({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
        multiTenancy: weaviate.configure.multiTenancy({ enabled: true }),
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary({
          vectorizeCollectionName: false,
        }),
      })
      .then(async (col) => {
        await col.tenants.create([tenantOne, tenantTwo]);
        return col;
      })
      .then((col) =>
        Promise.all([
          col.withTenant(tenantOne).data.insert({
            properties: {
              testProp: 'one',
            },
          }),
          col.withTenant(tenantTwo).data.insert({
            properties: {
              testProp: 'two',
            },
          }),
        ])
      );
  });

  it('should find the objects in their tenants by ID', async () => {
    const obj1 = await collection.withTenant(tenantOne).query.fetchObjectById(id1);
    const obj2 = await collection.withTenant(tenantTwo).query.fetchObjectById(id2);
    expect(obj1?.properties.testProp).toEqual('one');
    expect(obj1?.uuid).toEqual(id1);
    expect(obj2?.properties.testProp).toEqual('two');
    expect(obj2?.uuid).toEqual(id2);
  });

  it('should return null if searching in the wrong tenant', async () => {
    const obj1 = await collection.withTenant(tenantTwo).query.fetchObjectById(id1);
    const obj2 = await collection.withTenant(tenantOne).query.fetchObjectById(id2);
    expect(obj1).toBeNull();
    expect(obj2).toBeNull();
  });

  it('should find the objects in their tenants by fetch', async () => {
    const obj1 = await collection.withTenant(tenantOne).query.fetchObjects();
    const obj2 = await collection.withTenant(tenantTwo).query.fetchObjects();
    expect(obj1.objects.length).toEqual(1);
    expect(obj1.objects[0].properties.testProp).toEqual('one');
    expect(obj1.objects[0].uuid).toEqual(id1);
    expect(obj2.objects.length).toEqual(1);
    expect(obj2.objects[0].properties.testProp).toEqual('two');
    expect(obj2.objects[0].uuid).toEqual(id2);
  });

  it('should find the objects in their tenants by bm25', async () => {
    const obj1 = await collection.withTenant(tenantOne).query.bm25('one');
    const obj2 = await collection.withTenant(tenantTwo).query.bm25('two');
    expect(obj1.objects.length).toEqual(1);
    expect(obj1.objects[0].properties.testProp).toEqual('one');
    expect(obj1.objects[0].uuid).toEqual(id1);
    expect(obj2.objects.length).toEqual(1);
    expect(obj2.objects[0].properties.testProp).toEqual('two');
    expect(obj2.objects[0].uuid).toEqual(id2);
  });

  it('should find the objects in their tenants by hybrid', async () => {
    const obj1 = await collection.withTenant(tenantOne).query.hybrid('one');
    const obj2 = await collection.withTenant(tenantTwo).query.hybrid('two');
    expect(obj1.objects.length).toEqual(1);
    expect(obj1.objects[0].properties.testProp).toEqual('one');
    expect(obj1.objects[0].uuid).toEqual(id1);
    expect(obj2.objects.length).toEqual(1);
    expect(obj2.objects[0].properties.testProp).toEqual('two');
    expect(obj2.objects[0].uuid).toEqual(id2);
  });

  it('should find the objects in their tenants by nearObject', async () => {
    const obj1 = await collection.withTenant(tenantOne).query.nearObject(id1);
    const obj2 = await collection.withTenant(tenantTwo).query.nearObject(id2);
    expect(obj1.objects.length).toEqual(1);
    expect(obj1.objects[0].properties.testProp).toEqual('one');
    expect(obj1.objects[0].uuid).toEqual(id1);
    expect(obj2.objects.length).toEqual(1);
    expect(obj2.objects[0].properties.testProp).toEqual('two');
    expect(obj2.objects[0].uuid).toEqual(id2);
  });

  it('should find the objects in their tenants by nearText', async () => {
    const obj1 = await collection.withTenant(tenantOne).query.nearText(['one']);
    const obj2 = await collection.withTenant(tenantTwo).query.nearText(['two']);
    expect(obj1.objects.length).toEqual(1);
    expect(obj1.objects[0].properties.testProp).toEqual('one');
    expect(obj1.objects[0].uuid).toEqual(id1);
    expect(obj2.objects.length).toEqual(1);
    expect(obj2.objects[0].properties.testProp).toEqual('two');
    expect(obj2.objects[0].uuid).toEqual(id2);
  });

  it('should find the objects in their tenants by nearVector', async () => {
    const { vectors: vecs1 } = (await collection
      .withTenant(tenantOne)
      .query.fetchObjectById(id1, { includeVector: true }))!;
    const { vectors: vecs2 } = (await collection
      .withTenant(tenantTwo)
      .query.fetchObjectById(id2, { includeVector: true }))!;
    const obj1 = await collection.withTenant(tenantOne).query.nearVector(vecs1.default);
    const obj2 = await collection.withTenant(tenantTwo).query.nearVector(vecs2.default);
    expect(obj1.objects.length).toEqual(1);
    expect(obj1.objects[0].properties.testProp).toEqual('one');
    expect(obj1.objects[0].uuid).toEqual(id1);
    expect(obj2.objects.length).toEqual(1);
    expect(obj2.objects[0].properties.testProp).toEqual('two');
    expect(obj2.objects[0].uuid).toEqual(id2);
  });
});

// const maybe = process.env.OPENAI_APIKEY ? describe : describe.skip;

// maybe('Testing of collection.query using rerank functionality', () => {
//   let client: WeaviateClient;
//   let collection: Collection;
//   const collectionName = 'TestCollectionRerank';
//   let id1: string;
//   let id2: string;

//   afterAll(() => {
//     return client.collections.delete(collectionName).catch((err) => {
//       console.error(err);
//       throw err;
//     });
//   });

//   beforeAll(async () => {
//     client = await weaviate.connectToLocal({
//       port: 8079,
//       grpcPort: 50050,
//       headers: {
//         'X-OpenAI-Api-Key': process.env.OPENAI_APIKEY as string,
//       },
//     });
//     collection = client.collections.get(collectionName);
//     [id1, id2] = await client.collections
//       .create({
//         name: collectionName,
//         properties: [
//           {
//             name: 'text',
//             dataType: 'text',
//           },
//         ],
//         reranker: weaviate.configure.reranker.transformers(),
//         vectorizers: weaviate.configure.vectorizer.text2VecOpenAI(),
//       })
//       .then(() =>
//         Promise.all([
//           collection.data.insert({
//             properties: {
//               text: 'This is a test',
//             },
//           }),
//           collection.data.insert({
//             properties: {
//               text: 'This is another test',
//             },
//           }),
//         ])
//       );
//   });

//   it('should rerank the results in a bm25 query', async () => {
//     const ret = await collection.query.bm25('test', {
//       rerank: {
//         property: 'text',
//         query: 'another',
//       },
//     });
//     const objects = ret.objects;
//     expect(objects.length).toEqual(2);
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[0].properties.text).toEqual('This is another test');
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[1].properties.text).toEqual('This is a test');
//   });

//   it('should rerank the results in a hybrid query', async () => {
//     const ret = await collection.query.hybrid('test', {
//       rerank: {
//         property: 'text',
//         query: 'another',
//       },
//     });
//     const objects = ret.objects;
//     expect(objects.length).toEqual(2);
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[0].properties.text).toEqual('This is another test');
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[1].properties.text).toEqual('This is a test');
//   });

//   it.skip('should rerank the results in a nearObject query', async () => {
//     const ret = await collection.query.nearObject(id1, {
//       rerank: {
//         property: 'text',
//         query: 'another',
//       },
//     });
//     const objects = ret.objects;
//     expect(objects.length).toEqual(2);
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[0].properties.text).toEqual('This is another test');
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[1].properties.text).toEqual('This is a test');
//   });

//   it('should rerank the results in a nearText query', async () => {
//     const ret = await collection.query.nearText('text', {
//       rerank: {
//         property: 'text',
//         query: 'another',
//       },
//     });
//     const objects = ret.objects;
//     expect(objects.length).toEqual(2);
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[0].properties.text).toEqual('This is another test');
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[1].properties.text).toEqual('This is a test');
//   });

//   it.skip('should rerank the results in a nearObject query', async () => {
//     const obj = await collection.query.fetchObjectById(id1, { includeVector: true });
//     const ret = await collection.query.nearVector(obj?.vectors.default!, {
//       rerank: {
//         property: 'text',
//         query: 'another',
//       },
//     });
//     const objects = ret.objects;
//     expect(objects.length).toEqual(2);
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[0].properties.text).toEqual('This is another test');
//     expect(objects[0].metadata?.rerankScore).toBeDefined();
//     expect(objects[1].properties.text).toEqual('This is a test');
//   });
// });



---
File: /src/collections/query/types.ts
---

import { FilterValue } from '../filters/index.js';
import { MultiTargetVectorJoin } from '../index.js';
import { Sorting } from '../sort/classes.js';
import {
  GroupByOptions,
  GroupByReturn,
  QueryMetadata,
  QueryProperty,
  QueryReference,
  RerankOptions,
  WeaviateObject,
  WeaviateReturn,
} from '../types/index.js';
import { PrimitiveKeys } from '../types/internal.js';

/** Options available in the `query.fetchObjectById` method */
export type FetchObjectByIdOptions<T> = {
  /** Whether to include the vector of the object in the response. If using named vectors, pass an array of strings to include only specific vectors. */
  includeVector?: boolean | string[];
  /**
   * Which properties of the object to return. Can be primitive, in which case specify their names, or nested, in which case
   * use the QueryNested<T> type. If not specified, all properties are returned.
   */
  returnProperties?: QueryProperty<T>[];
  /** Which references of the object to return. If not specified, no references are returned. */
  returnReferences?: QueryReference<T>[];
};

/** Options available in the `query.fetchObjects` method */
export type FetchObjectsOptions<T> = {
  /** How many objects to return in the query */
  limit?: number;
  /** How many objects to skip in the query. Incompatible with the `after` cursor */
  offset?: number;
  /** The cursor to start the query from. Incompatible with the `offset` param */
  after?: string;
  /** The filters to be applied to the query. Use `weaviate.filter.*` to create filters */
  filters?: FilterValue;
  /** The sorting to be applied to the query. Use `weaviate.sort.*` to create sorting */
  sort?: Sorting<T>;
  /** Whether to include the vector of the object in the response. If using named vectors, pass an array of strings to include only specific vectors. */
  includeVector?: boolean | string[];
  /** Which metadata of the object to return. If not specified, no metadata is returned. */
  returnMetadata?: QueryMetadata;
  /**
   * Which properties of the object to return. Can be primitive, in which case specify their names, or nested, in which case
   * use the QueryNested<T> type. If not specified, all properties are returned.
   */
  returnProperties?: QueryProperty<T>[];
  /** Which references of the object to return. If not specified, no references are returned. */
  returnReferences?: QueryReference<T>[];
};

/** Base options available to all the query methods that involve searching. */
export type SearchOptions<T> = {
  /** How many objects to return in the query */
  limit?: number;
  /** How many objects to skip in the query. Incompatible with the `after` cursor */
  offset?: number;
  /** The [autocut](https://weaviate.io/developers/weaviate/api/graphql/additional-operators#autocut) parameter */
  autoLimit?: number;
  /** The filters to be applied to the query. Use `weaviate.filter.*` to create filters */
  filters?: FilterValue;
  /** How to rerank the query results. Requires a configured [reranking](https://weaviate.io/developers/weaviate/concepts/reranking) module. */
  rerank?: RerankOptions<T>;
  /** Whether to include the vector of the object in the response. If using named vectors, pass an array of strings to include only specific vectors. */
  includeVector?: boolean | string[];
  /** Which metadata of the object to return. If not specified, no metadata is returned. */
  returnMetadata?: QueryMetadata;
  /**
   * Which properties of the object to return. Can be primitive, in which case specify their names, or nested, in which case
   * use the QueryNested<T> type. If not specified, all properties are returned.
   */
  returnProperties?: QueryProperty<T>[];
  /** Which references of the object to return. If not specified, no references are returned. */
  returnReferences?: QueryReference<T>[];
};

/** Which property of the collection to perform the keyword search on. */
export type Bm25QueryProperty<T> = {
  /** The property name to search on. */
  name: PrimitiveKeys<T>;
  /** The weight to provide to the keyword search for this property. */
  weight: number;
};

/** Base options available in the `query.bm25` method */
export type BaseBm25Options<T> = SearchOptions<T> & {
  /** Which properties of the collection to perform the keyword search on. */
  queryProperties?: (PrimitiveKeys<T> | Bm25QueryProperty<T>)[];
};

/** Options available in the `query.bm25` method when specifying the `groupBy` parameter. */
export type GroupByBm25Options<T> = BaseBm25Options<T> & {
  /** The group by options to apply to the search. */
  groupBy: GroupByOptions<T>;
};

/** Options available in the `query.bm25` method */
export type Bm25Options<T> = BaseBm25Options<T> | GroupByBm25Options<T> | undefined;

/** Base options available in the `query.hybrid` method */
export type BaseHybridOptions<T> = SearchOptions<T> & {
  /** The weight of the BM25 score. If not specified, the default weight specified by the server is used. */
  alpha?: number;
  /** The specific vector to search for or a specific vector subsearch. If not specified, the query is vectorized and used in the similarity search. */
  vector?: NearVectorInputType | HybridNearTextSubSearch | HybridNearVectorSubSearch;
  /** The properties to search in. If not specified, all properties are searched. */
  queryProperties?: (PrimitiveKeys<T> | Bm25QueryProperty<T>)[];
  /** The type of fusion to apply. If not specified, the default fusion type specified by the server is used. */
  fusionType?: 'Ranked' | 'RelativeScore';
  /** Specify which vector(s) to search on if using named vectors. */
  targetVector?: TargetVectorInputType;
};

export type HybridSubSearchBase = {
  certainty?: number;
  distance?: number;
};

export type HybridNearTextSubSearch = HybridSubSearchBase & {
  query: string | string[];
  moveTo?: MoveOptions;
  moveAway?: MoveOptions;
};

export type HybridNearVectorSubSearch = HybridSubSearchBase & {
  vector: NearVectorInputType;
};

/** Options available in the `query.hybrid` method when specifying the `groupBy` parameter. */
export type GroupByHybridOptions<T> = BaseHybridOptions<T> & {
  /** The group by options to apply to the search. */
  groupBy: GroupByOptions<T>;
};

/** Options available in the `query.hybrid` method */
export type HybridOptions<T> = BaseHybridOptions<T> | GroupByHybridOptions<T> | undefined;

/** Base options for the near search queries. */
export type BaseNearOptions<T> = SearchOptions<T> & {
  /** The minimum similarity score to return. Incompatible with the `distance` param. */
  certainty?: number;
  /** The maximum distance to search. Incompatible with the `certainty` param. */
  distance?: number;
  /** Specify which vector to search on if using named vectors. */
  targetVector?: TargetVectorInputType;
};

/** Options available in the near search queries when specifying the `groupBy` parameter. */
export type GroupByNearOptions<T> = BaseNearOptions<T> & {
  /** The group by options to apply to the search. */
  groupBy: GroupByOptions<T>;
};

/** Options available when specifying `moveTo` and `moveAway` in the `query.nearText` method. */
export type MoveOptions = {
  force: number;
  objects?: string[];
  concepts?: string[];
};

/** Base options for the `query.nearText` method. */
export type BaseNearTextOptions<T> = BaseNearOptions<T> & {
  moveTo?: MoveOptions;
  moveAway?: MoveOptions;
};

/** Options available in the near text search queries when specifying the `groupBy` parameter. */
export type GroupByNearTextOptions<T> = BaseNearTextOptions<T> & {
  groupBy: GroupByOptions<T>;
};

/** The type of the media to search for in the `query.nearMedia` method */
export type NearMediaType = 'audio' | 'depth' | 'image' | 'imu' | 'thermal' | 'video';

/**
 * The vector(s) to search for in the `query/generate.nearVector` and `query/generate.hybrid` methods. One of:
 * - a single vector, in which case pass a single number array.
 * - multiple named vectors, in which case pass an object of type `Record<string, number[] | number[][]>`.
 */
export type NearVectorInputType = number[] | Record<string, number[] | number[][]>;

/**
 * Over which vector spaces to perform the vector search query in the `nearX` search method. One of:
 * - a single vector space search, in which case pass a string with the name of the vector space to search in.
 * - a multi-vector space search, in which case pass an array of strings with the names of the vector spaces to search in.
 * - a weighted multi-vector space search, in which case pass an object of type `MultiTargetVectorJoin` detailing the vector spaces to search in.
 */
export type TargetVectorInputType = string | string[] | MultiTargetVectorJoin;

interface Bm25<T> {
  /**
   * Search for objects in this collection using the keyword-based BM25 algorithm.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/bm25) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string} query - The query to search for.
   * @param {BaseBm25Options<T>} [opts] - The available options for the search excluding the `groupBy` param.
   * @returns {Promise<WeaviateReturn<T>>} - The result of the search within the fetched collection.
   */
  bm25(query: string, opts?: BaseBm25Options<T>): Promise<WeaviateReturn<T>>;
  /**
   * Search for objects in this collection using the keyword-based BM25 algorithm.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/bm25) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string} query - The query to search for.
   * @param {GroupByBm25Options<T>} opts - The available options for the search including the `groupBy` param.
   * @returns {Promise<GroupByReturn<T>>} - The result of the search within the fetched collection.
   */
  bm25(query: string, opts: GroupByBm25Options<T>): Promise<GroupByReturn<T>>;
  /**
   * Search for objects in this collection using the keyword-based BM25 algorithm.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/bm25) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string} query - The query to search for.
   * @param {Bm25Options<T>} [opts] - The available options for the search including the `groupBy` param.
   * @returns {Promise<GroupByReturn<T>>} - The result of the search within the fetched collection.
   */
  bm25(query: string, opts?: Bm25Options<T>): QueryReturn<T>;
}

interface Hybrid<T> {
  /**
   * Search for objects in this collection using the hybrid algorithm blending keyword-based BM25 and vector-based similarity.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/hybrid) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string} query - The query to search for in the BM25 keyword search..
   * @param {BaseHybridOptions<T>} [opts] - The available options for the search excluding the `groupBy` param.
   * @returns {Promise<WeaviateReturn<T>>} - The result of the search within the fetched collection.
   */
  hybrid(query: string, opts?: BaseHybridOptions<T>): Promise<WeaviateReturn<T>>;
  /**
   * Search for objects in this collection using the hybrid algorithm blending keyword-based BM25 and vector-based similarity.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/hybrid) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string} query - The query to search for in the BM25 keyword search..
   * @param {GroupByHybridOptions<T>} opts - The available options for the search including the `groupBy` param.
   * @returns {Promise<GroupByReturn<T>>} - The result of the search within the fetched collection.
   */
  hybrid(query: string, opts: GroupByHybridOptions<T>): Promise<GroupByReturn<T>>;
  /**
   * Search for objects in this collection using the hybrid algorithm blending keyword-based BM25 and vector-based similarity.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/hybrid) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string} query - The query to search for in the BM25 keyword search..
   * @param {HybridOptions<T>} [opts] - The available options for the search including the `groupBy` param.
   * @returns {Promise<QueryReturn<T>>} - The result of the search within the fetched collection.
   */
  hybrid(query: string, opts?: HybridOptions<T>): QueryReturn<T>;
}

interface NearImage<T> {
  /**
   * Search for objects by image in this collection using an image-capable vectorization module and vector-based similarity search.
   * You must have an image-capable vectorization module installed in order to use this method,
   * e.g. `img2vec-neural`, `multi2vec-clip`, or `multi2vec-bind.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/image) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string | Buffer} image - The image to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {BaseNearOptions<T>} [opts] - The available options for the search excluding the `groupBy` param.
   * @returns {Promise<WeaviateReturn<T>>} - The result of the search within the fetched collection.
   */
  nearImage(image: string | Buffer, opts?: BaseNearOptions<T>): Promise<WeaviateReturn<T>>;
  /**
   * Search for objects by image in this collection using an image-capable vectorization module and vector-based similarity search.
   * You must have an image-capable vectorization module installed in order to use this method,
   * e.g. `img2vec-neural`, `multi2vec-clip`, or `multi2vec-bind.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string | Buffer} image - The image to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {GroupByNearOptions<T>} opts - The available options for the search including the `groupBy` param.
   * @returns {Promise<GroupByReturn<T>>} - The group by result of the search within the fetched collection.
   */
  nearImage(image: string | Buffer, opts: GroupByNearOptions<T>): Promise<GroupByReturn<T>>;
  /**
   * Search for objects by image in this collection using an image-capable vectorization module and vector-based similarity search.
   * You must have an image-capable vectorization module installed in order to use this method,
   * e.g. `img2vec-neural`, `multi2vec-clip`, or `multi2vec-bind.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string | Buffer} image - The image to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {NearOptions<T>} [opts] - The available options for the search.
   * @returns {QueryReturn<T>} - The result of the search within the fetched collection.
   */
  nearImage(image: string | Buffer, opts?: NearOptions<T>): QueryReturn<T>;
}

interface NearMedia<T> {
  /**
   * Search for objects by image in this collection using an image-capable vectorization module and vector-based similarity search.
   * You must have a multi-media-capable vectorization module installed in order to use this method, e.g. `multi2vec-bind` or `multi2vec-palm`.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string | Buffer} media - The media to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {NearMediaType} type - The type of media to search for, e.g. 'audio'.
   * @param {BaseNearOptions<T>} [opts] - The available options for the search excluding the `groupBy` param.
   * @returns {Promise<WeaviateReturn<T>>} - The result of the search within the fetched collection.
   */
  nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    opts?: BaseNearOptions<T>
  ): Promise<WeaviateReturn<T>>;
  /**
   * Search for objects by image in this collection using an image-capable vectorization module and vector-based similarity search.
   * You must have a multi-media-capable vectorization module installed in order to use this method, e.g. `multi2vec-bind` or `multi2vec-palm`.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string | Buffer} media - The media to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {NearMediaType} type - The type of media to search for, e.g. 'audio'.
   * @param {GroupByNearOptions<T>} opts - The available options for the search including the `groupBy` param.
   * @returns {Promise<GroupByReturn<T>>} - The group by result of the search within the fetched collection.
   */
  nearMedia(
    media: string | Buffer,
    type: NearMediaType,
    opts: GroupByNearOptions<T>
  ): Promise<GroupByReturn<T>>;
  /**
   * Search for objects by image in this collection using an image-capable vectorization module and vector-based similarity search.
   * You must have a multi-media-capable vectorization module installed in order to use this method, e.g. `multi2vec-bind` or `multi2vec-palm`.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/modules/retriever-vectorizer-modules/multi2vec-bind) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string | Buffer} media - The media to search on. This can be a base64 string, a file path string, or a buffer.
   * @param {NearMediaType} type - The type of media to search for, e.g. 'audio'.
   * @param {NearOptions<T>} [opts] - The available options for the search.
   * @returns {QueryReturn<T>} - The result of the search within the fetched collection.
   */
  nearMedia(media: string | Buffer, type: NearMediaType, opts?: NearOptions<T>): QueryReturn<T>;
}

interface NearObject<T> {
  /**
   * Search for objects in this collection by another object using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#nearobject) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string} id - The UUID of the object to search for.
   * @param {BaseNearOptions<T>} [opts] - The available options for the search excluding the `groupBy` param.
   * @returns {Promise<WeaviateReturn<T>>} - The result of the search within the fetched collection.
   */
  nearObject(id: string, opts?: BaseNearOptions<T>): Promise<WeaviateReturn<T>>;
  /**
   * Search for objects in this collection by another object using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#nearobject) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string} id - The UUID of the object to search for.
   * @param {GroupByNearOptions<T>} opts - The available options for the search including the `groupBy` param.
   * @returns {Promise<GroupByReturn<T>>} - The group by result of the search within the fetched collection.
   */
  nearObject(id: string, opts: GroupByNearOptions<T>): Promise<GroupByReturn<T>>;
  /**
   * Search for objects in this collection by another object using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {number[]} id - The UUID of the object to search for.
   * @param {NearOptions<T>} [opts] - The available options for the search.
   * @returns {QueryReturn<T>} - The result of the search within the fetched collection.
   */
  nearObject(id: string, opts?: NearOptions<T>): QueryReturn<T>;
}

interface NearText<T> {
  /**
   * Search for objects in this collection by text using text-capable vectorization module and vector-based similarity search.
   * You must have a text-capable vectorization module installed in order to use this method,
   * e.g. any of the `text2vec-` and `multi2vec-` modules.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#neartext) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {string | string[]} query - The text query to search for.
   * @param {BaseNearTextOptions<T>} [opts] - The available options for the search excluding the `groupBy` param.
   * @returns {Promise<WeaviateReturn<T>>} - The result of the search within the fetched collection.
   */
  nearText(query: string | string[], opts?: BaseNearTextOptions<T>): Promise<WeaviateReturn<T>>;
  /**
   * Search for objects in this collection by text using text-capable vectorization module and vector-based similarity search.
   * You must have a text-capable vectorization module installed in order to use this method,
   * e.g. any of the `text2vec-` and `multi2vec-` modules.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#neartext) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {string | string[]} query - The text query to search for.
   * @param {GroupByNearTextOptions<T>} opts - The available options for the search including the `groupBy` param.
   * @returns {Promise<GroupByReturn<T>>} - The group by result of the search within the fetched collection.
   */
  nearText(query: string | string[], opts: GroupByNearTextOptions<T>): Promise<GroupByReturn<T>>;
  /**
   * Search for objects in this collection by text using text-capable vectorization module and vector-based similarity search.
   * You must have a text-capable vectorization module installed in order to use this method,
   * e.g. any of the `text2vec-` and `multi2vec-` modules.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/api/graphql/search-operators#neartext) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {string | string[]} query - The text query to search for.
   * @param {NearTextOptions<T>} [opts] - The available options for the search.
   * @returns {QueryReturn<T>} - The result of the search within the fetched collection.
   */
  nearText(query: string | string[], opts?: NearTextOptions<T>): QueryReturn<T>;
}

interface NearVector<T> {
  /**
   * Search for objects by vector in this collection using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search without the `groupBy` param.
   *
   * @param {NearVectorInputType} vector - The vector(s) to search on.
   * @param {BaseNearOptions<T>} [opts] - The available options for the search excluding the `groupBy` param.
   * @returns {Promise<WeaviateReturn<T>>} - The result of the search within the fetched collection.
   */
  nearVector(vector: NearVectorInputType, opts?: BaseNearOptions<T>): Promise<WeaviateReturn<T>>;
  /**
   * Search for objects by vector in this collection using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search with the `groupBy` param.
   *
   * @param {NearVectorInputType} vector - The vector(s) to search for.
   * @param {GroupByNearOptions<T>} opts - The available options for the search including the `groupBy` param.
   * @returns {Promise<GroupByReturn<T>>} - The group by result of the search within the fetched collection.
   */
  nearVector(vector: NearVectorInputType, opts: GroupByNearOptions<T>): Promise<GroupByReturn<T>>;
  /**
   * Search for objects by vector in this collection using a vector-based similarity search.
   *
   * See the [docs](https://weaviate.io/developers/weaviate/search/similarity) for a more detailed explanation.
   *
   * This overload is for performing a search with a programmatically defined `opts` param.
   *
   * @param {NearVectorInputType} vector - The vector(s) to search for.
   * @param {NearOptions<T>} [opts] - The available options for the search.
   * @returns {QueryReturn<T>} - The result of the search within the fetched collection.
   */
  nearVector(vector: NearVectorInputType, opts?: NearOptions<T>): QueryReturn<T>;
}

/** All the available methods on the `.query` namespace. */
export interface Query<T>
  extends Bm25<T>,
    Hybrid<T>,
    NearImage<T>,
    NearMedia<T>,
    NearObject<T>,
    NearText<T>,
    NearVector<T> {
  /**
   * Retrieve an object from the server by its UUID.
   *
   * @param {string} id - The UUID of the object to retrieve.
   * @param {FetchObjectByIdOptions} [opts] - The available options for fetching the object.
   * @returns {Promise<WeaviateObject<T> | null>} - The object with the given UUID, or null if it does not exist.
   */
  fetchObjectById: (id: string, opts?: FetchObjectByIdOptions<T>) => Promise<WeaviateObject<T> | null>;

  /**
   * Retrieve objects from the server without searching.
   *
   * @param {FetchObjectsOptions} [opts] - The available options for fetching the objects.
   * @returns {Promise<WeaviateReturn<T>>} - The objects within the fetched collection.
   */
  fetchObjects: (opts?: FetchObjectsOptions<T>) => Promise<WeaviateReturn<T>>;
}
/** Options available in the `query.nearImage`, `query.nearMedia`, `query.nearObject`, and `query.nearVector` methods */
export type NearOptions<T> = BaseNearOptions<T> | GroupByNearOptions<T> | undefined;

/** Options available in the `query.nearText` method */
export type NearTextOptions<T> = BaseNearTextOptions<T> | GroupByNearTextOptions<T> | undefined;

/** The return type of the `query` methods. It is a union of a standard query and a group by query due to function overloading. */
export type QueryReturn<T> = Promise<WeaviateReturn<T>> | Promise<GroupByReturn<T>>;



---
File: /src/collections/query/utils.ts
---

import { MultiTargetVectorJoin } from '../index.js';
import { NearVectorInputType, TargetVectorInputType } from './types.js';

export class NearVectorInputGuards {
  public static is1DArray(input: NearVectorInputType): input is number[] {
    return Array.isArray(input) && input.length > 0 && !Array.isArray(input[0]);
  }

  public static isObject(input: NearVectorInputType): input is Record<string, number[] | number[][]> {
    return !Array.isArray(input);
  }
}

export class ArrayInputGuards {
  public static is1DArray<U, T extends U[]>(input: U | T): input is T {
    return Array.isArray(input) && input.length > 0 && !Array.isArray(input[0]);
  }
  public static is2DArray<U, T extends U[]>(input: U | T): input is T {
    return Array.isArray(input) && input.length > 0 && Array.isArray(input[0]);
  }
}

export class TargetVectorInputGuards {
  public static isSingle(input: TargetVectorInputType): input is string {
    return typeof input === 'string';
  }

  public static isMulti(input: TargetVectorInputType): input is string[] {
    return Array.isArray(input);
  }

  public static isMultiJoin(input: TargetVectorInputType): input is MultiTargetVectorJoin {
    const i = input as MultiTargetVectorJoin;
    return i.combination !== undefined && i.targetVectors !== undefined;
  }
}



---
File: /src/collections/references/classes.ts
---

import { Properties, ReferenceInput, ReferenceToMultiTarget, WeaviateObject } from '../types/index.js';
import { Beacon } from './types.js';
import { uuidToBeacon } from './utils.js';

export class ReferenceManager<T> {
  public objects: WeaviateObject<T>[];
  public targetCollection: string;
  public uuids?: string[];

  constructor(targetCollection: string, objects?: WeaviateObject<T>[], uuids?: string[]) {
    this.objects = objects ?? [];
    this.targetCollection = targetCollection;
    this.uuids = uuids;
  }

  public toBeaconObjs(): Beacon[] {
    return this.uuids ? this.uuids.map((uuid) => uuidToBeacon(uuid, this.targetCollection)) : [];
  }

  public toBeaconStrings(): string[] {
    return this.uuids ? this.uuids.map((uuid) => uuidToBeacon(uuid, this.targetCollection).beacon) : [];
  }

  public isMultiTarget(): boolean {
    return this.targetCollection !== '';
  }
}

/**
 * A factory class to create references from objects to other objects.
 */
export class Reference {
  /**
   * Create a single-target reference with given UUID(s).
   *
   * @param {string | string[]} uuids The UUID(s) of the target object(s).
   * @returns {ReferenceManager} The reference manager object.
   */
  public static to<TProperties extends Properties = Properties>(
    uuids: string | string[]
  ): ReferenceManager<TProperties> {
    return new ReferenceManager<TProperties>('', undefined, Array.isArray(uuids) ? uuids : [uuids]);
  }
  /**
   * Create a multi-target reference with given UUID(s) pointing to a specific target collection.
   *
   * @param {string | string[]} uuids The UUID(s) of the target object(s).
   * @param {string} targetCollection The target collection name.
   * @returns {ReferenceManager} The reference manager object.
   */
  public static toMultiTarget<TProperties extends Properties = Properties>(
    uuids: string | string[],
    targetCollection: string
  ): ReferenceManager<TProperties> {
    return new ReferenceManager<TProperties>(
      targetCollection,
      undefined,
      Array.isArray(uuids) ? uuids : [uuids]
    );
  }
}

export class ReferenceGuards {
  public static isReferenceManager<T>(arg: ReferenceInput<T>): arg is ReferenceManager<T> {
    return arg instanceof ReferenceManager;
  }

  public static isUuid<T>(arg: ReferenceInput<T>): arg is string {
    return typeof arg === 'string';
  }

  public static isUuids<T>(arg: ReferenceInput<T>): arg is string[] {
    return Array.isArray(arg);
  }

  public static isMultiTarget<T>(arg: ReferenceInput<T>): arg is ReferenceToMultiTarget {
    return (arg as ReferenceToMultiTarget).targetCollection !== undefined;
  }
}



---
File: /src/collections/references/index.ts
---

export { Reference, ReferenceManager } from './classes.js';
export type { Beacon, CrossReference, CrossReferenceDefault, CrossReferences, UnionOf } from './types.js';



---
File: /src/collections/references/types.ts
---

import { Properties, WeaviateNonGenericObject } from '../types/index.js';
import { ReferenceManager } from './classes.js';

export type CrossReference<TProperties extends Properties> = ReferenceManager<TProperties>;

export type CrossReferenceDefault = {
  objects: WeaviateNonGenericObject[];
};

export type CrossReferences<TProperties extends Properties[]> = ReferenceManager<UnionOf<TProperties>>;

export type UnionOf<T> = T extends (infer U)[] ? U : never;

export type Beacon = {
  beacon: string;
};



---
File: /src/collections/references/utils.ts
---

import { ReferenceInput } from '../types/index.js';
import { ReferenceGuards, ReferenceManager } from './classes.js';
import { Beacon } from './types.js';

export function uuidToBeacon(uuid: string, targetCollection?: string): Beacon {
  return {
    beacon: `weaviate://localhost/${targetCollection ? `${targetCollection}/` : ''}${uuid}`,
  };
}

export const referenceFromObjects = <TProperties>(
  objects: any[],
  targetCollection: string,
  uuids: string[]
): ReferenceManager<TProperties> => {
  return new ReferenceManager<TProperties>(targetCollection, objects, uuids);
};

export const referenceToBeacons = <T>(ref: ReferenceInput<T>): Beacon[] => {
  if (ReferenceGuards.isReferenceManager(ref)) {
    return ref.toBeaconObjs();
  } else if (ReferenceGuards.isUuid(ref)) {
    return [uuidToBeacon(ref)];
  } else if (ReferenceGuards.isUuids(ref)) {
    return ref.map((uuid) => uuidToBeacon(uuid));
  } else if (ReferenceGuards.isMultiTarget(ref)) {
    return typeof ref.uuids === 'string'
      ? [uuidToBeacon(ref.uuids, ref.targetCollection)]
      : ref.uuids.map((uuid) => uuidToBeacon(uuid, ref.targetCollection));
  }
  return [];
};



---
File: /src/collections/serialize/index.ts
---

import { v4 as uuidv4 } from 'uuid';
import { WhereFilter } from '../../openapi/types.js';
import {
  BatchObject as BatchObjectGRPC,
  BatchObject_MultiTargetRefProps,
  BatchObject_Properties,
  BatchObject_SingleTargetRefProps,
} from '../../proto/v1/batch.js';
import { GenerativeSearch } from '../../proto/v1/generative.js';
import {
  BM25,
  CombinationMethod,
  GroupBy,
  Hybrid,
  Hybrid_FusionType,
  MetadataRequest,
  NearAudioSearch,
  NearDepthSearch,
  NearIMUSearch,
  NearImageSearch,
  NearObject,
  NearTextSearch,
  NearTextSearch_Move,
  NearThermalSearch,
  NearVector,
  NearVideoSearch,
  ObjectPropertiesRequest,
  PropertiesRequest,
  Rerank,
  SortBy as SortByGrpc,
  Targets,
  VectorForTarget,
  WeightsForTarget,
} from '../../proto/v1/search_get.js';

import {
  WeaviateInvalidInputError,
  WeaviateSerializationError,
  WeaviateUnsupportedFeatureError,
} from '../../errors.js';
import {
  BaseSearchArgs,
  SearchBm25Args,
  SearchFetchArgs,
  SearchHybridArgs,
  SearchNearAudioArgs,
  SearchNearDepthArgs,
  SearchNearIMUArgs,
  SearchNearImageArgs,
  SearchNearObjectArgs,
  SearchNearTextArgs,
  SearchNearThermalArgs,
  SearchNearVectorArgs,
  SearchNearVideoArgs,
} from '../../grpc/searcher.js';
import {
  BooleanArrayProperties,
  FilterTarget,
  Filters as FiltersGRPC,
  Filters_Operator,
  IntArrayProperties,
  NumberArrayProperties,
  ObjectArrayProperties,
  ObjectProperties,
  ObjectPropertiesValue,
  TextArrayProperties,
  Vectors as VectorsGrpc,
} from '../../proto/v1/base.js';
import { FilterId } from '../filters/classes.js';
import { FilterValue, Filters } from '../filters/index.js';
import {
  FilterValueType,
  GeoRangeFilter,
  PrimitiveFilterValueType,
  PrimitiveListFilterValueType,
} from '../filters/types.js';
import { MultiTargetVectorJoin, PrimitiveKeys } from '../index.js';
import {
  BaseHybridOptions,
  BaseNearOptions,
  Bm25Options,
  Bm25QueryProperty,
  FetchObjectByIdOptions,
  FetchObjectsOptions,
  HybridNearTextSubSearch,
  HybridNearVectorSubSearch,
  HybridOptions,
  NearOptions,
  NearTextOptions,
  NearVectorInputType,
  SearchOptions,
  TargetVectorInputType,
} from '../query/types.js';
import { ArrayInputGuards, NearVectorInputGuards, TargetVectorInputGuards } from '../query/utils.js';
import { ReferenceGuards } from '../references/classes.js';
import { Beacon } from '../references/index.js';
import { uuidToBeacon } from '../references/utils.js';
import { TenantBC, TenantCreate, TenantUpdate } from '../tenants/types.js';
import {
  BatchObject,
  BatchObjects,
  DataObject,
  GenerateOptions,
  GeoCoordinate,
  GroupByOptions,
  MetadataKeys,
  NestedProperties,
  NonReferenceInputs,
  PhoneNumberInput,
  QueryMetadata,
  QueryNested,
  QueryProperty,
  QueryReference,
  ReferenceInput,
  RerankOptions,
  SortBy,
  WeaviateField,
} from '../types/index.js';

class FilterGuards {
  static isFilters = (
    argument?: Filters | PrimitiveFilterValueType | PrimitiveListFilterValueType
  ): argument is Filters => {
    return argument instanceof Filters;
  };

  static isText = (argument?: FilterValueType): argument is string => {
    return typeof argument === 'string';
  };

  static isTextArray = (argument?: FilterValueType): argument is string[] => {
    return (
      argument instanceof Array &&
      (argument as Array<FilterValueType>).every((arg) => typeof arg === 'string')
    );
  };

  static isInt = (argument?: FilterValueType): argument is number => {
    return typeof argument === 'number' && Number.isInteger(argument);
  };

  static isIntArray = (argument?: FilterValueType): argument is number[] => {
    return (
      argument instanceof Array &&
      (argument as Array<FilterValueType>).every((arg) => typeof arg === 'number' && Number.isInteger(arg))
    );
  };

  static isFloat = (argument?: FilterValueType): argument is number => {
    return typeof argument === 'number' && !Number.isInteger(argument);
  };

  static isFloatArray = (argument?: FilterValueType): argument is number[] => {
    return (
      argument instanceof Array &&
      (argument as Array<FilterValueType>).every((arg) => typeof arg === 'number' && !Number.isInteger(arg))
    );
  };

  static isBoolean = (argument?: FilterValueType): argument is boolean => {
    return typeof argument === 'boolean';
  };

  static isBooleanArray = (argument?: FilterValueType): argument is boolean[] => {
    return (
      argument instanceof Array &&
      (argument as Array<FilterValueType>).every((arg) => typeof arg === 'boolean')
    );
  };

  static isDate = (argument?: FilterValueType): argument is Date => {
    return argument instanceof Date;
  };

  static isDateArray = (argument?: FilterValueType): argument is Date[] => {
    return (
      argument instanceof Array && (argument as Array<FilterValueType>).every((arg) => arg instanceof Date)
    );
  };

  static isGeoRange = (argument?: FilterValueType): argument is GeoRangeFilter => {
    if (argument === undefined) {
      return false;
    }
    const arg = argument as GeoRangeFilter;
    return arg.latitude !== undefined && arg.longitude !== undefined && arg.distance !== undefined;
  };
}

export class DataGuards {
  static isText = (argument?: WeaviateField): argument is string => {
    return typeof argument === 'string';
  };

  static isTextArray = (argument?: WeaviateField): argument is string[] => {
    return (
      argument instanceof Array &&
      argument.length > 0 &&
      (argument as Array<FilterValueType>).every(DataGuards.isText)
    );
  };

  static isInt = (argument?: WeaviateField): argument is number => {
    return (
      typeof argument === 'number' &&
      Number.isInteger(argument) &&
      !Number.isNaN(argument) &&
      Number.isFinite(argument)
    );
  };

  static isIntArray = (argument?: WeaviateField): argument is number[] => {
    return (
      argument instanceof Array &&
      argument.length > 0 &&
      (argument as Array<FilterValueType>).every(DataGuards.isInt)
    );
  };

  static isFloat = (argument?: WeaviateField): argument is number => {
    return (
      typeof argument === 'number' &&
      !Number.isInteger(argument) &&
      !Number.isNaN(argument) &&
      Number.isFinite(argument)
    );
  };

  static isFloatArray = (argument?: WeaviateField): argument is number[] => {
    return (
      argument instanceof Array &&
      argument.length > 0 &&
      (argument as Array<FilterValueType>).every(DataGuards.isFloat)
    );
  };

  static isBoolean = (argument?: WeaviateField): argument is boolean => {
    return typeof argument === 'boolean';
  };

  static isBooleanArray = (argument?: WeaviateField): argument is boolean[] => {
    return (
      argument instanceof Array &&
      argument.length > 0 &&
      (argument as Array<FilterValueType>).every(DataGuards.isBoolean)
    );
  };

  static isDate = (argument?: WeaviateField): argument is Date => {
    return argument instanceof Date;
  };

  static isDateArray = (argument?: WeaviateField): argument is Date[] => {
    return (
      argument instanceof Array &&
      argument.length > 0 &&
      (argument as Array<FilterValueType>).every(DataGuards.isDate)
    );
  };

  static isGeoCoordinate = (argument?: WeaviateField): argument is GeoCoordinate => {
    return (
      argument instanceof Object &&
      (argument as GeoCoordinate).latitude !== undefined &&
      (argument as GeoCoordinate).longitude !== undefined &&
      Object.keys(argument).length === 2
    );
  };

  static isPhoneNumber = (argument?: WeaviateField): argument is PhoneNumberInput => {
    return (
      argument instanceof Object &&
      (argument as PhoneNumberInput).number !== undefined &&
      (Object.keys(argument).length === 1 ||
        (Object.keys(argument).length === 2 && (argument as PhoneNumberInput).defaultCountry !== undefined))
    );
  };

  static isNested = (argument?: WeaviateField): argument is NestedProperties => {
    return (
      argument instanceof Object &&
      !(argument instanceof Array) &&
      !DataGuards.isDate(argument) &&
      !DataGuards.isGeoCoordinate(argument) &&
      !DataGuards.isPhoneNumber(argument)
    );
  };

  static isNestedArray = (argument?: WeaviateField): argument is NestedProperties[] => {
    return (
      argument instanceof Array &&
      argument.length > 0 &&
      (argument as Array<FilterValueType>).every(DataGuards.isNested)
    );
  };

  static isEmptyArray = (argument?: WeaviateField): argument is [] => {
    return argument instanceof Array && argument.length === 0;
  };

  static isDataObject = <T>(obj: DataObject<T> | NonReferenceInputs<T>): obj is DataObject<T> => {
    return (
      (obj as DataObject<T>).id !== undefined ||
      (obj as DataObject<T>).properties !== undefined ||
      (obj as DataObject<T>).references !== undefined ||
      (obj as DataObject<T>).vectors !== undefined
    );
  };
}

export class MetadataGuards {
  static isKeys = (argument?: QueryMetadata): argument is MetadataKeys => {
    return argument instanceof Array && argument.length > 0;
  };

  static isAll = (argument?: QueryMetadata): argument is 'all' => {
    return argument === 'all';
  };

  static isUndefined = (argument?: QueryMetadata): argument is undefined => {
    return argument === undefined;
  };
}

export class Serialize {
  public static isNamedVectors = <T>(opts?: BaseNearOptions<T>): boolean => {
    return Array.isArray(opts?.includeVector) || opts?.targetVector !== undefined;
  };

  public static isMultiTarget = <T>(opts?: BaseNearOptions<T>): boolean => {
    return opts?.targetVector !== undefined && !TargetVectorInputGuards.isSingle(opts.targetVector);
  };

  public static isMultiWeightPerTarget = <T>(opts?: BaseNearOptions<T>): boolean => {
    return (
      opts?.targetVector !== undefined &&
      TargetVectorInputGuards.isMultiJoin(opts.targetVector) &&
      opts.targetVector.weights !== undefined &&
      Object.values(opts.targetVector.weights).some(ArrayInputGuards.is1DArray)
    );
  };

  public static isMultiVector = (vec?: NearVectorInputType): boolean => {
    return (
      vec !== undefined &&
      !Array.isArray(vec) &&
      Object.values(vec).some(ArrayInputGuards.is1DArray || ArrayInputGuards.is2DArray)
    );
  };

  public static isMultiVectorPerTarget = (vec?: NearVectorInputType): boolean => {
    return vec !== undefined && !Array.isArray(vec) && Object.values(vec).some(ArrayInputGuards.is2DArray);
  };

  private static common = <T>(args?: SearchOptions<T>): BaseSearchArgs => {
    const out: BaseSearchArgs = {
      limit: args?.limit,
      offset: args?.offset,
      filters: args?.filters ? Serialize.filtersGRPC(args.filters) : undefined,
      properties:
        args?.returnProperties || args?.returnReferences
          ? Serialize.queryProperties(args.returnProperties, args.returnReferences)
          : undefined,
      metadata: Serialize.metadata(args?.includeVector, args?.returnMetadata),
    };
    if (args?.rerank) {
      out.rerank = Serialize.rerank(args.rerank);
    }
    return out;
  };

  public static fetchObjects = <T>(args?: FetchObjectsOptions<T>): SearchFetchArgs => {
    return {
      ...Serialize.common(args),
      after: args?.after,
      sortBy: args?.sort ? Serialize.sortBy(args.sort.sorts) : undefined,
    };
  };

  public static fetchObjectById = <T>(args: { id: string } & FetchObjectByIdOptions<T>): SearchFetchArgs => {
    return {
      ...Serialize.common({
        filters: new FilterId().equal(args.id),
        includeVector: args.includeVector,
        returnMetadata: ['creationTime', 'updateTime', 'isConsistent'],
        returnProperties: args.returnProperties,
        returnReferences: args.returnReferences,
      }),
    };
  };

  private static bm25QueryProperties = <T>(
    properties?: (PrimitiveKeys<T> | Bm25QueryProperty<T>)[]
  ): string[] | undefined => {
    return properties?.map((property) => {
      if (typeof property === 'string') {
        return property;
      } else {
        return `${property.name}^${property.weight}`;
      }
    });
  };

  public static bm25 = <T>(args: { query: string } & Bm25Options<T>): SearchBm25Args => {
    return {
      ...Serialize.common(args),
      bm25Search: BM25.fromPartial({
        query: args.query,
        properties: this.bm25QueryProperties(args.queryProperties),
      }),
      autocut: args.autoLimit,
    };
  };

  public static isHybridVectorSearch = <T>(
    vector: BaseHybridOptions<T>['vector']
  ): vector is number[] | Record<string, number[] | number[][]> => {
    return (
      vector !== undefined &&
      !Serialize.isHybridNearTextSearch(vector) &&
      !Serialize.isHybridNearVectorSearch(vector)
    );
  };

  public static isHybridNearTextSearch = <T>(
    vector: BaseHybridOptions<T>['vector']
  ): vector is HybridNearTextSubSearch => {
    return (vector as HybridNearTextSubSearch)?.query !== undefined;
  };

  public static isHybridNearVectorSearch = <T>(
    vector: BaseHybridOptions<T>['vector']
  ): vector is HybridNearVectorSubSearch => {
    return (vector as HybridNearVectorSubSearch)?.vector !== undefined;
  };

  private static hybridVector = <T>(args: {
    supportsTargets: boolean;
    supportsVectorsForTargets: boolean;
    supportsWeightsForTargets: boolean;
    vector?: BaseHybridOptions<T>['vector'];
  }) => {
    const vector = args.vector;
    if (Serialize.isHybridVectorSearch(vector)) {
      const { targets, targetVectors, vectorBytes, vectorPerTarget, vectorForTargets } = Serialize.vectors({
        ...args,
        argumentName: 'vector',
        vector: vector,
      });
      return vectorBytes !== undefined
        ? { vectorBytes, targetVectors, targets }
        : {
            targetVectors,
            targets,
            nearVector: NearVector.fromPartial({
              vectorForTargets,
              vectorPerTarget,
            }),
          };
    } else if (Serialize.isHybridNearTextSearch(vector)) {
      const { targetVectors, targets } = Serialize.targetVector(args);
      return {
        targets,
        targetVectors,
        nearText: NearTextSearch.fromPartial({
          query: typeof vector.query === 'string' ? [vector.query] : vector.query,
          certainty: vector.certainty,
          distance: vector.distance,
          moveAway: vector.moveAway ? NearTextSearch_Move.fromPartial(vector.moveAway) : undefined,
          moveTo: vector.moveTo ? NearTextSearch_Move.fromPartial(vector.moveTo) : undefined,
        }),
      };
    } else if (Serialize.isHybridNearVectorSearch(vector)) {
      const { targetVectors, targets, vectorBytes, vectorPerTarget, vectorForTargets } = Serialize.vectors({
        ...args,
        argumentName: 'vector',
        vector: vector.vector,
      });
      return {
        targetVectors,
        targets,
        nearVector: NearVector.fromPartial({
          certainty: vector.certainty,
          distance: vector.distance,
          vectorBytes,
          vectorPerTarget,
          vectorForTargets,
        }),
      };
    } else {
      const { targets, targetVectors } = Serialize.targetVector(args);
      return { targets, targetVectors };
    }
  };

  public static hybrid = <T>(
    args: {
      query: string;
      supportsTargets: boolean;
      supportsVectorsForTargets: boolean;
      supportsWeightsForTargets: boolean;
    } & HybridOptions<T>
  ): SearchHybridArgs => {
    const fusionType = (fusionType?: string): Hybrid_FusionType => {
      switch (fusionType) {
        case 'Ranked':
          return Hybrid_FusionType.FUSION_TYPE_RANKED;
        case 'RelativeScore':
          return Hybrid_FusionType.FUSION_TYPE_RELATIVE_SCORE;
        default:
          return Hybrid_FusionType.FUSION_TYPE_UNSPECIFIED;
      }
    };
    const { targets, targetVectors, vectorBytes, nearText, nearVector } = Serialize.hybridVector(args);
    return {
      ...Serialize.common(args),
      hybridSearch: Hybrid.fromPartial({
        query: args.query,
        alpha: args.alpha ? args.alpha : 0.5,
        properties: this.bm25QueryProperties(args.queryProperties),
        vectorBytes: vectorBytes,
        fusionType: fusionType(args.fusionType),
        targetVectors,
        targets,
        nearText,
        nearVector,
      }),
      autocut: args.autoLimit,
    };
  };

  public static nearAudio = <T>(
    args: { audio: string; supportsTargets: boolean; supportsWeightsForTargets: boolean } & NearOptions<T>
  ): SearchNearAudioArgs => {
    const { targets, targetVectors } = Serialize.targetVector(args);
    return {
      ...Serialize.common(args),
      nearAudio: NearAudioSearch.fromPartial({
        audio: args.audio,
        certainty: args.certainty,
        distance: args.distance,
        targetVectors,
        targets,
      }),
      autocut: args.autoLimit,
    };
  };

  public static nearDepth = <T>(
    args: { depth: string; supportsTargets: boolean; supportsWeightsForTargets: boolean } & NearOptions<T>
  ): SearchNearDepthArgs => {
    const { targets, targetVectors } = Serialize.targetVector(args);
    return {
      ...Serialize.common(args),
      nearDepth: NearDepthSearch.fromPartial({
        depth: args.depth,
        certainty: args.certainty,
        distance: args.distance,
        targetVectors,
        targets,
      }),
      autocut: args.autoLimit,
    };
  };

  public static nearImage = <T>(
    args: { image: string; supportsTargets: boolean; supportsWeightsForTargets: boolean } & NearOptions<T>
  ): SearchNearImageArgs => {
    const { targets, targetVectors } = Serialize.targetVector(args);
    return {
      ...Serialize.common(args),
      nearImage: NearImageSearch.fromPartial({
        image: args.image,
        certainty: args.certainty,
        distance: args.distance,
        targetVectors,
        targets,
      }),
      autocut: args.autoLimit,
    };
  };

  public static nearIMU = <T>(
    args: { imu: string; supportsTargets: boolean; supportsWeightsForTargets: boolean } & NearOptions<T>
  ): SearchNearIMUArgs => {
    const { targets, targetVectors } = Serialize.targetVector(args);
    return {
      ...Serialize.common(args),
      nearIMU: NearIMUSearch.fromPartial({
        imu: args.imu,
        certainty: args.certainty,
        distance: args.distance,
        targetVectors,
        targets,
      }),
      autocut: args.autoLimit,
    };
  };

  public static nearObject = <T>(
    args: { id: string; supportsTargets: boolean; supportsWeightsForTargets: boolean } & NearOptions<T>
  ): SearchNearObjectArgs => {
    const { targets, targetVectors } = Serialize.targetVector(args);
    return {
      ...Serialize.common(args),
      nearObject: NearObject.fromPartial({
        id: args.id,
        certainty: args.certainty,
        distance: args.distance,
        targetVectors,
        targets,
      }),
      autocut: args.autoLimit,
    };
  };

  private static nearTextSearch = (args: {
    query: string | string[];
    supportsTargets: boolean;
    supportsWeightsForTargets: boolean;
    targetVector?: TargetVectorInputType;
    certainty?: number;
    distance?: number;
    moveAway?: { concepts?: string[]; force?: number; objects?: string[] };
    moveTo?: { concepts?: string[]; force?: number; objects?: string[] };
  }) => {
    const { targets, targetVectors } = Serialize.targetVector(args);
    return NearTextSearch.fromPartial({
      query: typeof args.query === 'string' ? [args.query] : args.query,
      certainty: args.certainty,
      distance: args.distance,
      targets,
      targetVectors,
      moveAway: args.moveAway
        ? NearTextSearch_Move.fromPartial({
            concepts: args.moveAway.concepts,
            force: args.moveAway.force,
            uuids: args.moveAway.objects,
          })
        : undefined,
      moveTo: args.moveTo
        ? NearTextSearch_Move.fromPartial({
            concepts: args.moveTo.concepts,
            force: args.moveTo.force,
            uuids: args.moveTo.objects,
          })
        : undefined,
    });
  };

  public static nearText = <T>(
    args: {
      query: string | string[];
      supportsTargets: boolean;
      supportsWeightsForTargets: boolean;
    } & NearTextOptions<T>
  ): SearchNearTextArgs => {
    return {
      ...Serialize.common(args),
      nearText: this.nearTextSearch(args),
      autocut: args.autoLimit,
    };
  };

  public static nearThermal = <T>(
    args: { thermal: string; supportsTargets: boolean; supportsWeightsForTargets: boolean } & NearOptions<T>
  ): SearchNearThermalArgs => {
    const { targets, targetVectors } = Serialize.targetVector(args);
    return {
      ...Serialize.common(args),
      nearThermal: NearThermalSearch.fromPartial({
        thermal: args.thermal,
        certainty: args.certainty,
        distance: args.distance,
        targetVectors,
        targets,
      }),
      autocut: args.autoLimit,
    };
  };

  private static vectorToBytes = (vector: number[]): Uint8Array => {
    return new Uint8Array(new Float32Array(vector).buffer);
  };

  private static nearVectorSearch = (args: {
    vector: NearVectorInputType;
    supportsTargets: boolean;
    supportsVectorsForTargets: boolean;
    supportsWeightsForTargets: boolean;
    certainty?: number;
    distance?: number;
    targetVector?: TargetVectorInputType;
  }) => {
    const { targetVectors, targets, vectorBytes, vectorPerTarget, vectorForTargets } = Serialize.vectors({
      ...args,
      argumentName: 'nearVector',
    });
    return NearVector.fromPartial({
      certainty: args.certainty,
      distance: args.distance,
      targetVectors,
      targets,
      vectorPerTarget,
      vectorBytes,
      vectorForTargets,
    });
  };

  public static targetVector = (args: {
    supportsTargets: boolean;
    supportsWeightsForTargets: boolean;
    targetVector?: TargetVectorInputType;
  }): { targets?: Targets; targetVectors?: string[] } => {
    if (args.targetVector === undefined) {
      return {};
    } else if (TargetVectorInputGuards.isSingle(args.targetVector)) {
      return args.supportsTargets
        ? {
            targets: Targets.fromPartial({
              targetVectors: [args.targetVector],
            }),
          }
        : { targetVectors: [args.targetVector] };
    } else if (TargetVectorInputGuards.isMulti(args.targetVector)) {
      return args.supportsTargets
        ? {
            targets: Targets.fromPartial({
              targetVectors: args.targetVector,
            }),
          }
        : { targetVectors: args.targetVector };
    } else {
      return { targets: Serialize.targets(args.targetVector, args.supportsWeightsForTargets) };
    }
  };

  private static vectors = (args: {
    supportsTargets: boolean;
    supportsVectorsForTargets: boolean;
    supportsWeightsForTargets: boolean;
    argumentName: 'nearVector' | 'vector';
    targetVector?: TargetVectorInputType;
    vector?: NearVectorInputType;
  }): {
    targetVectors?: string[];
    targets?: Targets;
    vectorBytes?: Uint8Array;
    vectorPerTarget?: Record<string, Uint8Array>;
    vectorForTargets?: VectorForTarget[];
  } => {
    const invalidVectorError =
      new WeaviateInvalidInputError(`${args.argumentName} argument must be populated and:
            - an array of numbers (number[])
            - an object with target names as keys and 1D and/or 2D arrays of numbers (number[] or number[][]) as values
      received: ${args.vector} and ${args.targetVector}`);

    if (args.vector === undefined) {
      return Serialize.targetVector(args);
    }
    if (NearVectorInputGuards.isObject(args.vector)) {
      if (Object.keys(args.vector).length === 0) {
        throw invalidVectorError;
      }
      if (args.supportsVectorsForTargets) {
        const vectorForTargets: VectorForTarget[] = Object.entries(args.vector)
          .map(([target, vector]) => {
            return {
              target,
              vector: vector,
            };
          })
          .reduce((acc, { target, vector }) => {
            return ArrayInputGuards.is2DArray(vector)
              ? acc.concat(vector.map((v) => ({ name: target, vectorBytes: Serialize.vectorToBytes(v) })))
              : acc.concat([{ name: target, vectorBytes: Serialize.vectorToBytes(vector) }]);
          }, [] as VectorForTarget[]);
        return args.targetVector !== undefined
          ? {
              ...Serialize.targetVector(args),
              vectorForTargets,
            }
          : {
              targetVectors: undefined,
              targets: Targets.fromPartial({
                targetVectors: vectorForTargets.map((v) => v.name),
              }),
              vectorForTargets,
            };
      } else {
        const vectorPerTarget: Record<string, Uint8Array> = {};
        Object.entries(args.vector).forEach(([k, v]) => {
          if (ArrayInputGuards.is2DArray(v)) {
            return;
          }
          vectorPerTarget[k] = Serialize.vectorToBytes(v);
        });
        if (args.targetVector !== undefined) {
          const { targets, targetVectors } = Serialize.targetVector(args);
          return {
            targetVectors,
            targets,
            vectorPerTarget,
          };
        } else {
          return args.supportsTargets
            ? {
                targets: Targets.fromPartial({
                  targetVectors: Object.keys(vectorPerTarget),
                }),
                vectorPerTarget,
              }
            : {
                targetVectors: Object.keys(vectorPerTarget),
                vectorPerTarget,
              };
        }
      }
    } else {
      if (args.vector.length === 0) {
        throw invalidVectorError;
      }
      if (NearVectorInputGuards.is1DArray(args.vector)) {
        const { targetVectors, targets } = Serialize.targetVector(args);
        const vectorBytes = Serialize.vectorToBytes(args.vector);
        return {
          targetVectors,
          targets,
          vectorBytes,
        };
      }
      throw invalidVectorError;
    }
  };

  private static targets = (
    targets: MultiTargetVectorJoin,
    supportsWeightsForTargets: boolean
  ): {
    combination: CombinationMethod;
    targetVectors: string[];
    weights: Record<string, number>;
    weightsForTargets: WeightsForTarget[];
  } => {
    let combination: CombinationMethod;
    switch (targets.combination) {
      case 'sum':
        combination = CombinationMethod.COMBINATION_METHOD_TYPE_SUM;
        break;
      case 'average':
        combination = CombinationMethod.COMBINATION_METHOD_TYPE_AVERAGE;
        break;
      case 'minimum':
        combination = CombinationMethod.COMBINATION_METHOD_TYPE_MIN;
        break;
      case 'relative-score':
        combination = CombinationMethod.COMBINATION_METHOD_TYPE_RELATIVE_SCORE;
        break;
      case 'manual-weights':
        combination = CombinationMethod.COMBINATION_METHOD_TYPE_MANUAL;
        break;
      default:
        throw new Error('Invalid combination method');
    }
    if (targets.weights !== undefined && supportsWeightsForTargets) {
      const weightsForTargets: WeightsForTarget[] = Object.entries(targets.weights)
        .map(([target, weight]) => {
          return {
            target,
            weight,
          };
        })
        .reduce((acc, { target, weight }) => {
          return Array.isArray(weight)
            ? acc.concat(weight.map((w) => ({ target, weight: w })))
            : acc.concat([{ target, weight }]);
        }, [] as WeightsForTarget[]);
      return {
        combination,
        targetVectors: weightsForTargets.map((w) => w.target),
        weights: {},
        weightsForTargets,
      };
    } else if (targets.weights !== undefined && !supportsWeightsForTargets) {
      if (Object.values(targets.weights).some((v) => Array.isArray(v))) {
        throw new WeaviateUnsupportedFeatureError(
          'Multiple weights per target are not supported in this Weaviate version. Please upgrade to at least Weaviate 1.27.0.'
        );
      }
      return {
        combination,
        targetVectors: targets.targetVectors,
        weights: targets.weights as Record<string, number>, // TS can't type narrow the complicated .some predicate above
        weightsForTargets: [],
      };
    } else {
      return {
        combination,
        targetVectors: targets.targetVectors,
        weights: {},
        weightsForTargets: [],
      };
    }
  };

  public static nearVector = <T>(
    args: {
      vector: NearVectorInputType;
      supportsTargets: boolean;
      supportsVectorsForTargets: boolean;
      supportsWeightsForTargets: boolean;
    } & NearOptions<T>
  ): SearchNearVectorArgs => {
    return {
      ...Serialize.common(args),
      nearVector: Serialize.nearVectorSearch(args),
      autocut: args.autoLimit,
    };
  };

  public static nearVideo = <T>(
    args: { video: string; supportsTargets: boolean; supportsWeightsForTargets: boolean } & NearOptions<T>
  ): SearchNearVideoArgs => {
    const { targets, targetVectors } = Serialize.targetVector(args);
    return {
      ...Serialize.common(args),
      nearVideo: NearVideoSearch.fromPartial({
        video: args.video,
        certainty: args.certainty,
        distance: args.distance,
        targetVectors,
        targets,
      }),
      autocut: args.autoLimit,
    };
  };

  public static filtersGRPC = (filters: FilterValue): FiltersGRPC => {
    const resolveFilters = (filters: FilterValue): FiltersGRPC[] => {
      const out: FiltersGRPC[] = [];
      filters.filters?.forEach((val) => out.push(Serialize.filtersGRPC(val)));
      return out;
    };
    const { value } = filters;
    switch (filters.operator) {
      case 'And':
        return FiltersGRPC.fromPartial({
          operator: Filters_Operator.OPERATOR_AND,
          filters: resolveFilters(filters),
        });
      case 'Or':
        return FiltersGRPC.fromPartial({
          operator: Filters_Operator.OPERATOR_OR,
          filters: resolveFilters(filters),
        });
      default:
        return FiltersGRPC.fromPartial({
          operator: Serialize.operator(filters.operator),
          target: filters.target,
          valueText: this.filtersGRPCValueText(value),
          valueTextArray: this.filtersGRPCValueTextArray(value),
          valueInt: FilterGuards.isInt(value) ? value : undefined,
          valueIntArray: FilterGuards.isIntArray(value) ? { values: value } : undefined,
          valueNumber: FilterGuards.isFloat(value) ? value : undefined,
          valueNumberArray: FilterGuards.isFloatArray(value) ? { values: value } : undefined,
          valueBoolean: FilterGuards.isBoolean(value) ? value : undefined,
          valueBooleanArray: FilterGuards.isBooleanArray(value) ? { values: value } : undefined,
          valueGeo: FilterGuards.isGeoRange(value) ? value : undefined,
        });
    }
  };

  private static filtersGRPCValueText = (value: any) => {
    if (FilterGuards.isText(value)) {
      return value;
    } else if (FilterGuards.isDate(value)) {
      return value.toISOString();
    } else {
      return undefined;
    }
  };

  private static filtersGRPCValueTextArray = (value: any) => {
    if (FilterGuards.isTextArray(value)) {
      return { values: value };
    } else if (FilterGuards.isDateArray(value)) {
      return { values: value.map((v) => v.toISOString()) };
    } else {
      return undefined;
    }
  };

  private static filterTargetToREST = (target: FilterTarget): string[] => {
    if (target.property) {
      return [target.property];
    } else if (target.singleTarget) {
      throw new WeaviateSerializationError(
        'Cannot use Filter.byRef() in the aggregate API currently. Instead use Filter.byRefMultiTarget() and specify the target collection explicitly.'
      );
    } else if (target.multiTarget) {
      if (target.multiTarget.target === undefined) {
        throw new WeaviateSerializationError(
          `target of multiTarget filter was unexpectedly undefined: ${target}`
        );
      }
      return [
        target.multiTarget.on,
        target.multiTarget.targetCollection,
        ...Serialize.filterTargetToREST(target.multiTarget.target),
      ];
    } else if (target.count) {
      return [target.count.on];
    } else {
      return [];
    }
  };

  public static filtersREST = (filters: FilterValue): WhereFilter => {
    const { value } = filters;
    if (filters.operator === 'And' || filters.operator === 'Or') {
      return {
        operator: filters.operator,
        operands: filters.filters?.map(Serialize.filtersREST),
      };
    } else {
      if (filters.target === undefined) {
        throw new WeaviateSerializationError(`target of filter was unexpectedly undefined: ${filters}`);
      }
      const out = {
        path: Serialize.filterTargetToREST(filters.target),
        operator: filters.operator,
      };
      if (FilterGuards.isText(value)) {
        return {
          ...out,
          valueText: value,
        };
      } else if (FilterGuards.isTextArray(value)) {
        return {
          ...out,
          valueTextArray: value,
        };
      } else if (FilterGuards.isInt(value)) {
        return {
          ...out,
          valueInt: value,
        };
      } else if (FilterGuards.isIntArray(value)) {
        return {
          ...out,
          valueIntArray: value,
        };
      } else if (FilterGuards.isBoolean(value)) {
        return {
          ...out,
          valueBoolean: value,
        };
      } else if (FilterGuards.isBooleanArray(value)) {
        return {
          ...out,
          valueBooleanArray: value,
        };
      } else if (FilterGuards.isFloat(value)) {
        return {
          ...out,
          valueNumber: value,
        };
      } else if (FilterGuards.isFloatArray(value)) {
        return {
          ...out,
          valueNumberArray: value,
        };
      } else if (FilterGuards.isDate(value)) {
        return {
          ...out,
          valueDate: value.toISOString(),
        };
      } else if (FilterGuards.isDateArray(value)) {
        return {
          ...out,
          valueDateArray: value.map((v) => v.toISOString()),
        };
      } else if (FilterGuards.isGeoRange(value)) {
        return {
          ...out,
          valueGeoRange: {
            geoCoordinates: {
              latitude: value.latitude,
              longitude: value.longitude,
            },
            distance: {
              max: value.distance,
            },
          },
        };
      } else {
        throw new WeaviateInvalidInputError('Invalid filter value type');
      }
    }
  };

  private static operator = (operator: string): Filters_Operator => {
    switch (operator) {
      case 'Equal':
        return Filters_Operator.OPERATOR_EQUAL;
      case 'NotEqual':
        return Filters_Operator.OPERATOR_NOT_EQUAL;
      case 'ContainsAny':
        return Filters_Operator.OPERATOR_CONTAINS_ANY;
      case 'ContainsAll':
        return Filters_Operator.OPERATOR_CONTAINS_ALL;
      case 'GreaterThan':
        return Filters_Operator.OPERATOR_GREATER_THAN;
      case 'GreaterThanEqual':
        return Filters_Operator.OPERATOR_GREATER_THAN_EQUAL;
      case 'LessThan':
        return Filters_Operator.OPERATOR_LESS_THAN;
      case 'LessThanEqual':
        return Filters_Operator.OPERATOR_LESS_THAN_EQUAL;
      case 'Like':
        return Filters_Operator.OPERATOR_LIKE;
      case 'WithinGeoRange':
        return Filters_Operator.OPERATOR_WITHIN_GEO_RANGE;
      case 'IsNull':
        return Filters_Operator.OPERATOR_IS_NULL;
      default:
        return Filters_Operator.OPERATOR_UNSPECIFIED;
    }
  };

  private static queryProperties = <T>(
    properties?: QueryProperty<T>[],
    references?: QueryReference<T>[]
  ): PropertiesRequest => {
    const nonRefProperties = properties?.filter((property) => typeof property === 'string') as
      | string[]
      | undefined;
    const refProperties = references;
    const objectProperties = properties?.filter((property) => typeof property === 'object') as
      | QueryNested<T>[]
      | undefined;

    const resolveObjectProperty = (property: QueryNested<T>): ObjectPropertiesRequest => {
      const objProps = property.properties.filter((property) => typeof property !== 'string') as unknown; // cannot get types to work currently :(
      return {
        propName: property.name,
        primitiveProperties: property.properties.filter(
          (property) => typeof property === 'string'
        ) as string[],
        objectProperties: (objProps as QueryNested<T>[]).map(resolveObjectProperty),
      };
    };

    return {
      nonRefProperties: nonRefProperties === undefined ? [] : nonRefProperties,
      returnAllNonrefProperties: nonRefProperties === undefined,
      refProperties: refProperties
        ? refProperties.map((property) => {
            return {
              referenceProperty: property.linkOn,
              properties: Serialize.queryProperties(property.returnProperties as any),
              metadata: Serialize.metadata(property.includeVector, property.returnMetadata),
              targetCollection: property.targetCollection ? property.targetCollection : '',
            };
          })
        : [],
      objectProperties: objectProperties
        ? objectProperties.map((property) => {
            const objProps = property.properties.filter(
              (property) => typeof property !== 'string'
            ) as unknown; // cannot get types to work currently :(
            return {
              propName: property.name,
              primitiveProperties: property.properties.filter(
                (property) => typeof property === 'string'
              ) as string[],
              objectProperties: (objProps as QueryNested<T>[]).map(resolveObjectProperty),
            };
          })
        : [],
    };
  };

  private static metadata = (
    includeVector?: boolean | string[],
    metadata?: QueryMetadata
  ): MetadataRequest => {
    const out: any = {
      uuid: true,
      vector: typeof includeVector === 'boolean' ? includeVector : false,
      vectors: Array.isArray(includeVector) ? includeVector : [],
    };
    if (MetadataGuards.isAll(metadata)) {
      return {
        ...out,
        creationTimeUnix: true,
        lastUpdateTimeUnix: true,
        distance: true,
        certainty: true,
        score: true,
        explainScore: true,
        isConsistent: true,
      };
    }
    metadata?.forEach((key) => {
      let weaviateKey: string;
      if (key === 'creationTime') {
        weaviateKey = 'creationTimeUnix';
      } else if (key === 'updateTime') {
        weaviateKey = 'lastUpdateTimeUnix';
      } else {
        weaviateKey = key;
      }
      out[weaviateKey] = true;
    });
    return MetadataRequest.fromPartial(out);
  };

  private static sortBy = (sort: SortBy[]): SortByGrpc[] => {
    return sort.map((sort) => {
      return {
        ascending: !!sort.ascending,
        path: [sort.property],
      };
    });
  };

  public static rerank = <T>(rerank: RerankOptions<T>): Rerank => {
    return Rerank.fromPartial({
      property: rerank.property as string,
      query: rerank.query,
    });
  };

  public static generative = <T>(generative?: GenerateOptions<T>): GenerativeSearch => {
    return GenerativeSearch.fromPartial({
      singleResponsePrompt: generative?.singlePrompt,
      groupedResponseTask: generative?.groupedTask,
      groupedProperties: generative?.groupedProperties as string[],
    });
  };

  public static groupBy = <T>(groupBy?: GroupByOptions<T>): GroupBy => {
    return GroupBy.fromPartial({
      path: groupBy?.property ? [groupBy.property as string] : undefined,
      numberOfGroups: groupBy?.numberOfGroups,
      objectsPerGroup: groupBy?.objectsPerGroup,
    });
  };

  public static isGroupBy = <T>(args: any): args is T => {
    if (args === undefined) return false;
    return args.groupBy !== undefined;
  };

  public static restProperties = (
    properties: Record<string, WeaviateField>,
    references?: Record<string, ReferenceInput<any>>
  ): Record<string, any> => {
    const parsedProperties: any = {};
    Object.keys(properties).forEach((key) => {
      const value = properties[key];
      if (DataGuards.isDate(value)) {
        parsedProperties[key] = value.toISOString();
      } else if (DataGuards.isDateArray(value)) {
        parsedProperties[key] = value.map((v) => v.toISOString());
      } else if (DataGuards.isPhoneNumber(value)) {
        parsedProperties[key] = {
          input: value.number,
          defaultCountry: value.defaultCountry,
        };
      } else if (DataGuards.isNestedArray(value)) {
        parsedProperties[key] = value.map((v) => Serialize.restProperties(v));
      } else if (DataGuards.isNested(value)) {
        parsedProperties[key] = Serialize.restProperties(value);
      } else {
        parsedProperties[key] = value;
      }
    });
    if (!references) return parsedProperties;
    for (const [key, value] of Object.entries(references)) {
      if (ReferenceGuards.isReferenceManager(value)) {
        parsedProperties[key] = value.toBeaconObjs();
      } else if (ReferenceGuards.isUuid(value)) {
        parsedProperties[key] = [uuidToBeacon(value)];
      } else if (ReferenceGuards.isMultiTarget(value)) {
        parsedProperties[key] =
          typeof value.uuids === 'string'
            ? [uuidToBeacon(value.uuids, value.targetCollection)]
            : value.uuids.map((uuid) => uuidToBeacon(uuid, value.targetCollection));
      } else {
        let out: Beacon[] = [];
        value.forEach((v) => {
          if (ReferenceGuards.isReferenceManager(v)) {
            out = out.concat(v.toBeaconObjs());
          } else if (ReferenceGuards.isUuid(v)) {
            out.push(uuidToBeacon(v));
          } else {
            out = out.concat(
              (ReferenceGuards.isUuid(v.uuids) ? [v.uuids] : v.uuids).map((uuid) =>
                uuidToBeacon(uuid, v.targetCollection)
              )
            );
          }
        });
        parsedProperties[key] = out;
      }
    }
    return parsedProperties;
  };

  private static batchProperties = (
    properties?: Record<string, any>,
    references?: Record<string, ReferenceInput<any>>
  ): BatchObject_Properties => {
    const multiTarget: BatchObject_MultiTargetRefProps[] = [];
    const singleTarget: BatchObject_SingleTargetRefProps[] = [];
    const nonRefProperties: Record<string, any> = {};
    const emptyArray: string[] = [];
    const boolArray: BooleanArrayProperties[] = [];
    const textArray: TextArrayProperties[] = [];
    const intArray: IntArrayProperties[] = [];
    const floatArray: NumberArrayProperties[] = [];
    const objectProperties: ObjectProperties[] = [];
    const objectArrayProperties: ObjectArrayProperties[] = [];

    const resolveProps = (key: string, value: any) => {
      if (DataGuards.isEmptyArray(value)) {
        emptyArray.push(key);
      } else if (DataGuards.isBooleanArray(value)) {
        boolArray.push({
          propName: key,
          values: value,
        });
      } else if (DataGuards.isDateArray(value)) {
        textArray.push({
          propName: key,
          values: value.map((v) => v.toISOString()),
        });
      } else if (DataGuards.isTextArray(value)) {
        textArray.push({
          propName: key,
          values: value,
        });
      } else if (DataGuards.isIntArray(value)) {
        intArray.push({
          propName: key,
          values: value,
        });
      } else if (DataGuards.isFloatArray(value)) {
        floatArray.push({
          propName: key,
          values: [],
          valuesBytes: new Uint8Array(new Float64Array(value).buffer), // is double in proto => f64 in go
        });
      } else if (DataGuards.isDate(value)) {
        nonRefProperties[key] = value.toISOString();
      } else if (DataGuards.isPhoneNumber(value)) {
        nonRefProperties[key] = {
          input: value.number,
          defaultCountry: value.defaultCountry,
        };
      } else if (DataGuards.isGeoCoordinate(value)) {
        nonRefProperties[key] = value;
      } else if (DataGuards.isNestedArray(value)) {
        objectArrayProperties.push({
          propName: key,
          values: value.map((v) => ObjectPropertiesValue.fromPartial(Serialize.batchProperties(v))),
        });
      } else if (DataGuards.isNested(value)) {
        const parsed = Serialize.batchProperties(value);
        objectProperties.push({
          propName: key,
          value: ObjectPropertiesValue.fromPartial(parsed),
        });
      } else {
        nonRefProperties[key] = value;
      }
    };

    const resolveRefs = (key: string, value: ReferenceInput<any>) => {
      if (ReferenceGuards.isReferenceManager(value)) {
        if (value.isMultiTarget()) {
          multiTarget.push({
            propName: key,
            targetCollection: value.targetCollection,
            uuids: value.toBeaconStrings(),
          });
        } else {
          singleTarget.push({
            propName: key,
            uuids: value.toBeaconStrings(),
          });
        }
      } else if (ReferenceGuards.isUuid(value)) {
        singleTarget.push({
          propName: key,
          uuids: [value],
        });
      } else if (ReferenceGuards.isMultiTarget(value)) {
        multiTarget.push({
          propName: key,
          targetCollection: value.targetCollection,
          uuids: typeof value.uuids === 'string' ? [value.uuids] : value.uuids,
        });
      } else {
        value.forEach((v) => resolveRefs(key, v));
      }
    };

    if (properties) {
      Object.entries(properties).forEach(([key, value]) => resolveProps(key, value));
    }

    if (references) {
      Object.entries(references).forEach(([key, value]) => resolveRefs(key, value));
    }

    return {
      nonRefProperties: nonRefProperties,
      multiTargetRefProps: multiTarget,
      singleTargetRefProps: singleTarget,
      textArrayProperties: textArray,
      intArrayProperties: intArray,
      numberArrayProperties: floatArray,
      booleanArrayProperties: boolArray,
      objectProperties: objectProperties,
      objectArrayProperties: objectArrayProperties,
      emptyListProps: emptyArray,
    };
  };

  public static batchObjects = <T>(
    collection: string,
    objects: (DataObject<T> | NonReferenceInputs<T>)[],
    requiresInsertFix: boolean,
    tenant?: string
  ): Promise<BatchObjects<T>> => {
    const objs: BatchObjectGRPC[] = [];
    const batch: BatchObject<T>[] = [];

    const iterate = (index: number) => {
      // This allows the potentially CPU-intensive work to be done in chunks
      // releasing control to the event loop after every object so that other
      // events can be processed without blocking completely.

      if (index < objects.length) {
        setTimeout(() => iterate(index + 1));
      } else {
        return;
      }

      const object = objects[index];
      const obj = DataGuards.isDataObject(object)
        ? object
        : { id: undefined, properties: object, references: undefined, vectors: undefined };

      let vectorBytes: Uint8Array | undefined;
      let vectors: VectorsGrpc[] | undefined;
      if (obj.vectors !== undefined && !Array.isArray(obj.vectors)) {
        vectors = Object.entries(obj.vectors).map(([k, v]) =>
          VectorsGrpc.fromPartial({
            vectorBytes: Serialize.vectorToBytes(v),
            name: k,
          })
        );
      } else if (Array.isArray(obj.vectors) && requiresInsertFix) {
        vectors = [
          VectorsGrpc.fromPartial({
            vectorBytes: Serialize.vectorToBytes(obj.vectors),
            name: 'default',
          }),
        ];
        vectorBytes = Serialize.vectorToBytes(obj.vectors);
        // required in case collection was made with <1.24.0 and has since been migrated to >=1.24.0
      } else if (obj.vectors !== undefined) {
        vectorBytes = Serialize.vectorToBytes(obj.vectors);
      }

      objs.push(
        BatchObjectGRPC.fromPartial({
          collection: collection,
          properties: Serialize.batchProperties(obj.properties, obj.references),
          tenant: tenant,
          uuid: obj.id ? obj.id : uuidv4(),
          vectorBytes,
          vectors,
        })
      );

      batch.push({
        ...obj,
        collection: collection,
        tenant: tenant,
      });
    };

    const waitFor = () => {
      const poll = (resolve: (value: null) => void) => {
        if (objs.length < objects.length) {
          setTimeout(() => poll(resolve), 500);
        } else {
          resolve(null);
        }
      };
      return new Promise(poll);
    };

    iterate(0);

    return waitFor().then(() => {
      return { batch: batch, mapped: objs };
    });
  };

  public static tenants<T, M>(tenants: T[], mapper: (tenant: T) => M): M[][] {
    const mapped = [];
    const batches = Math.ceil(tenants.length / 100);
    for (let i = 0; i < batches; i++) {
      const batch = tenants.slice(i * 100, (i + 1) * 100);
      mapped.push(batch.map(mapper));
    }
    return mapped;
  }

  public static tenantCreate<T extends TenantBC | TenantCreate>(
    tenant: T
  ): {
    name: string;
    activityStatus?: 'HOT' | 'COLD';
  } {
    let activityStatus: 'HOT' | 'COLD' | undefined;
    switch (tenant.activityStatus) {
      case 'ACTIVE':
        activityStatus = 'HOT';
        break;
      case 'INACTIVE':
        activityStatus = 'COLD';
        break;
      case 'HOT':
      case 'COLD':
      case undefined:
        activityStatus = tenant.activityStatus;
        break;
      case 'FROZEN':
        throw new WeaviateInvalidInputError(
          'Invalid activity status. Please provide one of the following: ACTIVE, INACTIVE, HOT, COLD.'
        );
      default:
        throw new WeaviateInvalidInputError(
          'Invalid activity status. Please provide one of the following: ACTIVE, INACTIVE, HOT, COLD.'
        );
    }
    return {
      name: tenant.name,
      activityStatus,
    };
  }

  public static tenantUpdate<T extends TenantBC | TenantUpdate>(
    tenant: T
  ): { name: string; activityStatus: 'HOT' | 'COLD' | 'FROZEN' } {
    let activityStatus: 'HOT' | 'COLD' | 'FROZEN';
    switch (tenant.activityStatus) {
      case 'ACTIVE':
        activityStatus = 'HOT';
        break;
      case 'INACTIVE':
        activityStatus = 'COLD';
        break;
      case 'OFFLOADED':
        activityStatus = 'FROZEN';
        break;
      case 'HOT':
      case 'COLD':
      case 'FROZEN':
        activityStatus = tenant.activityStatus;
        break;
      default:
        throw new WeaviateInvalidInputError(
          'Invalid activity status. Please provide one of the following: ACTIVE, INACTIVE, HOT, COLD, OFFLOADED.'
        );
    }
    return {
      name: tenant.name,
      activityStatus,
    };
  }
}



---
File: /src/collections/serialize/unit.test.ts
---

import {
  SearchBm25Args,
  SearchFetchArgs,
  SearchHybridArgs,
  SearchNearAudioArgs,
  SearchNearDepthArgs,
  SearchNearIMUArgs,
  SearchNearImageArgs,
  SearchNearObjectArgs,
  SearchNearTextArgs,
  SearchNearThermalArgs,
  SearchNearVectorArgs,
  SearchNearVideoArgs,
} from '../../grpc/searcher.js';
import { Filters, Filters_Operator } from '../../proto/v1/base.js';
import { GenerativeSearch } from '../../proto/v1/generative.js';
import {
  BM25,
  CombinationMethod,
  GroupBy,
  Hybrid,
  Hybrid_FusionType,
  MetadataRequest,
  NearAudioSearch,
  NearDepthSearch,
  NearIMUSearch,
  NearImageSearch,
  NearObject,
  NearTextSearch,
  NearTextSearch_Move,
  NearThermalSearch,
  NearVector,
  NearVideoSearch,
  PropertiesRequest,
  Targets,
} from '../../proto/v1/search_get.js';
import { Filters as FiltersFactory } from '../filters/classes.js';
import filter from '../filters/index.js';
import { TargetVectorInputType } from '../query/types.js';
import { Reference } from '../references/index.js';
import sort from '../sort/index.js';
import { WeaviateField } from '../types/index.js';
import multiTargetVector from '../vectors/multiTargetVector.js';
import { DataGuards, Serialize } from './index.js';

describe('Unit testing of Serialize', () => {
  it('should parse args for fetchObjects', () => {
    const args = Serialize.fetchObjects({
      limit: 1,
      offset: 0,
      after: 'one',
      filters: filter<any>().byProperty('name').equal('test'),
      sort: sort<any>().byProperty('name'),
      includeVector: true,
      returnMetadata: 'all',
      returnProperties: ['name'],
      returnReferences: [{ linkOn: 'ref' }],
    });
    expect(args).toEqual<SearchFetchArgs>({
      limit: 1,
      offset: 0,
      after: 'one',
      filters: Filters.fromPartial({
        operator: Filters_Operator.OPERATOR_EQUAL,
        target: {
          property: 'name',
        },
        valueText: 'test',
      }),
      sortBy: [{ ascending: true, path: ['name'] }],
      metadata: MetadataRequest.fromPartial({
        certainty: true,
        distance: true,
        uuid: true,
        vector: true,
        vectors: undefined,
        creationTimeUnix: true,
        lastUpdateTimeUnix: true,
        isConsistent: true,
        explainScore: true,
        score: true,
      }),
      properties: PropertiesRequest.fromPartial({
        nonRefProperties: ['name'],
        refProperties: [
          {
            metadata: MetadataRequest.fromPartial({ uuid: true }),
            properties: PropertiesRequest.fromPartial({ returnAllNonrefProperties: true }),
            referenceProperty: 'ref',
            targetCollection: '',
          },
        ],
      }),
    });
  });

  it('should parse args for fetchObjectById', () => {
    const args = Serialize.fetchObjectById({
      id: '1',
      includeVector: ['title'],
      returnProperties: ['name'],
      returnReferences: [{ linkOn: 'ref' }],
    });
    expect(args).toEqual<SearchFetchArgs>({
      filters: Filters.fromPartial({
        operator: Filters_Operator.OPERATOR_EQUAL,
        target: {
          property: '_id',
        },
        valueText: '1',
      }),
      metadata: MetadataRequest.fromPartial({
        creationTimeUnix: true,
        lastUpdateTimeUnix: true,
        isConsistent: true,
        uuid: true,
        vectors: ['title'],
      }),
      properties: PropertiesRequest.fromPartial({
        nonRefProperties: ['name'],
        refProperties: [
          {
            metadata: MetadataRequest.fromPartial({ uuid: true }),
            properties: PropertiesRequest.fromPartial({ returnAllNonrefProperties: true }),
            referenceProperty: 'ref',
            targetCollection: '',
          },
        ],
      }),
    });
  });

  it('should parse args for bm25', () => {
    const args = Serialize.bm25({
      query: 'test',
      queryProperties: ['name'],
      autoLimit: 1,
    });
    expect(args).toEqual<SearchBm25Args>({
      bm25Search: BM25.fromPartial({
        query: 'test',
        properties: ['name'],
      }),
      autocut: 1,
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for simple hybrid', () => {
    const args = Serialize.hybrid({
      query: 'test',
      queryProperties: ['name'],
      alpha: 0.6,
      vector: [1, 2, 3],
      targetVector: 'title',
      fusionType: 'Ranked',
      supportsTargets: false,
      supportsVectorsForTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchHybridArgs>({
      hybridSearch: Hybrid.fromPartial({
        query: 'test',
        properties: ['name'],
        alpha: 0.6,
        vectorBytes: new Uint8Array(new Float32Array([1, 2, 3]).buffer),
        targetVectors: ['title'],
        fusionType: Hybrid_FusionType.FUSION_TYPE_RANKED,
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for multi-vector & multi-target hybrid', () => {
    const args = Serialize.hybrid({
      query: 'test',
      queryProperties: ['name'],
      alpha: 0.6,
      vector: {
        title: [
          [1, 2, 3],
          [4, 5, 6],
        ],
        description: [7, 8, 9],
      },
      targetVector: multiTargetVector().manualWeights({ title: [0.5, 0.5], description: 0.5 }),
      fusionType: 'Ranked',
      supportsTargets: true,
      supportsVectorsForTargets: true,
      supportsWeightsForTargets: true,
    });
    expect(args).toEqual<SearchHybridArgs>({
      hybridSearch: Hybrid.fromPartial({
        query: 'test',
        properties: ['name'],
        alpha: 0.6,
        nearVector: NearVector.fromPartial({
          vectorForTargets: [
            { name: 'title', vectorBytes: new Uint8Array(new Float32Array([1, 2, 3]).buffer) },
            { name: 'title', vectorBytes: new Uint8Array(new Float32Array([4, 5, 6]).buffer) },
            { name: 'description', vectorBytes: new Uint8Array(new Float32Array([7, 8, 9]).buffer) },
          ],
        }),
        targets: Targets.fromPartial({
          combination: CombinationMethod.COMBINATION_METHOD_TYPE_MANUAL,
          targetVectors: ['title', 'title', 'description'],
          weightsForTargets: [
            {
              target: 'title',
              weight: 0.5,
            },
            {
              target: 'title',
              weight: 0.5,
            },
            {
              target: 'description',
              weight: 0.5,
            },
          ],
        }),
        fusionType: Hybrid_FusionType.FUSION_TYPE_RANKED,
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearAudio', () => {
    const args = Serialize.nearAudio({
      audio: 'audio',
      certainty: 0.6,
      distance: 0.4,
      targetVector: 'audio',
      supportsTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearAudioArgs>({
      nearAudio: NearAudioSearch.fromPartial({
        audio: 'audio',
        certainty: 0.6,
        distance: 0.4,
        targetVectors: ['audio'],
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearDepth', () => {
    const args = Serialize.nearDepth({
      depth: 'depth',
      supportsTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearDepthArgs>({
      nearDepth: NearDepthSearch.fromPartial({
        depth: 'depth',
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearIMU', () => {
    const args = Serialize.nearIMU({
      imu: 'imu',
      supportsTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearIMUArgs>({
      nearIMU: NearIMUSearch.fromPartial({
        imu: 'imu',
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearImage', () => {
    const args = Serialize.nearImage({
      image: 'image',
      supportsTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearImageArgs>({
      nearImage: NearImageSearch.fromPartial({
        image: 'image',
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearObject', () => {
    const args = Serialize.nearObject({
      id: 'id',
      supportsTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearObjectArgs>({
      nearObject: NearObject.fromPartial({
        id: 'id',
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearText', () => {
    const args = Serialize.nearText({
      query: 'test',
      moveAway: {
        objects: ['0'],
        concepts: ['bad'],
        force: 0.4,
      },
      moveTo: {
        objects: ['1'],
        concepts: ['good'],
        force: 0.6,
      },
      supportsTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearTextArgs>({
      nearText: NearTextSearch.fromPartial({
        query: ['test'],
        moveAway: NearTextSearch_Move.fromPartial({
          uuids: ['0'],
          concepts: ['bad'],
          force: 0.4,
        }),
        moveTo: NearTextSearch_Move.fromPartial({
          uuids: ['1'],
          concepts: ['good'],
          force: 0.6,
        }),
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearThermal', () => {
    const args = Serialize.nearThermal({
      thermal: 'thermal',
      supportsTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearThermalArgs>({
      nearThermal: NearThermalSearch.fromPartial({
        thermal: 'thermal',
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearVector with single vector', () => {
    const args = Serialize.nearVector({
      vector: [1, 2, 3],
      supportsTargets: false,
      supportsVectorsForTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearVectorArgs>({
      nearVector: NearVector.fromPartial({
        vectorBytes: new Uint8Array(new Float32Array([1, 2, 3]).buffer),
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearVector with two named vectors and supportsTargets (<1.27.0)', () => {
    const args = Serialize.nearVector({
      vector: {
        a: [1, 2, 3],
        b: [4, 5, 6],
      },
      supportsTargets: true,
      supportsVectorsForTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearVectorArgs>({
      nearVector: NearVector.fromPartial({
        vectorPerTarget: {
          a: new Uint8Array(new Float32Array([1, 2, 3]).buffer),
          b: new Uint8Array(new Float32Array([4, 5, 6]).buffer),
        },
        targets: { targetVectors: ['a', 'b'] },
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearVector with two named vectors and all supports (==1.27.x)', () => {
    const args = Serialize.nearVector({
      vector: {
        a: [
          [1, 2, 3],
          [4, 5, 6],
        ],
        b: [7, 8, 9],
      },
      supportsTargets: true,
      supportsVectorsForTargets: true,
      supportsWeightsForTargets: true,
    });
    expect(args).toEqual<SearchNearVectorArgs>({
      nearVector: NearVector.fromPartial({
        vectorForTargets: [
          { name: 'a', vectorBytes: new Uint8Array(new Float32Array([1, 2, 3]).buffer) },
          { name: 'a', vectorBytes: new Uint8Array(new Float32Array([4, 5, 6]).buffer) },
          { name: 'b', vectorBytes: new Uint8Array(new Float32Array([7, 8, 9]).buffer) },
        ],
        targets: { targetVectors: ['a', 'a', 'b'] },
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for nearVideo', () => {
    const args = Serialize.nearVideo({
      video: 'video',
      supportsTargets: false,
      supportsWeightsForTargets: false,
    });
    expect(args).toEqual<SearchNearVideoArgs>({
      nearVideo: NearVideoSearch.fromPartial({
        video: 'video',
      }),
      metadata: MetadataRequest.fromPartial({ uuid: true }),
    });
  });

  it('should parse args for generative', () => {
    const args = Serialize.generative({
      singlePrompt: 'test',
      groupedProperties: ['name'],
      groupedTask: 'testing',
    });
    expect(args).toEqual<GenerativeSearch>({
      singleResponsePrompt: 'test',
      groupedProperties: ['name'],
      groupedResponseTask: 'testing',
      single: undefined,
      grouped: undefined,
    });
  });

  it('should parse args for groupBy', () => {
    const args = Serialize.groupBy({
      property: 'name',
      numberOfGroups: 1,
      objectsPerGroup: 2,
    });
    expect(args).toEqual<GroupBy>({
      path: ['name'],
      numberOfGroups: 1,
      objectsPerGroup: 2,
    });
  });

  it('should parse args for isGroupBy', () => {
    const isGroupBy = Serialize.isGroupBy({
      groupBy: {
        property: 'name',
        numberOfGroups: 1,
        objectsPerGroup: 2,
      },
    });
    const isNotGroupBy = Serialize.isGroupBy({});
    expect(isGroupBy).toEqual(true);
    expect(isNotGroupBy).toEqual(false);
  });

  it('should parse args for restProperties', () => {
    const args = Serialize.restProperties(
      {
        name: 'John',
        age: 30,
        height: 1.8,
        isHappy: true,
        birthday: new Date(),
        namedays: [new Date(), new Date()],
        location: {
          latitude: 1,
          longitude: 1,
        },
        phoneNumber: {
          number: '+44 1234 567890',
        },
        clothing: [
          {
            type: 'shirt',
            color: 'blue',
            whenMade: new Date(),
          },
          {
            type: 'pants',
            color: 'black',
            whenMade: new Date(),
          },
        ],
        mindset: {
          hopeful: true,
          optimistic: true,
        },
      },
      {
        str: '1',
        strs: ['2', '3'],
        typeStr: {
          targetCollection: 'A',
          uuids: '4',
        },
        typesStr: [
          {
            targetCollection: 'B',
            uuids: '5',
          },
          {
            targetCollection: 'C',
            uuids: '6',
          },
        ],
        typeStrs: {
          targetCollection: 'D',
          uuids: ['7', '8'],
        },
        typesStrs: [
          {
            targetCollection: 'E',
            uuids: ['9', '10'],
          },
          {
            targetCollection: 'F',
            uuids: ['11', '12'],
          },
        ],
        mngrStrSngl: Reference.to('13'),
        mngrsStrSngl: [Reference.to('14'), Reference.to('15')],
        mngrStrMlt: Reference.toMultiTarget('16', 'G'),
        mngrsStrMlt: [Reference.toMultiTarget(['17', '18'], 'H'), Reference.toMultiTarget(['19', '20'], 'I')],
        mngrStrsSngl: Reference.to(['21', '22']),
        mngrsStrsSngl: [Reference.to(['23', '24']), Reference.to(['25', '26'])],
        mngrStrsMlt: Reference.toMultiTarget(['27', '28'], 'J'),
        mngrsStrsMlt: [
          Reference.toMultiTarget(['29', '30'], 'K'),
          Reference.toMultiTarget(['31', '32'], 'L'),
        ],
      }
    );
    expect(args).toEqual({
      name: 'John',
      age: 30,
      height: 1.8,
      isHappy: true,
      birthday: expect.any(String),
      namedays: [expect.any(String), expect.any(String)],
      location: {
        latitude: 1,
        longitude: 1,
      },
      phoneNumber: {
        input: '+44 1234 567890',
      },
      clothing: [
        {
          type: 'shirt',
          color: 'blue',
          whenMade: expect.any(String),
        },
        {
          type: 'pants',
          color: 'black',
          whenMade: expect.any(String),
        },
      ],
      mindset: {
        hopeful: true,
        optimistic: true,
      },
      str: [{ beacon: 'weaviate://localhost/1' }],
      strs: [{ beacon: 'weaviate://localhost/2' }, { beacon: 'weaviate://localhost/3' }],
      typeStr: [{ beacon: 'weaviate://localhost/A/4' }],
      typesStr: [{ beacon: 'weaviate://localhost/B/5' }, { beacon: 'weaviate://localhost/C/6' }],
      typeStrs: [{ beacon: 'weaviate://localhost/D/7' }, { beacon: 'weaviate://localhost/D/8' }],
      typesStrs: [
        { beacon: 'weaviate://localhost/E/9' },
        { beacon: 'weaviate://localhost/E/10' },
        { beacon: 'weaviate://localhost/F/11' },
        { beacon: 'weaviate://localhost/F/12' },
      ],
      mngrStrSngl: [{ beacon: 'weaviate://localhost/13' }],
      mngrsStrSngl: [{ beacon: 'weaviate://localhost/14' }, { beacon: 'weaviate://localhost/15' }],
      mngrStrMlt: [{ beacon: 'weaviate://localhost/G/16' }],
      mngrsStrMlt: [
        { beacon: 'weaviate://localhost/H/17' },
        { beacon: 'weaviate://localhost/H/18' },
        { beacon: 'weaviate://localhost/I/19' },
        { beacon: 'weaviate://localhost/I/20' },
      ],
      mngrStrsSngl: [{ beacon: 'weaviate://localhost/21' }, { beacon: 'weaviate://localhost/22' }],
      mngrsStrsSngl: [
        { beacon: 'weaviate://localhost/23' },
        { beacon: 'weaviate://localhost/24' },
        { beacon: 'weaviate://localhost/25' },
        { beacon: 'weaviate://localhost/26' },
      ],
      mngrStrsMlt: [{ beacon: 'weaviate://localhost/J/27' }, { beacon: 'weaviate://localhost/J/28' }],
      mngrsStrsMlt: [
        { beacon: 'weaviate://localhost/K/29' },
        { beacon: 'weaviate://localhost/K/30' },
        { beacon: 'weaviate://localhost/L/31' },
        { beacon: 'weaviate://localhost/L/32' },
      ],
    });
  });

  it('should parse isMultiWeightPerTarget', () => {
    expect(
      Serialize.isMultiWeightPerTarget({
        targetVector: 'a',
      })
    ).toEqual(false);
    expect(
      Serialize.isMultiWeightPerTarget({
        targetVector: ['a'],
      })
    ).toEqual(false);
    expect(
      Serialize.isMultiWeightPerTarget({
        targetVector: multiTargetVector().manualWeights({ a: 0.5, b: 0.5 }),
      })
    ).toEqual(false);
    expect(
      Serialize.isMultiWeightPerTarget({
        targetVector: multiTargetVector().manualWeights({ a: [0.5, 0.5], b: 0.5 }),
      })
    ).toEqual(true);
  });

  describe('should parse TargetVectorInput type', () => {
    type Out = {
      targets?: Targets;
      targetVectors?: string[];
    };
    type Test = {
      name: string;
      targetVector: TargetVectorInputType;
      supportsTargets: boolean;
      supportsWeightsForTargets: boolean;
      out: Out;
    };
    const tests: Test[] = [
      {
        name: 'should parse single target vector into targets',
        targetVector: 'a',
        supportsTargets: true,
        supportsWeightsForTargets: false,
        out: {
          targets: Targets.fromPartial({ targetVectors: ['a'] }),
        },
      },
      {
        name: 'should parse list of target vectors into targets',
        targetVector: ['a', 'b'],
        supportsTargets: true,
        supportsWeightsForTargets: false,
        out: {
          targets: Targets.fromPartial({ targetVectors: ['a', 'b'] }),
        },
      },
      {
        name: 'should parse MultiTargetJoin sum',
        targetVector: multiTargetVector().average(['a', 'b']),
        supportsTargets: true,
        supportsWeightsForTargets: false,
        out: {
          targets: Targets.fromPartial({
            combination: CombinationMethod.COMBINATION_METHOD_TYPE_AVERAGE,
            targetVectors: ['a', 'b'],
          }),
        },
      },
      {
        name: 'should parse MultiTargetJoin manual single weight per target',
        targetVector: multiTargetVector().manualWeights({ a: 0.5, b: 0.5 }),
        supportsTargets: true,
        supportsWeightsForTargets: false,
        out: {
          targets: Targets.fromPartial({
            combination: CombinationMethod.COMBINATION_METHOD_TYPE_MANUAL,
            targetVectors: ['a', 'b'],
            weights: { a: 0.5, b: 0.5 },
          }),
        },
      },
      {
        name: 'should parse MultiTargetJoin manual multiple weights per target',
        targetVector: multiTargetVector().manualWeights({ a: [0.5, 0.5], b: 0.5 }),
        supportsTargets: true,
        supportsWeightsForTargets: true,
        out: {
          targets: Targets.fromPartial({
            combination: CombinationMethod.COMBINATION_METHOD_TYPE_MANUAL,
            targetVectors: ['a', 'a', 'b'],
            weightsForTargets: [
              { target: 'a', weight: 0.5 },
              { target: 'a', weight: 0.5 },
              { target: 'b', weight: 0.5 },
            ],
          }),
        },
      },
      {
        name: 'should parse MultiTargetJoin minimum',
        targetVector: multiTargetVector().minimum(['a', 'b']),
        supportsTargets: true,
        supportsWeightsForTargets: false,
        out: {
          targets: Targets.fromPartial({
            combination: CombinationMethod.COMBINATION_METHOD_TYPE_MIN,
            targetVectors: ['a', 'b'],
          }),
        },
      },
      {
        name: 'should parse MultiTargetJoin sum',
        targetVector: multiTargetVector().average(['a', 'b']),
        supportsTargets: true,
        supportsWeightsForTargets: false,
        out: {
          targets: Targets.fromPartial({
            combination: CombinationMethod.COMBINATION_METHOD_TYPE_AVERAGE,
            targetVectors: ['a', 'b'],
          }),
        },
      },
      {
        name: 'should parse MultiTargetJoin relativeScore single weight per target',
        targetVector: multiTargetVector().relativeScore({ a: 0.5, b: 0.5 }),
        supportsTargets: true,
        supportsWeightsForTargets: false,
        out: {
          targets: Targets.fromPartial({
            combination: CombinationMethod.COMBINATION_METHOD_TYPE_RELATIVE_SCORE,
            targetVectors: ['a', 'b'],
            weights: { a: 0.5, b: 0.5 },
          }),
        },
      },
      {
        name: 'should parse MultiTargetJoin relativeScore multiple weights per target',
        targetVector: multiTargetVector().relativeScore({ a: [0.5, 0.5], b: 0.5 }),
        supportsTargets: true,
        supportsWeightsForTargets: true,
        out: {
          targets: Targets.fromPartial({
            combination: CombinationMethod.COMBINATION_METHOD_TYPE_RELATIVE_SCORE,
            targetVectors: ['a', 'a', 'b'],
            weightsForTargets: [
              { target: 'a', weight: 0.5 },
              { target: 'a', weight: 0.5 },
              { target: 'b', weight: 0.5 },
            ],
          }),
        },
      },
      {
        name: 'should parse MultiTargetJoin sum',
        targetVector: multiTargetVector().sum(['a', 'b']),
        supportsTargets: true,
        supportsWeightsForTargets: false,
        out: {
          targets: Targets.fromPartial({
            combination: CombinationMethod.COMBINATION_METHOD_TYPE_SUM,
            targetVectors: ['a', 'b'],
          }),
        },
      },
    ];
    const test = (test: Test) =>
      it(test.name, () => {
        const args = Serialize.targetVector(test);
        expect(args).toEqual<Out>(test.out);
      });
    tests.forEach(test);
  });

  describe('.filtersGRPC', () => {
    it('should parse a text property', () => {
      const f = filter<any>().byProperty('name').equal('test');
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'name',
        },
        valueText: 'test',
      });
    });
    it('should parse a text array property', () => {
      const f = filter<any>().byProperty('name').equal(['test1', 'test2']);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'name',
        },
        valueTextArray: { values: ['test1', 'test2'] },
      });
    });
    it('should parse an int property', () => {
      const f = filter<any>().byProperty('age').equal(10);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'age',
        },
        valueInt: 10,
      });
    });
    it('should parse an int array property', () => {
      const f = filter<any>().byProperty('age').equal([10, 20]);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'age',
        },
        valueIntArray: { values: [10, 20] },
      });
    });
    it('should parse a float property', () => {
      const f = filter<any>().byProperty('height').equal(1.8);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'height',
        },
        valueNumber: 1.8,
      });
    });
    it('should parse a float array property', () => {
      const f = filter<any>().byProperty('height').equal([1.8, 2.8]);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'height',
        },
        valueNumberArray: { values: [1.8, 2.8] },
      });
    });
    it('should parse a boolean property', () => {
      const f = filter<any>().byProperty('isHappy').equal(true);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'isHappy',
        },
        valueBoolean: true,
      });
    });
    it('should parse a boolean array property', () => {
      const f = filter<any>().byProperty('isHappy').equal([true, false]);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'isHappy',
        },
        valueBooleanArray: { values: [true, false] },
      });
    });
    it('should parse a date property', () => {
      const date = new Date();
      const f = filter<any>().byProperty('birthday').equal(date);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'birthday',
        },
        valueText: date.toISOString(),
      });
    });
    it('should parse a date array property', () => {
      const date1 = new Date();
      const date2 = new Date();
      const f = filter<any>().byProperty('birthday').equal([date1, date2]);
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_EQUAL,
        on: [],
        filters: [],
        target: {
          property: 'birthday',
        },
        valueTextArray: { values: [date1.toISOString(), date2.toISOString()] },
      });
    });
    it('should parse a geo property', () => {
      const f = filter<any>()
        .byProperty('location')
        .withinGeoRange({ latitude: 1, longitude: 1, distance: 1 });
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_WITHIN_GEO_RANGE,
        on: [],
        filters: [],
        target: {
          property: 'location',
        },
        valueGeo: {
          distance: 1,
          latitude: 1,
          longitude: 1,
        },
      });
    });
    it('should parse several filters in a Filters.and', () => {
      const f = FiltersFactory.and(
        filter<any>().byProperty('name').equal('test'),
        filter<any>().byProperty('age').equal(10)
      );
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_AND,
        on: [],
        target: undefined,
        filters: [
          {
            operator: Filters_Operator.OPERATOR_EQUAL,
            on: [],
            filters: [],
            target: {
              property: 'name',
            },
            valueText: 'test',
          },
          {
            operator: Filters_Operator.OPERATOR_EQUAL,
            on: [],
            filters: [],
            target: {
              property: 'age',
            },
            valueInt: 10,
          },
        ],
      });
    });
    it('should parse several filters in a Filters.or', () => {
      const f = FiltersFactory.or(
        filter<any>().byProperty('name').equal('test'),
        filter<any>().byProperty('age').equal(10)
      );
      const args = Serialize.filtersGRPC(f);
      expect(args).toEqual<Filters>({
        operator: Filters_Operator.OPERATOR_OR,
        on: [],
        target: undefined,
        filters: [
          {
            operator: Filters_Operator.OPERATOR_EQUAL,
            on: [],
            filters: [],
            target: {
              property: 'name',
            },
            valueText: 'test',
          },
          {
            operator: Filters_Operator.OPERATOR_EQUAL,
            on: [],
            filters: [],
            target: {
              property: 'age',
            },
            valueInt: 10,
          },
        ],
      });
    });
  });
});

describe('Unit testing of DataGuards', () => {
  const values: WeaviateField[] = [
    1,
    1.1,
    NaN,
    Infinity,
    new Date(),
    { prop: 'hi' },
    [],
    true,
    'text',
    {
      latitude: 1,
      longitude: 1,
    },
    {
      number: '+44 1234 567890',
    },
    [1],
    [1.1],
    [NaN],
    [Infinity],
    [new Date()],
    [{ prop: 'hi' }],
    [true],
    ['text'],
  ];
  const opposite =
    (f: (...args: any[]) => any) =>
    (...args: any[]): any =>
      !f(...args);
  it('should check isText', () => {
    const pred = (v: any) => v === 'text';
    values
      .filter(pred)
      .map(DataGuards.isText)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isText)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isTextArray', () => {
    const pred = (v: any) => Array.isArray(v) && v[0] === 'text';
    values
      .filter(pred)
      .map(DataGuards.isTextArray)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isTextArray)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isInt', () => {
    const pred = (v: any) => v === 1;
    values
      .filter(pred)
      .map(DataGuards.isInt)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isInt)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isIntArray', () => {
    const pred = (v: any) => Array.isArray(v) && v[0] === 1;
    values
      .filter(pred)
      .map(DataGuards.isIntArray)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isIntArray)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isFloat', () => {
    const pred = (v: any) => v === 1.1;
    values
      .filter(pred)
      .map(DataGuards.isFloat)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isFloat)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isFloatArray', () => {
    const pred = (v: any) => Array.isArray(v) && v[0] === 1.1;
    values
      .filter(pred)
      .map(DataGuards.isFloatArray)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isFloatArray)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isBoolean', () => {
    const pred = (v: any) => v === true;
    values
      .filter(pred)
      .map(DataGuards.isBoolean)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isBoolean)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isBooleanArray', () => {
    const pred = (v: any) => Array.isArray(v) && v[0] === true;
    values
      .filter(pred)
      .map(DataGuards.isBooleanArray)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isBooleanArray)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isDate', () => {
    const pred = (v: any) => v instanceof Date;
    values
      .filter(pred)
      .map(DataGuards.isDate)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isDate)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isDateArray', () => {
    const pred = (v: any) => Array.isArray(v) && v[0] instanceof Date;
    values
      .filter(pred)
      .map(DataGuards.isDateArray)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isDateArray)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isGeoCoordinate', () => {
    const pred = (v: any) => v.latitude && v.longitude;
    values
      .filter(pred)
      .map(DataGuards.isGeoCoordinate)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isGeoCoordinate)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isPhoneNumber', () => {
    const pred = (v: any) => v.number;
    values
      .filter(pred)
      .map(DataGuards.isPhoneNumber)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isPhoneNumber)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isNested', () => {
    const pred = (v: any) => v.prop === 'hi';
    values
      .filter(pred)
      .map(DataGuards.isNested)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isNested)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isNestedArray', () => {
    const pred = (v: any) => Array.isArray(v) && v[0]?.prop === 'hi';
    values
      .filter(pred)
      .map(DataGuards.isNestedArray)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isNestedArray)
      .forEach((result) => expect(result).toEqual(false));
  });

  it('should check isEmptyArray', () => {
    const pred = (v: any) => Array.isArray(v) && v.length === 0;
    values
      .filter(pred)
      .map(DataGuards.isEmptyArray)
      .forEach((result) => expect(result).toEqual(true));
    values
      .filter(opposite(pred))
      .map(DataGuards.isEmptyArray)
      .forEach((result) => expect(result).toEqual(false));
  });
});



---
File: /src/collections/sort/classes.ts
---

import { SortBy } from '../types/index.js';
import { NonRefKeys } from '../types/internal.js';

export class Sorting<T> {
  public sorts: SortBy[];

  constructor() {
    this.sorts = [];
  }

  /** Sort by the objects' property. */
  public byProperty<K extends NonRefKeys<T>>(property: K, ascending = true) {
    this.sorts.push({ property, ascending });
    return this;
  }

  /** Sort by the objects' ID. */
  public byId(ascending = true) {
    this.sorts.push({ property: '_id', ascending });
    return this;
  }

  /** Sort by the objects' creation time. */
  public byCreationTime(ascending = true) {
    this.sorts.push({ property: '_creationTimeUnix', ascending });
    return this;
  }

  /** Sort by the objects' last update time. */
  public byUpdateTime(ascending = true) {
    this.sorts.push({ property: '_lastUpdateTimeUnix', ascending });
    return this;
  }
}



---
File: /src/collections/sort/index.ts
---

export type { Sort } from './types.js';

import { NonRefKeys } from '../types/internal.js';
import { Sorting } from './classes.js';
import { Sort } from './types.js';

const sort = <T>(): Sort<T> => {
  return {
    byProperty<T, K extends NonRefKeys<T>>(property: K, ascending = true) {
      return new Sorting<T>().byProperty(property, ascending);
    },
    byId<T>(ascending = true) {
      return new Sorting<T>().byId(ascending);
    },
    byCreationTime<T>(ascending = true) {
      return new Sorting<T>().byCreationTime(ascending);
    },
    byUpdateTime<T>(ascending = true) {
      return new Sorting<T>().byUpdateTime(ascending);
    },
  };
};

export default sort;

export { Sorting };



---
File: /src/collections/sort/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */
import weaviate, { WeaviateClient } from '../../index.js';
import { Collection } from '../collection/index.js';

describe('Testing of the Sort class with a simple collection', () => {
  let client: WeaviateClient;
  type Name = 'TestCollectionSortSimple';
  let collection: Collection<TestType, Name>;
  let collections: (Collection<TestType, Name> | Collection<any, Name>)[];
  const collectionName = 'TestCollectionSortSimple';
  let ids = [
    'd9ebd143-83aa-46c6-80ca-98730debe78c',
    'd9ebd143-83aa-46c6-80ca-98730debe78d',
    'd9ebd143-83aa-46c6-80ca-98730debe78e',
    'd9ebd143-83aa-46c6-80ca-98730debe78f',
  ];

  type TestType = {
    text: string;
    int: number;
    float: number;
    date: Date;
    isCool: boolean;
    nullable?: string;
  };

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    collections = [collection, client.collections.get(collectionName)];
    ids = await client.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'text',
            dataType: 'text',
          },
          {
            name: 'int',
            dataType: 'int',
          },
          {
            name: 'float',
            dataType: 'number',
          },
          {
            name: 'date',
            dataType: 'date',
          },
          {
            name: 'nullable',
            dataType: 'text',
          },
          {
            name: 'isCool',
            dataType: 'boolean',
          },
        ],
      })
      .catch((err) => {
        throw err;
      })
      .then(() =>
        collection.data.insertMany([
          {
            properties: {
              text: 'one',
              int: 1,
              float: 1.1,
              date: new Date('2021-01-01'),
              isCool: true,
            },
            id: ids[0],
          },
          {
            properties: {
              text: 'two',
              int: 2,
              float: 2.2,
              date: new Date('2021-01-02'),
              isCool: false,
            },
            id: ids[1],
          },
          {
            properties: {
              text: 'three',
              int: 3,
              float: 3.3,
              date: new Date('2021-01-03'),
              isCool: false,
            },
            id: ids[2],
          },
          {
            properties: {
              text: 'four',
              int: 4,
              float: 4.4,
              date: new Date('2021-01-04'),
              isCool: false,
              nullable: 'oi',
            },
            id: ids[3],
          },
        ])
      )
      .then((res) => {
        if (res.hasErrors) {
          console.error(res.errors);
          throw new Error('Failed to insert objects');
        }
        return Object.values(res.uuids);
      })
      .catch((err) => {
        throw err;
      });
    return ids;
  });

  it('should sort by text ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('text'),
          })
          .then((res) =>
            expect(res.objects.map((o) => o.properties.text)).toEqual(['four', 'one', 'three', 'two'])
          )
      )
    );
  });

  it('should sort by text descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('text', false),
          })
          .then((res) =>
            expect(res.objects.map((o) => o.properties.text)).toEqual(['two', 'three', 'one', 'four'])
          )
      )
    );
  });

  it('should sort by int ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('int'),
          })
          .then((res) => expect(res.objects.map((o) => o.properties.int)).toEqual([1, 2, 3, 4]))
      )
    );
  });

  it('should sort by int descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('int', false),
          })
          .then((res) => expect(res.objects.map((o) => o.properties.int)).toEqual([4, 3, 2, 1]))
      )
    );
  });

  it('should sort by float ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('float'),
          })
          .then((res) => expect(res.objects.map((o) => o.properties.float)).toEqual([1.1, 2.2, 3.3, 4.4]))
      )
    );
  });

  it('should sort by float descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('float', false),
          })
          .then((res) => expect(res.objects.map((o) => o.properties.float)).toEqual([4.4, 3.3, 2.2, 1.1]))
      )
    );
  });

  it('should sort by date ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('date'),
          })
          .then((res) =>
            expect(res.objects.map((o) => o.properties.date)).toEqual([
              new Date('2021-01-01'),
              new Date('2021-01-02'),
              new Date('2021-01-03'),
              new Date('2021-01-04'),
            ])
          )
      )
    );
  });

  it('should sort by date descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('date', false),
          })
          .then((res) =>
            expect(res.objects.map((o) => o.properties.date)).toEqual([
              new Date('2021-01-04'),
              new Date('2021-01-03'),
              new Date('2021-01-02'),
              new Date('2021-01-01'),
            ])
          )
      )
    );
  });

  it('should sort by boolean ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('isCool'),
          })
          .then((res) =>
            expect(res.objects.map((o) => o.properties.isCool)).toEqual([false, false, false, true])
          )
      )
    );
  });

  it('should sort by boolean descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('isCool', false),
          })
          .then((res) =>
            expect(res.objects.map((o) => o.properties.isCool)).toEqual([true, false, false, false])
          )
      )
    );
  });

  it('should sort with nullable ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('nullable'),
          })
          .then((res) =>
            expect(res.objects.map((o) => o.properties.nullable)).toEqual([
              undefined,
              undefined,
              undefined,
              'oi',
            ])
          )
      )
    );
  });

  it('should sort with nullable descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byProperty('nullable', false),
          })
          .then((res) =>
            expect(res.objects.map((o) => o.properties.nullable)).toEqual([
              'oi',
              undefined,
              undefined,
              undefined,
            ])
          )
      )
    );
  });

  it('should sort by id ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byId(),
          })
          .then((res) => expect(res.objects.map((o) => o.uuid)).toEqual(ids))
      )
    );
  });

  it('should sort by id descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byId(false),
          })
          .then((res) => expect(res.objects.map((o) => o.uuid)).toEqual(ids.slice().reverse()))
      )
    );
  });

  it('should sort by creation time ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byCreationTime(),
            returnMetadata: ['creationTime'],
          })
          .then((res) =>
            expect(res.objects.map((o) => o.metadata?.creationTime?.getTime()!)).toEqual(
              res.objects.map((o) => o.metadata?.creationTime?.getTime()!).sort((a, b) => a - b)
            )
          )
      )
    );
  });

  it('should sort by creation time descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byCreationTime(false),
            returnMetadata: ['creationTime'],
          })
          .then((res) =>
            expect(res.objects.map((o) => o.metadata?.updateTime?.getTime()!)).toEqual(
              res.objects.map((o) => o.metadata?.updateTime?.getTime()!).sort((a, b) => b - a)
            )
          )
      )
    );
  });

  it('should sort by update time ascending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byUpdateTime(),
            returnMetadata: ['updateTime'],
          })
          .then((res) =>
            expect(res.objects.map((o) => o.metadata?.updateTime?.getTime()!)).toEqual(
              res.objects.map((o) => o.metadata?.updateTime?.getTime()!).sort((a, b) => a - b)
            )
          )
      )
    );
  });

  it('should sort by update time descending', async () => {
    await Promise.all(
      collections.map((c) =>
        c.query
          .fetchObjects({
            sort: collection.sort.byUpdateTime(false),
            returnMetadata: ['updateTime'],
          })
          .then((res) =>
            expect(res.objects.map((o) => o.metadata?.updateTime?.getTime()!)).toEqual(
              res.objects.map((o) => o.metadata?.updateTime?.getTime()!).sort((a, b) => b - a)
            )
          )
      )
    );
  });
});



---
File: /src/collections/sort/types.ts
---

import { NonRefKeys } from '../types/internal.js';
import { Sorting } from './classes.js';

/**
 * Define how the query's sort operation should be performed using the available methods.
 */
export interface Sort<T> {
  /** Sort by an object property. */
  byProperty<K extends NonRefKeys<T>>(property: K, ascending?: boolean): Sorting<T>;
  /** Sort by the objects' ID. */
  byId(ascending?: boolean): Sorting<T>;
  /** Sort by the objects' creation time. */
  byCreationTime(ascending?: boolean): Sorting<T>;
  /** Sort by the objects' last update time. */
  byUpdateTime(ascending?: boolean): Sorting<T>;
}



---
File: /src/collections/tenants/index.ts
---

import { ConnectionGRPC } from '../../connection/index.js';
import { WeaviateUnsupportedFeatureError } from '../../errors.js';
import { Tenant as TenantREST } from '../../openapi/types.js';
import { TenantsCreator, TenantsDeleter, TenantsGetter, TenantsUpdater } from '../../schema/index.js';
import { DbVersionSupport } from '../../utils/dbVersion.js';
import { Deserialize } from '../deserialize/index.js';
import { Serialize } from '../serialize/index.js';
import { Tenant, TenantBC, TenantBase, TenantCreate, TenantUpdate } from './types.js';

const checkSupportForGRPCTenantsGetEndpoint = async (dbVersionSupport: DbVersionSupport) => {
  const check = await dbVersionSupport.supportsTenantsGetGRPCMethod();
  if (!check.supports) throw new WeaviateUnsupportedFeatureError(check.message);
};

const parseValueOrValueArray = <V>(value: V | V[]) => (Array.isArray(value) ? value : [value]);

const parseStringOrTenant = <T extends TenantBase>(tenant: string | T) =>
  typeof tenant === 'string' ? tenant : tenant.name;

const parseTenantREST = (tenant: TenantREST): Tenant => {
  return {
    name: tenant.name!,
    activityStatus: Deserialize.activityStatusREST(tenant.activityStatus),
  };
};

const tenants = (
  connection: ConnectionGRPC,
  collection: string,
  dbVersionSupport: DbVersionSupport
): Tenants => {
  const getGRPC = (names?: string[]) =>
    checkSupportForGRPCTenantsGetEndpoint(dbVersionSupport)
      .then(() => connection.tenants(collection))
      .then((builder) => builder.withGet({ names }))
      .then(Deserialize.tenantsGet);
  const getREST = () =>
    new TenantsGetter(connection, collection).do().then((tenants) => {
      const result: Record<string, Tenant> = {};
      tenants.forEach((tenant) => {
        if (!tenant.name) return;
        result[tenant.name] = parseTenantREST(tenant);
      });
      return result;
    });
  return {
    create: (tenants: TenantBC | TenantCreate | (TenantBC | TenantCreate)[]) =>
      new TenantsCreator(connection, collection, parseValueOrValueArray(tenants).map(Serialize.tenantCreate))
        .do()
        .then((res) => res.map(parseTenantREST)),
    get: async function () {
      const check = await dbVersionSupport.supportsTenantsGetGRPCMethod();
      return check.supports ? getGRPC() : getREST();
    },
    getByNames: <T extends TenantBase>(tenants: (string | T)[]) => getGRPC(tenants.map(parseStringOrTenant)),
    getByName: <T extends TenantBase>(tenant: string | T) => {
      const tenantName = parseStringOrTenant(tenant);
      return getGRPC([tenantName]).then((tenants) => tenants[tenantName] || null);
    },
    remove: <T extends TenantBase>(tenants: string | T | (string | T)[]) =>
      new TenantsDeleter(
        connection,
        collection,
        parseValueOrValueArray(tenants).map(parseStringOrTenant)
      ).do(),
    update: async (tenants: TenantBC | TenantUpdate | (TenantBC | TenantUpdate)[]) => {
      const out: Tenant[] = [];
      for await (const res of Serialize.tenants(parseValueOrValueArray(tenants), Serialize.tenantUpdate).map(
        (tenants) =>
          new TenantsUpdater(connection, collection, tenants).do().then((res) => res.map(parseTenantREST))
      )) {
        out.push(...res);
      }
      return out;
    },
  };
};

export default tenants;

export { Tenant, TenantBase, TenantCreate, TenantUpdate };

/**
 * Represents all the CRUD methods available on a collection's multi-tenancy specification within Weaviate.

 * The collection must have been created with multi-tenancy enabled in order to use any of these methods. This class
 * should not be instantiated directly, but is available as a property of the `Collection` class under
 * the `collection.tenants` class attribute.
 *
 * Starting from Weaviate v1.26, the naming convention around tenant activitiy statuses is changing.
 * The changing nomenclature is as follows:
 * - `HOT` is now `ACTIVE`, which means loaded fully into memory and ready for use.
 * - `COLD` is now `INACTIVE`, which means not loaded into memory with files stored on disk.
 *
 * With this change, new statuses are being added. One is mutable and the other two are immutable. They are:
 * - `OFFLOADED`, which means the tenant is not loaded into memory with files stored on the cloud.
 * - `OFFLOADING`, which means the tenant is transitioning to the `OFFLOADED` status.
 * - `ONLOADING`, which means the tenant is transitioning from the `OFFLOADED` status.
 */
export interface Tenants {
  /**
   * Create the specified tenants for a collection in Weaviate.
   * The collection must have been created with multi-tenancy enabled.
   *
   * For details on the new activity statuses, see the docstring for the `Tenants` interface type.
   *
   * @param {TenantCreate | TenantCreate[]} tenants The tenant or tenants to create.
   * @returns {Promise<Tenant[]>} The created tenant(s) as a list of Tenant.
   */
  create: (tenants: TenantBC | TenantCreate | (TenantBC | TenantCreate)[]) => Promise<Tenant[]>;
  /**
   * Return all tenants currently associated with a collection in Weaviate.
   * The collection must have been created with multi-tenancy enabled.
   *
   * For details on the new activity statuses, see the docstring for the `Tenants` interface type.
   *
   * @returns {Promise<Record<string, Tenant>>} A list of tenants as an object of Tenant types, where the key is the tenant name.
   */
  get: () => Promise<Record<string, Tenant>>;
  /**
   * Return the specified tenants from a collection in Weaviate.
   * The collection must have been created with multi-tenancy enabled.
   *
   * For details on the new activity statuses, see the docstring for the `Tenants` interface type.
   *
   * @typedef {TenantBase} T A type that extends TenantBase.
   * @param {(string | T)[]} names The tenants to retrieve.
   * @returns {Promise<Tenant[]>} The list of tenants. If the tenant does not exist, it will not be included in the list.
   */
  getByNames: <T extends TenantBase>(names: (string | T)[]) => Promise<Record<string, Tenant>>;
  /**
   * Return the specified tenant from a collection in Weaviate.
   * The collection must have been created with multi-tenancy enabled.
   *
   * For details on the new activity statuses, see the docstring for the `Tenants` interface type.
   *
   * @typedef {TenantBase} T A type that extends TenantBase.
   * @param {string | T} name The name of the tenant to retrieve.
   * @returns {Promise<Tenant | null>} The tenant as a Tenant type, or null if the tenant does not exist.
   */
  getByName: <T extends TenantBase>(name: string | T) => Promise<Tenant | null>;
  /**
   * Remove the specified tenants from a collection in Weaviate.
   * The collection must have been created with multi-tenancy enabled.
   *
   * For details on the new activity statuses, see the docstring for the `Tenants` interface type.
   *
   * @typedef {TenantBase} T A type that extends TenantBase.
   * @param {Tenant | Tenant[]} tenants The tenant or tenants to remove.
   * @returns {Promise<void>} An empty promise.
   */
  remove: <T extends TenantBase>(tenants: string | T | (string | T)[]) => Promise<void>;
  /**
   * Update the specified tenants for a collection in Weaviate.
   * The collection must have been created with multi-tenancy enabled.
   *
   * For details on the new activity statuses, see the docstring for the `Tenants` interface type.
   *
   * @param {TenantInput | TenantInput[]} tenants The tenant or tenants to update.
   * @returns {Promise<Tenant[]>} The updated tenant(s) as a list of Tenant.
   */
  update: (tenants: TenantBC | TenantUpdate | (TenantBC | TenantUpdate)[]) => Promise<Tenant[]>;
}



---
File: /src/collections/tenants/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { WeaviateUnsupportedFeatureError } from '../../errors.js';
import weaviate, { WeaviateClient } from '../../index.js';
import { Collection } from '../collection/index.js';

describe('Testing of the collection.tenants methods', () => {
  let client: WeaviateClient;
  let collection: Collection<any, 'TestCollectionTenants'>;
  const collectionName = 'TestCollectionTenants';

  afterAll(() => {
    return client.collections.delete(collectionName).catch((err) => {
      console.error(err);
      throw err;
    });
  });

  beforeAll(async () => {
    client = await weaviate.connectToLocal();
    collection = client.collections.get(collectionName);
    return client.collections
      .create({
        name: collectionName,
        multiTenancy: weaviate.configure.multiTenancy({ enabled: true }),
      })
      .then(() =>
        collection.tenants.create([
          { name: 'hot', activityStatus: 'HOT' },
          { name: 'cold', activityStatus: 'COLD' },
          { name: 'cold-new', activityStatus: 'COLD' },
          { name: 'remove-me', activityStatus: 'HOT' },
        ])
      );
  });

  it('should be able to create a tenant with old nomenclature', async () => {
    const tenant = 'tenant';
    const result = await collection.tenants.create([{ name: tenant, activityStatus: 'HOT' }]);
    expect(result.length).toBe(1);
    expect(result[0].name).toBe(tenant);
    expect(result[0].activityStatus).toBe('ACTIVE');
  });

  it('should be able to create a tenant with new nomenclature', async () => {
    const tenant = 'tenant';
    const result = await collection.tenants.create([{ name: tenant, activityStatus: 'ACTIVE' }]);
    expect(result.length).toBe(1);
    expect(result[0].name).toBe(tenant);
    expect(result[0].activityStatus).toBe('ACTIVE');
  });

  it('should be able to get existing tenants', async () => {
    const result = await collection.tenants.get();

    expect(result).toHaveProperty('hot');
    expect(result.hot.name).toBe('hot');
    expect(result.hot.activityStatus).toBe('ACTIVE');

    expect(result).toHaveProperty('cold');
    expect(result.cold.name).toBe('cold');
    // expect(result.tenant.activityStatus).toBe('COLD'); // updated below
  });

  it('should be able to remove a tenant', async () => {
    const result = await collection.tenants
      .remove([{ name: 'remove-me' }])
      .then(() => collection.tenants.get());
    expect(result).not.toHaveProperty('remove-me');
  });

  it('should be able to update a tenant with old nomenclature', async () => {
    const result = await collection.tenants.update([{ name: 'cold', activityStatus: 'HOT' }]);
    expect(result.length).toBe(1);
    expect(result[0].name).toBe('cold');
    expect(result[0].activityStatus).toBe('ACTIVE');
  });

  it('should be able to update a tenant with new nomenclature', async () => {
    const result = await collection.tenants.update([{ name: 'cold-new', activityStatus: 'ACTIVE' }]);
    expect(result.length).toBe(1);
    expect(result[0].name).toBe('cold-new');
    expect(result[0].activityStatus).toBe('ACTIVE');
  });

  describe('getByName and getByNames', () => {
    it('should be able to get a tenant by name string', async () => {
      const query = () => collection.tenants.getByName('hot');
      if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
        await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
        return;
      }
      const result = await query();
      expect(result).toHaveProperty('name', 'hot');
      expect(result).toHaveProperty('activityStatus', 'ACTIVE');
    });

    it('should be able to get a tenant by tenant object', async () => {
      const query = () => collection.tenants.getByName({ name: 'hot' });
      if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
        await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
        return;
      }
      const result = await query();
      expect(result).toHaveProperty('name', 'hot');
      expect(result).toHaveProperty('activityStatus', 'ACTIVE');
    });

    it('should fail to get a non-existing tenant', async () => {
      const query = () => collection.tenants.getByName('non-existing');
      if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
        await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
        return;
      }
      const result = await query();
      expect(result).toBeNull();
    });

    it('should be able to get tenants by name strings', async () => {
      const query = () => collection.tenants.getByNames(['hot', 'cold']);
      if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
        await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
        return;
      }
      const result = await query();
      expect(result).toHaveProperty('hot');
      expect(result).toHaveProperty('cold');
    });

    it('should be able to get tenants by tenant objects', async () => {
      const query = () => collection.tenants.getByNames([{ name: 'hot' }, { name: 'cold' }]);
      if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
        await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
        return;
      }
      const result = await query();
      expect(result).toHaveProperty('hot');
      expect(result).toHaveProperty('cold');
    });

    it('should be able to get tenants by mixed name strings and tenant objects', async () => {
      const query = () => collection.tenants.getByNames(['hot', { name: 'cold' }]);
      if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
        await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
        return;
      }
      const result = await query();
      expect(result).toHaveProperty('hot');
      expect(result).toHaveProperty('cold');
    });

    it('should be able to get partial tenants', async () => {
      const query = () => collection.tenants.getByNames(['hot', 'non-existing']);
      if (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0))) {
        await expect(query()).rejects.toThrow(WeaviateUnsupportedFeatureError);
        return;
      }
      const result = await query();
      expect(result).toHaveProperty('hot');
      expect(result).not.toHaveProperty('cold');
      expect(result).not.toHaveProperty('non-existing');
    });
  });

  it('should be able to create and update 1000 tenants', async () => {
    const howManyToAdd = 1000;
    const howManyPreExisting = Object.entries(await collection.tenants.get()).length;
    const howMany = howManyToAdd + howManyPreExisting;
    const tenants = Array.from({ length: howManyToAdd }, (_, i) => ({
      name: `tenant-${i}`,
    }));
    await collection.tenants.create(tenants);
    const getTenants = await collection.tenants.get();
    expect(Object.entries(getTenants).length).toBe(howMany);
    expect(Object.values(getTenants).every((tenant) => tenant.activityStatus === 'ACTIVE')).toBe(true);
    const updated = await collection.tenants.update(
      Object.values(getTenants).map((tenant) => ({ name: tenant.name, activityStatus: 'INACTIVE' }))
    );
    expect(Object.entries(updated).length).toBe(howMany);
    expect(Object.values(updated).every((tenant) => tenant.activityStatus === 'INACTIVE')).toBe(true);
  });
});



---
File: /src/collections/tenants/types.ts
---

/** The base type for a tenant. Only the name is required. */
export type TenantBase = {
  /** The name of the tenant. */
  name: string;
};

/** The expected type when creating a tenant. */
export type TenantCreate = TenantBase & {
  /** The activity status of the tenant. Defaults to 'ACTIVE' if not provided. */
  activityStatus?: 'ACTIVE' | 'INACTIVE';
};

/** The expected type when updating a tenant. */
export type TenantUpdate = TenantBase & {
  /** The activity status of the tenant. Must be set to one of the options. */
  activityStatus: 'ACTIVE' | 'INACTIVE' | 'OFFLOADED';
};

/** The expected type when getting tenants. */
export type TenantsGetOptions = {
  tenants?: string;
};

/**
 * The expected type returned by all tenant methods.
 */
export type Tenant = TenantBase & {
  /** There are two statuses that are immutable: `OFFLOADED` and `ONLOADING, which are set by the server:
   * - `ONLOADING`, which means the tenant is transitioning from the `OFFLOADED` status to `ACTIVE/INACTIVE`.
   * - `OFFLOADING`, which means the tenant is transitioning from `ACTIVE/INACTIVE` to the `OFFLOADED` status.
   * The other three statuses are mutable within the `.create` and `.update`, methods:
   * - `ACTIVE`, which means loaded fully into memory and ready for use.
   * - `INACTIVE`, which means not loaded into memory with files stored on disk.
   * - `OFFLOADED`, which means not loaded into memory with files stored on the cloud.
   */
  activityStatus: 'ACTIVE' | 'INACTIVE' | 'OFFLOADED' | 'OFFLOADING' | 'ONLOADING';
};

/** This is the type of the Tenant as defined in Weaviate's OpenAPI schema. It is included here for Backwards Compatibility. */
export type TenantBC = TenantBase & {
  activityStatus?: 'HOT' | 'COLD' | 'FROZEN';
};



---
File: /src/collections/tenants/unit.test.ts
---

import express from 'express';
import { Server as HttpServer } from 'http';

import { createServer, Server as GrpcServer } from 'nice-grpc';
import {
  HealthCheckRequest,
  HealthCheckResponse,
  HealthCheckResponse_ServingStatus,
  HealthDefinition,
  HealthServiceImplementation,
} from '../../proto/google/health/v1/health';
import { TenantActivityStatus, TenantsGetReply, TenantsGetRequest } from '../../proto/v1/tenants';
import { WeaviateDefinition, WeaviateServiceImplementation } from '../../proto/v1/weaviate';

import weaviate, { Tenant } from '../../index';

const TENANTS_COLLECTION_NAME = 'TestCollectionTenants';

const makeRestApp = (version: string) => {
  const httpApp = express();
  httpApp.get(`/v1/schema/${TENANTS_COLLECTION_NAME}/tenants`, (req, res) =>
    res.send([
      { name: 'hot', activityStatus: 'HOT' },
      { name: 'cold', activityStatus: 'COLD' },
      { name: 'frozen', activityStatus: 'FROZEN' },
      { name: 'freezing', activityStatus: 'FREEZING' },
      { name: 'unfreezing', activityStatus: 'UNFREEZING' },
    ])
  );
  httpApp.get('/v1/meta', (req, res) => res.send({ version }));
  return httpApp;
};

const makeGrpcApp = () => {
  const weaviateMockImpl: WeaviateServiceImplementation = {
    tenantsGet: (request: TenantsGetRequest): Promise<TenantsGetReply> =>
      Promise.resolve({
        took: 0.1,
        tenants: [
          { name: 'hot', activityStatus: TenantActivityStatus.TENANT_ACTIVITY_STATUS_HOT },
          { name: 'cold', activityStatus: TenantActivityStatus.TENANT_ACTIVITY_STATUS_COLD },
          { name: 'frozen', activityStatus: TenantActivityStatus.TENANT_ACTIVITY_STATUS_FROZEN },
          { name: 'freezing', activityStatus: TenantActivityStatus.TENANT_ACTIVITY_STATUS_FREEZING },
          { name: 'unfreezing', activityStatus: TenantActivityStatus.TENANT_ACTIVITY_STATUS_UNFREEZING },
        ],
      }),
    search: jest.fn(),
    batchDelete: jest.fn(),
    batchObjects: jest.fn(),
  };
  const healthMockImpl: HealthServiceImplementation = {
    check: (request: HealthCheckRequest): Promise<HealthCheckResponse> =>
      Promise.resolve(HealthCheckResponse.create({ status: HealthCheckResponse_ServingStatus.SERVING })),
    watch: jest.fn(),
  };

  const grpcApp = createServer();
  grpcApp.add(WeaviateDefinition, weaviateMockImpl);
  grpcApp.add(HealthDefinition, healthMockImpl);

  return grpcApp;
};

const makeMockServers = async (weaviateVersion: string, httpPort: number, grpcAddress: string) => {
  const rest = makeRestApp(weaviateVersion);
  const grpc = makeGrpcApp();
  const server = await rest.listen(httpPort);
  await grpc.listen(grpcAddress);
  return { rest: server, grpc };
};

describe('Mock testing of tenants.get() method with a REST server', () => {
  let servers: {
    rest: HttpServer;
    grpc: GrpcServer;
  };

  beforeAll(async () => {
    servers = await makeMockServers('1.24.0', 8954, 'localhost:8955');
  });

  it('should get mocked tenants', async () => {
    const client = await weaviate.connectToLocal({ port: 8954, grpcPort: 8955 });
    const collection = client.collections.get(TENANTS_COLLECTION_NAME);
    const tenants = await collection.tenants.get();
    expect(tenants).toEqual<Record<string, Tenant>>({
      hot: { name: 'hot', activityStatus: 'ACTIVE' },
      cold: { name: 'cold', activityStatus: 'INACTIVE' },
      frozen: { name: 'frozen', activityStatus: 'OFFLOADED' },
      freezing: { name: 'freezing', activityStatus: 'OFFLOADING' },
      unfreezing: { name: 'unfreezing', activityStatus: 'ONLOADING' },
    });
  });

  afterAll(() => Promise.all([servers.rest.close(), servers.grpc.shutdown()]));
});

describe('Mock testing of tenants.get() method with a gRPC server', () => {
  let servers: {
    rest: HttpServer;
    grpc: GrpcServer;
  };

  beforeAll(async () => {
    servers = await makeMockServers('1.25.0', 8956, 'localhost:8957');
  });

  it('should get the mocked tenants', async () => {
    const client = await weaviate.connectToLocal({ port: 8956, grpcPort: 8957 });
    const collection = client.collections.get(TENANTS_COLLECTION_NAME);
    const tenants = await collection.tenants.get();
    expect(tenants).toEqual<Record<string, Tenant>>({
      hot: { name: 'hot', activityStatus: 'ACTIVE' },
      cold: { name: 'cold', activityStatus: 'INACTIVE' },
      frozen: { name: 'frozen', activityStatus: 'OFFLOADED' },
      freezing: { name: 'freezing', activityStatus: 'OFFLOADING' },
      unfreezing: { name: 'unfreezing', activityStatus: 'ONLOADING' },
    });
  });

  afterAll(() => Promise.all([servers.rest.close(), servers.grpc.shutdown()]));
});



---
File: /src/collections/types/batch.ts
---

import { BatchReference } from '../../openapi/types.js';
import { BatchObject as BatchObjectGRPC } from '../../proto/v1/batch.js';
import { NonReferenceInputs, ReferenceInputs, Vectors } from '../index.js';

export type BatchObjectsReturn<T> = {
  allResponses: (string | ErrorObject<T>)[];
  elapsedSeconds: number;
  errors: Record<number, ErrorObject<T>>;
  hasErrors: boolean;
  uuids: Record<number, string>;
};

export type ErrorObject<T> = {
  code?: number;
  message: string;
  object: BatchObject<T>;
  originalUuid?: string;
};

export type BatchObject<T> = {
  collection: string;
  properties?: NonReferenceInputs<T>;
  references?: ReferenceInputs<T>;
  id?: string;
  vectors?: number[] | Vectors;
  tenant?: string;
};

export type BatchObjects<T> = {
  batch: BatchObject<T>[];
  mapped: BatchObjectGRPC[];
};

export type ErrorReference = {
  message: string;
  reference: BatchReference;
};

export type BatchReferencesReturn = {
  elapsedSeconds: number;
  errors: Record<number, ErrorReference>;
  hasErrors: boolean;
};



---
File: /src/collections/types/data.ts
---

import { NonReferenceInputs, ReferenceInputs } from './internal.js';
import { Vectors } from './query.js';

export type DataObject<T> = {
  id?: string;
  properties?: NonReferenceInputs<T>;
  references?: ReferenceInputs<T>;
  vectors?: number[] | Vectors;
};

export type DeleteManyObject = {
  id: string;
  successful: boolean;
  error?: string;
};

export type DeleteManyReturn<V> = {
  failed: number;
  matches: number;
  objects: V extends true ? DeleteManyObject[] : undefined;
  successful: number;
};

export type ReferenceToMultiTarget = {
  targetCollection: string;
  uuids: string | string[];
};



---
File: /src/collections/types/generate.ts
---

import { GroupByObject, GroupByResult, WeaviateGenericObject, WeaviateNonGenericObject } from './query.js';

export type GenerativeGenericObject<T> = WeaviateGenericObject<T> & {
  /** The LLM-generated output applicable to this single object. */
  generated?: string;
};

export type GenerativeNonGenericObject = WeaviateNonGenericObject & {
  /** The LLM-generated output applicable to this single object. */
  generated?: string;
};

/** An object belonging to a collection as returned by the methods in the `collection.generate` namespace.
 *
 * Depending on the generic type `T`, the object will have subfields that map from `T`'s specific type definition.
 * If not, then the object will be non-generic and have a `properties` field that maps from a generic string to a `WeaviateField`.
 */
export type GenerativeObject<T> = T extends undefined
  ? GenerativeNonGenericObject
  : GenerativeGenericObject<T>;

/** The return of a query method in the `collection.generate` namespace. */
export type GenerativeReturn<T> = {
  /** The objects that were found by the query. */
  objects: GenerativeObject<T>[];
  /** The LLM-generated output applicable to this query as a whole. */
  generated?: string;
};

export type GenerativeGroupByResult<T> = GroupByResult<T> & {
  generated?: string;
};

/** The return of a query method in the `collection.generate` namespace where the `groupBy` argument was specified. */
export type GenerativeGroupByReturn<T> = {
  /** The objects that were found by the query. */
  objects: GroupByObject<T>[];
  /** The groups that were created by the query. */
  groups: Record<string, GenerativeGroupByResult<T>>;
  /** The LLM-generated output applicable to this query as a whole. */
  generated?: string;
};

/** Options available when defining queries using methods in the `collection.generate` namespace. */
export type GenerateOptions<T> = {
  /** The prompt to use when generating content relevant to each object of the collection individually. */
  singlePrompt?: string;
  /** The prompt to use when generating content relevant to objects returned by the query as a whole. */
  groupedTask?: string;
  /** The properties to use as context to be injected into the `groupedTask` prompt when performing the grouped generation. */
  groupedProperties?: T extends undefined ? string[] : (keyof T)[];
};

export type GenerateReturn<T> = Promise<GenerativeReturn<T>> | Promise<GenerativeGroupByReturn<T>>;



---
File: /src/collections/types/index.ts
---

export * from '../config/types/index.js';
export * from '../configure/types/index.js';
export type { CollectionConfigCreate } from '../index.js';
export * from './batch.js';
export * from './data.js';
export * from './generate.js';
export type {
  IsEmptyType,
  IsNestedField,
  IsPrimitiveField,
  IsWeaviateField,
  NestedKeys,
  NonRefKeys,
  NonReferenceInputs,
  PrimitiveKeys,
  QueryNested,
  QueryProperty,
  QueryReference,
  RefKeys,
  ReferenceInput,
  ReferenceInputs,
} from './internal.js';
export * from './query.js';

import {
  GeoCoordinate as GeoCoordinateGRPC,
  PhoneNumber as PhoneNumberGRPC,
} from '../../proto/v1/properties.js';

import { CrossReference } from '../references/index.js';

// The order of type resolution is important here since object can be inferred as all other types
// hence it should be the last type in the union
export type DataType<T = any> = T extends infer U | undefined
  ? U extends string
    ? 'text' | 'uuid' | 'blob'
    : U extends number
    ? 'number' | 'int'
    : U extends boolean
    ? 'boolean'
    : U extends Date
    ? 'date'
    : U extends string[]
    ? 'text[]' | 'uuid[]'
    : U extends number[]
    ? 'number[]' | 'int[]'
    : U extends boolean[]
    ? 'boolean[]'
    : U extends Date[]
    ? 'date[]'
    : U extends GeoCoordinate
    ? 'geoCoordinates'
    : U extends PhoneNumber
    ? 'phoneNumber'
    : U extends object[]
    ? 'object[]'
    : U extends object
    ? 'object'
    : never
  : never;

export type GeoCoordinate = Required<GeoCoordinateGRPC>;

export type PhoneNumber = Required<PhoneNumberGRPC>;

export type PrimitiveField =
  | string
  | string[]
  | boolean
  | boolean[]
  | number
  | number[]
  | Date
  | Date[]
  | Blob
  | GeoCoordinate
  | PhoneNumber
  | PhoneNumberInput
  | null;

export type NestedField = NestedProperties | NestedProperties[];

export type WeaviateField = PrimitiveField | NestedField;

export type Property = WeaviateField | CrossReference<Properties> | undefined;

export interface Properties {
  [k: string]: Property;
}

export interface NestedProperties {
  [k: string]: WeaviateField;
}

export type PhoneNumberInput = {
  number: string;
  defaultCountry?: string;
};



---
File: /src/collections/types/internal.ts
---

import {
  NestedProperties,
  PhoneNumber,
  PhoneNumberInput,
  PrimitiveField,
  RefProperty,
  RefPropertyDefault,
  ReferenceToMultiTarget,
  WeaviateField,
} from '../index.js';
import { ReferenceManager } from '../references/classes.js';
import { CrossReference } from '../references/index.js';

export type ExtractCrossReferenceType<T> = T extends CrossReference<infer U> ? U : never;

type ExtractNestedType<T> = T extends (infer U)[]
  ? U extends NestedProperties
    ? U
    : never
  : T extends NestedProperties
  ? T
  : never;

export type QueryNested<T> = {
  [K in NestedKeys<T>]: {
    name: K;
    properties: QueryProperty<ExtractNestedType<T[K]>>[];
  };
}[NestedKeys<T>];

export type QueryNestedDefault = {
  name: string;
  properties: (string | QueryNestedDefault)[];
};

export type QueryProperty<T> = T extends undefined
  ? string | QueryNestedDefault
  : PrimitiveKeys<T> | QueryNested<T>;
export type QueryReference<T> = T extends undefined ? RefPropertyDefault : RefProperty<T>;
export type NonRefProperty<T> = keyof T | QueryNested<T>;
export type NonPrimitiveProperty<T> = RefProperty<T> | QueryNested<T>;

export type IsEmptyType<T> = keyof T extends never ? true : false;

export type ReferenceInput<T> =
  | string
  | ReferenceToMultiTarget
  | ReferenceManager<T>
  | (string | ReferenceToMultiTarget | ReferenceManager<T>)[];

export type ReferenceInputs<Obj> = Obj extends undefined
  ? Record<string, ReferenceInput<undefined>>
  : {
      [Key in keyof Obj as Key extends RefKeys<Obj> ? Key : never]: ReferenceInput<
        ExtractCrossReferenceType<Obj[Key]>
      >;
    };

export type IsPrimitiveField<T> = T extends PrimitiveField ? T : never;

export type IsWeaviateField<T> = T extends WeaviateField ? T : never;

export type IsNestedField<T> = T extends NestedProperties | NestedProperties[] ? T : never;

/**
 * This is an internal type that is used to extract the keys of a user-provided generic type that are primitive fields, e.g. non-nested and non-reference.
 */
export type PrimitiveKeys<Obj> = Obj extends undefined
  ? string
  : {
      [Key in keyof Obj]-?: undefined extends Obj[Key]
        ? IsPrimitiveField<Exclude<Obj[Key], undefined>> extends never
          ? never
          : Key
        : IsPrimitiveField<Obj[Key]> extends never
        ? never
        : Key;
    }[keyof Obj] &
      string;

/**
 * This is an internal type that is used to extract the keys of a user-provided generic type that are references.
 */
export type RefKeys<Obj> = {
  [Key in keyof Obj]: Obj[Key] extends CrossReference<any> | undefined ? Key : never;
}[keyof Obj] &
  string;

/**
 * This is an internal type that is used to extract the keys of a user-provided generic type that are not references.
 */
export type NonRefKeys<Obj> = {
  [Key in keyof Obj]-?: undefined extends Obj[Key]
    ? IsWeaviateField<Exclude<Obj[Key], undefined>> extends never
      ? never
      : Key
    : IsWeaviateField<Obj[Key]> extends never
    ? never
    : Key;
}[keyof Obj] &
  string;

/**
 * This is an internal type that is used to extract the keys of a user-provided generic type that are nested properties.
 */
export type NestedKeys<Obj> = {
  [Key in keyof Obj]-?: undefined extends Obj[Key]
    ? IsNestedField<Exclude<Obj[Key], undefined>> extends never
      ? never
      : Key
    : IsNestedField<Obj[Key]> extends never
    ? never
    : Key;
}[keyof Obj] &
  string;

/**
 * This is an internal type that is used to extract the allowed inputs for a non-generic type that is not a reference.
 */
export type NonReferenceInputs<Obj> = Obj extends undefined
  ? Record<string, WeaviateField>
  : {
      [Key in keyof Obj as Key extends NonRefKeys<Obj> ? Key : never]: MapPhoneNumberType<Obj[Key]>;
    };

export type MapPhoneNumberType<T> = T extends PhoneNumber ? PhoneNumberInput : T;



---
File: /src/collections/types/query.ts
---

import { WeaviateField } from '../index.js';
import { CrossReferenceDefault } from '../references/index.js';
import {
  ExtractCrossReferenceType,
  NonRefKeys,
  QueryNestedDefault,
  QueryProperty,
  QueryReference,
  RefKeys,
} from './internal.js';

export type Metadata = {
  creationTime: Date;
  updateTime: Date;
  distance: number;
  certainty: number;
  score: number;
  explainScore: string;
  rerankScore: number;
  isConsistent: boolean;
};

export type MetadataKeys = (keyof Metadata)[];

export type QueryMetadata = 'all' | MetadataKeys | undefined;

export type ReturnMetadata = Partial<Metadata>;

export type WeaviateGenericObject<T> = {
  /** The generic returned properties of the object derived from the type `T`. */
  properties: ReturnProperties<T>;
  /** The returned metadata of the object. */
  metadata: ReturnMetadata | undefined;
  /** The returned references of the object derived from the type `T`. */
  references: ReturnReferences<T> | undefined;
  /** The UUID of the object. */
  uuid: string;
  /** The returned vectors of the object. */
  vectors: Vectors;
};

export type WeaviateNonGenericObject = {
  /** The returned properties of the object. */
  properties: Record<string, WeaviateField>;
  /** The returned metadata of the object. */
  metadata: ReturnMetadata | undefined;
  /** The returned references of the object. */
  references: Record<string, CrossReferenceDefault> | undefined;
  /** The UUID of the object. */
  uuid: string;
  /** The returned vectors of the object. */
  vectors: Vectors;
};

export type ReturnProperties<T> = Pick<T, NonRefKeys<T>>;

export type ReturnReferences<T> = Pick<T, RefKeys<T>>;

export type Vectors = Record<string, number[]>;

export type ReturnVectors<V> = V extends string[]
  ? { [Key in V[number]]: number[] }
  : Record<string, number[]>;

/** An object belonging to a collection as returned by the methods in the `collection.query` namespace.
 *
 * Depending on the generic type `T`, the object will have subfields that map from `T`'s specific type definition.
 * If not, then the object will be non-generic and have a `properties` field that maps from a generic string to a `WeaviateField`.
 */
export type WeaviateObject<T> = T extends undefined // need this instead of Properties to avoid circular type reference
  ? WeaviateNonGenericObject
  : WeaviateGenericObject<T>;

/** The return of a query method in the `collection.query` namespace. */
export type WeaviateReturn<T> = {
  /** The objects that were found by the query. */
  objects: WeaviateObject<T>[];
};

export type GroupByObject<T> = WeaviateObject<T> & {
  belongsToGroup: string;
};

export type GroupByResult<T> = {
  name: string;
  minDistance: number;
  maxDistance: number;
  numberOfObjects: number;
  objects: WeaviateObject<T>[];
};

/** The return of a query method in the `collection.query` namespace where the `groupBy` argument was specified. */
export type GroupByReturn<T> = {
  /** The objects that were found by the query. */
  objects: GroupByObject<T>[];
  /** The groups that were created by the query. */
  groups: Record<string, GroupByResult<T>>;
};

export type GroupByOptions<T> = T extends undefined
  ? {
      property: string;
      numberOfGroups: number;
      objectsPerGroup: number;
    }
  : {
      property: keyof T;
      numberOfGroups: number;
      objectsPerGroup: number;
    };

export type RerankOptions<T> = T extends undefined
  ? {
      property: string;
      query: string;
    }
  : {
      property: keyof T;
      query?: string;
    };

export interface BaseRefProperty<T> {
  /** The property to link on when defining the references traversal. */
  linkOn: RefKeys<T>;
  /** Whether to return the vector(s) of the referenced objects in the query. */
  includeVector?: boolean | string[];
  /** The metadata to return for the referenced objects. */
  returnMetadata?: QueryMetadata;
  /** The properties to return for the referenced objects. */
  returnProperties?: QueryProperty<T>[];
  /** The references to return for the referenced objects. */
  returnReferences?: QueryReference<ExtractCrossReferenceType<T[this['linkOn']]>>[];
  /** The collection to target when traversing the references. Required for multi-target references. */
  targetCollection?: string;
}

export type RefProperty<T> = BaseRefProperty<T>;

export type RefPropertyDefault = {
  /** The property to link on when defining the references traversal. */
  linkOn: string;
  /** Whether to return the vector(s) of the referenced objects in the query. */
  includeVector?: boolean | string[];
  /** The metadata to return for the referenced objects. */
  returnMetadata?: QueryMetadata;
  /** The properties to return for the referenced objects. */
  returnProperties?: (string | QueryNestedDefault)[];
  /** The references to return for the referenced objects. */
  returnReferences?: RefPropertyDefault[];
  /** The collection to target when traversing the references. Required for multi-target references. */
  targetCollection?: string;
};

export type SortBy = {
  property: string;
  ascending?: boolean;
};



---
File: /src/collections/vectors/multiTargetVector.ts
---

/** The allowed combination methods for multi-target vector joins */
export type MultiTargetVectorJoinCombination =
  | 'sum'
  | 'average'
  | 'minimum'
  | 'relative-score'
  | 'manual-weights';

/** Weights for each target vector in a multi-target vector join */
export type MultiTargetVectorWeights = Record<string, number | number[]>;

/** A multi-target vector join used when specifying a vector-based query */
export type MultiTargetVectorJoin = {
  /** The combination method to use for the target vectors */
  combination: MultiTargetVectorJoinCombination;
  /** The target vectors to combine */
  targetVectors: string[];
  /** The weights to use for each target vector */
  weights?: MultiTargetVectorWeights;
};

export default () => {
  return {
    sum: (targetVectors: string[]): MultiTargetVectorJoin => {
      return { combination: 'sum' as MultiTargetVectorJoinCombination, targetVectors };
    },
    average: (targetVectors: string[]): MultiTargetVectorJoin => {
      return { combination: 'average' as MultiTargetVectorJoinCombination, targetVectors };
    },
    minimum: (targetVectors: string[]): MultiTargetVectorJoin => {
      return { combination: 'minimum' as MultiTargetVectorJoinCombination, targetVectors };
    },
    relativeScore: (weights: MultiTargetVectorWeights): MultiTargetVectorJoin => {
      return {
        combination: 'relative-score' as MultiTargetVectorJoinCombination,
        targetVectors: Object.keys(weights),
        weights,
      };
    },
    manualWeights: (weights: MultiTargetVectorWeights): MultiTargetVectorJoin => {
      return {
        combination: 'manual-weights' as MultiTargetVectorJoinCombination,
        targetVectors: Object.keys(weights),
        weights,
      };
    },
  };
};

export interface MultiTargetVector {
  /** Create a multi-target vector join that sums the vector scores over the target vectors */
  sum: (targetVectors: string[]) => MultiTargetVectorJoin;
  /** Create a multi-target vector join that averages the vector scores over the target vectors */
  average: (targetVectors: string[]) => MultiTargetVectorJoin;
  /** Create a multi-target vector join that takes the minimum vector score over the target vectors */
  minimum: (targetVectors: string[]) => MultiTargetVectorJoin;
  /** Create a multi-target vector join that uses relative weights for each target vector */
  relativeScore: (weights: MultiTargetVectorWeights) => MultiTargetVectorJoin;
  /** Create a multi-target vector join that uses manual weights for each target vector */
  manualWeights: (weights: MultiTargetVectorWeights) => MultiTargetVectorJoin;
}



---
File: /src/collections/index.ts
---

import Connection from '../connection/grpc.js';
import { WeaviateInvalidInputError, WeaviateUnsupportedFeatureError } from '../errors.js';
import { WeaviateClass } from '../openapi/types.js';
import ClassExists from '../schema/classExists.js';
import { ClassCreator, ClassDeleter, ClassGetter, SchemaGetter } from '../schema/index.js';
import { DbVersionSupport } from '../utils/dbVersion.js';
import collection, { Collection } from './collection/index.js';
import { classToCollection, resolveProperty, resolveReference } from './config/utils.js';
import { QuantizerGuards } from './configure/parsing.js';
import { configGuards } from './index.js';
import {
  CollectionConfig,
  GenerativeConfig,
  GenerativeSearch,
  InvertedIndexConfigCreate,
  ModuleConfig,
  MultiTenancyConfigCreate,
  Properties,
  PropertyConfigCreate,
  ReferenceConfigCreate,
  ReplicationConfigCreate,
  Reranker,
  RerankerConfig,
  ShardingConfigCreate,
  VectorConfigCreate,
  VectorIndexConfigCreate,
  VectorIndexConfigDynamicCreate,
  VectorIndexConfigFlatCreate,
  VectorIndexConfigHNSWCreate,
  VectorIndexType,
  Vectorizer,
  VectorizerConfig,
  VectorizersConfigCreate,
} from './types/index.js';
import { PrimitiveKeys } from './types/internal.js';

/**
 * All the options available when creating a new collection.
 *
 * Inspect [the docs](https://weaviate.io/developers/weaviate/configuration) for more information on the
 * different configuration options and how they affect the behavior of your collection.
 */
export type CollectionConfigCreate<TProperties = undefined, N = string> = {
  /** The name of the collection. */
  name: N;
  /** The description of the collection. */
  description?: string;
  /** The configuration for Weaviate's generative capabilities. */
  generative?: ModuleConfig<GenerativeSearch, GenerativeConfig>;
  /** The configuration for Weaviate's inverted index. */
  invertedIndex?: InvertedIndexConfigCreate;
  /** The configuration for Weaviate's multi-tenancy capabilities. */
  multiTenancy?: MultiTenancyConfigCreate;
  /** The properties of the objects in the collection. */
  properties?: PropertyConfigCreate<TProperties>[];
  /** The references of the objects in the collection. */
  references?: ReferenceConfigCreate<TProperties>[];
  /** The configuration for Weaviate's replication strategy. Is mutually exclusive with `sharding`. */
  replication?: ReplicationConfigCreate;
  /** The configuration for Weaviate's reranking capabilities. */
  reranker?: ModuleConfig<Reranker, RerankerConfig>;
  /** The configuration for Weaviate's sharding strategy. Is mutually exclusive with `replication`. */
  sharding?: ShardingConfigCreate;
  /** The configuration for Weaviate's vectorizer(s) capabilities. */
  vectorizers?: VectorizersConfigCreate<TProperties>;
};

const parseVectorIndex = (module: ModuleConfig<VectorIndexType, VectorIndexConfigCreate>): any => {
  if (module.config === undefined) return undefined;
  if (module.name === 'dynamic') {
    const { hnsw, flat, ...conf } = module.config as VectorIndexConfigDynamicCreate;
    return {
      ...conf,
      hnsw: parseVectorIndex({ name: 'hnsw', config: hnsw }),
      flat: parseVectorIndex({ name: 'flat', config: flat }),
    };
  }
  const { quantizer, ...conf } = module.config as
    | VectorIndexConfigFlatCreate
    | VectorIndexConfigHNSWCreate
    | Record<string, any>;
  if (quantizer === undefined) return conf;
  if (QuantizerGuards.isBQCreate(quantizer)) {
    const { type, ...quant } = quantizer;
    return {
      ...conf,
      bq: {
        ...quant,
        enabled: true,
      },
    };
  }
  if (QuantizerGuards.isPQCreate(quantizer)) {
    const { type, ...quant } = quantizer;
    return {
      ...conf,
      pq: {
        ...quant,
        enabled: true,
      },
    };
  }
};

const parseVectorizerConfig = (config?: VectorizerConfig): any => {
  if (config === undefined) return {};
  const { vectorizeCollectionName, ...rest } = config as any;
  return {
    ...rest,
    vectorizeClassName: vectorizeCollectionName,
  };
};

const collections = (connection: Connection, dbVersionSupport: DbVersionSupport) => {
  const listAll = () =>
    new SchemaGetter(connection)
      .do()
      .then((schema) => (schema.classes ? schema.classes.map(classToCollection<any>) : []));
  const deleteCollection = (name: string) => new ClassDeleter(connection).withClassName(name).do();
  return {
    create: async function <TProperties extends Properties | undefined = undefined, TName = string>(
      config: CollectionConfigCreate<TProperties, TName>
    ) {
      const { name, invertedIndex, multiTenancy, replication, sharding, ...rest } = config;

      const supportsDynamicVectorIndex = await dbVersionSupport.supportsDynamicVectorIndex();
      const supportsNamedVectors = await dbVersionSupport.supportsNamedVectors();
      const supportsHNSWAndBQ = await dbVersionSupport.supportsHNSWAndBQ();

      const moduleConfig: any = {};
      if (config.generative) {
        const generative =
          config.generative.name === 'generative-azure-openai' ? 'generative-openai' : config.generative.name;
        moduleConfig[generative] = config.generative.config ? config.generative.config : {};
      }
      if (config.reranker) {
        moduleConfig[config.reranker.name] = config.reranker.config ? config.reranker.config : {};
      }

      const makeVectorsConfig = (configVectorizers: VectorizersConfigCreate<TProperties>) => {
        let vectorizers: string[] = [];
        const vectorsConfig: Record<string, any> = {};
        const vectorizersConfig = Array.isArray(configVectorizers)
          ? configVectorizers
          : [
              {
                ...configVectorizers,
                name: 'default',
              },
            ];
        vectorizersConfig.forEach((v) => {
          if (v.vectorIndex.name === 'dynamic' && !supportsDynamicVectorIndex.supports) {
            throw new WeaviateUnsupportedFeatureError(supportsDynamicVectorIndex.message);
          }
          const vectorConfig: any = {
            vectorIndexConfig: parseVectorIndex(v.vectorIndex),
            vectorIndexType: v.vectorIndex.name,
            vectorizer: {},
          };
          const vectorizer =
            v.vectorizer.name === 'text2vec-azure-openai' ? 'text2vec-openai' : v.vectorizer.name;
          vectorizers = [...vectorizers, vectorizer];
          vectorConfig.vectorizer[vectorizer] = {
            properties: v.properties,
            ...parseVectorizerConfig(v.vectorizer.config),
          };
          if (v.name === undefined) {
            throw new WeaviateInvalidInputError(
              'vectorName is required for each vectorizer when specifying more than one vectorizer'
            );
          }
          vectorsConfig[v.name] = vectorConfig;
        });
        return { vectorsConfig, vectorizers };
      };

      const makeLegacyVectorizer = (
        configVectorizers: VectorConfigCreate<PrimitiveKeys<TProperties>, undefined, string, Vectorizer>
      ) => {
        const vectorizer =
          configVectorizers.vectorizer.name === 'text2vec-azure-openai'
            ? 'text2vec-openai'
            : configVectorizers.vectorizer.name;
        const moduleConfig: any = {};
        moduleConfig[vectorizer] = parseVectorizerConfig(configVectorizers.vectorizer.config);

        const vectorIndexConfig = parseVectorIndex(configVectorizers.vectorIndex);
        const vectorIndexType = configVectorizers.vectorIndex.name;

        if (
          vectorIndexType === 'hnsw' &&
          configVectorizers.vectorIndex.config !== undefined &&
          configGuards.quantizer.isBQ(configVectorizers.vectorIndex.config.quantizer as any)
        ) {
          if (!supportsHNSWAndBQ.supports) {
            throw new WeaviateUnsupportedFeatureError(supportsHNSWAndBQ.message);
          }
        }

        if (vectorIndexType === 'dynamic' && !supportsDynamicVectorIndex.supports) {
          throw new WeaviateUnsupportedFeatureError(supportsDynamicVectorIndex.message);
        }

        return {
          vectorizer,
          moduleConfig,
          vectorIndexConfig,
          vectorIndexType,
        };
      };

      let schema: any = {
        ...rest,
        class: name,
        invertedIndexConfig: invertedIndex,
        moduleConfig: moduleConfig,
        multiTenancyConfig: multiTenancy,
        replicationConfig: replication,
        shardingConfig: sharding,
      };
      let vectorizers: string[] = [];
      if (supportsNamedVectors.supports) {
        const { vectorsConfig, vectorizers: vecs } = config.vectorizers
          ? makeVectorsConfig(config.vectorizers)
          : { vectorsConfig: undefined, vectorizers: [] };
        schema.vectorConfig = vectorsConfig;
        vectorizers = [...vecs];
      } else {
        if (config.vectorizers !== undefined && Array.isArray(config.vectorizers)) {
          throw new WeaviateUnsupportedFeatureError(supportsNamedVectors.message);
        }
        const configs = config.vectorizers
          ? makeLegacyVectorizer(config.vectorizers)
          : {
              vectorizer: undefined,
              moduleConfig: undefined,
              vectorIndexConfig: undefined,
              vectorIndexType: undefined,
            };
        schema = {
          ...schema,
          moduleConfig: {
            ...schema.moduleConfig,
            ...configs.moduleConfig,
          },
          vectorizer: configs.vectorizer,
          vectorIndexConfig: configs.vectorIndexConfig,
          vectorIndexType: configs.vectorIndexType,
        };
        if (configs.vectorizer !== undefined) {
          vectorizers = [configs.vectorizer];
        }
      }
      const properties = config.properties
        ? config.properties.map((prop) => resolveProperty<TProperties>(prop as any, vectorizers))
        : [];
      const references = config.references ? config.references.map(resolveReference<TProperties>) : [];
      schema.properties = [...properties, ...references];

      await new ClassCreator(connection).withClass(schema).do();
      return collection<TProperties, TName>(connection, name, dbVersionSupport);
    },
    createFromSchema: async function (config: WeaviateClass) {
      const { class: name } = await new ClassCreator(connection).withClass(config).do();
      return collection<Properties, string>(connection, name as string, dbVersionSupport);
    },
    delete: deleteCollection,
    deleteAll: () => listAll().then((configs) => Promise.all(configs?.map((c) => deleteCollection(c.name)))),
    exists: (name: string) => new ClassExists(connection).withClassName(name).do(),
    export: <TProperties>(name: string) =>
      new ClassGetter(connection)
        .withClassName(name)
        .do()
        .then(classToCollection<TProperties>),
    listAll: listAll,
    get: <TProperties extends Properties | undefined = undefined, TName extends string = string>(
      name: TName
    ) => collection<TProperties, TName>(connection, name, dbVersionSupport),
  };
};

export interface Collections {
  create<TProperties extends Properties | undefined = undefined, TName = string>(
    config: CollectionConfigCreate<TProperties, TName>
  ): Promise<Collection<TProperties, TName>>;
  createFromSchema(config: WeaviateClass): Promise<Collection<Properties, string>>;
  delete(collection: string): Promise<void>;
  deleteAll(): Promise<void[]>;
  exists(name: string): Promise<boolean>;
  export(name: string): Promise<CollectionConfig>;
  get<TProperties extends Properties | undefined = undefined, TName extends string = string>(
    name: TName
  ): Collection<TProperties, TName>;
  listAll(): Promise<CollectionConfig[]>;
  // use<TProperties extends Properties | undefined = undefined, TName extends string = string>(
  //   name: TName
  // ): Collection<TProperties, TName>;
}

export default collections;
export * from './aggregate/index.js';
export * from './backup/index.js';
export * from './cluster/index.js';
export * from './collection/index.js';
export * from './config/index.js';
export * from './configure/index.js';
export * from './data/index.js';
export * from './filters/index.js';
export * from './generate/index.js';
export * from './iterator/index.js';
export * from './query/index.js';
export * from './references/index.js';
export * from './sort/index.js';
export * from './tenants/index.js';
export * from './types/index.js';
export * from './vectors/multiTargetVector.js';



---
File: /src/collections/integration.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import weaviate, { WeaviateClient } from '../index';
import {
  CollectionConfigCreate,
  GeoCoordinate,
  PQConfig,
  PhoneNumber,
  PropertyConfig,
  ReplicationDeletionStrategy,
  Text2VecContextionaryConfig,
  Text2VecOpenAIConfig,
  VectorIndexConfigHNSW,
} from './types/index';

describe('Testing of the collections.create method', () => {
  let cluster: WeaviateClient;
  let contextionary: WeaviateClient;
  let openai: WeaviateClient;

  beforeAll(async () => {
    cluster = await weaviate.connectToLocal({
      port: 8087,
      grpcPort: 50051,
    });
    contextionary = await weaviate.connectToLocal({
      port: 8080,
      grpcPort: 50051,
    });
    openai = await weaviate.connectToLocal({
      port: 8086,
      grpcPort: 50051,
    });
  });

  afterAll(() =>
    Promise.all([
      cluster.collections.deleteAll(),
      contextionary.collections.deleteAll(),
      openai.collections.deleteAll(),
    ])
  );

  it('should be able to create a simple collection with a generic', async () => {
    const collectionName = 'TestCollectionSimpleGeneric';
    type TestCollectionSimple = {
      testProp: string;
    };
    const response = await contextionary.collections
      .create<TestCollectionSimple>({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
      })
      .then(() => contextionary.collections.get<TestCollectionSimple>(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(1);
    expect(response.properties[0].name).toEqual('testProp');
    expect(response.properties[0].dataType).toEqual('text');
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to create a simple collection without a generic', async () => {
    const collectionName = 'TestCollectionSimpleNonGeneric';
    const response = await contextionary.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
      })
      .then(() => contextionary.collections.get(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(1);
    expect(response.properties[0].name).toEqual('testProp');
    expect(response.properties[0].dataType).toEqual('text');
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to create a collection with one fully customised text property', () => {
    return contextionary.collections
      .create({
        name: 'TestCollectionTextProperty',
        properties: [
          {
            name: 'text',
            dataType: 'text',
            indexFilterable: true,
            indexSearchable: true,
            skipVectorization: true,
            tokenization: 'field',
            vectorizePropertyName: true,
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary(),
      })
      .then((collection) => collection.config.get())
      .then((config) =>
        expect(config.properties[0]).toEqual<PropertyConfig>({
          name: 'text',
          dataType: 'text',
          indexFilterable: true,
          indexInverted: false,
          indexRangeFilters: false,
          indexSearchable: true,
          tokenization: 'field',
          vectorizerConfig: {
            'text2vec-contextionary': {
              skip: true,
              vectorizePropertyName: true,
            },
          },
        })
      );
  });

  it('should be able to create a collection with one fully customised int property', () => {
    return contextionary.collections
      .create({
        name: 'TestCollectionIntProperty',
        properties: [
          {
            name: 'int',
            dataType: 'int',
            indexFilterable: true,
            indexRangeFilters: true,
            skipVectorization: true,
            vectorizePropertyName: true,
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary(),
      })
      .then((collection) => collection.config.get())
      .then(async (config) =>
        expect(config.properties[0]).toEqual<PropertyConfig>({
          name: 'int',
          dataType: 'int',
          indexFilterable: true,
          indexInverted: false,
          indexRangeFilters: await contextionary.getWeaviateVersion().then((ver) => ver.isAtLeast(1, 26, 0)),
          indexSearchable: false,
          tokenization: 'none',
          vectorizerConfig: {
            'text2vec-contextionary': {
              skip: true,
              vectorizePropertyName: true,
            },
          },
        })
      );
  });

  it('should be able to create a simple collection without a generic and no properties', async () => {
    const collectionName = 'TestCollectionSimpleNonGenericNoProperties';
    const response = await contextionary.collections
      .create({
        name: collectionName,
      })
      .then(() => contextionary.collections.get(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(0);
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to create a simple collection without a generic using a schema var', async () => {
    const collectionName = 'TestCollectionSimpleNonGenericVar';
    const schema = {
      name: collectionName,
      properties: [
        {
          name: 'testProp',
          dataType: 'text' as const,
        },
      ],
    };
    const response = await contextionary.collections
      .create(schema)
      .then(async (collection) => expect(await collection.exists()).toEqual(true))
      .then(() => contextionary.collections.get(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(1);
    expect(response.properties[0].name).toEqual('testProp');
    expect(response.properties[0].dataType).toEqual('text');
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to create a simple collection with a generic using a schema var with const', async () => {
    const collectionName = 'TestCollectionSimpleGenericVarConst';
    type TestCollectionSimple = {
      testProp: string;
    };
    const schema = {
      name: collectionName,
      properties: [
        {
          name: 'testProp' as const,
          dataType: 'text' as const,
        },
      ],
    };
    const response = await contextionary.collections
      .create<TestCollectionSimple>(schema)
      .then(async (collection) => expect(await collection.exists()).toEqual(true))
      .then(() => contextionary.collections.get<TestCollectionSimple>(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(1);
    expect(response.properties[0].name).toEqual('testProp');
    expect(response.properties[0].dataType).toEqual('text');
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to create a simple collection with a generic using a schema var with type', async () => {
    const collectionName = 'TestCollectionSimpleGenericVarType';
    type TestCollectionSimple = {
      testProp: string;
    };
    const schema: CollectionConfigCreate<TestCollectionSimple> = {
      name: collectionName,
      properties: [
        {
          name: 'testProp',
          dataType: 'text',
        },
      ],
    };
    const response = await contextionary.collections
      .create<TestCollectionSimple>(schema)
      .then(async (collection) => expect(await collection.exists()).toEqual(true))
      .then(() => contextionary.collections.get<TestCollectionSimple>(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(1);
    expect(response.properties[0].name).toEqual('testProp');
    expect(response.properties[0].dataType).toEqual('text');
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to create a nested collection', async () => {
    const collectionName = 'TestCollectionNested';
    type TestCollectionNested = {
      testProp: {
        nestedProp: string;
      };
    };
    const response = await contextionary.collections
      .create<TestCollectionNested>({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'object',
            nestedProperties: [
              {
                name: 'nestedProp',
                dataType: 'text',
              },
            ],
          },
        ],
      })
      .then(async (collection) => expect(await collection.exists()).toEqual(true))
      .then(() => contextionary.collections.get<TestCollectionNested>(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties.length).toEqual(1);
    expect(response.properties[0].name).toEqual('testProp');
    expect(response.properties[0].dataType).toEqual('object');
    expect(response.properties[0].nestedProperties?.length).toEqual(1);
    expect(response.properties[0].nestedProperties?.[0].name).toEqual('nestedProp');
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to create a collection with generic properties', () => {
    const collectionName = 'TestCollectionGenericProperties';

    type TestCollectionGenericProperties = {
      text: string;
      texts: string[];
      number: number;
      numbers: number[];
      int: number;
      ints: number[];
      date: Date;
      dates: Date[];
      boolean: boolean;
      booleans: boolean[];
      object: {
        nestedProp: string;
      };
      objects: {
        nestedProp: string;
      }[];
      blob: string;
      geoCoordinates: GeoCoordinate;
      phoneNumber: PhoneNumber;
    };

    return cluster.collections.create<TestCollectionGenericProperties, 'TestCollectionGenericProperties'>({
      name: collectionName,
      properties: [
        {
          name: 'text',
          dataType: 'text',
        },
        {
          name: 'texts',
          dataType: 'text[]',
        },
        {
          name: 'number',
          dataType: 'number',
        },
        {
          name: 'numbers',
          dataType: 'number[]',
        },
        {
          name: 'int',
          dataType: 'int',
        },
        {
          name: 'ints',
          dataType: 'int[]',
        },
        {
          name: 'date',
          dataType: 'date',
        },
        {
          name: 'dates',
          dataType: 'date[]',
        },
        {
          name: 'boolean',
          dataType: 'boolean',
        },
        {
          name: 'booleans',
          dataType: 'boolean[]',
        },
        {
          name: 'object',
          dataType: 'object',
          nestedProperties: [
            {
              name: 'nestedProp',
              dataType: 'text',
            },
          ],
        },
        {
          name: 'objects',
          dataType: 'object[]',
          nestedProperties: [
            {
              name: 'nestedProp',
              dataType: 'text',
            },
          ],
        },
        {
          name: 'blob',
          dataType: 'blob',
        },
        {
          name: 'geoCoordinates',
          dataType: 'geoCoordinates',
        },
        {
          name: 'phoneNumber',
          dataType: 'phoneNumber',
        },
      ],
    });
  });

  it('should be able to create a complex collection', async () => {
    const collectionName = 'TestCollectionSimple';
    const response = await cluster.collections
      .create({
        name: collectionName,
        description: 'A test collection',
        invertedIndex: {
          bm25: {
            b: 0.8,
            k1: 1.3,
          },
          cleanupIntervalSeconds: 10,
          indexTimestamps: true,
          indexPropertyLength: true,
          indexNullState: true,
          stopwords: {
            preset: 'en',
            additions: ['a'],
            removals: ['the'],
          },
        },
        properties: [
          {
            name: 'text',
            dataType: weaviate.configure.dataType.TEXT,
          },
          {
            name: 'texts',
            dataType: weaviate.configure.dataType.TEXT_ARRAY,
          },
          {
            name: 'number',
            dataType: weaviate.configure.dataType.NUMBER,
          },
          {
            name: 'numbers',
            dataType: weaviate.configure.dataType.NUMBER_ARRAY,
          },
          {
            name: 'int',
            dataType: weaviate.configure.dataType.INT,
          },
          {
            name: 'ints',
            dataType: weaviate.configure.dataType.INT_ARRAY,
          },
          {
            name: 'date',
            dataType: weaviate.configure.dataType.DATE,
          },
          {
            name: 'dates',
            dataType: weaviate.configure.dataType.DATE_ARRAY,
          },
          {
            name: 'boolean',
            dataType: weaviate.configure.dataType.BOOLEAN,
          },
          {
            name: 'booleans',
            dataType: weaviate.configure.dataType.BOOLEAN_ARRAY,
          },
          {
            name: 'object',
            dataType: weaviate.configure.dataType.OBJECT,
            nestedProperties: [
              {
                name: 'nestedProp',
                dataType: weaviate.configure.dataType.TEXT,
              },
            ],
          },
          {
            name: 'objects',
            dataType: weaviate.configure.dataType.OBJECT_ARRAY,
            nestedProperties: [
              {
                name: 'nestedProp',
                dataType: weaviate.configure.dataType.TEXT,
              },
            ],
          },
          {
            name: 'blob',
            dataType: weaviate.configure.dataType.BLOB,
          },
          {
            name: 'geoCoordinates',
            dataType: weaviate.configure.dataType.GEO_COORDINATES,
          },
          {
            name: 'phoneNumber',
            dataType: weaviate.configure.dataType.PHONE_NUMBER,
          },
        ],
        multiTenancy: {
          enabled: true,
        },
        replication: {
          factor: 2,
        },
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary({
          vectorIndexConfig: {
            name: 'hnsw' as const,
            config: {
              cleanupIntervalSeconds: 10,
              distance: 'dot',
              dynamicEfFactor: 6,
              dynamicEfMax: 100,
              dynamicEfMin: 10,
              ef: -2,
              efConstruction: 100,
              filterStrategy: 'acorn',
              flatSearchCutoff: 41000,
              maxConnections: 72,
              quantizer: {
                bitCompression: true,
                centroids: 128,
                encoder: {
                  distribution: 'normal',
                  type: 'tile',
                },
                segments: 4,
                trainingLimit: 100001,
                type: 'pq',
              },
              skip: true,
              vectorCacheMaxObjects: 100000,
            },
          },
        }),
      })
      .then(async (collection) => expect(await collection.exists()).toEqual(true))
      .then(() => cluster.collections.get(collectionName).config.get());

    expect(response.name).toEqual(collectionName);
    expect(response.description).toEqual('A test collection');

    expect(response.properties?.length).toEqual(15);
    expect(response.properties?.[0].name).toEqual('text');
    expect(response.properties?.[0].dataType).toEqual('text');
    expect(response.properties?.[1].name).toEqual('texts');
    expect(response.properties?.[1].dataType).toEqual('text[]');
    expect(response.properties?.[2].name).toEqual('number');
    expect(response.properties?.[2].dataType).toEqual('number');
    expect(response.properties?.[3].name).toEqual('numbers');
    expect(response.properties?.[3].dataType).toEqual('number[]');
    expect(response.properties?.[4].name).toEqual('int');
    expect(response.properties?.[4].dataType).toEqual('int');
    expect(response.properties?.[5].name).toEqual('ints');
    expect(response.properties?.[5].dataType).toEqual('int[]');
    expect(response.properties?.[6].name).toEqual('date');
    expect(response.properties?.[6].dataType).toEqual('date');
    expect(response.properties?.[7].name).toEqual('dates');
    expect(response.properties?.[7].dataType).toEqual('date[]');
    expect(response.properties?.[8].name).toEqual('boolean');
    expect(response.properties?.[8].dataType).toEqual('boolean');
    expect(response.properties?.[9].name).toEqual('booleans');
    expect(response.properties?.[9].dataType).toEqual('boolean[]');
    expect(response.properties?.[10].name).toEqual('object');
    expect(response.properties?.[10].dataType).toEqual('object');
    expect(response.properties?.[10].nestedProperties?.length).toEqual(1);
    expect(response.properties?.[10].nestedProperties?.[0].name).toEqual('nestedProp');
    expect(response.properties?.[10].nestedProperties?.[0].dataType).toEqual('text');
    expect(response.properties?.[11].name).toEqual('objects');
    expect(response.properties?.[11].dataType).toEqual('object[]');
    expect(response.properties?.[11].nestedProperties?.length).toEqual(1);
    expect(response.properties?.[11].nestedProperties?.[0].name).toEqual('nestedProp');
    expect(response.properties?.[11].nestedProperties?.[0].dataType).toEqual('text');
    expect(response.properties?.[12].name).toEqual('blob');
    expect(response.properties?.[12].dataType).toEqual('blob');
    expect(response.properties?.[13].name).toEqual('geoCoordinates');
    expect(response.properties?.[13].dataType).toEqual('geoCoordinates');
    expect(response.properties?.[14].name).toEqual('phoneNumber');
    expect(response.properties?.[14].dataType).toEqual('phoneNumber');

    expect(response.invertedIndex.bm25.b).toEqual(0.8);
    expect(response.invertedIndex.bm25.k1).toEqual(1.3);
    expect(response.invertedIndex.cleanupIntervalSeconds).toEqual(10);
    expect(response.invertedIndex.indexTimestamps).toEqual(true);
    expect(response.invertedIndex.indexPropertyLength).toEqual(true);
    expect(response.invertedIndex.indexNullState).toEqual(true);
    // expect(response.invertedIndexConfig?.stopwords?.additions).toEqual(['a']); // potential weaviate bug, this returns as None
    expect(response.invertedIndex.stopwords?.preset).toEqual('en');
    expect(response.invertedIndex.stopwords?.removals).toEqual(['the']);

    expect(response.multiTenancy.enabled).toEqual(true);

    expect(response.replication.asyncEnabled).toEqual(false);
    expect(response.replication.deletionStrategy).toEqual<ReplicationDeletionStrategy>(
      (await cluster.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 25, 0)))
        ? 'NoAutomatedResolution'
        : 'DeleteOnConflict'
    );
    expect(response.replication.factor).toEqual(2);

    const indexConfig = response.vectorizers.default.indexConfig as VectorIndexConfigHNSW;
    const quantizer = indexConfig.quantizer as PQConfig;
    expect(indexConfig.cleanupIntervalSeconds).toEqual(10);
    expect(indexConfig.distance).toEqual('dot');
    expect(indexConfig.dynamicEfFactor).toEqual(6);
    expect(indexConfig.dynamicEfMax).toEqual(100);
    expect(indexConfig.dynamicEfMin).toEqual(10);
    expect(indexConfig.ef).toEqual(-2);
    expect(indexConfig.efConstruction).toEqual(100);
    expect(indexConfig.filterStrategy).toEqual(
      (await cluster.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 27, 0))) ? 'sweeping' : 'acorn'
    );
    expect(indexConfig.flatSearchCutoff).toEqual(41000);
    expect(indexConfig.maxConnections).toEqual(72);
    expect(quantizer.bitCompression).toEqual(true);
    expect(quantizer.centroids).toEqual(128);
    expect(quantizer.encoder.distribution).toEqual('normal');
    // expect(quantizer.encoder.type).toEqual('tile'); // potential weaviate bug, this returns as PQEncoderType.KMEANS
    expect(quantizer.segments).toEqual(4);
    expect(quantizer.trainingLimit).toEqual(100001);
    expect(indexConfig.skip).toEqual(true);
    expect(indexConfig.vectorCacheMaxObjects).toEqual(100000);

    expect(response.vectorizers.default.indexType).toEqual('hnsw');

    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
  });

  it('should be able to create a collection with the contextionary vectorizer using configure.vectorizer', async () => {
    const collectionName = 'ThisOneIsATest'; // must include words in contextionary's vocabulary to pass since vectorizeCollectionName will be true
    const response = await contextionary.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecContextionary(),
      })
      .then(async (collection) => expect(await collection.exists()).toEqual(true))
      .then(() => contextionary.collections.get(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(1);
    expect(response.properties?.[0].name).toEqual('testProp');
    expect(response.properties?.[0].dataType).toEqual('text');
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect((response.vectorizers.default.indexConfig as VectorIndexConfigHNSW).quantizer).toBeUndefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-contextionary');
    expect(
      (response.vectorizers.default.vectorizer.config as Text2VecContextionaryConfig).vectorizeCollectionName
    ).toEqual(true);
  });

  it('should be able to create a collection with an openai vectorizer with configure.vectorizer', async () => {
    const collectionName = 'TestCollectionOpenAIVectorizerWithConfigureVectorizer';
    const response = await openai.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
        vectorizers: weaviate.configure.vectorizer.text2VecOpenAI(),
      })
      .then(async (collection) => expect(await collection.exists()).toEqual(true))
      .then(() => openai.collections.get(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(1);
    expect(response.properties?.[0].name).toEqual('testProp');
    expect(response.properties?.[0].dataType).toEqual('text');
    expect(response.vectorizers.default.indexConfig).toBeDefined();
    expect((response.vectorizers.default.indexConfig as VectorIndexConfigHNSW).quantizer).toBeUndefined();
    expect(response.vectorizers.default.indexType).toEqual('hnsw');
    expect(response.vectorizers.default.vectorizer.name).toEqual('text2vec-openai');
    expect(
      (response.vectorizers.default.vectorizer.config as Text2VecOpenAIConfig).vectorizeCollectionName
    ).toEqual(true);
  });

  it('should be able to create a collection with the openai generative with configure.Generative', async () => {
    const collectionName = 'TestCollectionOpenAIGenerativeWithConfigureGenerative';
    const response = await openai.collections
      .create({
        name: collectionName,
        properties: [
          {
            name: 'testProp',
            dataType: 'text',
          },
        ],
        generative: weaviate.configure.generative.openAI(),
      })
      .then(async (collection) => expect(await collection.exists()).toEqual(true))
      .then(() => openai.collections.get(collectionName).config.get());
    expect(response.name).toEqual(collectionName);
    expect(response.properties?.length).toEqual(1);
    expect(response.properties?.[0].name).toEqual('testProp');
    expect(response.properties?.[0].dataType).toEqual('text');
    expect(response.generative).toEqual({
      name: 'generative-openai',
      config: {},
    });
  });
});



---
File: /src/collections/journey.test.ts
---

import weaviate, { CollectionConfig, WeaviateClient } from '../index.js';
import { GeoCoordinate } from '../proto/v1/properties.js';

describe('Journey testing of the client using a WCD cluster', () => {
  let client: WeaviateClient;
  const collectionName = `MyTSTestingCollection_${Date.now()}`;

  type MyType = {
    name: string;
    age: number;
    location?: GeoCoordinate;
    dateOfBirth: Date;
  };

  beforeAll(async () => {
    client = await weaviate.connectToWeaviateCloud(
      'https://piblpmmdsiknacjnm1ltla.c1.europe-west3.gcp.weaviate.cloud',
      {
        authCredentials: 'NOg5AliYnrN6z7dZDuGv7SLVKhTabAaSTKS7',
      }
    );
    return client.collections.delete(collectionName);
  });

  it('should create the correct config for a collection with vectorizer, generative, and reranker modules', () => {
    return client.collections.create<MyType>({
      name: collectionName,
      properties: [
        {
          name: 'name',
          dataType: 'text',
        },
        {
          name: 'age',
          dataType: 'int',
        },
        {
          name: 'location',
          dataType: 'geoCoordinates',
        },
        {
          name: 'dateOfBirth',
          dataType: 'date',
        },
      ],
      generative: weaviate.configure.generative.cohere(),
      reranker: weaviate.configure.reranker.cohere(),
      vectorizers: weaviate.configure.vectorizer.text2VecCohere(),
    });
  });

  it('should get the config for the created collection', () => {
    return client.collections
      .get(collectionName)
      .config.get()
      .then(async (config) => {
        expect(config).toEqual<CollectionConfig>({
          name: collectionName,
          generative: {
            name: 'generative-cohere',
            config: {},
          },
          invertedIndex: {
            bm25: {
              b: 0.75,
              k1: 1.2,
            },
            cleanupIntervalSeconds: 60,
            stopwords: {
              additions: [],
              preset: 'en',
              removals: [],
            },
            indexNullState: false,
            indexPropertyLength: false,
            indexTimestamps: false,
          },
          multiTenancy: {
            autoTenantActivation: false,
            autoTenantCreation: false,
            enabled: false,
          },
          properties: [
            {
              name: 'name',
              dataType: 'text',
              indexFilterable: true,
              indexInverted: false,
              indexRangeFilters: false,
              indexSearchable: true,
              vectorizerConfig: {
                'text2vec-cohere': {
                  skip: false,
                  vectorizePropertyName: true,
                },
              },
              tokenization: 'word',
            },
            {
              name: 'age',
              dataType: 'int',
              indexFilterable: true,
              indexInverted: false,
              indexRangeFilters: false,
              indexSearchable: false,
              vectorizerConfig: {
                'text2vec-cohere': {
                  skip: false,
                  vectorizePropertyName: true,
                },
              },
              tokenization: 'none',
            },
            {
              name: 'location',
              dataType: 'geoCoordinates',
              indexFilterable: true,
              indexInverted: false,
              indexRangeFilters: false,
              indexSearchable: false,
              vectorizerConfig: {
                'text2vec-cohere': {
                  skip: false,
                  vectorizePropertyName: true,
                },
              },
              tokenization: 'none',
            },
            {
              name: 'dateOfBirth',
              dataType: 'date',
              indexFilterable: true,
              indexInverted: false,
              indexRangeFilters: false,
              indexSearchable: false,
              vectorizerConfig: {
                'text2vec-cohere': {
                  skip: false,
                  vectorizePropertyName: true,
                },
              },
              tokenization: 'none',
            },
          ],
          references: [],
          replication: {
            asyncEnabled: false,
            deletionStrategy: 'NoAutomatedResolution',
            factor: 1,
          },
          reranker: {
            name: 'reranker-cohere',
            config: {},
          },
          sharding: {
            virtualPerPhysical: 128,
            desiredCount: 1,
            actualCount: 1,
            desiredVirtualCount: 128,
            actualVirtualCount: 128,
            key: '_id',
            strategy: 'hash',
            function: 'murmur3',
          },
          vectorizers: {
            default: {
              vectorizer: {
                name: 'text2vec-cohere',
                config: {
                  vectorizeCollectionName: true,
                },
              },
              indexConfig: {
                cleanupIntervalSeconds: 300,
                distance: 'cosine',
                dynamicEfMin: 100,
                dynamicEfMax: 500,
                dynamicEfFactor: 8,
                ef: -1,
                efConstruction: 128,
                filterStrategy: 'sweeping',
                flatSearchCutoff: 40000,
                maxConnections: (await client.getWeaviateVersion().then((ver) => ver.isLowerThan(1, 26, 0)))
                  ? 64
                  : 32,
                skip: false,
                vectorCacheMaxObjects: 1000000000000,
                quantizer: undefined,
                type: 'hnsw',
              },
              indexType: 'hnsw',
            },
          },
        });
      });
  });
});



---
File: /src/connection/auth.ts
---

import { HttpClient } from './http.js';

/**
 * The allowed authentication credentials. See [the docs](https://weaviate.io/developers/weaviate/configuration/authentication) for more information.
 *
 * The following types are allowed:
 * - `AuthUserPasswordCredentials`
 * - `AuthAccessTokenCredentials`
 * - `AuthClientCredentials`
 * - `ApiKey`
 * - `string`
 *
 * A string is interpreted as an API key.
 */
export type AuthCredentials =
  | AuthUserPasswordCredentials
  | AuthAccessTokenCredentials
  | AuthClientCredentials
  | ApiKey
  | string;

export const isApiKey = (creds?: AuthCredentials): creds is ApiKey | string => {
  return typeof creds === 'string' || creds instanceof ApiKey;
};

export const mapApiKey = (creds: ApiKey | string): ApiKey => {
  return creds instanceof ApiKey ? creds : new ApiKey(creds);
};

interface AuthenticatorResult {
  accessToken: string;
  expiresAt: number;
  refreshToken: string;
}

interface OidcCredentials {
  silentRefresh: boolean;
}

export interface OidcAuthFlow {
  refresh: () => Promise<AuthenticatorResult>;
}

export class OidcAuthenticator {
  private readonly http: HttpClient;
  private readonly creds: OidcCredentials;
  private accessToken: string;
  private refreshToken?: string;
  private expiresAt: number;
  private refreshRunning: boolean;
  private refreshInterval!: NodeJS.Timeout;

  constructor(http: HttpClient, creds: any) {
    this.http = http;
    this.creds = creds;
    this.accessToken = '';
    this.refreshToken = '';
    this.expiresAt = 0;
    this.refreshRunning = false;

    // If the authentication method is access token,
    // our bearer token is already available for use
    if (this.creds instanceof AuthAccessTokenCredentials) {
      this.accessToken = this.creds.accessToken;
      this.expiresAt = this.creds.expiresAt;
      this.refreshToken = this.creds.refreshToken;
    }
  }

  refresh = async (localConfig: any) => {
    const config = await this.getOpenidConfig(localConfig);

    let authenticator: OidcAuthFlow;
    switch (this.creds.constructor) {
      case AuthUserPasswordCredentials:
        authenticator = new UserPasswordAuthenticator(this.http, this.creds, config);
        break;
      case AuthAccessTokenCredentials:
        authenticator = new AccessTokenAuthenticator(this.http, this.creds, config);
        break;
      case AuthClientCredentials:
        authenticator = new ClientCredentialsAuthenticator(this.http, this.creds, config);
        break;
      default:
        throw new Error('unsupported credential type');
    }

    return authenticator.refresh().then((resp) => {
      this.accessToken = resp.accessToken;
      this.expiresAt = resp.expiresAt;
      this.refreshToken = resp.refreshToken;
      this.startTokenRefresh(authenticator);
    });
  };

  getOpenidConfig = (localConfig: any) => {
    return this.http.externalGet(localConfig.href).then((openidProviderConfig: any) => {
      const scopes = localConfig.scopes || [];
      return {
        clientId: localConfig.clientId,
        provider: openidProviderConfig,
        scopes: scopes,
      };
    });
  };

  startTokenRefresh = (authenticator: { refresh: () => any }) => {
    if (this.creds.silentRefresh && !this.refreshRunning && this.refreshTokenProvided()) {
      this.refreshInterval = setInterval(async () => {
        // check every 30s if the token will expire in <= 1m,
        // if so, refresh
        if (this.expiresAt - Date.now() <= 60_000) {
          const resp = await authenticator.refresh();
          this.accessToken = resp.accessToken;
          this.expiresAt = resp.expiresAt;
          this.refreshToken = resp.refreshToken;
        }
      }, 30_000);
      this.refreshRunning = true;
    }
  };

  stopTokenRefresh = () => {
    clearInterval(this.refreshInterval);
    this.refreshRunning = false;
  };

  refreshTokenProvided = () => {
    return this.refreshToken && this.refreshToken != '';
  };

  getAccessToken = () => {
    return this.accessToken;
  };

  getExpiresAt = () => {
    return this.expiresAt;
  };

  resetExpiresAt() {
    this.expiresAt = 0;
  }
}

export interface UserPasswordCredentialsInput {
  username: string;
  password?: string;
  scopes?: any[];
  silentRefresh?: boolean;
}

export class AuthUserPasswordCredentials implements OidcCredentials {
  private username: string;
  private password?: string;
  private scopes?: any[];
  public readonly silentRefresh: boolean;
  constructor(creds: UserPasswordCredentialsInput) {
    this.username = creds.username;
    this.password = creds.password;
    this.scopes = creds.scopes;
    this.silentRefresh = parseSilentRefresh(creds.silentRefresh);
  }
}

interface RequestAccessTokenResponse {
  access_token: string;
  expires_in: number;
  refresh_token: string;
}

class UserPasswordAuthenticator implements OidcAuthFlow {
  private creds: any;
  private http: any;
  private openidConfig: any;
  constructor(http: any, creds: any, config: any) {
    this.http = http;
    this.creds = creds;
    this.openidConfig = config;
    if (creds.scopes) {
      this.openidConfig.scopes.push(creds.scopes);
    }
  }

  refresh = () => {
    this.validateOpenidConfig();
    return this.requestAccessToken()
      .then((tokenResp: RequestAccessTokenResponse) => {
        return {
          accessToken: tokenResp.access_token,
          expiresAt: calcExpirationEpoch(tokenResp.expires_in),
          refreshToken: tokenResp.refresh_token,
        };
      })
      .catch((err: any) => {
        return Promise.reject(new Error(`failed to refresh access token: ${err}`));
      });
  };

  validateOpenidConfig = () => {
    if (
      this.openidConfig.provider.grant_types_supported !== undefined &&
      !this.openidConfig.provider.grant_types_supported.includes('password')
    ) {
      throw new Error('grant_type password not supported');
    }
    if (this.openidConfig.provider.token_endpoint.includes('https://login.microsoftonline.com')) {
      throw new Error(
        'microsoft/azure recommends to avoid authentication using ' +
          'username and password, so this method is not supported by this client'
      );
    }
    this.openidConfig.scopes.push('offline_access');
  };

  requestAccessToken = () => {
    const url = this.openidConfig.provider.token_endpoint;
    const params = new URLSearchParams({
      grant_type: 'password',
      client_id: this.openidConfig.clientId,
      username: this.creds.username,
      password: this.creds.password,
      scope: this.openidConfig.scopes.join(' '),
    });
    const contentType = 'application/x-www-form-urlencoded;charset=UTF-8';
    return this.http.externalPost(url, params, contentType);
  };
}

export interface AccessTokenCredentialsInput {
  accessToken: string;
  expiresIn: number;
  refreshToken?: string;
  silentRefresh?: boolean;
}

export class AuthAccessTokenCredentials implements OidcCredentials {
  public readonly accessToken: string;
  public readonly expiresAt: number;
  public readonly refreshToken?: string;
  public readonly silentRefresh: boolean;

  constructor(creds: AccessTokenCredentialsInput) {
    this.validate(creds);
    this.accessToken = creds.accessToken;
    this.expiresAt = calcExpirationEpoch(creds.expiresIn);
    this.refreshToken = creds.refreshToken;
    this.silentRefresh = parseSilentRefresh(creds.silentRefresh);
  }

  validate = (creds: AccessTokenCredentialsInput) => {
    if (creds.expiresIn === undefined) {
      throw new Error('AuthAccessTokenCredentials: expiresIn is required');
    }
    if (!Number.isInteger(creds.expiresIn) || creds.expiresIn <= 0) {
      throw new Error('AuthAccessTokenCredentials: expiresIn must be int > 0');
    }
  };
}

class AccessTokenAuthenticator implements OidcAuthFlow {
  private creds: any;
  private http: any;
  private openidConfig: any;
  constructor(http: any, creds: any, config: any) {
    this.http = http;
    this.creds = creds;
    this.openidConfig = config;
  }

  refresh = () => {
    if (this.creds.refreshToken === undefined || this.creds.refreshToken == '') {
      console.warn('AuthAccessTokenCredentials not provided with refreshToken, cannot refresh');
      return Promise.resolve({
        accessToken: this.creds.accessToken,
        expiresAt: this.creds.expiresAt,
      });
    }
    this.validateOpenidConfig();
    return this.requestAccessToken()
      .then((tokenResp: RequestAccessTokenResponse) => {
        return {
          accessToken: tokenResp.access_token,
          expiresAt: calcExpirationEpoch(tokenResp.expires_in),
          refreshToken: tokenResp.refresh_token,
        };
      })
      .catch((err: any) => {
        return Promise.reject(new Error(`failed to refresh access token: ${err}`));
      });
  };

  validateOpenidConfig = () => {
    if (
      this.openidConfig.provider.grant_types_supported === undefined ||
      !this.openidConfig.provider.grant_types_supported.includes('refresh_token')
    ) {
      throw new Error('grant_type refresh_token not supported');
    }
  };

  requestAccessToken = () => {
    const url = this.openidConfig.provider.token_endpoint;
    const params = new URLSearchParams({
      grant_type: 'refresh_token',
      client_id: this.openidConfig.clientId,
      refresh_token: this.creds.refreshToken,
    });
    const contentType = 'application/x-www-form-urlencoded;charset=UTF-8';
    return this.http.externalPost(url, params, contentType);
  };
}

export interface ClientCredentialsInput {
  clientSecret: string;
  scopes?: any[];
  silentRefresh?: boolean;
}

export class AuthClientCredentials implements OidcCredentials {
  private clientSecret: any;
  private scopes?: any[];
  public readonly silentRefresh: boolean;

  constructor(creds: ClientCredentialsInput) {
    this.clientSecret = creds.clientSecret;
    this.scopes = creds.scopes;
    this.silentRefresh = parseSilentRefresh(creds.silentRefresh);
  }
}

class ClientCredentialsAuthenticator implements OidcAuthFlow {
  private creds: any;
  private http: any;
  private openidConfig: any;

  constructor(http: any, creds: any, config: any) {
    this.http = http;
    this.creds = creds;
    this.openidConfig = config;
    if (creds.scopes) {
      this.openidConfig.scopes.push(creds.scopes);
    }
  }

  refresh = () => {
    this.validateOpenidConfig();
    return this.requestAccessToken()
      .then((tokenResp: RequestAccessTokenResponse) => {
        return {
          accessToken: tokenResp.access_token,
          expiresAt: calcExpirationEpoch(tokenResp.expires_in),
          refreshToken: tokenResp.refresh_token,
        };
      })
      .catch((err: any) => {
        return Promise.reject(new Error(`failed to refresh access token: ${err}`));
      });
  };

  validateOpenidConfig = () => {
    if (this.openidConfig.scopes.length > 0) {
      return;
    }
    if (this.openidConfig.provider.token_endpoint.includes('https://login.microsoftonline.com')) {
      this.openidConfig.scopes.push(this.openidConfig.clientId + '/.default');
    }
  };

  requestAccessToken = () => {
    const url = this.openidConfig.provider.token_endpoint;
    const params = new URLSearchParams({
      grant_type: 'client_credentials',
      client_id: this.openidConfig.clientId,
      client_secret: this.creds.clientSecret,
      scope: this.openidConfig.scopes.join(' '),
    });

    const contentType = 'application/x-www-form-urlencoded;charset=UTF-8';
    return this.http.externalPost(url, params, contentType);
  };
}

export class ApiKey {
  public readonly apiKey: string;

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }
}

function calcExpirationEpoch(expiresIn: number): number {
  return Date.now() + (expiresIn - 2) * 1000; // -2 for some lag
}

function parseSilentRefresh(silentRefresh: boolean | undefined): boolean {
  // Silent token refresh by default
  if (silentRefresh === undefined) {
    return true;
  } else {
    return silentRefresh;
  }
}



---
File: /src/connection/gql.ts
---

import { GraphQLClient as Client, Variables } from 'graphql-request';
import ConnectionREST, { InternalConnectionParams } from './http.js';

export default class ConnectionGQL extends ConnectionREST {
  private gql: GraphQLClient;

  constructor(params: InternalConnectionParams) {
    super(params);
    this.gql = gqlClient(params);
  }

  query = <V extends Variables, T = any>(query: any, variables?: V) => {
    if (this.authEnabled) {
      return this.login().then((token) => {
        const headers = { Authorization: `Bearer ${token}` };
        return this.gql.query<V, T>(query, variables, headers);
      });
    }
    return this.gql.query<V, T>(query, variables);
  };

  close = () => this.http.close();
}

export * from './auth.js';

export type TQuery = any;
export interface GraphQLClient {
  query: <V extends Variables, T>(
    query: TQuery,
    variables?: V,
    headers?: HeadersInit
  ) => Promise<{ data: T }>;
}

export const gqlClient = (config: InternalConnectionParams): GraphQLClient => {
  const version = '/v1/graphql';
  const baseUri = `${config.host}${version}`;
  const defaultHeaders = config.headers;
  return {
    // for backward compatibility with replaced graphql-client lib,
    // results are wrapped into { data: data }
    query: <V extends Variables, T>(query: TQuery, variables?: V, headers?: HeadersInit) => {
      return new Client(baseUri, {
        headers: {
          ...defaultHeaders,
          ...headers,
        },
      })
        .request<T>(query, variables, headers)
        .then((data) => ({ data }));
    },
  };
};



---
File: /src/connection/grpc.ts
---

import { isAbortError } from 'abort-controller-x';

import ConnectionGQL from './gql.js';
import { InternalConnectionParams } from './http.js';

import { ConsistencyLevel } from '../data/index.js';

import { ChannelCredentials, ChannelOptions, createChannel, createClientFactory, Metadata } from 'nice-grpc';
import { retryMiddleware } from 'nice-grpc-client-middleware-retry';

import { HealthCheckResponse_ServingStatus, HealthDefinition } from '../proto/google/health/v1/health.js';
import { WeaviateDefinition } from '../proto/v1/weaviate.js';

import Batcher, { Batch } from '../grpc/batcher.js';
import Searcher, { Search } from '../grpc/searcher.js';
import TenantsManager, { Tenants } from '../grpc/tenantsManager.js';
import { DbVersionSupport, initDbVersionProvider } from '../utils/dbVersion.js';

import { WeaviateGRPCUnavailableError, WeaviateUnsupportedFeatureError } from '../errors.js';
import { Meta } from '../openapi/types.js';

export interface GrpcConnectionParams extends InternalConnectionParams {
  grpcAddress: string;
  grpcSecure: boolean;
}

const clientFactory = createClientFactory().use(retryMiddleware);

const MAX_GRPC_MESSAGE_LENGTH = 104858000; // 10mb, needs to be synchronized with GRPC server

// Must extend from ConnectionGQL so that it can be passed to all the builder methods,
// which are tightly coupled to ConnectionGQL
export default class ConnectionGRPC extends ConnectionGQL {
  private grpc: GrpcClient;

  private constructor(params: GrpcConnectionParams & { grpcMaxMessageLength: number }) {
    super(params);
    this.grpc = grpcClient(params);
  }

  static use = (params: GrpcConnectionParams) => {
    const rest = new ConnectionGQL(params);
    const dbVersionProvider = initDbVersionProvider(rest);
    const dbVersionSupport = new DbVersionSupport(dbVersionProvider);
    if (params.skipInitChecks) {
      return {
        connection: new ConnectionGRPC({
          ...params,
          grpcMaxMessageLength: MAX_GRPC_MESSAGE_LENGTH,
        }),
        dbVersionProvider,
        dbVersionSupport,
      };
    }
    return Promise.all([
      ConnectionGRPC.connect(
        params,
        (rest.get('/meta', true) as Promise<Meta>).then(
          (res: Meta) => res.grpcMaxMessageSize || MAX_GRPC_MESSAGE_LENGTH
        )
      ),
      dbVersionSupport.supportsCompatibleGrpcService().then((check) => {
        if (!check.supports) {
          throw new WeaviateUnsupportedFeatureError(
            `Checking for gRPC compatibility failed with message: ${check.message}`
          );
        }
      }),
    ]).then(([connection]) => {
      return { connection, dbVersionProvider, dbVersionSupport };
    });
  };

  private static async connect(
    params: GrpcConnectionParams,
    grpcMaxLengthPromise: Promise<number>
  ): Promise<ConnectionGRPC> {
    const connection = await grpcMaxLengthPromise.then(
      (grpcMaxMessageLength) =>
        new ConnectionGRPC({
          ...params,
          grpcMaxMessageLength,
        })
    );
    const isHealthy = await connection.grpc.health();
    if (!isHealthy) {
      await connection.close();
      throw new WeaviateGRPCUnavailableError(params.grpcAddress);
    }
    return connection;
  }

  search = (collection: string, consistencyLevel?: ConsistencyLevel, tenant?: string) => {
    if (this.authEnabled) {
      return this.login().then((token) =>
        this.grpc.search(collection, consistencyLevel, tenant, `Bearer ${token}`)
      );
    }
    return new Promise<Search>((resolve) => resolve(this.grpc.search(collection, consistencyLevel, tenant)));
  };

  batch = (collection: string, consistencyLevel?: ConsistencyLevel, tenant?: string) => {
    if (this.authEnabled) {
      return this.login().then((token) =>
        this.grpc.batch(collection, consistencyLevel, tenant, `Bearer ${token}`)
      );
    }
    return new Promise<Batch>((resolve) => resolve(this.grpc.batch(collection, consistencyLevel, tenant)));
  };

  tenants = (collection: string) => {
    if (this.authEnabled) {
      return this.login().then((token) => this.grpc.tenants(collection, `Bearer ${token}`));
    }
    return new Promise<Tenants>((resolve) => resolve(this.grpc.tenants(collection)));
  };

  close = () => {
    this.grpc.close();
    this.http.close();
  };
}

export interface GrpcClient {
  close: () => void;
  batch: (
    collection: string,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string,
    bearerToken?: string
  ) => Batch;
  health: () => Promise<boolean>;
  search: (
    collection: string,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string,
    bearerToken?: string
  ) => Search;
  tenants: (collection: string, bearerToken?: string) => Tenants;
}

export const grpcClient = (config: GrpcConnectionParams & { grpcMaxMessageLength: number }): GrpcClient => {
  const channelOptions: ChannelOptions = {
    'grpc.max_send_message_length': config.grpcMaxMessageLength,
    'grpc.max_receive_message_length': config.grpcMaxMessageLength,
  };
  if (config.grpcProxyUrl) {
    // grpc.http_proxy is not used by grpc.js under-the-hood
    // only uses the env var and whether http_proxy is enabled
    process.env.grpc_proxy = config.grpcProxyUrl;
    channelOptions['grpc.enabled_http_proxy'] = true;
  }
  const channel = createChannel(
    config.grpcAddress,
    config.grpcSecure ? ChannelCredentials.createSsl() : ChannelCredentials.createInsecure(),
    channelOptions
  );
  const client = clientFactory.create(WeaviateDefinition, channel);
  const health = clientFactory.create(HealthDefinition, channel);
  return {
    close: () => channel.close(),
    batch: (collection: string, consistencyLevel?: ConsistencyLevel, tenant?: string, bearerToken?: string) =>
      Batcher.use(
        client,
        collection,
        new Metadata(bearerToken ? { ...config.headers, authorization: bearerToken } : config.headers),
        config.timeout?.insert || 90,
        consistencyLevel,
        tenant
      ),
    health: () => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), (config.timeout?.init || 2) * 1000);
      return health
        .check({ service: '/grpc.health.v1.Health/Check' }, { signal: controller.signal })
        .then((res) => res.status === HealthCheckResponse_ServingStatus.SERVING)
        .catch((err) => {
          if (isAbortError(err)) {
            throw new WeaviateGRPCUnavailableError(config.grpcAddress);
          }
          throw err;
        })
        .finally(() => clearTimeout(timeoutId));
    },
    search: (
      collection: string,
      consistencyLevel?: ConsistencyLevel,
      tenant?: string,
      bearerToken?: string
    ) =>
      Searcher.use(
        client,
        collection,
        new Metadata(bearerToken ? { ...config.headers, authorization: bearerToken } : config.headers),
        config.timeout?.query || 30,
        consistencyLevel,
        tenant
      ),
    tenants: (collection: string, bearerToken?: string) =>
      TenantsManager.use(
        client,
        collection,
        new Metadata(bearerToken ? { ...config.headers, authorization: bearerToken } : config.headers),
        config.timeout?.query || 30
      ),
  };
};



---
File: /src/connection/helpers.test.ts
---

import weaviate from '../index.js';
import { connectToWeaviateCloud } from './helpers.js';

const WCD_URL = 'https://piblpmmdsiknacjnm1ltla.c1.europe-west3.gcp.weaviate.cloud';
const WCD_KEY = 'cy4ua772mBlMdfw3YnclqAWzFhQt0RLIN0sl';

describe('Testing of the connection helper methods', () => {
  it('should connect to a WCS cluster', () => {
    return weaviate
      .connectToWeaviateCloud(WCD_URL, {
        authCredentials: new weaviate.ApiKey(WCD_KEY),
      })
      .then((client) => client.getMeta())
      .then((res: any) => {
        expect(res.version).toBeDefined();
      })
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('should connect to a local cluster', () => {
    return weaviate
      .connectToLocal()
      .then((client) => client.getMeta())
      .then((res: any) => {
        expect(res.version).toBeDefined();
      })
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  describe('adds Weaviate Embedding Service headers', () => {
    it('to empty headers', async () => {
      const clientMakerMock = jest.fn().mockResolvedValue(undefined);

      await connectToWeaviateCloud(WCD_URL, clientMakerMock, {
        authCredentials: new weaviate.ApiKey(WCD_KEY),
      });

      expect(clientMakerMock.mock.calls[0][0].headers).toEqual({
        'X-Weaviate-Api-Key': WCD_KEY,
        'X-Weaviate-Cluster-Url': WCD_URL,
      });
    });

    it('to existing headers', async () => {
      const clientMakerMock = jest.fn().mockResolvedValue(undefined);

      await connectToWeaviateCloud(WCD_URL, clientMakerMock, {
        authCredentials: new weaviate.ApiKey(WCD_KEY),
        headers: { existingHeader: 'existingValue' },
      });

      expect(clientMakerMock.mock.calls[0][0].headers).toEqual({
        existingHeader: 'existingValue',
        'X-Weaviate-Api-Key': WCD_KEY,
        'X-Weaviate-Cluster-Url': WCD_URL,
      });
    });
  });

  describe('does not add Weaviate Embedding Service headers when not using API key', () => {
    it('to empty headers', async () => {
      const clientMakerMock = jest.fn().mockResolvedValue(undefined);

      await connectToWeaviateCloud(WCD_URL, clientMakerMock, {
        authCredentials: new weaviate.AuthUserPasswordCredentials({ username: 'test' }),
      });

      expect(clientMakerMock.mock.calls[0][0].headers).toBe(undefined);
    });

    it('to existing headers', async () => {
      const clientMakerMock = jest.fn().mockResolvedValue(undefined);

      await connectToWeaviateCloud(WCD_URL, clientMakerMock, {
        authCredentials: new weaviate.AuthUserPasswordCredentials({ username: 'test' }),
        headers: { existingHeader: 'existingValue' },
      });

      expect(clientMakerMock.mock.calls[0][0].headers).toEqual({ existingHeader: 'existingValue' });
    });
  });
});



---
File: /src/connection/helpers.ts
---

import { WeaviateStartUpError } from '../errors.js';
import { ClientParams, WeaviateClient } from '../index.js';
import { AuthCredentials, isApiKey, mapApiKey } from './auth.js';
import { ProxiesParams, TimeoutParams } from './http.js';

/** The options available to the `weaviate.connectToWeaviateCloud` method. */
export type ConnectToWeaviateCloudOptions = {
  /** The authentication credentials to use when connecting to Weaviate, e.g. API key */
  authCredentials?: AuthCredentials;
  /** Additional headers to include in the request */
  headers?: Record<string, string>;
  /** The timeouts to use when making requests to Weaviate */
  timeout?: TimeoutParams;
  /** Whether to skip the initialization checks */
  skipInitChecks?: boolean;
};

/** @deprecated Use `ConnectToWeaviateCloudOptions` instead. */
export type ConnectToWCDOptions = ConnectToWeaviateCloudOptions;

/** @deprecated Use `ConnectToWeaviateCloudOptions` instead. */
export type ConnectToWCSOptions = ConnectToWeaviateCloudOptions;

export type ConnectToLocalOptions = {
  /** The host where Weaviate is served. Assumes that the HTTP/1.1 and HTTP/2 servers are served on the same host */
  host?: string;
  /** The port of the HTTP/1.1 server */
  port?: number;
  /** The port of the HTTP/2 server */
  grpcPort?: number;
  /** The authentication credentials to use when connecting to Weaviate, e.g. API key */
  authCredentials?: AuthCredentials;
  /** Additional headers to include in the request */
  headers?: Record<string, string>;
  /** The timeouts to use when making requests to Weaviate */
  timeout?: TimeoutParams;
  /** Whether to skip the initialization checks */
  skipInitChecks?: boolean;
};

export type ConnectToCustomOptions = {
  /** The hostname of the HTTP/1.1 server */
  httpHost?: string;
  /** An additional path of the HTTP/1.1 server, e.g. `http://proxy.net/weaviate` */
  httpPath?: string;
  /** The port of the HTTP/1.1 server */
  httpPort?: number;
  /** Whether to use a secure connection to the HTTP/1.1 server */
  httpSecure?: boolean;
  /** The hostname of the HTTP/2 server */
  grpcHost?: string;
  /** The port of the HTTP/2 server */
  grpcPort?: number;
  /** Whether to use a secure connection to the HTTP/2 server */
  grpcSecure?: boolean;
  /** The authentication credentials to use when connecting to Weaviate, e.g. API key */
  authCredentials?: AuthCredentials;
  /** Additional headers to include in the request */
  headers?: Record<string, string>;
  /** The proxy configuration to use */
  proxies?: ProxiesParams;
  /** The timeouts to use when making requests to Weaviate */
  timeout?: TimeoutParams;
  /** Whether to skip the initialization checks */
  skipInitChecks?: boolean;
};

export function connectToWeaviateCloud(
  clusterURL: string,
  clientMaker: (params: ClientParams) => Promise<WeaviateClient>,
  options?: ConnectToWeaviateCloudOptions
): Promise<WeaviateClient> {
  // check if the URL is set
  if (!clusterURL) throw new Error('Missing `clusterURL` parameter');

  if (!clusterURL.startsWith('http')) {
    clusterURL = `https://${clusterURL}`;
  }
  const url = new URL(clusterURL);

  let grpcHost: string;
  if (url.hostname.endsWith('.weaviate.network')) {
    const [ident, ...rest] = url.hostname.split('.');
    grpcHost = `${ident}.grpc.${rest.join('.')}`;
  } else {
    grpcHost = `grpc-${url.hostname}`;
  }

  return clientMaker({
    connectionParams: {
      http: {
        secure: true,
        host: url.hostname,
        port: 443,
      },
      grpc: {
        secure: true,
        host: grpcHost,
        port: 443,
      },
    },
    auth: options?.authCredentials,
    headers: addWeaviateEmbeddingServiceHeaders(clusterURL, options),
  }).catch((e) => {
    throw new WeaviateStartUpError(`Weaviate failed to startup with message: ${e.message}`);
  });
}

export function connectToLocal(
  clientMaker: (params: ClientParams) => Promise<WeaviateClient>,
  options?: ConnectToLocalOptions
): Promise<WeaviateClient> {
  return clientMaker({
    connectionParams: {
      http: {
        secure: false,
        host: options?.host || 'localhost',
        port: options?.port || 8080,
      },
      grpc: {
        secure: false,
        host: options?.host || 'localhost',
        port: options?.grpcPort || 50051,
      },
    },
    auth: options?.authCredentials,
    headers: options?.headers,
  }).catch((e) => {
    throw new WeaviateStartUpError(`Weaviate failed to startup with message: ${e.message}`);
  });
}

export function connectToCustom(
  clientMaker: (params: ClientParams) => Promise<WeaviateClient>,
  options?: ConnectToCustomOptions
): Promise<WeaviateClient> {
  return clientMaker({
    connectionParams: {
      http: {
        secure: options?.httpSecure || false,
        host: options?.httpHost || 'localhost',
        path: options?.httpPath || '',
        port: options?.httpPort || 8080,
      },
      grpc: {
        secure: options?.grpcSecure || false,
        host: options?.grpcHost || 'localhost',
        port: options?.grpcPort || 50051,
      },
    },
    auth: options?.authCredentials,
    headers: options?.headers,
    proxies: options?.proxies,
  }).catch((e) => {
    throw new WeaviateStartUpError(`Weaviate failed to startup with message: ${e.message}`);
  });
}

function addWeaviateEmbeddingServiceHeaders(clusterURL: string, options?: ConnectToWeaviateCloudOptions) {
  if (!isApiKey(options?.authCredentials)) {
    return options?.headers;
  }

  return {
    ...options.headers,
    'X-Weaviate-Api-Key': mapApiKey(options.authCredentials).apiKey,
    'X-Weaviate-Cluster-Url': clusterURL,
  };
}



---
File: /src/connection/http.ts
---

import { isAbortError } from 'abort-controller-x';
import { Agent } from 'http';

import OpenidConfigurationGetter from '../misc/openidConfigurationGetter.js';

import {
  WeaviateInvalidInputError,
  WeaviateRequestTimeoutError,
  WeaviateUnexpectedStatusCodeError,
} from '../errors.js';
import {
  ApiKey,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
  AuthUserPasswordCredentials,
  OidcAuthenticator,
} from './auth.js';

/**
 * You can only specify the gRPC proxy URL at this point in time. This is because ProxiesParams should be used to define tunnelling proxies
 * and Weaviate does not support tunnelling proxies over HTTP/1.1 at this time.
 *
 * To use a forwarding proxy you should instead specify its URL as if it were the Weaviate instance itself.
 */
export type ProxiesParams = {
  // http?: string;
  // https?: string;
  grpc?: string;
};

export type TimeoutParams = {
  /** Define the configured timeout when querying data from Weaviate */
  query?: number;
  /** Define the configured timeout when mutating data to Weaviate */
  insert?: number;
  /** Define the configured timeout when initially connecting to Weaviate */
  init?: number;
};

export type InternalConnectionParams = {
  authClientSecret?: AuthClientCredentials | AuthAccessTokenCredentials | AuthUserPasswordCredentials;
  apiKey?: ApiKey;
  host: string;
  scheme?: string;
  headers?: HeadersInit;
  // http1Agent?: Agent;
  grpcProxyUrl?: string;
  agent?: Agent;
  timeout?: TimeoutParams;
  skipInitChecks?: boolean;
};

export default class ConnectionREST {
  private apiKey?: string;
  protected authEnabled: boolean;
  public readonly host: string;
  public readonly http: HttpClient;
  public oidcAuth?: OidcAuthenticator;

  constructor(params: InternalConnectionParams) {
    params = this.sanitizeParams(params);
    this.host = params.host;
    this.http = httpClient(params);
    this.authEnabled = this.parseAuthParams(params);
  }

  private parseAuthParams(params: InternalConnectionParams): boolean {
    if (params.authClientSecret && params.apiKey) {
      throw new WeaviateInvalidInputError(
        'must provide one of authClientSecret (OIDC) or apiKey, cannot provide both'
      );
    }
    if (params.authClientSecret) {
      this.oidcAuth = new OidcAuthenticator(this.http, params.authClientSecret);
      return true;
    }
    if (params.apiKey) {
      this.apiKey = params.apiKey?.apiKey;
      return true;
    }
    return false;
  }

  private sanitizeParams(params: InternalConnectionParams) {
    // Remove trailing slashes from the host
    while (params.host.endsWith('/')) {
      params.host = params.host.slice(0, -1);
    }

    const protocolPattern = /^(https?|ftp|file)(?::\/\/)/;
    const extractedSchemeMatch = params.host.match(protocolPattern);

    // Check for the existence of scheme in params
    if (params.scheme) {
      // If the host contains a scheme different than provided scheme, replace it and throw a warning
      if (extractedSchemeMatch && extractedSchemeMatch[1] !== `${params.scheme}`) {
        throw new WeaviateInvalidInputError(
          `The host contains a different protocol than specified in the scheme (scheme: ${params.scheme} != host: ${extractedSchemeMatch[1]})`
        );
      } else if (!extractedSchemeMatch) {
        // If no scheme in the host, simply prefix with the provided scheme
        params.host = `${params.scheme}://${params.host}`;
      }
      // If there's no scheme in params, ensure the host starts with a recognized protocol
    } else if (!extractedSchemeMatch) {
      throw new WeaviateInvalidInputError(
        'The host must start with a recognized protocol (e.g., http or https) if no scheme is provided.'
      );
    }

    return params;
  }

  postReturn = <B, T>(path: string, payload: B): Promise<T> => {
    if (this.authEnabled) {
      return this.login().then((token) =>
        this.http.post<B, T>(path, payload, true, token).then((res) => res as T)
      );
    }
    return this.http.post<B, T>(path, payload, true, '').then((res) => res as T);
  };

  postEmpty = <B>(path: string, payload: B): Promise<void> => {
    if (this.authEnabled) {
      return this.login().then((token) => this.http.post<B, void>(path, payload, false, token));
    }
    return this.http.post<B, void>(path, payload, false, '');
  };

  put = (path: string, payload: any, expectReturnContent = true) => {
    if (this.authEnabled) {
      return this.login().then((token) => this.http.put(path, payload, expectReturnContent, token));
    }
    return this.http.put(path, payload, expectReturnContent);
  };

  patch = (path: string, payload: any) => {
    if (this.authEnabled) {
      return this.login().then((token) => this.http.patch(path, payload, token));
    }
    return this.http.patch(path, payload);
  };

  delete = (path: string, payload: any, expectReturnContent = false) => {
    if (this.authEnabled) {
      return this.login().then((token) => this.http.delete(path, payload, expectReturnContent, token));
    }
    return this.http.delete(path, payload, expectReturnContent);
  };

  head = (path: string, payload: any) => {
    if (this.authEnabled) {
      return this.login().then((token) => this.http.head(path, payload, token));
    }
    return this.http.head(path, payload);
  };

  get = (path: string, expectReturnContent = true) => {
    if (this.authEnabled) {
      return this.login().then((token) => this.http.get(path, expectReturnContent, token));
    }
    return this.http.get(path, expectReturnContent);
  };

  login = async () => {
    if (this.apiKey) {
      return this.apiKey;
    }

    if (!this.oidcAuth) {
      return '';
    }

    const localConfig = await new OpenidConfigurationGetter(this.http).do();

    if (localConfig === undefined) {
      console.warn('client is configured for authentication, but server is not');
      return '';
    }

    if (Date.now() >= this.oidcAuth.getExpiresAt()) {
      await this.oidcAuth.refresh(localConfig);
    }
    return this.oidcAuth.getAccessToken();
  };
}

export * from './auth.js';

export interface HttpClient {
  close: () => void;
  patch: (path: string, payload: any, bearerToken?: string) => any;
  head: (path: string, payload: any, bearerToken?: string) => any;
  post: <B, T>(
    path: string,
    payload: B,
    expectReturnContent: boolean,
    bearerToken: string
  ) => Promise<T | undefined>;
  get: (path: string, expectReturnContent?: boolean, bearerToken?: string) => any;
  externalPost: (externalUrl: string, body: any, contentType: any) => any;
  getRaw: (path: string, bearerToken?: string) => any;
  delete: (path: string, payload: any, expectReturnContent?: boolean, bearerToken?: string) => any;
  put: (path: string, payload: any, expectReturnContent?: boolean, bearerToken?: string) => any;
  externalGet: (externalUrl: string) => Promise<any>;
}

const fetchWithTimeout = (
  input: RequestInfo | URL,
  timeout: number,
  init?: RequestInit | undefined
): Promise<Response> => {
  const controller = new AbortController();
  // Set a timeout to abort the request
  const timeoutId = setTimeout(() => controller.abort(), timeout * 1000);
  return fetch(input, { ...init, signal: controller.signal })
    .catch((error) => {
      if (isAbortError(error)) {
        throw new WeaviateRequestTimeoutError(`Request timed out after ${timeout}ms`);
      }
      throw error; // For other errors, rethrow them
    })
    .finally(() => clearTimeout(timeoutId));
};

export const httpClient = (config: InternalConnectionParams): HttpClient => {
  const version = '/v1';
  const baseUri = `${config.host}${version}`;
  const url = makeUrl(baseUri);

  return {
    close: () => config.agent?.destroy(),
    post: <B, T>(
      path: string,
      payload: B,
      expectReturnContent: boolean,
      bearerToken: string
    ): Promise<T | undefined> => {
      const request = {
        method: 'POST',
        headers: {
          ...config.headers,
          'content-type': 'application/json',
        },
        body: JSON.stringify(payload),
        agent: config.agent,
      };
      addAuthHeaderIfNeeded(request, bearerToken);
      return fetchWithTimeout(url(path), config.timeout?.insert || 90, request).then(
        checkStatus<T>(expectReturnContent)
      );
    },
    put: <B, T>(
      path: string,
      payload: B,
      expectReturnContent = true,
      bearerToken = ''
    ): Promise<T | undefined> => {
      const request = {
        method: 'PUT',
        headers: {
          ...config.headers,
          'content-type': 'application/json',
        },
        body: JSON.stringify(payload),
        agent: config.agent,
      };
      addAuthHeaderIfNeeded(request, bearerToken);
      return fetchWithTimeout(url(path), config.timeout?.insert || 90, request).then(
        checkStatus<T>(expectReturnContent)
      );
    },
    patch: <B, T>(path: string, payload: B, bearerToken = ''): Promise<T | undefined> => {
      const request = {
        method: 'PATCH',
        headers: {
          ...config.headers,
          'content-type': 'application/json',
        },
        body: JSON.stringify(payload),
        agent: config.agent,
      };
      addAuthHeaderIfNeeded(request, bearerToken);
      return fetchWithTimeout(url(path), config.timeout?.insert || 90, request).then(checkStatus<T>(false));
    },
    delete: <B>(path: string, payload: B | null = null, expectReturnContent = false, bearerToken = '') => {
      const request = {
        method: 'DELETE',
        headers: {
          ...config.headers,
          'content-type': 'application/json',
        },
        body: payload ? JSON.stringify(payload) : undefined,
        agent: config.agent,
      };
      addAuthHeaderIfNeeded(request, bearerToken);
      return fetchWithTimeout(url(path), config.timeout?.insert || 90, request).then(
        checkStatus<undefined>(expectReturnContent)
      );
    },
    head: <B>(path: string, payload: B | null = null, bearerToken = '') => {
      const request = {
        method: 'HEAD',
        headers: {
          ...config.headers,
          'content-type': 'application/json',
        },
        body: payload ? JSON.stringify(payload) : undefined,
        agent: config.agent,
      };
      addAuthHeaderIfNeeded(request, bearerToken);
      return fetchWithTimeout(url(path), config.timeout?.query || 30, request).then(
        handleHeadResponse<undefined>(false)
      );
    },
    get: <T>(path: string, expectReturnContent = true, bearerToken = ''): Promise<T | undefined> => {
      const request = {
        method: 'GET',
        headers: {
          ...config.headers,
        },
        agent: config.agent,
      };
      addAuthHeaderIfNeeded(request, bearerToken);
      return fetchWithTimeout(url(path), config.timeout?.query || 30, request).then(
        checkStatus<T>(expectReturnContent)
      );
    },
    getRaw: (path: string, bearerToken = '') => {
      // getRaw does not handle the status leaving this to the caller
      const request = {
        method: 'GET',
        headers: {
          ...config.headers,
        },
        agent: config.agent,
      };
      addAuthHeaderIfNeeded(request, bearerToken);
      return fetchWithTimeout(url(path), config.timeout?.query || 30, request);
    },
    externalGet: (externalUrl: string) => {
      return fetch(externalUrl, {
        method: 'GET',
        headers: {
          ...config.headers,
        },
      }).then(checkStatus<any>(true));
    },
    externalPost: (externalUrl: string, body: any, contentType: any) => {
      if (contentType == undefined || contentType == '') {
        contentType = 'application/json';
      }
      const request = {
        body: undefined,
        method: 'POST',
        headers: {
          ...config.headers,
          'content-type': contentType,
        },
      };
      if (body != null) {
        request.body = body;
      }
      return fetch(externalUrl, request).then(checkStatus<any>(true));
    },
  };
};

const makeUrl = (basePath: string) => (path: string) => basePath + path;

const checkStatus =
  <T>(expectResponseBody: boolean) =>
  (res: Response) => {
    if (res.status >= 400) {
      return res.text().then((errText: string) => {
        let err: string;
        try {
          // in case of invalid json response (like empty string)
          err = JSON.stringify(JSON.parse(errText));
        } catch (e) {
          err = errText;
        }
        return Promise.reject(new WeaviateUnexpectedStatusCodeError(res.status, err));
      });
    }
    if (expectResponseBody) {
      return res.json() as Promise<T>;
    }
    return Promise.resolve(undefined);
  };

const handleHeadResponse =
  <T>(expectResponseBody: boolean) =>
  (res: Response) => {
    if (res.status == 200 || res.status == 204 || res.status == 404) {
      return Promise.resolve(res.status == 200 || res.status == 204);
    }
    return checkStatus<T>(expectResponseBody)(res);
  };

function addAuthHeaderIfNeeded(request: any, bearerToken: string) {
  if (bearerToken !== '') {
    request.headers.Authorization = `Bearer ${bearerToken}`;
  }
}



---
File: /src/connection/index.ts
---

import ConnectionGQL from './gql.js';
import ConnectionGRPC from './grpc.js';
import ConnectionREST from './http.js';

export default ConnectionGQL;

export type {
  ConnectToCustomOptions,
  ConnectToLocalOptions,
  ConnectToWCDOptions,
  ConnectToWCSOptions,
  ConnectToWeaviateCloudOptions,
} from './helpers.js';
export type { InternalConnectionParams } from './http.js';
export { ConnectionGQL, ConnectionGRPC, ConnectionREST };



---
File: /src/connection/integration.test.ts
---

import { StartedWeaviateContainer, WeaviateContainer } from '@testcontainers/weaviate';
import weaviate from '..';
import { WeaviateStartUpError } from '../errors';
import { Meta } from '../openapi/types';
import { DbVersion } from '../utils/dbVersion';

describe('Integration testing of the ConnectionGRPC class', () => {
  let container: StartedWeaviateContainer;

  const getVersion = () =>
    fetch(`http://${container.getHost()}:${container.getMappedPort(8080)}/v1/meta`)
      .then((res) => res.json() as Promise<Meta>)
      .then((meta) => DbVersion.fromString(meta.version!));

  beforeAll(async () => {
    container = await new WeaviateContainer(`semitechnologies/weaviate:${process.env.WEAVIATE_VERSION}`)
      .withExposedPorts(8080, 50051)
      .withEnvironment({
        GRPC_MAX_MESSAGE_SIZE: '1',
      })
      .start();
    expect(container).toBeDefined();
  });
  afterAll(async () => {
    await container.stop();
  });
  it('should fail to startup due to message-size limit', async () => {
    const dbVersion = await getVersion();
    try {
      await weaviate.connectToLocal({
        host: container.getHost(),
        port: container.getMappedPort(8080),
        grpcPort: container.getMappedPort(50051),
      });
      expect(dbVersion.isLowerThan(1, 27, 1)).toBe(true);
    } catch (err) {
      expect(err).toBeInstanceOf(WeaviateStartUpError);
      expect((err as WeaviateStartUpError).message).toContain(
        'RESOURCE_EXHAUSTED: Attempted to send message with a size larger than 1'
      );
      expect(dbVersion.isAtLeast(1, 27, 1)).toBe(true);
    }
  });
});



---
File: /src/connection/journey.test.ts
---

import {
  ApiKey,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
  AuthUserPasswordCredentials,
} from './auth.js';
import Connection from './index.js';

import { WeaviateStartUpError } from '../errors.js';
import weaviate from '../index.js';

describe('connection', () => {
  it('makes a logged-in request when client host param has trailing slashes', async () => {
    if (process.env.WCS_DUMMY_CI_PW == undefined || process.env.WCS_DUMMY_CI_PW == '') {
      console.warn('Skipping because `WCS_DUMMY_CI_PW` is not set');
      return Promise.resolve();
    }

    const client = await weaviate.connectToLocal({
      port: 8085,
      authCredentials: new AuthUserPasswordCredentials({
        username: 'ms_2d0e007e7136de11d5f29fce7a53dae219a51458@existiert.net',
        password: process.env.WCS_DUMMY_CI_PW,
        silentRefresh: false,
      }),
    });

    return client
      .getMeta()
      .then((res) => {
        expect(res.version).toBeDefined();
      })
      .catch((e) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  // it('makes an Azure logged-in request with client credentials', async () => {
  //   if (process.env.AZURE_CLIENT_SECRET == undefined || process.env.AZURE_CLIENT_SECRET == '') {
  //     console.warn('Skipping because `AZURE_CLIENT_SECRET` is not set');
  //     return Promise.resolve();
  //   }

  //   const client = await weaviate.connectToLocal({
  //     port: 8081,
  //     authCredentials: new AuthClientCredentials({
  //       clientSecret: process.env.AZURE_CLIENT_SECRET,
  //       silentRefresh: false,
  //     }),
  //   });

  //   return client
  //     .getMeta()
  //     .then((res) => {
  //       expect(res.version).toBeDefined();
  //     })
  //     .catch((e) => {
  //       throw new Error('it should not have errord: ' + e);
  //     });
  // });

  it('makes an Okta logged-in request with client credentials', async () => {
    if (process.env.OKTA_CLIENT_SECRET == undefined || process.env.OKTA_CLIENT_SECRET == '') {
      console.warn('Skipping because `OKTA_CLIENT_SECRET` is not set');
      return Promise.resolve();
    }

    const client = await weaviate.connectToLocal({
      port: 8082,
      authCredentials: new AuthClientCredentials({
        clientSecret: process.env.OKTA_CLIENT_SECRET,
        scopes: ['some_scope'],
        silentRefresh: false,
      }),
    });

    return client
      .getMeta()
      .then((res) => {
        expect(res.version).toBeDefined();
      })
      .catch((e) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('makes an Okta logged-in request with username/password', async () => {
    if (process.env.OKTA_DUMMY_CI_PW == undefined || process.env.OKTA_DUMMY_CI_PW == '') {
      console.warn('Skipping because `OKTA_DUMMY_CI_PW` is not set');
      return Promise.resolve();
    }

    const client = await weaviate.connectToLocal({
      port: 8083,
      authCredentials: new AuthUserPasswordCredentials({
        username: 'test@test.de',
        password: process.env.OKTA_DUMMY_CI_PW,
        silentRefresh: false,
      }),
    });

    return client
      .getMeta()
      .then((res: any) => {
        expect(res.version).toBeDefined();
      })
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('makes a WCS logged-in request with username/password', async () => {
    if (process.env.WCS_DUMMY_CI_PW == undefined || process.env.WCS_DUMMY_CI_PW == '') {
      console.warn('Skipping because `WCS_DUMMY_CI_PW` is not set');
      return Promise.resolve();
    }

    const client = await weaviate.connectToLocal({
      port: 8085,
      authCredentials: new AuthUserPasswordCredentials({
        username: 'ms_2d0e007e7136de11d5f29fce7a53dae219a51458@existiert.net',
        password: process.env.WCS_DUMMY_CI_PW,
        silentRefresh: false,
      }),
    });

    return client
      .getMeta()
      .then((res) => {
        expect(res.version).toBeDefined();
      })
      .catch((e) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('makes a logged-in request with API key', async () => {
    const client = await weaviate.connectToLocal({
      port: 8085,
      authCredentials: new ApiKey('my-secret-key'),
    });

    return client
      .getMeta()
      .then((res) => {
        expect(res.version).toBeDefined();
      })
      .catch((e) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('makes a logged-in request with API key as string', async () => {
    const client = await weaviate.connectToLocal({
      port: 8085,
      authCredentials: 'my-secret-key',
    });

    return client
      .getMeta()
      .then((res) => {
        expect(res.version).toBeDefined();
      })
      .catch((e) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('makes a logged-in request with access token', async () => {
    if (process.env.WCS_DUMMY_CI_PW == undefined || process.env.WCS_DUMMY_CI_PW == '') {
      console.warn('Skipping because `WCS_DUMMY_CI_PW` is not set');
      return;
    }

    const dummy = new Connection({
      scheme: 'http',
      host: 'localhost:8085',
      authClientSecret: new AuthUserPasswordCredentials({
        username: 'ms_2d0e007e7136de11d5f29fce7a53dae219a51458@existiert.net',
        password: process.env.WCS_DUMMY_CI_PW,
        silentRefresh: false,
      }),
    });
    // obtain access token with user/pass so we can
    // use it to test AuthAccessTokenCredentials
    await dummy.login();

    const accessToken = (dummy as any).oidcAuth?.accessToken || '';
    const client = await weaviate.connectToLocal({
      port: 8085,
      authCredentials: new AuthAccessTokenCredentials({
        accessToken: accessToken,
        expiresIn: 900,
      }),
    });

    return client
      .getMeta()
      .then((res) => {
        expect(res.version).toBeDefined();
        client.oidcAuth?.stopTokenRefresh();
      })
      .catch((e) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('uses refresh token to fetch new access token', async () => {
    if (process.env.WCS_DUMMY_CI_PW == undefined || process.env.WCS_DUMMY_CI_PW == '') {
      console.warn('Skipping because `WCS_DUMMY_CI_PW` is not set');
      return;
    }

    const dummy = new Connection({
      scheme: 'http',
      host: 'localhost:8085',
      authClientSecret: new AuthUserPasswordCredentials({
        username: 'ms_2d0e007e7136de11d5f29fce7a53dae219a51458@existiert.net',
        password: process.env.WCS_DUMMY_CI_PW,
        silentRefresh: false,
      }),
    });
    // obtain access token with user/pass so we can
    // use it to test AuthAccessTokenCredentials
    await dummy.login();

    const accessToken = (dummy as any).oidcAuth?.accessToken || '';
    const conn = new Connection({
      scheme: 'http',
      host: 'localhost:8085',
      authClientSecret: new AuthAccessTokenCredentials({
        accessToken: accessToken,
        expiresIn: 1,
        refreshToken: (dummy as any).oidcAuth?.refreshToken,
      }),
    });
    // force the use of refreshToken
    (conn as any).oidcAuth?.resetExpiresAt();

    return conn
      .login()
      .then((resp) => {
        expect(resp).toBeDefined();
        expect(resp != '').toBeTruthy();
        conn.oidcAuth?.stopTokenRefresh();
      })
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('fails to access auth-enabled server without client auth', async () => {
    expect.assertions(3);
    try {
      await weaviate.connectToLocal({
        port: 8085,
      });
      throw new Error('Promise should have been rejected');
    } catch (error: any) {
      expect(error).toBeInstanceOf(WeaviateStartUpError);
      expect(error.message).toContain('401');
      expect(error.message).toContain('anonymous access not enabled');
    }
  });

  it('warns when client auth is configured, but server auth is not', async () => {
    const logSpy = jest.spyOn(console, 'warn');

    const client = await weaviate.connectToLocal({
      authCredentials: new AuthUserPasswordCredentials({
        username: 'some-user',
        password: 'passwd',
      }),
    });

    await client
      .getMeta()
      .then((res) => {
        expect(res.version).toBeDefined();
      })
      .catch((e) => {
        throw new Error('it should not have errord: ' + e);
      });

    expect(logSpy).toHaveBeenCalledWith('client is configured for authentication, but server is not');
  });

  it('warns when client access token expires, no refresh token provided', async () => {
    const logSpy = jest.spyOn(console, 'warn');

    const conn = new Connection({
      scheme: 'http',
      host: 'localhost:8085',
      authClientSecret: new AuthAccessTokenCredentials({
        accessToken: 'abcd1234',
        expiresIn: 1,
      }),
    });
    // force the use of refreshToken
    (conn as any).oidcAuth?.resetExpiresAt();

    await conn
      .login()
      .then((resp) => {
        expect(resp).toBeDefined();
        expect(resp).toEqual('abcd1234');
      })
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });

    expect(logSpy).toHaveBeenCalledWith(
      'AuthAccessTokenCredentials not provided with refreshToken, cannot refresh'
    );
  });

  it('fails to create client with both OIDC creds and API key set', () => {
    expect(() => {
      // eslint-disable-next-line no-new
      new Connection({
        scheme: 'http',
        host: 'localhost:8085',
        authClientSecret: new AuthAccessTokenCredentials({
          accessToken: 'abcd1234',
          expiresIn: 1,
        }),
        apiKey: new ApiKey('some-key'),
      });
    }).toThrow('must provide one of authClientSecret (OIDC) or apiKey, cannot provide both');
  });
});



---
File: /src/connection/proxy.test.ts
---

import weaviate from '../index.js';

describe('Testing of the client connecting to a proxied Weaviate instance', () => {
  // Skip because Envoy Proxy in CI is too flaky with strange error:
  //  ClientError: /grpc.health.v1.Health/Check INTERNAL: Received RST_STREAM with code 2 triggered by internal client error: Protocol error
  it.skip('should connect to a local instance using simultaneous http and grpc proxies', async () => {
    const client = await weaviate.connectToCustom({
      httpHost: 'localhost',
      httpPath: '/http',
      httpPort: 10000,
      httpSecure: false,
      grpcHost: 'weaviate-proxy',
      grpcPort: 8021,
      proxies: {
        grpc: 'http://localhost:10001',
      },
    });
    expect(client).toBeDefined();
    return client.collections
      .delete('Test')
      .then(() =>
        client.collections.create({
          name: 'Test',
        })
      )
      .then(async (collection) => {
        await collection.data.insert();
        return collection;
      })
      .then((collection) => collection.query.fetchObjects())
      .then((res) => expect(res.objects).toHaveLength(1));
  });
});



---
File: /src/connection/unit.test.ts
---

import { testServer } from '../../test/server.js';
import {
  ApiKey,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
  AuthUserPasswordCredentials,
} from './auth.js';
import Connection from './index.js';

describe('mock server auth tests', () => {
  const server = testServer();
  describe('OIDC auth flows', () => {
    it('should login with client_credentials grant', async () => {
      const conn = new Connection({
        scheme: 'http',
        host: 'localhost:' + server.port,
        authClientSecret: new AuthClientCredentials({
          clientSecret: 'supersecret',
          scopes: ['some_scope'],
          silentRefresh: false,
        }),
      });

      await conn
        .login()
        .then((token) => {
          expect(token).toEqual('access_token_000');
          expect((conn as any).oidcAuth?.refreshToken).toEqual('refresh_token_000');
          expect((conn as any).oidcAuth?.expiresAt).toBeGreaterThan(Date.now());
        })
        .catch((e) => {
          throw new Error('it should not have failed: ' + e);
        });

      const request = server.lastRequest();

      expect(request.body).toEqual({
        client_id: 'client123',
        client_secret: 'supersecret',
        grant_type: 'client_credentials',
        scope: 'some_scope',
      });
    });

    it('should login with password grant', async () => {
      const conn = new Connection({
        scheme: 'http',
        host: 'localhost:' + server.port,
        authClientSecret: new AuthUserPasswordCredentials({
          username: 'user123',
          password: 'secure_password',
          scopes: ['custom_scope'],
        }),
      });

      await conn
        .login()
        .then((token) => {
          expect(token).toEqual('access_token_000');
          expect((conn as any).oidcAuth?.refreshToken).toEqual('refresh_token_000');
          expect((conn as any).oidcAuth?.expiresAt).toBeGreaterThan(Date.now());
          conn.oidcAuth?.stopTokenRefresh();
        })
        .catch((e) => {
          throw new Error('it should not have failed: ' + e);
        });

      const request = server.lastRequest();

      expect(request.body).toEqual({
        username: 'user123',
        password: 'secure_password',
        grant_type: 'password',
        client_id: 'client123',
        scope: 'custom_scope offline_access',
      });
    });

    it('should login with refresh_token grant', async () => {
      const conn = new Connection({
        scheme: 'http',
        host: 'localhost:' + server.port,
        authClientSecret: new AuthAccessTokenCredentials({
          accessToken: 'old-access-token',
          expiresIn: 1,
          refreshToken: 'old-refresh-token',
        }),
      });

      // force the use of refreshToken
      (conn as any).oidcAuth?.resetExpiresAt();

      await conn
        .login()
        .then((token) => {
          expect(token).toEqual('access_token_000');
          expect((conn as any).oidcAuth?.refreshToken).toEqual('refresh_token_000');
          expect((conn as any).oidcAuth?.expiresAt).toBeGreaterThan(Date.now());
          conn.oidcAuth?.stopTokenRefresh();
        })
        .catch((e) => {
          throw new Error('it should not have failed: ' + e);
        });

      const request = server.lastRequest();

      expect(request.body).toEqual({
        client_id: 'client123',
        grant_type: 'refresh_token',
        refresh_token: 'old-refresh-token',
      });
    });
  });

  it('should login with API key', async () => {
    const apiKey = 'abcd123';

    const conn = new Connection({
      scheme: 'http',
      host: 'localhost:' + server.port,
      apiKey: new ApiKey(apiKey),
    });

    await conn.login().then((key) => expect(key).toEqual(apiKey));
  });

  it('should construct the correct url when host contains scheme', () => {
    const apiKey = 'abcd123';

    const conn = new Connection({
      scheme: 'http',
      host: 'http://localhost:' + server.port,
      apiKey: new ApiKey(apiKey),
    });
    const expectedPath = 'http://localhost:' + server.port;

    expect(conn.host).toEqual(expectedPath);
  });

  it('should construct the correct url when scheme specified and host does not contain scheme', () => {
    const apiKey = 'abcd123';

    const conn = new Connection({
      scheme: 'http',
      host: 'localhost:' + server.port,
      apiKey: new ApiKey(apiKey),
    });
    const expectedPath = 'http://localhost:' + server.port;

    expect(conn.host).toEqual(expectedPath);
  });

  it('should construct the correct url when no scheme is specified but host contains scheme', () => {
    const apiKey = 'abcd123';

    const conn = new Connection({
      host: 'http://localhost:' + server.port,
      apiKey: new ApiKey(apiKey),
    });
    const expectedPath = 'http://localhost:' + server.port;

    expect(conn.host).toEqual(expectedPath);
  });

  it('should throw error when host contains different scheme than specified', () => {
    const apiKey = 'abcd123';

    const createConnection = () => {
      return new Connection({
        scheme: 'https',
        host: 'http://localhost:' + server.port,
        apiKey: new ApiKey(apiKey),
      });
    };

    expect(createConnection).toThrow(
      'The host contains a different protocol than specified in the scheme (scheme: https != host: http)'
    );
  });

  it('should throw error when scheme not specified and included in host', () => {
    const apiKey = 'abcd123';

    const createConnection = () => {
      return new Connection({
        host: 'localhost:' + server.port,
        apiKey: new ApiKey(apiKey),
      });
    };

    expect(createConnection).toThrow(
      'The host must start with a recognized protocol (e.g., http or https) if no scheme is provided.'
    );
  });

  it('shuts down the server', () => {
    return server.close();
  });
});



---
File: /src/data/checker.ts
---

import Connection from '../connection/index.js';
import { CommandBase } from '../validation/commandBase.js';
import { ObjectsPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class Checker extends CommandBase {
  private className!: string;
  private consistencyLevel?: ConsistencyLevel;
  private id!: string;
  private tenant?: string;
  private objectsPath: ObjectsPath;

  constructor(client: Connection, objectsPath: ObjectsPath) {
    super(client);
    this.objectsPath = objectsPath;
  }

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  withConsistencyLevel = (consistencyLevel: ConsistencyLevel) => {
    this.consistencyLevel = consistencyLevel;
    return this;
  };

  buildPath = () => {
    return this.objectsPath.buildCheck(this.id, this.className, this.consistencyLevel, this.tenant);
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validateId = () => {
    this.validateIsSet(this.id, 'id', '.withId(id)');
  };

  validate = () => {
    this.validateId();
  };

  do = (): Promise<boolean> => {
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    this.validate();

    return this.buildPath().then((path: string) => this.client.head(path, undefined));
  };
}



---
File: /src/data/creator.ts
---

import Connection from '../connection/index.js';
import { Properties, WeaviateObject } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';
import { ObjectsPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class Creator extends CommandBase {
  private className?: string;
  private consistencyLevel?: ConsistencyLevel;
  private id?: string;
  private objectsPath: ObjectsPath;
  private properties?: Properties;
  private vector?: number[];
  private vectors?: Record<string, number[]>;
  private tenant?: string;

  constructor(client: Connection, objectsPath: ObjectsPath) {
    super(client);
    this.objectsPath = objectsPath;
  }

  withVector = (vector: number[]) => {
    this.vector = vector;
    return this;
  };

  withVectors = (vectors: Record<string, number[]>) => {
    this.vectors = vectors;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withProperties = (properties: Properties) => {
    this.properties = properties;
    return this;
  };

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  payload = (): WeaviateObject => ({
    tenant: this.tenant,
    vector: this.vector,
    properties: this.properties,
    class: this.className,
    id: this.id,
    vectors: this.vectors,
  });

  validate = () => {
    this.validateClassName();
  };

  do = (): Promise<WeaviateObject> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    return this.objectsPath
      .buildCreate(this.consistencyLevel)
      .then((path: string) => this.client.postReturn(path, this.payload()));
  };
}



---
File: /src/data/deleter.ts
---

import Connection from '../connection/index.js';
import { CommandBase } from '../validation/commandBase.js';
import { ObjectsPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class Deleter extends CommandBase {
  private className!: string;
  private consistencyLevel?: ConsistencyLevel;
  private id!: string;
  private tenant?: string;
  private objectsPath: ObjectsPath;

  constructor(client: Connection, objectsPath: ObjectsPath) {
    super(client);
    this.objectsPath = objectsPath;
  }

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validateId = () => {
    this.validateIsSet(this.id, 'id', '.withId(id)');
  };

  validate = () => {
    this.validateId();
  };

  do = () => {
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    this.validate();

    return this.objectsPath
      .buildDelete(this.id, this.className, this.consistencyLevel, this.tenant)
      .then((path: string) => {
        return this.client.delete(path, undefined, false);
      });
  };
}



---
File: /src/data/getter.ts
---

import Connection from '../connection/index.js';
import { WeaviateObjectsList } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { ObjectsPath } from './path.js';

export default class Getter extends CommandBase {
  private additional: string[];
  private after!: string;
  private className?: string;
  private limit?: number;
  private tenant?: string;
  private objectsPath: ObjectsPath;

  constructor(client: Connection, objectsPath: ObjectsPath) {
    super(client);
    this.objectsPath = objectsPath;
    this.additional = [];
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withAfter = (id: string) => {
    this.after = id;
    return this;
  };

  withLimit = (limit: number) => {
    this.limit = limit;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  extendAdditional = (prop: string) => {
    this.additional = [...this.additional, prop];
    return this;
  };

  withAdditional = (additionalFlag: any) => this.extendAdditional(additionalFlag);

  withVector = () => this.extendAdditional('vector');

  validate() {
    // nothing to validate
  }

  do = (): Promise<WeaviateObjectsList> => {
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    return this.objectsPath
      .buildGet(this.className, this.limit, this.additional, this.after, this.tenant)
      .then((path: string) => {
        return this.client.get(path);
      });
  };
}



---
File: /src/data/getterById.ts
---

import Connection from '../connection/index.js';
import { WeaviateObject } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { ObjectsPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class GetterById extends CommandBase {
  private additional: string[];
  private className!: string;
  private id!: string;
  private consistencyLevel?: ConsistencyLevel;
  private nodeName?: string;
  private tenant?: string;
  private objectsPath: ObjectsPath;

  constructor(client: Connection, objectsPath: ObjectsPath) {
    super(client);
    this.objectsPath = objectsPath;
    this.additional = [];
  }

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  extendAdditional = (prop: string) => {
    this.additional = [...this.additional, prop];
    return this;
  };

  withAdditional = (additionalFlag: string) => this.extendAdditional(additionalFlag);

  withVector = () => this.extendAdditional('vector');

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  withNodeName = (nodeName: string) => {
    this.nodeName = nodeName;
    return this;
  };

  validateId = () => {
    if (this.id == undefined || this.id == null || this.id.length == 0) {
      this.addError('id must be set - initialize with getterById(id)');
    }
  };

  validate = () => {
    this.validateId();
  };

  buildPath = (): Promise<string> => {
    return this.objectsPath.buildGetOne(
      this.id,
      this.className,
      this.additional,
      this.consistencyLevel,
      this.nodeName,
      this.tenant
    );
  };

  do = (): Promise<WeaviateObject> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    return this.buildPath().then((path) => {
      return this.client.get(path);
    });
  };
}



---
File: /src/data/index.ts
---

import Connection from '../connection/index.js';
import { BeaconPath } from '../utils/beaconPath.js';
import { DbVersionSupport } from '../utils/dbVersion.js';
import Checker from './checker.js';
import Creator from './creator.js';
import Deleter from './deleter.js';
import Getter from './getter.js';
import GetterById from './getterById.js';
import Merger from './merger.js';
import { ObjectsPath, ReferencesPath } from './path.js';
import ReferenceCreator from './referenceCreator.js';
import ReferenceDeleter from './referenceDeleter.js';
import ReferencePayloadBuilder from './referencePayloadBuilder.js';
import ReferenceReplacer from './referenceReplacer.js';
import Updater from './updater.js';
import Validator from './validator.js';

export interface Data {
  creator: () => Creator;
  validator: () => Validator;
  updater: () => Updater;
  merger: () => Merger;
  getter: () => Getter;
  getterById: () => GetterById;
  deleter: () => Deleter;
  checker: () => Checker;
  referenceCreator: () => ReferenceCreator;
  referenceReplacer: () => ReferenceReplacer;
  referenceDeleter: () => ReferenceDeleter;
  referencePayloadBuilder: () => ReferencePayloadBuilder;
}

const data = (client: Connection, dbVersionSupport: DbVersionSupport): Data => {
  const objectsPath = new ObjectsPath(dbVersionSupport);
  const referencesPath = new ReferencesPath(dbVersionSupport);
  const beaconPath = new BeaconPath(dbVersionSupport);

  return {
    creator: () => new Creator(client, objectsPath),
    validator: () => new Validator(client),
    updater: () => new Updater(client, objectsPath),
    merger: () => new Merger(client, objectsPath),
    getter: () => new Getter(client, objectsPath),
    getterById: () => new GetterById(client, objectsPath),
    deleter: () => new Deleter(client, objectsPath),
    checker: () => new Checker(client, objectsPath),
    referenceCreator: () => new ReferenceCreator(client, referencesPath, beaconPath),
    referenceReplacer: () => new ReferenceReplacer(client, referencesPath, beaconPath),
    referenceDeleter: () => new ReferenceDeleter(client, referencesPath, beaconPath),
    referencePayloadBuilder: () => new ReferencePayloadBuilder(client),
  };
};

export default data;
export { default as Checker } from './checker.js';
export { default as Creator } from './creator.js';
export { default as Deleter } from './deleter.js';
export { default as Getter } from './getter.js';
export { default as GetterById } from './getterById.js';
export { default as Merger } from './merger.js';
export { default as ReferenceCreator } from './referenceCreator.js';
export { default as ReferenceDeleter } from './referenceDeleter.js';
export { default as ReferencePayloadBuilder } from './referencePayloadBuilder.js';
export { default as ReferenceReplacer } from './referenceReplacer.js';
export { default as Updater } from './updater.js';
export { default as Validator } from './validator.js';

export type { ConsistencyLevel } from './replication.js';



---
File: /src/data/journey.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import {
  Properties,
  Tenant,
  WeaviateClass,
  WeaviateError,
  WeaviateObject,
  WeaviateObjectsList,
} from '../openapi/types.js';
import weaviate, { WeaviateClient } from '../v2/index.js';

const thingClassName = 'DataJourneyTestThing';
const refSourceClassName = 'DataJourneyTestRefSource';
const classCustomVectorClassName = 'ClassCustomVector';

const fail = (msg: string) => {
  throw new Error(msg);
};

describe('data', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('creates a schema class', () => {
    // this is just test setup, not part of what we want to test here
    return setup(client);
  });

  it('validates a valid thing', () => {
    const properties = {
      stringProp: 'without-id',
      objectProp: {
        nestedInt: 123,
        nestedNumber: 123.45,
        nestedText: 'some text',
        nestedObjects: [
          {
            nestedBoolLvl2: true,
            nestedDateLvl2: '2022-01-01T00:00:00+02:00',
            nestedNumbersLvl2: [11.1, 22.2],
          },
          {
            nestedBoolLvl2: false,
            nestedDateLvl2: '2023-01-01T00:00:00+02:00',
            nestedNumbersLvl2: [33.3, 44.4],
          },
        ],
      },
    };

    return client.data
      .validator()
      .withId('11992f06-2eac-4f0b-973f-7d230d3bdbaf')
      .withClassName(thingClassName)
      .withProperties(properties)
      .do()
      .then((res: boolean) => {
        expect(res).toEqual(true);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('(validator) errors on an invalid valid object', () => {
    const properties = { stringProp: 234 }; // number is invalid

    return client.data
      .validator()
      .withId('11992f06-2eac-4f0b-973f-7d230d3bdbaf')
      .withClassName(thingClassName)
      .withProperties(properties)
      .do()
      .catch((e: Error) => {
        expect(e.message).toEqual(
          `The request to Weaviate failed with status code: 422 and message: {"error":[{"message":"invalid object: invalid text property 'stringProp' on class 'DataJourneyTestThing': not a string, but json.Number"}]}`
        );
      });
  });

  let implicitThingId: string | undefined;

  it('creates a new thing object without an explicit id', () => {
    const properties = {
      stringProp: 'without-id',
      objectProp: {
        nestedInt: 123,
        nestedNumber: 123.45,
        nestedText: 'some text',
        nestedObjects: [
          {
            nestedBoolLvl2: true,
            nestedDateLvl2: '2022-01-01T00:00:00+02:00',
            nestedNumbersLvl2: [11.1, 22.2],
          },
          {
            nestedBoolLvl2: false,
            nestedDateLvl2: '2023-01-01T00:00:00+02:00',
            nestedNumbersLvl2: [33.3, 44.4],
          },
        ],
      },
    };

    return client.data
      .creator()
      .withClassName(thingClassName)
      .withProperties(properties)
      .do()
      .then((res: WeaviateObject) => {
        expect(res.properties).toEqual(properties);
        implicitThingId = res.id;
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('creates a new thing object with an explicit id', () => {
    const properties = {
      stringProp: 'with-id',
      objectProp: {
        nestedInt: 999,
        nestedNumber: 88.8,
        nestedText: 'another text',
        nestedObjects: [
          {
            nestedBoolLvl2: false,
            nestedDateLvl2: '2020-01-01T00:00:00+02:00',
            nestedNumbersLvl2: [55.5, 66.6],
          },
          {
            nestedBoolLvl2: true,
            nestedDateLvl2: '2021-01-01T00:00:00+02:00',
            nestedNumbersLvl2: [77.7, 88.8],
          },
        ],
      },
    };
    // explicitly make this an all-zero UUID. This way we can be sure that it's
    // the first to come up when using the cursor API. Since this test suite
    // also contains dynamicaly generated IDs, this is the only way to make
    // sure that this ID is first. This way the tests returning objects after
    // this ID won't be flaky.
    const id = '00000000-0000-0000-0000-000000000000';

    return client.data
      .creator()
      .withClassName(thingClassName)
      .withProperties(properties)
      .withId(id)
      .do()
      .then((res: WeaviateObject) => {
        expect(res.properties).toEqual(properties);
        expect(res.id).toEqual(id);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('creates another thing', () => {
    // we need this later for the reference test!
    const properties = {};
    const id = '599a0c64-5ed5-4d30-978b-6c9c45516db1';

    return client.data
      .creator()
      .withClassName(refSourceClassName)
      .withProperties(properties)
      .withId(id)
      .do()
      .then((res: WeaviateObject) => {
        expect(res.properties).toEqual(properties);
        expect(res.id).toEqual(id);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('errors without a className', () => {
    return client.data
      .creator()
      .do()
      .then(() => {
        throw new Error('it should have errord');
      })
      .catch((err: Error) => {
        expect(err.message).toEqual(
          'invalid usage: className must be set - set with .withClassName(className)'
        );
      });
  });

  it('gets all things', () => {
    return client.data
      .getter()
      .do()
      .then((res: WeaviateObjectsList) => {
        expect(res.objects).toHaveLength(3);
        expect(res.objects).toEqual(
          expect.arrayContaining([
            expect.objectContaining({
              id: '00000000-0000-0000-0000-000000000000',
              properties: {
                stringProp: 'with-id',
                objectProp: {
                  nestedInt: 999,
                  nestedNumber: 88.8,
                  nestedText: 'another text',
                  nestedObjects: [
                    {
                      nestedBoolLvl2: false,
                      nestedDateLvl2: '2020-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [55.5, 66.6],
                    },
                    {
                      nestedBoolLvl2: true,
                      nestedDateLvl2: '2021-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [77.7, 88.8],
                    },
                  ],
                },
              },
            }),
            expect.objectContaining({
              properties: {
                stringProp: 'without-id',
                objectProp: {
                  nestedInt: 123,
                  nestedNumber: 123.45,
                  nestedText: 'some text',
                  nestedObjects: [
                    {
                      nestedBoolLvl2: true,
                      nestedDateLvl2: '2022-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [11.1, 22.2],
                    },
                    {
                      nestedBoolLvl2: false,
                      nestedDateLvl2: '2023-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [33.3, 44.4],
                    },
                  ],
                },
              },
            }),
          ])
        );
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('gets all classes objects', () => {
    return client.data
      .getter()
      .withClassName(thingClassName)
      .do()
      .then((res: WeaviateObjectsList) => {
        expect(res.objects).toHaveLength(2);
        expect(res.objects).toEqual(
          expect.arrayContaining([
            expect.objectContaining({
              id: '00000000-0000-0000-0000-000000000000',
              properties: {
                stringProp: 'with-id',
                objectProp: {
                  nestedInt: 999,
                  nestedNumber: 88.8,
                  nestedText: 'another text',
                  nestedObjects: [
                    {
                      nestedBoolLvl2: false,
                      nestedDateLvl2: '2020-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [55.5, 66.6],
                    },
                    {
                      nestedBoolLvl2: true,
                      nestedDateLvl2: '2021-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [77.7, 88.8],
                    },
                  ],
                },
              },
            }),
            expect.objectContaining({
              properties: {
                stringProp: 'without-id',
                objectProp: {
                  nestedInt: 123,
                  nestedNumber: 123.45,
                  nestedText: 'some text',
                  nestedObjects: [
                    {
                      nestedBoolLvl2: true,
                      nestedDateLvl2: '2022-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [11.1, 22.2],
                    },
                    {
                      nestedBoolLvl2: false,
                      nestedDateLvl2: '2023-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [33.3, 44.4],
                    },
                  ],
                },
              },
            }),
          ])
        );
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('gets all classes after a specfic object (Cursor API)', () => {
    return client.data
      .getter()
      .withClassName(thingClassName)
      .withLimit(100)
      .withAfter('00000000-0000-0000-0000-000000000000')
      .do()
      .then((res: WeaviateObjectsList) => {
        expect(res.objects).toHaveLength(1);
        expect(res.objects).toEqual(
          expect.arrayContaining([
            expect.objectContaining({
              properties: {
                stringProp: 'without-id',
                objectProp: {
                  nestedInt: 123,
                  nestedNumber: 123.45,
                  nestedText: 'some text',
                  nestedObjects: [
                    {
                      nestedBoolLvl2: true,
                      nestedDateLvl2: '2022-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [11.1, 22.2],
                    },
                    {
                      nestedBoolLvl2: false,
                      nestedDateLvl2: '2023-01-01T00:00:00+02:00',
                      nestedNumbersLvl2: [33.3, 44.4],
                    },
                  ],
                },
              },
            }),
          ])
        );
      })
      .catch((e) => fail('it should not have errord: ' + e));
  });

  it('gets all things with all optional _additional params', () => {
    return client.data
      .getter()
      .withAdditional('classification')
      .withAdditional('interpretation')
      .withAdditional('nearestNeighbors')
      .withAdditional('featureProjection')
      .withVector()
      .withLimit(2)
      .do()
      .then((res: WeaviateObjectsList) => {
        if (!res.objects) {
          throw new Error(`response should have objects: ${JSON.stringify(res)}`);
        }
        expect(res.objects).toHaveLength(2);
        expect(res.objects[0].vector?.length).toBeGreaterThan(10);
        expect(res.objects[0].additional?.interpretation).toBeDefined();
        expect(res.objects[0].additional?.featureProjection).toBeDefined();
        expect(res.objects[0].additional?.nearestNeighbors).toBeDefined();
        // not testing for classification as that's only set if the object was
        // actually classified, this one wasn't
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('gets all classes objects with all optional _additional params', () => {
    return client.data
      .getter()
      .withClassName(thingClassName)
      .withAdditional('classification')
      .withAdditional('interpretation')
      .withAdditional('nearestNeighbors')
      .withAdditional('featureProjection')
      .withVector()
      .do()
      .then((res: WeaviateObjectsList) => {
        if (!res.objects) {
          throw new Error(`response should have objects: ${JSON.stringify(res)}`);
        }
        expect(res.objects).toHaveLength(2);
        expect(res.objects[0].vector?.length).toBeGreaterThan(10);
        expect(res.objects[0].additional?.interpretation).toBeDefined();
        expect(res.objects[0].additional?.featureProjection).toBeDefined();
        expect(res.objects[0].additional?.nearestNeighbors).toBeDefined();
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('gets one thing by id only', () => {
    return client.data
      .getterById()
      .withId('00000000-0000-0000-0000-000000000000')
      .do()
      .then((res: WeaviateObject) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: '00000000-0000-0000-0000-000000000000',
            properties: {
              stringProp: 'with-id',
              objectProp: {
                nestedInt: 999,
                nestedNumber: 88.8,
                nestedText: 'another text',
                nestedObjects: [
                  {
                    nestedBoolLvl2: false,
                    nestedDateLvl2: '2020-01-01T00:00:00+02:00',
                    nestedNumbersLvl2: [55.5, 66.6],
                  },
                  {
                    nestedBoolLvl2: true,
                    nestedDateLvl2: '2021-01-01T00:00:00+02:00',
                    nestedNumbersLvl2: [77.7, 88.8],
                  },
                ],
              },
            },
          })
        );
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('gets one thing by id and class name', () => {
    return client.data
      .getterById()
      .withClassName(thingClassName)
      .withId('00000000-0000-0000-0000-000000000000')
      .do()
      .then((res: WeaviateObject) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: '00000000-0000-0000-0000-000000000000',
            properties: {
              stringProp: 'with-id',
              objectProp: {
                nestedInt: 999,
                nestedNumber: 88.8,
                nestedText: 'another text',
                nestedObjects: [
                  {
                    nestedBoolLvl2: false,
                    nestedDateLvl2: '2020-01-01T00:00:00+02:00',
                    nestedNumbersLvl2: [55.5, 66.6],
                  },
                  {
                    nestedBoolLvl2: true,
                    nestedDateLvl2: '2021-01-01T00:00:00+02:00',
                    nestedNumbersLvl2: [77.7, 88.8],
                  },
                ],
              },
            },
          })
        );
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('fails to get one thing by id with invalid class name', () => {
    return client.data
      .getterById()
      .withClassName('DoesNotExist')
      .withId('00000000-0000-0000-0000-000000000000')
      .do()
      .catch((err: Error) => {
        expect(err.message).toEqual('The request to Weaviate failed with status code: 404 and message: ');
      });
  });

  it('gets one thing by id with all optional additional props', () => {
    return client.data
      .getterById()
      .withId('00000000-0000-0000-0000-000000000000')
      .withAdditional('classification')
      .withAdditional('interpretation')
      .withAdditional('nearestNeighbors')
      .withVector()
      .do()
      .then((res: WeaviateObject) => {
        expect(res.vector?.length).toBeGreaterThan(10);
        expect(res.additional?.interpretation).toBeDefined();
        expect(res.additional?.nearestNeighbors).toBeDefined();
        // not testing for classification as that's only set if the object was
        // actually classified, this one wasn't
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('errors if the id is empty', () => {
    return client.data
      .getterById()
      .do()
      .then(() => {
        throw new Error('it should have errord');
      })
      .catch((e: WeaviateError) => {
        expect(e).toEqual(new Error('invalid usage: id must be set - initialize with getterById(id)'));
      });
  });

  it('updates a thing by id only', () => {
    const id = '00000000-0000-0000-0000-000000000000';
    return client.data
      .getterById()
      .withId(id)
      .do()
      .then((res: WeaviateObject) => {
        // alter the schema
        const properties: Properties = res.properties!;
        properties!.stringProp = 'thing-updated';
        properties!.objectProp = {
          nestedNumber: 55.5,
          nestedText: 'updated text',
          nestedObjects: [
            {
              nestedBoolLvl2: false,
              nestedNumbersLvl2: [],
            },
            {
              nestedBoolLvl2: true,
              nestedNumbersLvl2: [1.1],
            },
            {
              nestedBoolLvl2: true,
              nestedNumbersLvl2: [2.2, 3.3],
            },
          ],
        };
        return client.data.updater().withId(id).withClassName(thingClassName).withProperties(properties).do();
      })
      .then((res: WeaviateObject) => {
        expect(res.properties).toEqual({
          stringProp: 'thing-updated',
          objectProp: {
            nestedNumber: 55.5,
            nestedText: 'updated text',
            nestedObjects: [
              {
                nestedBoolLvl2: false,
                nestedNumbersLvl2: [],
              },
              {
                nestedBoolLvl2: true,
                nestedNumbersLvl2: [1.1],
              },
              {
                nestedBoolLvl2: true,
                nestedNumbersLvl2: [2.2, 3.3],
              },
            ],
          },
        });
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('updates a thing by id and class name', () => {
    const id = '00000000-0000-0000-0000-000000000000';
    return client.data
      .getterById()
      .withId(id)
      .withClassName(thingClassName)
      .do()
      .then((res: WeaviateObject) => {
        const properties: Properties = res.properties!;
        properties!.stringProp = 'thing-updated-with-class-name';
        return client.data.updater().withId(id).withClassName(thingClassName).withProperties(properties).do();
      })
      .then((res: WeaviateObject) => {
        expect(res.properties).toEqual({
          stringProp: 'thing-updated-with-class-name',
          objectProp: {
            nestedNumber: 55.5,
            nestedText: 'updated text',
            nestedObjects: [
              {
                nestedBoolLvl2: false,
                nestedNumbersLvl2: [],
              },
              {
                nestedBoolLvl2: true,
                nestedNumbersLvl2: [1.1],
              },
              {
                nestedBoolLvl2: true,
                nestedNumbersLvl2: [2.2, 3.3],
              },
            ],
          },
        });
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('merges a thing', () => {
    const id = '00000000-0000-0000-0000-000000000000';
    return client.data
      .getterById()
      .withId(id)
      .do()
      .then((res: WeaviateObject) => {
        // alter the schema
        const properties: Properties = res.properties!;
        properties!.intProp = 7;
        return client.data.merger().withId(id).withClassName(thingClassName).withProperties(properties).do();
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('adds a reference to a thing by id only', () => {
    const sourceId = '599a0c64-5ed5-4d30-978b-6c9c45516db1';
    const targetId = '00000000-0000-0000-0000-000000000000';

    return client.data
      .referenceCreator()
      .withId(sourceId)
      .withReferenceProperty('refProp')
      .withReference(client.data.referencePayloadBuilder().withId(targetId).payload())
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('replaces all references of a thing by id only', () => {
    const sourceId = '599a0c64-5ed5-4d30-978b-6c9c45516db1';
    const targetId: string | undefined = implicitThingId;

    return client.data
      .referenceReplacer()
      .withId(sourceId)
      .withReferenceProperty('refProp')
      .withReferences([client.data.referencePayloadBuilder().withId(targetId!).payload()])
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('deletes a single reference of a thing by id only', () => {
    const sourceId = '599a0c64-5ed5-4d30-978b-6c9c45516db1';
    const targetId: string | undefined = implicitThingId;

    return client.data
      .referenceDeleter()
      .withId(sourceId)
      .withReferenceProperty('refProp')
      .withReference(client.data.referencePayloadBuilder().withId(targetId!).payload())
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('adds a reference to a thing by id and class name', () => {
    const sourceId = '599a0c64-5ed5-4d30-978b-6c9c45516db1';
    const targetId = '00000000-0000-0000-0000-000000000000';

    return client.data
      .referenceCreator()
      .withId(sourceId)
      .withClassName(refSourceClassName)
      .withReferenceProperty('refProp')
      .withReference(
        client.data.referencePayloadBuilder().withId(targetId).withClassName(thingClassName).payload()
      )
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('replaces all references of a thing by id and class name', () => {
    const sourceId = '599a0c64-5ed5-4d30-978b-6c9c45516db1';
    const targetId: string | undefined = implicitThingId;

    return client.data
      .referenceReplacer()
      .withId(sourceId)
      .withClassName(refSourceClassName)
      .withReferenceProperty('refProp')
      .withReferences([
        client.data.referencePayloadBuilder().withId(targetId!).withClassName(thingClassName).payload(),
      ])
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('deletes a single reference of a thing by id and class name', () => {
    const sourceId = '599a0c64-5ed5-4d30-978b-6c9c45516db1';
    const targetId: string | undefined = implicitThingId;

    return client.data
      .referenceDeleter()
      .withId(sourceId)
      .withClassName(refSourceClassName)
      .withReferenceProperty('refProp')
      .withReference(
        client.data.referencePayloadBuilder().withId(targetId!).withClassName(thingClassName).payload()
      )
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('checks that object exists by id only', () => {
    return client.data
      .checker()
      .withId('00000000-0000-0000-0000-000000000000')
      .do()
      .then((exists: any) => {
        if (!exists) {
          fail('it should exist in DB');
        }
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('checks that object exists by id and class name', () => {
    return client.data
      .checker()
      .withId('00000000-0000-0000-0000-000000000000')
      .withClassName(thingClassName)
      .do()
      .then((exists: any) => {
        if (!exists) {
          fail('it should exist in DB');
        }
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('deletes a thing by id only', () => {
    return client.data
      .deleter()
      .withId('00000000-0000-0000-0000-000000000000')
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it("checks that object doesn't exist anymore with delete by id only", () => {
    return client.data
      .checker()
      .withId('00000000-0000-0000-0000-000000000000')
      .do()
      .then((exists: any) => {
        if (exists) {
          fail('it should not exist in DB');
        }
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('deletes a thing with id and class name', async () => {
    const properties = { stringProp: 'with-id' };
    const id = '6781a974-cfbf-455d-ace8-f1dba4564230';

    await client.data
      .creator()
      .withClassName(thingClassName)
      .withProperties(properties)
      .withId(id)
      .do()
      .then((res: WeaviateObject) => {
        expect(res.properties).toEqual(properties);
        expect(res.id).toEqual(id);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });

    return client.data
      .deleter()
      .withId(id)
      .withClassName(thingClassName)
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it("checks that object doesn't exist anymore with delete by id and class name", () => {
    return client.data
      .checker()
      .withId('6781a974-cfbf-455d-ace8-f1dba4564230')
      .do()
      .then((exists: any) => {
        if (exists) {
          fail('it should not exist in DB');
        }
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('verifies there are now fewer things (after delete)', () => {
    return Promise.all([
      client.data
        .getter()
        .do()
        .then((res: WeaviateObjectsList) => {
          expect(res.objects).toHaveLength(2);
        })
        .catch((e: WeaviateError) => {
          throw new Error('it should not have errord: ' + e);
        }),
    ]);
  });

  it('creates a new class with custom vector and explicit id', () => {
    const properties = { foo: 'bar' };
    const id = 'aaaac06c-463f-466c-9092-5930dbac3887';
    const vector = [
      -0.26736435, -0.112380296, 0.29648793, 0.39212644, 0.0033650293, -0.07112332, 0.07513781, 0.22459874,
    ];

    return client.data
      .creator()
      .withClassName(classCustomVectorClassName)
      .withProperties(properties)
      .withVector(vector)
      .withId(id)
      .do()
      .then((res: WeaviateObject) => {
        expect(res.properties).toEqual(properties);
        expect(res.vector).toEqual(vector);
        expect(res.id).toEqual(id);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('verifies that class with custom vector has been created', () => {
    const id = 'aaaac06c-463f-466c-9092-5930dbac3887';
    const vector = [
      -0.26736435, -0.112380296, 0.29648793, 0.39212644, 0.0033650293, -0.07112332, 0.07513781, 0.22459874,
    ];

    return client.data
      .getterById()
      .withId(id)
      .withVector()
      .do()
      .then((res: WeaviateObject) => {
        expect(res.vector).toEqual(vector);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('deletes a class with custom vector', () => {
    return client.data
      .deleter()
      .withId('aaaac06c-463f-466c-9092-5930dbac3887')
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('forms a get by id query with node_name set', () => {
    const id = '00000000-0000-0000-0000-000000000000';

    return client.data
      .getterById()
      .withClassName(thingClassName)
      .withId(id)
      .withVector()
      .withNodeName('node1')
      .buildPath()
      .then((path: string) => {
        expect(path).toContain('?include=vector');
        expect(path).toContain('&node_name=node1');
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('forms a get by id query with consistency_level set', () => {
    const id = '00000000-0000-0000-0000-000000000000';

    return client.data
      .getterById()
      .withClassName(thingClassName)
      .withId(id)
      .withVector()
      .withConsistencyLevel('QUORUM')
      .buildPath()
      .then((path: string) => {
        expect(path).toContain('?include=vector');
        expect(path).toContain('consistency_level=QUORUM');
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('forms a exists query with consistency_level set', () => {
    const id = '00000000-0000-0000-0000-000000000000';

    return client.data
      .checker()
      .withClassName(thingClassName)
      .withId(id)
      .withConsistencyLevel('QUORUM')
      .buildPath()
      .then((path: string) => {
        expect(path).toContain('consistency_level=QUORUM');
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('creates object with consistency_level set', async () => {
    const id = '144d1944-3ab4-4aa1-8095-92429d6cbaba';
    const properties = { foo: 'bar' };
    const vector = [
      -0.26736435, -0.112380296, 0.29648793, 0.39212644, 0.0033650293, -0.07112332, 0.07513781, 0.22459874,
    ];

    await client.data
      .creator()
      .withClassName(classCustomVectorClassName)
      .withProperties(properties)
      .withVector(vector)
      .withId(id)
      .withConsistencyLevel('ALL')
      .do()
      .then((res) => {
        expect(res.properties).toEqual(properties);
        expect(res.vector).toEqual(vector);
        expect(res.id).toEqual(id);
      })
      .catch((e) => fail('it should not have errord: ' + e));

    return client.data
      .getterById()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .do()
      .then((res) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: id,
            properties: properties,
          })
        );
      })
      .catch((e) => fail('it should not have errord: ' + e));
  });

  it('deletes object with consistency_level set', async () => {
    const id = '7a78b029-e7b4-499f-9bd8-70ea11b12345';
    const properties = { foo: 'bar' };
    const vector = [
      -0.26736435, -0.112380296, 0.29648793, 0.39212644, 0.0033650293, -0.07112332, 0.07513781, 0.22459874,
    ];

    await client.data
      .creator()
      .withClassName(classCustomVectorClassName)
      .withProperties(properties)
      .withVector(vector)
      .withId(id)
      .do()
      .then((res) => {
        expect(res.properties).toEqual(properties);
        expect(res.vector).toEqual(vector);
        expect(res.id).toEqual(id);
      })
      .catch((e: WeaviateError) => fail('it should not have errord: ' + e));

    await client.data
      .getterById()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .do()
      .then((res) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: id,
            properties: properties,
          })
        );
      })
      .catch((e: WeaviateError) => fail('it should not have errord: ' + e));

    return client.data
      .deleter()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .withConsistencyLevel('QUORUM')
      .do()
      .then()
      .catch((e: WeaviateError) => fail('it should not have errord: ' + e));
  });

  it('patches object with consistency_level set', async () => {
    const id = '7a78b029-e7b4-499f-9bd8-70ea11b12345';
    const properties: Properties = { foo: 'bar' };
    const vector = [
      -0.26736435, -0.112380296, 0.29648793, 0.39212644, 0.0033650293, -0.07112332, 0.07513781, 0.22459874,
    ];

    await client.data
      .creator()
      .withClassName(classCustomVectorClassName)
      .withProperties(properties)
      .withVector(vector)
      .withId(id)
      .do()
      .then((res) => {
        expect(res.properties).toEqual(properties);
        expect(res.vector).toEqual(vector);
        expect(res.id).toEqual(id);
      })
      .catch((e: WeaviateError) => fail('it should not have errord: ' + e));

    await client.data
      .getterById()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .do()
      .then((res) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: id,
            properties: properties,
          })
        );
      })
      .catch((e: WeaviateError) => fail('it should not have errord: ' + e));

    const newProperties: Properties = { foo: 'baz' };

    await client.data
      .merger()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .withProperties(newProperties)
      .withConsistencyLevel('QUORUM')
      .do()
      .then()
      .catch((e) => fail('it should not have errord: ' + e));

    return client.data
      .getterById()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .do()
      .then((res) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: id,
            properties: newProperties,
          })
        );
      })
      .catch((e) => fail('it should not have errord: ' + e));
  });

  it('updates object with consistency_level set', async () => {
    const id = '55eaf761-11fd-48a9-bf21-60e2048db188';
    const properties: Properties = { foo: 'bar' };
    const vector = [
      -0.26736435, -0.112380296, 0.29648793, 0.39212644, 0.0033650293, -0.07112332, 0.07513781, 0.22459874,
    ];

    await client.data
      .creator()
      .withClassName(classCustomVectorClassName)
      .withProperties(properties)
      .withVector(vector)
      .withId(id)
      .do()
      .then((res) => {
        expect(res.properties).toEqual(properties);
        expect(res.vector).toEqual(vector);
        expect(res.id).toEqual(id);
      })
      .catch((e: WeaviateError) => fail('it should not have errord: ' + e));

    await client.data
      .getterById()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .do()
      .then((res) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: id,
            properties: properties,
          })
        );
      })
      .catch((e: WeaviateError) => fail('it should not have errord: ' + e));

    const newProperties: Properties = { foo: 'baz' };

    await client.data
      .updater()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .withProperties(newProperties)
      .withConsistencyLevel('QUORUM')
      .do()
      .then()
      .catch((e) => fail('it should not have errord: ' + e));

    return client.data
      .getterById()
      .withClassName(classCustomVectorClassName)
      .withId(id)
      .do()
      .then((res) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: id,
            properties: newProperties,
          })
        );
      })
      .catch((e: WeaviateError) => fail('it should not have errord: ' + e));
  });

  it('creates reference with consistency_level set', async () => {
    const id1 = '5a99f759-400a-453e-b83a-766472994d05';
    const props1 = { stringProp: 'foobar' };

    const id2 = '8d3ae97a-664b-4252-91d5-9886eda9b580';

    await client.data
      .creator()
      .withClassName(thingClassName)
      .withProperties(props1)
      .withId(id1)
      .do()
      .then((res) => {
        expect(res.properties).toEqual(props1);
        expect(res.id).toEqual(id1);
      })
      .catch((e) => fail('it should not have errord: ' + e));

    await client.data
      .creator()
      .withClassName(refSourceClassName)
      .withId(id2)
      .do()
      .then((res) => {
        expect(res.id).toEqual(id2);
      })
      .catch((e) => fail('it should not have errord: ' + e));

    await client.data
      .referenceCreator()
      .withId(id2)
      .withReferenceProperty('refProp')
      .withConsistencyLevel('ONE')
      .withReference(client.data.referencePayloadBuilder().withId(id1).payload())
      .do()
      .catch((e) => fail('it should not have errord: ' + e));

    return client.data
      .getterById()
      .withClassName(refSourceClassName)
      .withId(id2)
      .do()
      .then((res) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: id2,
            properties: {
              refProp: [
                {
                  beacon: `weaviate://localhost/DataJourneyTestThing/${id1}`,
                  href: `/v1/objects/DataJourneyTestThing/${id1}`,
                },
              ],
            },
          })
        );
      })
      .catch((e) => fail('it should not have errord: ' + e));
  });

  it('replaces reference with consistency_level set', async () => {
    const id1 = '84c58d72-7303-4528-90d2-ebaa39bdd9d4';
    const props1 = { stringProp: 'foobar' };

    const id2 = '6ca5a30f-f3df-400f-92d2-7de1a48d80ac';

    await client.data
      .creator()
      .withClassName(thingClassName)
      .withProperties(props1)
      .withId(id1)
      .do()
      .then((res) => {
        expect(res.properties).toEqual(props1);
        expect(res.id).toEqual(id1);
      })
      .catch((e) => fail('it should not have errord: ' + e));

    await client.data
      .creator()
      .withClassName(refSourceClassName)
      .withId(id2)
      .do()
      .then((res) => {
        expect(res.id).toEqual(id2);
      })
      .catch((e) => fail('it should not have errord: ' + e));

    return client.data
      .referenceReplacer()
      .withId(id2)
      .withReferenceProperty('refProp')
      .withConsistencyLevel('ONE')
      .withReferences(client.data.referencePayloadBuilder().withId(id1).payload())
      .do()
      .catch((e) => fail('it should not have errord: ' + e));
  });

  it('deletes reference with consistency_level set', async () => {
    const id1 = 'cfc3151c-6f45-45e2-bb6a-55789c1fbbb2';
    const props1 = { stringProp: 'foobar' };

    const id2 = '70ff8bc0-1d3d-4df4-8bf0-774806ba53e3';

    await client.data
      .creator()
      .withClassName(thingClassName)
      .withProperties(props1)
      .withId(id1)
      .do()
      .then((res) => {
        expect(res.properties).toEqual(props1);
        expect(res.id).toEqual(id1);
      })
      .catch((e) => fail('it should not have errord: ' + e));

    await client.data
      .creator()
      .withClassName(refSourceClassName)
      .withId(id2)
      .do()
      .then((res) => {
        expect(res.id).toEqual(id2);
      })
      .catch((e) => fail('it should not have errord: ' + e));

    await client.data
      .referenceCreator()
      .withId(id2)
      .withReferenceProperty('refProp')
      .withConsistencyLevel('ONE')
      .withReference(client.data.referencePayloadBuilder().withId(id1).payload())
      .do()
      .catch((e) => fail('it should not have errord: ' + e));

    await client.data
      .getterById()
      .withClassName(refSourceClassName)
      .withId(id2)
      .do()
      .then((res) => {
        expect(res).toEqual(
          expect.objectContaining({
            id: id2,
            properties: {
              refProp: [
                {
                  beacon: `weaviate://localhost/DataJourneyTestThing/${id1}`,
                  href: `/v1/objects/DataJourneyTestThing/${id1}`,
                },
              ],
            },
          })
        );
      })
      .catch((e) => fail('it should not have errord: ' + e));

    return client.data
      .referenceDeleter()
      .withId(id2)
      .withReferenceProperty('refProp')
      .withConsistencyLevel('ONE')
      .withReference(client.data.referencePayloadBuilder().withId(id1).payload())
      .do()
      .catch((e) => fail('it should not have errord: ' + e));
  });

  it('checks an object exists with consistency_level set', async () => {
    const id = 'e7c7f6d5-4c9d-4a4e-8e1b-9d3d5a0e4d9f';
    const props = { stringProp: 'foobar' };

    await client.data
      .creator()
      .withClassName(thingClassName)
      .withProperties(props)
      .withId(id)
      .do()
      .then((res) => {
        expect(res.properties).toEqual(props);
        expect(res.id).toEqual(id);
      })
      .catch((e) => fail('it should not have errord: ' + e));

    return client.data
      .checker()
      .withId(id)
      .withConsistencyLevel('QUORUM')
      .do()
      .then((exists) => {
        expect(exists).toBe(true);
      })
      .catch((e) => fail('it should not have errord: ' + e));
  });

  it('tears down and cleans up', () => {
    return Promise.all([
      client.schema.classDeleter().withClassName(thingClassName).do(),
      client.schema.classDeleter().withClassName(refSourceClassName).do(),
      client.schema.classDeleter().withClassName(classCustomVectorClassName).do(),
    ]);
  });
});

describe('uuid support', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  it('creates class with properties of uuid and uuid[]', async () => {
    const className = 'ClassUUID';
    const id = 'abefd256-8574-442b-9293-9205193737ee';

    await client.schema
      .classCreator()
      .withClass({
        class: className,
        properties: [
          {
            dataType: ['uuid'],
            name: 'uuidProp',
          },
          {
            dataType: ['uuid[]'],
            name: 'uuidArrayProp',
          },
        ],
      })
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toBeTruthy();
      });

    await client.data
      .creator()
      .withClassName(className)
      .withId(id)
      .withProperties({
        uuidProp: '7aaa79d3-a564-45db-8fa8-c49e20b8a39a',
        uuidArrayProp: ['f70512a3-26cb-4ae4-9369-204555917f15', '9e516f40-fd54-4083-a476-f4675b2b5f92'],
      })
      .do()
      .then((res: WeaviateObject) => {
        expect(res).toBeTruthy();
      });

    await client.data
      .getterById()
      .withId(id)
      .withClassName(className)
      .do()
      .then((res: WeaviateObject) => {
        expect(res).toBeTruthy();
        expect(res.properties).toHaveProperty('uuidProp', '7aaa79d3-a564-45db-8fa8-c49e20b8a39a');
        expect(res.properties).toHaveProperty('uuidArrayProp', [
          'f70512a3-26cb-4ae4-9369-204555917f15',
          '9e516f40-fd54-4083-a476-f4675b2b5f92',
        ]);
      });

    return client.schema
      .classDeleter()
      .withClassName(className)
      .do()
      .then((res: void) => {
        expect(res).toEqual(undefined);
      });
  });
});

describe('multi tenancy', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  const documentClassName = 'Document';
  const document: WeaviateClass = {
    class: documentClassName,
    properties: [
      {
        name: 'tenant',
        dataType: ['text'],
      },
      {
        name: 'title',
        dataType: ['text'],
      },
    ],
    multiTenancyConfig: { enabled: true },
  };

  const passageClassName = 'Passage';
  const passage: WeaviateClass = {
    class: passageClassName,
    properties: [
      {
        name: 'tenant',
        dataType: ['text'],
      },
      {
        name: 'content',
        dataType: ['text'],
      },
      {
        name: 'ofDocument',
        dataType: [documentClassName],
      },
    ],
    multiTenancyConfig: { enabled: true },
  };

  const tenants: Array<Tenant> = [{ name: 'tenantA' }, { name: 'tenantB' }, { name: 'tenantC' }];
  const documentIDs = [
    '00000000-0000-0000-0000-000000000011',
    '00000000-0000-0000-0000-000000000022',
    '00000000-0000-0000-0000-000000000033',
  ];
  const documentTitles = ['GAN', 'OpenAI', 'SpaceX'];
  const passageIDs = [
    '00000000-0000-0000-0000-000000000001',
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000003',
  ];
  const txts = [
    'A generative adversarial network (GAN) is a class of machine learning frameworks designed by Ian Goodfellow and his colleagues in June 2014.',
    'OpenAI is an American artificial intelligence (AI) research laboratory consisting of the non-profit OpenAI Incorporated and its for-profit subsidiary corporation OpenAI Limited Partnership.',
    'The Space Exploration Technologies Corporation, commonly referred to as SpaceX is an American spacecraft manufacturer, launcher, and satellite communications company headquartered in Hawthorne, California.',
  ];

  it('create Document and Passage class with tenants', async () => {
    await client.schema
      .classCreator()
      .withClass(document)
      .do()
      .then()
      .catch((e) => fail('it should not have errord: ' + e));

    await client.schema
      .tenantsCreator(documentClassName, tenants)
      .do()
      .then((res) => expect(res).toHaveLength(3))
      .catch((e) => fail('it should not have errord: ' + e));

    await client.schema
      .classCreator()
      .withClass(passage)
      .do()
      .then()
      .catch((e) => fail('it should not have errord: ' + e));

    return client.schema
      .tenantsCreator(passageClassName, tenants)
      .do()
      .then((res) => expect(res).toHaveLength(3))
      .catch((e) => fail('it should not have errord: ' + e));
  });

  it('inserts Documents tenants objects', async () => {
    const expectFn = expect;
    for (let i = 0; i < documentIDs.length; i++) {
      client.data
        .creator()
        .withClassName(documentClassName)
        .withId(documentIDs[i])
        .withTenant(tenants[i].name!)
        .withProperties({
          title: documentTitles[i],
          tenant: tenants[i].name,
        })
        .do()
        .then((r) => {
          expectFn(r.id).toEqual(documentIDs[i]);
        })
        .catch((e) => {
          throw new Error('it should not have errored: ' + e);
        });
    }

    await client.data
      .creator()
      .withClassName(passageClassName)
      .withId(passageIDs[0])
      .withTenant(tenants[0].name!)
      .withProperties({
        content: txts[0],
        tenant: tenants[0].name,
      })
      .do()
      .then((r) => {
        expectFn(r.id).toEqual(passageIDs[0]);
      })
      .catch((e) => {
        throw new Error('it should not have errored: ' + e);
      });

    await client.data
      .creator()
      .withClassName(passageClassName)
      .withId(passageIDs[1])
      .withTenant(tenants[1].name!)
      .withProperties({
        content: txts[1],
        tenant: tenants[1].name,
      })
      .do()
      .then((r) => {
        expectFn(r.id).toEqual(passageIDs[1]);
      })
      .catch((e) => {
        throw new Error('it should not have errored: ' + e);
      });

    return client.data
      .creator()
      .withClassName(passageClassName)
      .withId(passageIDs[2])
      .withTenant(tenants[2].name!)
      .withProperties({
        content: txts[2],
        tenant: tenants[2].name,
      })
      .do()
      .then((r) => {
        expectFn(r.id).toEqual(passageIDs[2]);
      })
      .catch((e) => {
        throw new Error('it should not have errored: ' + e);
      });
  });

  it('exists Passage tenants objects', () => {
    return client.data
      .checker()
      .withClassName(passageClassName)
      .withId(passageIDs[0])
      .withTenant(tenants[0].name!)
      .do()
      .then((r) => {
        expect(r).toBe(true);
      })
      .catch((e) => {
        throw new Error('it should not have errored: ' + e);
      });
  });

  it('replaces Passage object', () => {
    return client.data
      .updater()
      .withClassName(passageClassName)
      .withId(passageIDs[0])
      .withTenant(tenants[0].name!)
      .withProperties({
        content: 'some new content',
        tenant: tenants[0].name,
      })
      .do()
      .then((r) => {
        expect(r.id).toEqual(passageIDs[0]);
        expect(r.properties.content).toEqual('some new content');
      })
      .catch((e) => {
        console.log(`error: ${e}`);
        throw new Error('it should not have errored: ' + e);
      });
  });

  it('gets by id a Passage object', () => {
    return client.data
      .getterById()
      .withClassName(passageClassName)
      .withId(passageIDs[0])
      .withTenant(tenants[0].name!)
      .do()
      .then((r) => {
        expect(r.id).toEqual(passageIDs[0]);
        expect(r.properties!.content).toEqual('some new content');
      })
      .catch((e) => {
        throw new Error('it should not have errored: ' + e);
      });
  });

  it('adds a referene Passage object', () => {
    return client.data
      .referenceCreator()
      .withId(passageIDs[0])
      .withClassName(passageClassName)
      .withReferenceProperty('ofDocument')
      .withReference(
        client.data
          .referencePayloadBuilder()
          .withId(documentIDs[0])
          .withClassName(documentClassName)
          .payload()
      )
      .withTenant(tenants[0].name!)
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('gets by id a Passage object with reference', () => {
    return client.data
      .getterById()
      .withClassName(passageClassName)
      .withId(passageIDs[0])
      .withTenant(tenants[0].name!)
      .do()
      .then((r) => {
        expect(r.id).toEqual(passageIDs[0]);
        expect(r.properties!.ofDocument).toHaveLength(1);
      })
      .catch((e) => {
        throw new Error('it should not have errored: ' + e);
      });
  });

  it('removes a referene Passage object', () => {
    return client.data
      .referenceDeleter()
      .withId(passageIDs[0])
      .withClassName(passageClassName)
      .withReferenceProperty('ofDocument')
      .withReference(
        client.data
          .referencePayloadBuilder()
          .withId(documentIDs[0])
          .withClassName(documentClassName)
          .payload()
      )
      .withTenant(tenants[0].name!)
      .do()
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('gets by id a Passage object with no reference', () => {
    return client.data
      .getterById()
      .withClassName(passageClassName)
      .withId(passageIDs[0])
      .withTenant(tenants[0].name!)
      .do()
      .then((r) => {
        expect(r.id).toEqual(passageIDs[0]);
        expect(r.properties!.ofDocument).toHaveLength(0);
      })
      .catch((e) => {
        throw new Error('it should not have errored: ' + e);
      });
  });

  it('delete Passage class', () => {
    return client.schema.classDeleter().withClassName(passageClassName).do();
  });

  it('delete Document class', () => {
    return client.schema.classDeleter().withClassName(documentClassName).do();
  });
});

const setup = async (client: WeaviateClient) => {
  const thing: WeaviateClass = {
    class: thingClassName,
    properties: [
      {
        name: 'stringProp',
        dataType: ['string'],
      },
      {
        name: 'intProp',
        dataType: ['int'],
      },
      {
        name: 'objectProp',
        dataType: ['object'],
        nestedProperties: [
          {
            name: 'nestedInt',
            dataType: ['int'],
          },
          {
            name: 'nestedNumber',
            dataType: ['number'],
          },
          {
            name: 'nestedText',
            dataType: ['text'],
          },
          {
            name: 'nestedObjects',
            dataType: ['object[]'],
            nestedProperties: [
              {
                name: 'nestedBoolLvl2',
                dataType: ['boolean'],
              },
              {
                name: 'nestedDateLvl2',
                dataType: ['date'],
              },
              {
                name: 'nestedNumbersLvl2',
                dataType: ['number[]'],
              },
            ],
          },
        ],
      },
    ],
  };

  await Promise.all([client.schema.classCreator().withClass(thing).do()]);

  const classCustomVector = {
    class: classCustomVectorClassName,
    vectorizer: 'none',
    properties: [
      {
        name: 'foo',
        dataType: ['string'],
      },
    ],
  };

  await Promise.all([client.schema.classCreator().withClass(classCustomVector).do()]);

  const refSource = {
    class: refSourceClassName,
    properties: [
      {
        name: 'refProp',
        dataType: [thingClassName],
        cardinality: 'many',
      },
    ],
  };

  return client.schema.classCreator().withClass(refSource).do();
};



---
File: /src/data/merger.ts
---

import Connection from '../connection/index.js';
import { Properties, WeaviateObject } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';
import { ObjectsPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class Merger extends CommandBase {
  private className!: string;
  private consistencyLevel?: ConsistencyLevel;
  private id!: string;
  private objectsPath: ObjectsPath;
  private properties?: Properties;
  private tenant?: string;

  constructor(client: Connection, objectsPath: ObjectsPath) {
    super(client);
    this.objectsPath = objectsPath;
  }

  withProperties = (properties: Properties) => {
    this.properties = properties;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with withClassName(className)');
    }
  };

  validateId = () => {
    if (this.id == undefined || this.id == null || this.id.length == 0) {
      this.addError('id must be set - set with withId(id)');
    }
  };

  payload = (): WeaviateObject => ({
    tenant: this.tenant,
    properties: this.properties,
    class: this.className,
    id: this.id,
  });

  validate = () => {
    this.validateClassName();
    this.validateId();
  };

  do = () => {
    this.validate();

    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    return this.objectsPath
      .buildMerge(this.id, this.className, this.consistencyLevel)
      .then((path: string) => this.client.patch(path, this.payload()));
  };
}



---
File: /src/data/path.test.ts
---

import { TestDbVersionProvider } from '../../test/dbVersionProvider.js';
import { DbVersionSupport } from '../utils/dbVersion.js';
import { ObjectsPath, ReferencesPath } from './path.js';

// This can be anything > 1.14.2, to support class-namespaced urls.
// The actual value is not used for anything else
const version = '1.18.0';

const objectsPathBuilder = new ObjectsPath(new DbVersionSupport(new TestDbVersionProvider(version)));

const refsPathBuilder = new ReferencesPath(new DbVersionSupport(new TestDbVersionProvider(version)));

describe('paths', () => {
  it('builds object create', () => {
    return objectsPathBuilder
      .buildCreate('ONE')
      .then((path) => expect(path).toEqual('/objects?consistency_level=ONE'))
      .catch((e) => fail(`unexpected error: ${e}`));
  });

  it('builds object delete', () => {
    return objectsPathBuilder
      .buildDelete('123456', 'SomeClass', 'ALL')
      .then((path) => expect(path).toEqual('/objects/SomeClass/123456?consistency_level=ALL'))
      .catch((e) => fail(`unexpected error: ${e}`));
  });

  it('builds object merge', () => {
    return objectsPathBuilder
      .buildMerge('123456', 'SomeClass', 'QUORUM')
      .then((path) => expect(path).toEqual('/objects/SomeClass/123456?consistency_level=QUORUM'))
      .catch((e) => fail(`unexpected error: ${e}`));
  });

  it('builds object update', () => {
    return objectsPathBuilder
      .buildUpdate('123456', 'SomeClass', 'ONE')
      .then((path) => expect(path).toEqual('/objects/SomeClass/123456?consistency_level=ONE'))
      .catch((e) => fail(`unexpected error: ${e}`));
  });

  it('builds references', () => {
    return refsPathBuilder
      .build('123456', 'SomeClass', 'SomeProp', 'ALL')
      .then((path) =>
        expect(path).toEqual('/objects/SomeClass/123456/references/SomeProp?consistency_level=ALL')
      )
      .catch((e) => fail(`unexpected error: ${e}`));
  });
});

describe('paths with tenantKey', () => {
  it('builds object delete', () => {
    return objectsPathBuilder
      .buildDelete('123456', 'SomeClass', 'ALL', 'tenantA')
      .then((path) => expect(path).toEqual('/objects/SomeClass/123456?consistency_level=ALL&tenant=tenantA'))
      .catch((e) => fail(`unexpected error: ${e}`));
  });

  it('builds references', () => {
    return refsPathBuilder
      .build('123456', 'SomeClass', 'SomeProp', 'ALL', 'tenantA')
      .then((path) =>
        expect(path).toEqual(
          '/objects/SomeClass/123456/references/SomeProp?consistency_level=ALL&tenant=tenantA'
        )
      )
      .catch((e) => fail(`unexpected error: ${e}`));
  });
});



---
File: /src/data/path.ts
---

import { DbVersionSupport } from '../utils/dbVersion.js';
import { isValidStringProperty } from '../validation/string.js';
import { isValidWeaviateVersion } from '../validation/version.js';
import { ConsistencyLevel } from './replication.js';

const objectsPathPrefix = '/objects';

export class ObjectsPath {
  private dbVersionSupport: DbVersionSupport;

  constructor(dbVersionSupport: DbVersionSupport) {
    this.dbVersionSupport = dbVersionSupport;
  }

  buildCreate(consistencyLevel?: string): Promise<string> {
    return this.build({ consistencyLevel }, [this.addQueryParams]);
  }
  buildDelete(id: string, className: string, consistencyLevel?: string, tenant?: string): Promise<string> {
    return this.build({ id, className, consistencyLevel, tenant: tenant }, [
      this.addClassNameDeprecatedNotSupportedCheck,
      this.addId,
      this.addQueryParams,
    ]);
  }
  buildCheck(
    id: string,
    className: string,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ): Promise<string> {
    return this.build({ id, className, consistencyLevel, tenant }, [
      this.addClassNameDeprecatedNotSupportedCheck,
      this.addId,
      this.addQueryParams,
    ]);
  }
  buildGetOne(
    id: string,
    className: string,
    additional: string[],
    consistencyLevel?: ConsistencyLevel,
    nodeName?: string,
    tenant?: string
  ): Promise<string> {
    return this.build({ id, className, additional: additional, consistencyLevel, nodeName, tenant: tenant }, [
      this.addClassNameDeprecatedNotSupportedCheck,
      this.addId,
      this.addQueryParams,
    ]);
  }
  buildGet(
    className?: string,
    limit?: number,
    additional?: string[],
    after?: string,
    tenant?: string
  ): Promise<string> {
    return this.build({ className, limit, additional, after, tenant: tenant }, [this.addQueryParamsForGet]);
  }
  buildUpdate(id: string, className: string, consistencyLevel?: string): Promise<string> {
    return this.build({ id, className, consistencyLevel }, [
      this.addClassNameDeprecatedCheck,
      this.addId,
      this.addQueryParams,
    ]);
  }
  buildMerge(id: string, className: string, consistencyLevel?: string): Promise<string> {
    return this.build({ id, className, consistencyLevel }, [
      this.addClassNameDeprecatedCheck,
      this.addId,
      this.addQueryParams,
    ]);
  }

  build(params: any, modifiers: any): Promise<string> {
    return this.dbVersionSupport.supportsClassNameNamespacedEndpointsPromise().then((support: any) => {
      let path = objectsPathPrefix;
      modifiers.forEach((modifier: any) => {
        path = modifier(params, path, support);
      });
      return path;
    });
  }

  addClassNameDeprecatedNotSupportedCheck(params: any, path: string, support: any) {
    if (support.supports) {
      if (isValidStringProperty(params.className)) {
        return `${path}/${params.className}`;
      } else {
        support.warns.deprecatedNonClassNameNamespacedEndpointsForObjects();
      }
    } else {
      support.warns.notSupportedClassNamespacedEndpointsForObjects();
    }
    return path;
  }
  addClassNameDeprecatedCheck(params: any, path: string, support: any) {
    if (support.supports) {
      if (isValidStringProperty(params.className)) {
        return `${path}/${params.className}`;
      } else {
        support.warns.deprecatedNonClassNameNamespacedEndpointsForObjects();
      }
    }
    return path;
  }
  addId(params: any, path: string) {
    if (isValidStringProperty(params.id)) {
      return `${path}/${params.id}`;
    }
    return path;
  }
  addQueryParams(params: any, path: string) {
    const queryParams = [];
    if (Array.isArray(params.additional) && params.additional.length > 0) {
      queryParams.push(`include=${params.additional.join(',')}`);
    }
    if (isValidStringProperty(params.nodeName)) {
      queryParams.push(`node_name=${params.nodeName}`);
    }
    if (isValidStringProperty(params.consistencyLevel)) {
      queryParams.push(`consistency_level=${params.consistencyLevel}`);
    }
    if (isValidStringProperty(params.tenant)) {
      queryParams.push(`tenant=${params.tenant}`);
    }
    if (queryParams.length > 0) {
      return `${path}?${queryParams.join('&')}`;
    }
    return path;
  }
  addQueryParamsForGet(params: any, path: string, support: any) {
    const queryParams = [];
    if (Array.isArray(params.additional) && params.additional.length > 0) {
      queryParams.push(`include=${params.additional.join(',')}`);
    }
    if (typeof params.limit == 'number' && params.limit > 0) {
      queryParams.push(`limit=${params.limit}`);
    }
    if (isValidStringProperty(params.className)) {
      if (support.supports) {
        queryParams.push(`class=${params.className}`);
      } else {
        support.warns.notSupportedClassParameterInEndpointsForObjects();
      }
    }
    if (isValidStringProperty(params.after)) {
      queryParams.push(`after=${params.after}`);
    }
    if (isValidStringProperty(params.tenant)) {
      queryParams.push(`tenant=${params.tenant}`);
    }
    if (queryParams.length > 0) {
      return `${path}?${queryParams.join('&')}`;
    }
    return path;
  }
}

export class ReferencesPath {
  private dbVersionSupport: DbVersionSupport;

  constructor(dbVersionSupport: DbVersionSupport) {
    this.dbVersionSupport = dbVersionSupport;
  }

  build(
    id: string,
    className: string,
    property: string,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ): Promise<string> {
    return this.dbVersionSupport.supportsClassNameNamespacedEndpointsPromise().then((support: any) => {
      let path = objectsPathPrefix;
      if (support.supports) {
        if (isValidStringProperty(className)) {
          path = `${path}/${className}`;
        } else {
          support.warns.deprecatedNonClassNameNamespacedEndpointsForReferences();
        }
      } else {
        support.warns.notSupportedClassNamespacedEndpointsForReferences();
      }
      if (support.version) {
        if (!isValidWeaviateVersion(support.version)) {
          support.warns.deprecatedWeaviateTooOld();
        }
      }
      if (isValidStringProperty(id)) {
        path = `${path}/${id}`;
      }
      path = `${path}/references`;
      if (isValidStringProperty(property)) {
        path = `${path}/${property}`;
      }
      const queryParams: Array<string> = [];
      if (isValidStringProperty(consistencyLevel)) {
        queryParams.push(`consistency_level=${consistencyLevel}`);
      }
      if (isValidStringProperty(tenant)) {
        queryParams.push(`tenant=${tenant}`);
      }
      if (queryParams.length > 0) {
        path = `${path}?${queryParams.join('&')}`;
      }
      return path;
    });
  }
}



---
File: /src/data/referenceCreator.ts
---

import Connection from '../connection/index.js';
import { Reference } from '../openapi/types.js';
import { BeaconPath } from '../utils/beaconPath.js';
import { CommandBase } from '../validation/commandBase.js';
import { ReferencesPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class ReferenceCreator extends CommandBase {
  private beaconPath: BeaconPath;
  private className!: string;
  private consistencyLevel?: ConsistencyLevel;
  private id!: string;
  private reference!: Reference;
  private referencesPath: ReferencesPath;
  private refProp!: string;
  private tenant?: string;

  constructor(client: Connection, referencesPath: ReferencesPath, beaconPath: BeaconPath) {
    super(client);
    this.referencesPath = referencesPath;
    this.beaconPath = beaconPath;
  }

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withClassName(className: string) {
    this.className = className;
    return this;
  }

  withReference = (ref: Reference) => {
    this.reference = ref;
    return this;
  };

  withReferenceProperty = (refProp: string) => {
    this.refProp = refProp;
    return this;
  };

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = () => {
    this.validateIsSet(this.id, 'id', '.withId(id)');
    this.validateIsSet(this.refProp, 'referenceProperty', '.withReferenceProperty(refProp)');
  };

  payload = () => this.reference;

  do = () => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    if (!this.reference.beacon) {
      throw new Error('reference beacon must be set');
    }

    return Promise.all([
      this.referencesPath.build(this.id, this.className, this.refProp, this.consistencyLevel, this.tenant),
      this.beaconPath.rebuild(this.reference.beacon),
    ]).then((results) => {
      const path = results[0];
      const beacon = results[1];
      return this.client.postEmpty(path, { beacon });
    });
  };
}



---
File: /src/data/referenceDeleter.ts
---

import Connection from '../connection/index.js';
import { Reference } from '../openapi/types.js';
import { BeaconPath } from '../utils/beaconPath.js';
import { CommandBase } from '../validation/commandBase.js';
import { ReferencesPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class ReferenceDeleter extends CommandBase {
  private beaconPath: BeaconPath;
  private className!: string;
  private consistencyLevel?: ConsistencyLevel;
  private id!: string;
  private reference!: Reference;
  private referencesPath: ReferencesPath;
  private refProp!: string;
  private tenant?: string;

  constructor(client: Connection, referencesPath: ReferencesPath, beaconPath: BeaconPath) {
    super(client);
    this.referencesPath = referencesPath;
    this.beaconPath = beaconPath;
  }

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withClassName(className: string) {
    this.className = className;
    return this;
  }

  withReference = (ref: Reference) => {
    this.reference = ref;
    return this;
  };

  withReferenceProperty = (refProp: string) => {
    this.refProp = refProp;
    return this;
  };

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = () => {
    this.validateIsSet(this.id, 'id', '.withId(id)');
    this.validateIsSet(this.refProp, 'referenceProperty', '.withReferenceProperty(refProp)');
  };

  payload = () => this.reference;

  do = () => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    if (!this.reference.beacon) {
      throw new Error('reference beacon must be set');
    }

    return Promise.all([
      this.referencesPath.build(this.id, this.className, this.refProp, this.consistencyLevel, this.tenant),
      this.beaconPath.rebuild(this.reference.beacon),
    ]).then((results) => {
      const path = results[0];
      const beacon = results[1];
      return this.client.delete(path, { beacon }, false);
    });
  };
}



---
File: /src/data/referencePayloadBuilder.ts
---

import Connection from '../connection/index.js';
import { Reference } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class ReferencePayloadBuilder extends CommandBase {
  private className?: string;
  private id?: string;

  constructor(client: Connection) {
    super(client);
  }

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withClassName(className: string) {
    this.className = className;
    return this;
  }

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = () => {
    this.validateIsSet(this.id, 'id', '.withId(id)');
  };

  payload = (): Reference => {
    this.validate();
    if (this.errors.length > 0) {
      throw new Error(this.errors.join(', '));
    }

    let beacon = `weaviate://localhost`;
    if (isValidStringProperty(this.className)) {
      beacon = `${beacon}/${this.className}`;
    }
    return {
      beacon: `${beacon}/${this.id}`,
    };
  };

  do(): Promise<any> {
    return Promise.reject(new Error('Should never be called'));
  }
}



---
File: /src/data/referenceReplacer.ts
---

import Connection from '../connection/index.js';
import { Reference } from '../openapi/types.js';
import { BeaconPath } from '../utils/beaconPath.js';
import { CommandBase } from '../validation/commandBase.js';
import { ReferencesPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class ReferenceReplacer extends CommandBase {
  private beaconPath: BeaconPath;
  private className!: string;
  private consistencyLevel?: ConsistencyLevel;
  private id!: string;
  private references!: Reference[];
  private referencesPath: ReferencesPath;
  private refProp!: string;
  private tenant?: string;

  constructor(client: Connection, referencesPath: ReferencesPath, beaconPath: BeaconPath) {
    super(client);
    this.beaconPath = beaconPath;
    this.referencesPath = referencesPath;
  }

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withClassName(className: string) {
    this.className = className;
    return this;
  }

  withReferences = (refs: any) => {
    this.references = refs;
    return this;
  };

  withReferenceProperty = (refProp: string) => {
    this.refProp = refProp;
    return this;
  };

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = () => {
    this.validateIsSet(this.id, 'id', '.withId(id)');
    this.validateIsSet(this.refProp, 'referenceProperty', '.withReferenceProperty(refProp)');
  };

  payload = () => this.references;

  do = () => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    const payloadPromise = Array.isArray(this.references)
      ? Promise.all(this.references.map((ref) => this.rebuildReferencePromise(ref)))
      : Promise.resolve([]);

    return Promise.all([
      this.referencesPath.build(this.id, this.className, this.refProp, this.consistencyLevel, this.tenant),
      payloadPromise,
    ]).then((results) => {
      const path = results[0];
      const payload = results[1];
      return this.client.put(path, payload, false);
    });
  };

  rebuildReferencePromise(reference: any) {
    return this.beaconPath.rebuild(reference.beacon).then((beacon: any) => ({ beacon }));
  }
}



---
File: /src/data/replication.ts
---

export type ConsistencyLevel = 'ALL' | 'ONE' | 'QUORUM';



---
File: /src/data/updater.ts
---

import Connection from '../connection/index.js';
import { Properties, WeaviateObject } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';
import { ObjectsPath } from './path.js';
import { ConsistencyLevel } from './replication.js';

export default class Updater extends CommandBase {
  private className!: string;
  private consistencyLevel?: ConsistencyLevel;
  private id!: string;
  private objectsPath: ObjectsPath;
  private properties?: Properties;
  private tenant?: string;
  private vector?: number[];
  private vectors?: Record<string, number[]>;

  constructor(client: Connection, objectsPath: ObjectsPath) {
    super(client);
    this.objectsPath = objectsPath;
  }

  withVector = (vector: number[]) => {
    this.vector = vector;
    return this;
  };

  withVectors = (vectors: Record<string, number[]>) => {
    this.vectors = vectors;
    return this;
  };

  withProperties = (properties: Properties) => {
    this.properties = properties;
    return this;
  };

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - use withClassName(className)');
    }
  };

  validateId = () => {
    if (this.id == undefined || this.id == null || this.id.length == 0) {
      this.addError('id must be set - initialize with updater(id)');
    }
  };

  withConsistencyLevel = (cl: ConsistencyLevel) => {
    this.consistencyLevel = cl;
    return this;
  };

  payload = (): WeaviateObject => ({
    tenant: this.tenant,
    properties: this.properties,
    class: this.className,
    id: this.id,
    vector: this.vector,
    vectors: this.vectors,
  });

  validate = () => {
    this.validateClassName();
    this.validateId();
  };

  do = () => {
    this.validate();

    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    return this.objectsPath
      .buildUpdate(this.id, this.className, this.consistencyLevel)
      .then((path: string) => this.client.put(path, this.payload()));
  };
}



---
File: /src/data/validator.ts
---

import Connection from '../connection/index.js';
import { Properties } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class Validator extends CommandBase {
  private className?: string;
  private id?: string;
  private properties?: Properties;

  constructor(client: Connection) {
    super(client);
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withProperties = (properties: Properties) => {
    this.properties = properties;
    return this;
  };

  withId = (id: string) => {
    this.id = id;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  payload = () => ({
    properties: this.properties,
    class: this.className,
    id: this.id,
  });

  validate = () => {
    this.validateClassName();
  };

  do = () => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const path = `/objects/validate`;
    return this.client.postEmpty(path, this.payload()).then(() => true);
  };
}



---
File: /src/graphql/aggregator.ts
---

import Connection from '../connection/index.js';
import { WhereFilter } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidPositiveIntProperty } from '../validation/number.js';
import NearMedia, {
  NearAudioArgs,
  NearDepthArgs,
  NearIMUArgs,
  NearMediaArgs,
  NearMediaBase,
  NearMediaType,
  NearVideoArgs,
} from './nearMedia.js';
import NearObject, { NearObjectArgs } from './nearObject.js';
import NearText, { NearTextArgs } from './nearText.js';
import NearVector, { NearVectorArgs } from './nearVector.js';
import Where from './where.js';

interface NearImageArgs extends NearMediaBase {
  image: string;
}

export default class Aggregator extends CommandBase {
  private className?: string;
  private fields?: string;
  private groupBy?: string[];
  private includesNearMediaFilter: boolean;
  private limit?: number;
  private nearMediaString?: string;
  private nearMediaType?: string;
  private nearObjectString?: string;
  private nearTextString?: string;
  private nearVectorString?: string;
  private objectLimit?: number;
  private whereString?: string;
  private tenant?: string;

  constructor(client: Connection) {
    super(client);
    this.includesNearMediaFilter = false;
  }

  withFields = (fields: string) => {
    this.fields = fields;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withWhere = (where: WhereFilter) => {
    try {
      this.whereString = new Where(where).toString();
    } catch (e: any) {
      this.addError(e as string);
    }
    return this;
  };

  private withNearMedia = (args: NearMediaArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearMediaString = new NearMedia(args).toString();
      this.nearMediaType = args.type;
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }

    return this;
  };

  withNearImage = (args: NearImageArgs) => {
    return this.withNearMedia({ ...args, media: args.image, type: NearMediaType.Image });
  };

  withNearAudio = (args: NearAudioArgs) => {
    return this.withNearMedia({ ...args, media: args.audio, type: NearMediaType.Audio });
  };

  withNearVideo = (args: NearVideoArgs) => {
    return this.withNearMedia({ ...args, media: args.video, type: NearMediaType.Video });
  };

  withNearDepth = (args: NearDepthArgs) => {
    return this.withNearMedia({ ...args, media: args.depth, type: NearMediaType.Depth });
  };

  withNearIMU = (args: NearIMUArgs) => {
    return this.withNearMedia({ ...args, media: args.imu, type: NearMediaType.IMU });
  };

  withNearText = (args: NearTextArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearTextString = new NearText(args).toString();
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withNearObject = (args: NearObjectArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearObjectString = new NearObject(args).toString();
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withNearVector = (args: NearVectorArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearVectorString = new NearVector(args).toString();
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withObjectLimit = (objectLimit: number) => {
    if (!isValidPositiveIntProperty(objectLimit)) {
      throw new Error('objectLimit must be a non-negative integer');
    }
    this.objectLimit = objectLimit;
    return this;
  };

  withLimit = (limit: number) => {
    this.limit = limit;
    return this;
  };

  withGroupBy = (groupBy: string[]) => {
    this.groupBy = groupBy;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateGroup = () => {
    if (!this.groupBy) {
      // nothing to check if this optional parameter is not set
      return;
    }

    if (!Array.isArray(this.groupBy)) {
      throw new Error('groupBy must be an array');
    }
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = () => {
    this.validateGroup();
    this.validateIsSet(this.className, 'className', '.withClassName(className)');
    this.validateIsSet(this.fields, 'fields', '.withFields(fields)');
  };

  do = () => {
    let params = '';

    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    if (
      this.whereString ||
      this.nearTextString ||
      this.nearObjectString ||
      this.nearVectorString ||
      this.limit ||
      this.groupBy ||
      this.tenant
    ) {
      let args: string[] = [];

      if (this.whereString) {
        args = [...args, `where:${this.whereString}`];
      }

      if (this.nearTextString) {
        args = [...args, `nearText:${this.nearTextString}`];
      }

      if (this.nearObjectString) {
        args = [...args, `nearObject:${this.nearObjectString}`];
      }

      if (this.nearVectorString) {
        args = [...args, `nearVector:${this.nearVectorString}`];
      }

      if (this.nearMediaString) {
        args = [...args, `${this.nearMediaType}:${this.nearMediaString}`];
      }

      if (this.groupBy) {
        args = [...args, `groupBy:${JSON.stringify(this.groupBy)}`];
      }

      if (this.limit) {
        args = [...args, `limit:${this.limit}`];
      }

      if (this.objectLimit) {
        args = [...args, `objectLimit:${this.objectLimit}`];
      }

      if (this.tenant) {
        args = [...args, `tenant:"${this.tenant}"`];
      }

      params = `(${args.join(',')})`;
    }

    return this.client.query(`{Aggregate{${this.className}${params}{${this.fields}}}}`);
  };
}



---
File: /src/graphql/ask.ts
---

export interface AskArgs {
  autocorrect?: boolean;
  certainty?: number;
  distance?: number;
  properties?: string[];
  question?: string;
  rerank?: boolean;
}

export default class GraphQLAsk {
  private autocorrect?: boolean;
  private certainty?: number;
  private distance?: number;
  private properties?: string[];
  private question?: string;
  private rerank?: boolean;

  constructor(args: AskArgs) {
    this.autocorrect = args.autocorrect;
    this.certainty = args.certainty;
    this.distance = args.distance;
    this.properties = args.properties;
    this.question = args.question;
    this.rerank = args.rerank;
  }

  toString(wrap = true) {
    this.validate();

    let args: any[] = [];

    if (this.question) {
      args = [...args, `question:${JSON.stringify(this.question)}`];
    }

    if (this.properties) {
      args = [...args, `properties:${JSON.stringify(this.properties)}`];
    }

    if (this.certainty) {
      args = [...args, `certainty:${this.certainty}`];
    }

    if (this.distance) {
      args = [...args, `distance:${this.distance}`];
    }

    if (this.autocorrect !== undefined) {
      args = [...args, `autocorrect:${this.autocorrect}`];
    }

    if (this.rerank !== undefined) {
      args = [...args, `rerank:${this.rerank}`];
    }

    if (!wrap) {
      return `${args.join(',')}`;
    }
    return `{${args.join(',')}}`;
  }

  validate() {
    if (!this.question) {
      throw new Error('ask filter: question needs to be set');
    }
  }
}



---
File: /src/graphql/bm25.ts
---

export interface Bm25Args {
  properties?: string[];
  query: string;
}

export default class GraphQLBm25 {
  private properties?: string[];
  private query: string;

  constructor(args: Bm25Args) {
    this.properties = args.properties;
    this.query = args.query;
  }

  toString() {
    let args = [`query:${JSON.stringify(this.query)}`]; // query must always be set

    if (this.properties !== undefined) {
      args = [...args, `properties:${JSON.stringify(this.properties)}`];
    }

    return `{${args.join(',')}}`;
  }
}



---
File: /src/graphql/explorer.ts
---

import Connection from '../connection/index.js';
import { CommandBase } from '../validation/commandBase.js';
import Ask, { AskArgs } from './ask.js';
import NearImage, { NearImageArgs } from './nearImage.js';
import NearMedia, {
  NearAudioArgs,
  NearDepthArgs,
  NearIMUArgs,
  NearMediaArgs,
  NearMediaType,
  NearThermalArgs,
  NearVideoArgs,
} from './nearMedia.js';
import NearObject, { NearObjectArgs } from './nearObject.js';
import NearText, { NearTextArgs } from './nearText.js';
import NearVector, { NearVectorArgs } from './nearVector.js';

export default class Explorer extends CommandBase {
  private askString?: string;
  private fields?: string;
  private group?: string[];
  private limit?: number;
  private includesNearMediaFilter: boolean;
  private nearMediaString?: string;
  private nearMediaType?: NearMediaType;
  private nearObjectString?: string;
  private nearTextString?: string;
  private nearVectorString?: string;
  private params: Record<string, any>;

  constructor(client: Connection) {
    super(client);
    this.params = {};
    this.includesNearMediaFilter = false;
  }

  withFields = (fields: string) => {
    this.fields = fields;
    return this;
  };

  withLimit = (limit: number) => {
    this.limit = limit;
    return this;
  };

  withNearText = (args: NearTextArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearTextString = new NearText(args).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withNearObject = (args: NearObjectArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearObjectString = new NearObject(args).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withAsk = (args: AskArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.askString = new Ask(args).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  private withNearMedia = (args: NearMediaArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearMediaString = new NearMedia(args).toString();
      this.nearMediaType = args.type;
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withNearImage = (args: NearImageArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearMediaString = new NearImage(args).toString();
      this.nearMediaType = NearMediaType.Image;
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withNearAudio = (args: NearAudioArgs) => {
    return this.withNearMedia({ ...args, media: args.audio, type: NearMediaType.Audio });
  };

  withNearVideo = (args: NearVideoArgs) => {
    return this.withNearMedia({ ...args, media: args.video, type: NearMediaType.Video });
  };

  withNearDepth = (args: NearDepthArgs) => {
    return this.withNearMedia({ ...args, media: args.depth, type: NearMediaType.Depth });
  };

  withNearThermal = (args: NearThermalArgs) => {
    return this.withNearMedia({ ...args, media: args.thermal, type: NearMediaType.Thermal });
  };

  withNearIMU = (args: NearIMUArgs) => {
    return this.withNearMedia({ ...args, media: args.imu, type: NearMediaType.IMU });
  };

  withNearVector = (args: NearVectorArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearVectorString = new NearVector(args).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  validateGroup = () => {
    if (!this.group) {
      // nothing to check if this optional parameter is not set
      return;
    }

    if (!Array.isArray(this.group)) {
      throw new Error('groupBy must be an array');
    }
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = () => {
    this.validateIsSet(this.fields, 'fields', '.withFields(fields)');
  };

  do = (): Promise<any> => {
    let params = '';

    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    let args: string[] = [];

    if (this.nearTextString) {
      args = [...args, `nearText:${this.nearTextString}`];
    }

    if (this.nearObjectString) {
      args = [...args, `nearObject:${this.nearObjectString}`];
    }

    if (this.askString) {
      args = [...args, `ask:${this.askString}`];
    }

    if (this.nearMediaString) {
      args = [...args, `${this.nearMediaType}:${this.nearMediaString}`];
    }

    if (this.nearVectorString) {
      args = [...args, `nearVector:${this.nearVectorString}`];
    }

    if (this.limit) {
      args = [...args, `limit:${this.limit}`];
    }

    params = `(${args.join(',')})`;

    return this.client.query(`{Explore${params}{${this.fields}}}`);
  };
}



---
File: /src/graphql/generate.ts
---

export interface GenerateArgs {
  groupedTask?: string;
  groupedProperties?: string[];
  singlePrompt?: string;
}

export interface GenerateParts {
  singleResult?: string;
  groupedResult?: string;
  results: string[];
}

export class GraphQLGenerate {
  private groupedTask?: string;
  private groupedProperties?: string[];
  private singlePrompt?: string;

  constructor(args: GenerateArgs) {
    this.groupedTask = args.groupedTask;
    this.groupedProperties = args.groupedProperties;
    this.singlePrompt = args.singlePrompt;
  }

  toString(): string {
    this.validate();

    let str = 'generate(';
    const results = ['error'];
    if (this.singlePrompt) {
      str += `singleResult:{prompt:"${this.singlePrompt.replace(/[\n\r]+/g, '')}"}`;
      results.push('singleResult');
    }
    if (this.groupedTask || (this.groupedProperties !== undefined && this.groupedProperties.length > 0)) {
      const args: string[] = [];
      if (this.groupedTask) {
        args.push(`task:"${this.groupedTask.replace(/[\n\r]+/g, '')}"`);
      }
      if (this.groupedProperties !== undefined && this.groupedProperties.length > 0) {
        args.push(`properties:${JSON.stringify(this.groupedProperties)}`);
      }
      str += `groupedResult:{${args.join(',')}}`;
      results.push('groupedResult');
    }
    str += `){${results.join(' ')}}`;
    return str;
  }

  private validate() {
    if (!this.groupedTask && !this.singlePrompt) {
      throw new Error('must provide at least one of `singlePrompt` or `groupTask`');
    }
    if (this.groupedTask !== undefined && this.groupedTask == '') {
      throw new Error('groupedTask must not be empty');
    }
    if (this.singlePrompt !== undefined && this.singlePrompt == '') {
      throw new Error('singlePrompt must not be empty');
    }
  }
}



---
File: /src/graphql/getter.test.ts
---

import { WhereFilter } from '../openapi/types.js';
import { AskArgs } from './ask.js';
import Getter, { FusionType } from './getter.js';
import { NearImageArgs } from './nearImage.js';
import { NearObjectArgs } from './nearObject.js';
import { NearTextArgs } from './nearText.js';
import { SortArgs } from './sort.js';

test('a simple query without params', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  const expectedQuery = `{Get{Person{name}}}`;

  new Getter(mockClient).withClassName('Person').withFields('name').do();

  expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
});

test('a simple query with a limit', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  const expectedQuery = `{Get{Person(limit:7){name}}}`;

  new Getter(mockClient).withClassName('Person').withFields('name').withLimit(7).do();

  expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
});

test('a simple query with a limit and offset', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  const expectedQuery = `{Get{Person(limit:7,offset:2){name}}}`;

  new Getter(mockClient).withClassName('Person').withFields('name').withOffset(2).withLimit(7).do();

  expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
});

test('a simple query with a limit and after', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  const expectedQuery = `{Get{Person(limit:7,after:"c6f379dd-94b7-4017-acd3-df769a320c92"){name}}}`;

  new Getter(mockClient)
    .withClassName('Person')
    .withFields('name')
    .withAfter('c6f379dd-94b7-4017-acd3-df769a320c92')
    .withLimit(7)
    .do();

  expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
});

test('a simple query with a group', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  const expectedQuery = `{Get{Person(group:{type:merge,force:0.7}){name}}}`;

  new Getter(mockClient)
    .withClassName('Person')
    .withFields('name')
    .withGroup({ type: 'merge', force: 0.7 })
    .do();

  expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
});

test('a simple query with autocut', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  const expectedQuery = `{Get{Person(where:{operator:Equal,valueText:"hawaii",path:["name"]},autocut:10){name}}}`;

  new Getter(mockClient)
    .withClassName('Person')
    .withAutocut(10)
    .withWhere({
      operator: 'Equal',
      valueText: 'hawaii',
      path: ['name'],
    })
    .withFields('name')
    .do();

  expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
});

describe('query with consistency level', () => {
  test('One', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(consistencyLevel:ONE){name}}}`;

    new Getter(mockClient).withClassName('Person').withFields('name').withConsistencyLevel('ONE').do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('Quorum', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(consistencyLevel:QUORUM){name}}}`;

    new Getter(mockClient).withClassName('Person').withFields('name').withConsistencyLevel('QUORUM').do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('All', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(consistencyLevel:ALL){name}}}`;

    new Getter(mockClient).withClassName('Person').withFields('name').withConsistencyLevel('ALL').do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('where filters', () => {
  test('a query with a valid where filter', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(where:{operator:Equal,valueText:"John Doe",path:["name"]}){name}}}`;
    const where: WhereFilter = {
      operator: 'Equal',
      valueText: 'John Doe',
      path: ['name'],
    };

    new Getter(mockClient).withClassName('Person').withFields('name').withWhere(where).do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a deprecated valueString', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(where:{operator:Equal,valueString:"John Doe",path:["name"]}){name}}}`;
    const where: WhereFilter = {
      operator: 'Equal',
      valueString: 'John Doe',
      path: ['name'],
    };

    new Getter(mockClient).withClassName('Person').withFields('name').withWhere(where).do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  // to prevent a regression on
  // https://github.com/weaviate/weaviate-javascript-client/issues/6
  test('a query with a where filter containing a geo query', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(where:{operator:WithinGeoRange,valueGeoRange:` +
      `{geoCoordinates:{latitude:51.51,longitude:-0.09},distance:{max:2000}}` +
      `,path:["name"]})` +
      `{name}}}`;
    const where: WhereFilter = {
      operator: 'WithinGeoRange',
      valueGeoRange: {
        geoCoordinates: {
          latitude: 51.51,
          longitude: -0.09,
        },
        distance: {
          max: 2000,
        },
      },
      path: ['name'],
    };

    new Getter(mockClient).withClassName('Person').withFields('name').withWhere(where).do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nested where filter', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(where:{operator:And,operands:[` +
      `{operator:Equal,valueString:"foo",path:["foo"]},` +
      `{operator:NotEqual,valueString:"bar",path:["bar"]}` +
      `]})` +
      `{name}}}`;
    const nestedWhere: WhereFilter = {
      operator: 'And',
      operands: [
        { valueString: 'foo', operator: 'Equal', path: ['foo'] },
        { valueString: 'bar', operator: 'NotEqual', path: ['bar'] },
      ],
    };

    new Getter(mockClient).withClassName('Person').withFields('name').withWhere(nestedWhere).do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('nearText searchers', () => {
  test('a query with a valid nearText', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearText:{concepts:["foo","bar"]})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({ concepts: ['foo', 'bar'] })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with optional parameters (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],certainty:0.7,moveTo:{concepts:["foo"],force:0.7},moveAwayFrom:{concepts:["bar"],force:0.5}})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        certainty: 0.7,
        moveTo: { concepts: ['foo'], force: 0.7 },
        moveAwayFrom: { concepts: ['bar'], force: 0.5 },
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with optional parameters (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],distance:0.3,moveTo:{concepts:["foo"],force:0.7},moveAwayFrom:{concepts:["bar"],force:0.5}})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        distance: 0.3,
        moveTo: { concepts: ['foo'], force: 0.7 },
        moveAwayFrom: { concepts: ['bar'], force: 0.5 },
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with optional parameters and autocorrect (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],certainty:0.7,moveTo:{concepts:["foo"],force:0.7},moveAwayFrom:{concepts:["bar"],force:0.5},autocorrect:true})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        certainty: 0.7,
        moveTo: { concepts: ['foo'], force: 0.7 },
        moveAwayFrom: { concepts: ['bar'], force: 0.5 },
        autocorrect: true,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with optional parameters and autocorrect (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],distance:0.7,moveTo:{concepts:["foo"],force:0.7},moveAwayFrom:{concepts:["bar"],force:0.5},autocorrect:true})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        distance: 0.7,
        moveTo: { concepts: ['foo'], force: 0.7 },
        moveAwayFrom: { concepts: ['bar'], force: 0.5 },
        autocorrect: true,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearText and autocorrect set to false', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(nearText:{concepts:["foo","bar"],autocorrect:false}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({ concepts: ['foo', 'bar'], autocorrect: false })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with moveTo with objects parameter (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],certainty:0.7,moveTo:{objects:[{id:"uuid"},{beacon:"beacon"}],force:0.7}})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        certainty: 0.7,
        moveTo: { force: 0.7, objects: [{ id: 'uuid' }, { beacon: 'beacon' }] },
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with moveTo with objects parameter (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],distance:0.7,moveTo:{objects:[{id:"uuid"},{beacon:"beacon"}],force:0.7}})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        distance: 0.7,
        moveTo: { force: 0.7, objects: [{ id: 'uuid' }, { beacon: 'beacon' }] },
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with moveAwayFrom with objects parameter (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],certainty:0.7,moveAwayFrom:{objects:[{id:"uuid"},{beacon:"beacon"}],force:0.7}})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        certainty: 0.7,
        moveAwayFrom: {
          force: 0.7,
          objects: [{ id: 'uuid' }, { beacon: 'beacon' }],
        },
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with moveAwayFrom with objects parameter (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],distance:0.7,moveAwayFrom:{objects:[{id:"uuid"},{beacon:"beacon"}],force:0.7}})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        distance: 0.7,
        moveAwayFrom: {
          force: 0.7,
          objects: [{ id: 'uuid' }, { beacon: 'beacon' }],
        },
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with moveTo and moveAway with objects parameter (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],certainty:0.7,moveTo:{objects:[{id:"uuid"}],force:0.7},moveAwayFrom:{objects:[{beacon:"beacon"}],force:0.5}})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        certainty: 0.7,
        moveTo: { force: 0.7, objects: [{ id: 'uuid' }] },
        moveAwayFrom: { force: 0.5, objects: [{ beacon: 'beacon' }] },
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with moveTo and moveAway with objects parameter (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(nearText:{concepts:["foo","bar"],distance:0.7,moveTo:{objects:[{id:"uuid"}],force:0.7},moveAwayFrom:{objects:[{beacon:"beacon"}],force:0.5}})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearText({
        concepts: ['foo', 'bar'],
        distance: 0.7,
        moveTo: { force: 0.7, objects: [{ id: 'uuid' }] },
        moveAwayFrom: { force: 0.5, objects: [{ beacon: 'beacon' }] },
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  describe('queries with invalid nearText searchers', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    interface testCase {
      title: string;
      nearText: NearTextArgs;
      msg: string;
    }

    const tests: testCase[] = [
      {
        title: 'moveTo empty object',
        nearText: { concepts: ['foo'], moveTo: {} },
        msg: 'nearText filter: moveTo.concepts or moveTo.objects must be present',
      },
      {
        title: 'moveTo without force with concepts',
        nearText: { concepts: ['foo'], moveTo: { concepts: ['foo'] } },
        msg: "nearText filter: moveTo must have fields 'concepts' or 'objects' and 'force'",
      },
      {
        title: 'moveTo without force with objects',
        nearText: {
          concepts: ['foo'],
          moveTo: { objects: [{ beacon: 'beacon' }] },
        },
        msg: "nearText filter: moveTo must have fields 'concepts' or 'objects' and 'force'",
      },
      {
        title: 'moveAwayFrom without concepts',
        nearText: { concepts: ['foo'], moveAwayFrom: {} },
        msg: 'nearText filter: moveAwayFrom.concepts or moveAwayFrom.objects must be present',
      },
      {
        title: 'moveAwayFrom without force with concepts',
        nearText: { concepts: ['foo'], moveAwayFrom: { concepts: ['foo'] } },
        msg: "nearText filter: moveAwayFrom must have fields 'concepts' or 'objects' and 'force'",
      },
      {
        title: 'moveAwayFrom without force with objects',
        nearText: {
          concepts: ['foo'],
          moveAwayFrom: { objects: [{ id: 'uuid' }] },
        },
        msg: "nearText filter: moveAwayFrom must have fields 'concepts' or 'objects' and 'force'",
      },
      {
        title: 'moveTo with empty object in objects',
        nearText: { concepts: ['foo'], moveTo: { force: 0.8, objects: [{}] } },
        msg: 'nearText: moveTo.objects[0].id or moveTo.objects[0].beacon must be present',
      },
      {
        title: 'moveAwayFrom with empty object in objects',
        nearText: {
          concepts: ['foo'],
          moveAwayFrom: { force: 0.8, objects: [{}] },
        },
        msg: 'nearText: moveAwayFrom.objects[0].id or moveAwayFrom.objects[0].beacon must be present',
      },
    ];

    tests.forEach((t) => {
      test(t.title, () => {
        expect(() => {
          new Getter(mockClient).withClassName('Person').withFields('name').withNearText(t.nearText);
        }).toThrow(t.msg);
      });
    });
  });
});

describe('nearVector searchers', () => {
  test('a query with a valid nearVector', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearVector:{vector:[0.1234,0.9876]})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearVector({ vector: [0.1234, 0.9876] })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with optional parameters (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(nearVector:{vector:[0.1234,0.9876],certainty:0.7}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearVector({
        vector: [0.1234, 0.9876],
        certainty: 0.7,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('with optional parameters (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(nearVector:{vector:[0.1234,0.9876],distance:0.7}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearVector({
        vector: [0.1234, 0.9876],
        distance: 0.7,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('nearObject searchers', () => {
  test('a query with a valid nearObject with id', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearObject:{id:"some-uuid"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearObject({ id: 'some-uuid' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearObject with beacon', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearObject:{beacon:"weaviate/some-uuid"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearObject({ beacon: 'weaviate/some-uuid' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearObject with all params (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(nearObject:{id:"some-uuid",beacon:"weaviate/some-uuid",certainty:0.7}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearObject({
        id: 'some-uuid',
        beacon: 'weaviate/some-uuid',
        certainty: 0.7,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearObject with all params (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(nearObject:{id:"some-uuid",beacon:"weaviate/some-uuid",distance:0.7}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearObject({
        id: 'some-uuid',
        beacon: 'weaviate/some-uuid',
        distance: 0.7,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  describe('queries with invalid nearObject searchers', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    interface testCase {
      title: string;
      nearObject: NearObjectArgs;
      msg: string;
    }

    const tests: testCase[] = [
      {
        title: 'an empty nearObject',
        nearObject: {},
        msg: 'nearObject filter: id or beacon needs to be set',
      },
    ];

    tests.forEach((t) => {
      test(t.title, () => {
        new Getter(mockClient)
          .withClassName('Person')
          .withFields('name')
          .withNearObject(t.nearObject)
          .do()
          .then(() => {
            throw new Error('it should have errord');
          })
          .catch((e: any) => {
            expect(e.toString()).toContain(t.msg);
          });
      });
    });
  });
});

describe('ask searchers', () => {
  test('a query with a valid ask with question', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(ask:{question:"What is Weaviate?"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({ question: 'What is Weaviate?' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with question and properties', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(ask:{question:"What is Weaviate?",properties:["prop1","prop2"]}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({
        question: 'What is Weaviate?',
        properties: ['prop1', 'prop2'],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with question, properties, certainty', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(ask:{question:"What is Weaviate?",properties:["prop1","prop2"],certainty:0.8})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({
        question: 'What is Weaviate?',
        properties: ['prop1', 'prop2'],
        certainty: 0.8,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with question, properties, distance', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(ask:{question:"What is Weaviate?",properties:["prop1","prop2"],distance:0.8})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({
        question: 'What is Weaviate?',
        properties: ['prop1', 'prop2'],
        distance: 0.8,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with all params (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(ask:{question:"What is Weaviate?",properties:["prop1","prop2"],certainty:0.8,autocorrect:true,rerank:true})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({
        question: 'What is Weaviate?',
        properties: ['prop1', 'prop2'],
        certainty: 0.8,
        autocorrect: true,
        rerank: true,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with all params (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(ask:{question:"What is Weaviate?",properties:["prop1","prop2"],distance:0.8,autocorrect:true,rerank:true})` +
      `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({
        question: 'What is Weaviate?',
        properties: ['prop1', 'prop2'],
        distance: 0.8,
        autocorrect: true,
        rerank: true,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with question and autocorrect', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(ask:{question:"What is Weaviate?",autocorrect:true}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({ question: 'What is Weaviate?', autocorrect: true })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with question and autocorrect set to false', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(ask:{question:"What is Weaviate?",autocorrect:false}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({ question: 'What is Weaviate?', autocorrect: false })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with question and rerank', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(ask:{question:"What is Weaviate?",rerank:true}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({ question: 'What is Weaviate?', rerank: true })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid ask with question and rerank set to false', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(ask:{question:"What is Weaviate?",rerank:false}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withAsk({ question: 'What is Weaviate?', rerank: false })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  describe('queries with invalid ask searchers', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    interface testCase {
      title: string;
      ask: AskArgs;
      msg: string;
    }

    const tests: testCase[] = [
      {
        title: 'an empty ask',
        ask: {},
        msg: 'ask filter: question needs to be set',
      },
    ];

    tests.forEach((t) => {
      test(t.title, () => {
        new Getter(mockClient)
          .withClassName('Person')
          .withFields('name')
          .withAsk(t.ask)
          .do()
          .then(() => {
            throw new Error('it should have errord');
          })
          .catch((e: any) => {
            expect(e.toString()).toContain(t.msg);
          });
      });
    });
  });
});

describe('nearImage searchers', () => {
  test('a query with a valid nearImage with image', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearImage:{image:"iVBORw0KGgoAAAANS"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearImage({ image: 'iVBORw0KGgoAAAANS' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearImage with all params (with certainty)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(nearImage:{image:"iVBORw0KGgoAAAANS",certainty:0.8}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearImage({
        image: 'iVBORw0KGgoAAAANS',
        certainty: 0.8,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearImage with all params (with distance)', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(nearImage:{image:"iVBORw0KGgoAAAANS",distance:0.8}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearImage({
        image: 'iVBORw0KGgoAAAANS',
        distance: 0.8,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearImage with base64 encoded image', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearImage:{image:"iVBORw0KGgoAAAANS"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearImage({ image: 'data:image/png;base64,iVBORw0KGgoAAAANS' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  describe('queries with invalid nearImage searchers', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    interface testCase {
      title: string;
      nearImage: NearImageArgs;
      msg: string;
    }

    const tests: testCase[] = [
      {
        title: 'an empty nearImage',
        nearImage: {},
        msg: 'nearImage filter: image field must be present',
      },
    ];

    tests.forEach((t) => {
      test(t.title, () => {
        new Getter(mockClient)
          .withClassName('Person')
          .withFields('name')
          .withNearImage(t.nearImage)
          .do()
          .then(() => {
            throw new Error('it should have errord');
          })
          .catch((e: any) => {
            expect(e.toString()).toContain(t.msg);
          });
      });
    });
  });
});

describe('nearMedia searchers', () => {
  test('a query with a valid nearVideo', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearVideo:{video:"iVBORw0KGgoAAAANS"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearVideo({ video: 'iVBORw0KGgoAAAANS' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearVideo with all params', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery = `{Get{Person(nearVideo:{video:"iVBORw0KGgoAAAANS",certainty:0.8,distance:0.6}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearVideo({
        video: 'iVBORw0KGgoAAAANS',
        certainty: 0.8,
        distance: 0.6,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearAudio', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearAudio:{audio:"iVBORw0KGgoAAAANS"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearAudio({ audio: 'iVBORw0KGgoAAAANS' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearThermal', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearThermal:{thermal:"iVBORw0KGgoAAAANS"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearThermal({ thermal: 'iVBORw0KGgoAAAANS' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearDepth', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearDepth:{depth:"iVBORw0KGgoAAAANS"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearDepth({ depth: 'iVBORw0KGgoAAAANS' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid nearIMU', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(nearIMU:{imu:"iVBORw0KGgoAAAANS"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withNearIMU({ imu: 'iVBORw0KGgoAAAANS' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('sort filters', () => {
  test('a query with a valid sort filter', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(sort:[{path:["property"],order:asc}])`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    const sort: SortArgs[] = [{ path: ['property'], order: 'asc' }];

    new Getter(mockClient).withClassName('Person').withFields('name').withSort(sort).do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid array of sort filter', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const subQuery = `(sort:[{path:["property"],order:asc}])`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    const sort = [{ path: ['property'], order: 'asc' }];

    new Getter(mockClient).withClassName('Person').withFields('name').withSort(sort).do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('a query with a valid array of sort filters', () => {
    const mockClient: any = {
      query: jest.fn(),
    };

    const expectedQuery =
      `{Get{Person` +
      `(sort:[{path:["property1"],order:asc},{path:["property2"],order:asc},{path:["property3"],order:desc}])` +
      `{name}}}`;

    const sort = [
      { path: ['property1'], order: 'asc' },
      { path: ['property2'], order: 'asc' },
      { path: ['property3'], order: 'desc' },
    ];

    new Getter(mockClient).withClassName('Person').withFields('name').withSort(sort).do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('bm25 valid searchers', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  test('query and no properties', () => {
    const subQuery = `(bm25:{query:"accountant"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient).withClassName('Person').withFields('name').withBm25({ query: 'accountant' }).do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and properties', () => {
    const expectedQuery = `{Get{Person(bm25:{query:"accountant",properties:["profession","position"]}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withBm25({ query: 'accountant', properties: ['profession', 'position'] })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and empty properties', () => {
    const subQuery = `(bm25:{query:"accountant",properties:[]})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withBm25({ query: 'accountant', properties: [] })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and groupby', () => {
    const expectedQuery = `{Get{Person(bm25:{query:"accountant"},groupBy:{path:["employer"],groups:2,objectsPerGroup:3}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withBm25({
        query: 'accountant',
      })
      .withGroupBy({ path: ['employer'], groups: 2, objectsPerGroup: 3 })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('hybrid valid searchers', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  test('query and no alpha, no vector', () => {
    const subQuery = `(hybrid:{query:"accountant"})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({ query: 'accountant' })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and alpha, no vector', () => {
    const subQuery = `(hybrid:{query:"accountant",alpha:0.75})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({ query: 'accountant', alpha: 0.75 })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and alpha 0, no vector', () => {
    const subQuery = `(hybrid:{query:"accountant",alpha:0})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({ query: 'accountant', alpha: 0 })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and vector, no alpha', () => {
    const expectedQuery = `{Get{Person(hybrid:{query:"accountant",vector:[1,2,3]}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({ query: 'accountant', vector: [1, 2, 3] })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and alpha and vector', () => {
    const expectedQuery = `{Get{Person(hybrid:{query:"accountant",alpha:0.75,vector:[1,2,3]}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({ query: 'accountant', alpha: 0.75, vector: [1, 2, 3] })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('queries and properties', () => {
    const expectedQuery = `{Get{Person(hybrid:{query:"accountant",properties:["name","employer"]}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({ query: 'accountant', properties: ['name', 'employer'] })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and alpha 0 and fusionType', () => {
    const subQuery = `(hybrid:{query:"accountant",alpha:0,fusionType:rankedFusion})`;
    const expectedQuery = `{Get{Person` + subQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({ query: 'accountant', alpha: 0, fusionType: FusionType.rankedFusion })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and groupby', () => {
    const expectedQuery = `{Get{Person(hybrid:{query:"accountant"},groupBy:{path:["employer"],groups:2,objectsPerGroup:3}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({
        query: 'accountant',
      })
      .withGroupBy({ path: ['employer'], groups: 2, objectsPerGroup: 3 })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('query and subsearches', () => {
    const subQuery = `searches:[{nearVector:{vector:[1,2,3],certainty:0.8,targetVectors:["employer"]}},{nearText:{concepts:["accountant"],distance:0.3,moveTo:{concepts:["foo"],objects:[{id:"uuid"}],force:0.8}}}]`;
    const expectedQuery = `{Get{Person(hybrid:{query:"accountant",${subQuery}}){name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withHybrid({
        query: 'accountant',
        searches: [
          { nearVector: { certainty: 0.8, targetVectors: ['employer'], vector: [1, 2, 3] } },
          {
            nearText: {
              concepts: ['accountant'],
              distance: 0.3,
              moveTo: {
                concepts: ['foo'],
                objects: [{ id: 'uuid' }],
                force: 0.8,
              },
            },
          },
        ],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('generative search', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  test('singlePrompt', () => {
    const expectedQuery =
      '{Get{Mammal{name taxonomy _additional{generate(singleResult:' +
      '{prompt:"When did dogs become mans best friend?"}){error singleResult}}}}}';
    new Getter(mockClient)
      .withClassName('Mammal')
      .withGenerate({
        singlePrompt: 'When did dogs become mans best friend?',
      })
      .withFields('name taxonomy')
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('singlePrompt with newlines', () => {
    const expectedQuery =
      '{Get{Mammal{name taxonomy _additional{generate(singleResult:' +
      '{prompt:"Which mammals can survive in Antarctica?"}){error singleResult}}}}}';

    new Getter(mockClient)
      .withClassName('Mammal')
      .withGenerate({
        singlePrompt: `Which mammals
 can survive
 in Antarctica?`,
      })
      .withFields('name taxonomy')
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('groupedTask', () => {
    const expectedQuery =
      '{Get{Mammal{name taxonomy _additional{generate(groupedResult:' +
      '{task:"Explain why platypi can lay eggs"}){error groupedResult}}}}}';

    new Getter(mockClient)
      .withClassName('Mammal')
      .withGenerate({
        groupedTask: 'Explain why platypi can lay eggs',
      })
      .withFields('name taxonomy')
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('groupedTask with newlines', () => {
    const expectedQuery =
      '{Get{Mammal{name taxonomy _additional{generate(groupedResult:' +
      '{task:"Tell me about how polar bears keep warm"}){error groupedResult}}}}}';

    new Getter(mockClient)
      .withClassName('Mammal')
      .withFields('name taxonomy')
      .withGenerate({
        groupedTask: `Tell
 me
 about
 how
 polar
 bears
 keep
 warm`,
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('single prompt and grouped task', () => {
    const expectedQuery =
      '{Get{Mammal{name taxonomy _additional{generate(singleResult:' +
      '{prompt:"How tall is a baby giraffe?"}groupedResult:{task:' +
      '"Explain how the heights of mammals relate to their prefferred food sources"})' +
      '{error singleResult groupedResult}}}}}';

    new Getter(mockClient)
      .withClassName('Mammal')
      .withFields('name taxonomy')
      .withGenerate({
        singlePrompt: 'How tall is a baby giraffe?',
        groupedTask: 'Explain how the heights of mammals relate to their prefferred food sources',
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('groupedTask with properties', () => {
    const expectedQuery =
      '{Get{Mammal{name taxonomy _additional{generate(groupedResult:' +
      '{task:"Explain why platypi can lay eggs",properties:["title","description"]}){error groupedResult}}}}}';

    new Getter(mockClient)
      .withClassName('Mammal')
      .withGenerate({
        groupedTask: 'Explain why platypi can lay eggs',
        groupedProperties: ['title', 'description'],
      })
      .withFields('name taxonomy')
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test('single prompt and grouped task with properties', () => {
    const expectedQuery =
      '{Get{Mammal{name taxonomy _additional{generate(singleResult:' +
      '{prompt:"How tall is a baby giraffe?"}groupedResult:{task:' +
      '"Explain how the heights of mammals relate to their prefferred food sources",properties:["property"]})' +
      '{error singleResult groupedResult}}}}}';

    new Getter(mockClient)
      .withClassName('Mammal')
      .withFields('name taxonomy')
      .withGenerate({
        singlePrompt: 'How tall is a baby giraffe?',
        groupedTask: 'Explain how the heights of mammals relate to their prefferred food sources',
        groupedProperties: ['property'],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('groupBy valid searchers', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  test('valid groupBy', () => {
    const groupByQuery = `(groupBy:{path:["property"],groups:2,objectsPerGroup:3})`;
    const expectedQuery = `{Get{Person` + groupByQuery + `{name}}}`;

    new Getter(mockClient)
      .withClassName('Person')
      .withFields('name')
      .withGroupBy({ path: ['property'], groups: 2, objectsPerGroup: 3 })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});

describe('query with where with ContainsAny / ContainsAll operators', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  const operators: Array<WhereFilter['operator']> = ['ContainsAll', 'ContainsAny'];

  test.each(operators)('valueTextArray with %s', (operator) => {
    const whereQuery = `(where:{operator:` + operator + `,valueText:["red","blue","green"],path:["colors"]})`;
    const expectedQuery = `{Get{WhereTest` + whereQuery + `{colors}}}`;

    new Getter(mockClient)
      .withClassName('WhereTest')
      .withFields('colors')
      .withWhere({
        operator,
        path: ['colors'],
        valueTextArray: ['red', 'blue', 'green'],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test.each(operators)('valueStringArray with %s', (operator) => {
    const whereQuery = `(where:{operator:` + operator + `,valueString:["red"],path:["colors"]})`;
    const expectedQuery = `{Get{WhereTest` + whereQuery + `{colors}}}`;

    new Getter(mockClient)
      .withClassName('WhereTest')
      .withFields('colors')
      .withWhere({
        operator,
        path: ['colors'],
        valueStringArray: ['red'],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test.each(operators)('valueNumberArray with %s', (operator) => {
    const whereQuery = `(where:{operator:` + operator + `,valueNumber:[1.1,2.1],path:["numbers"]})`;
    const expectedQuery = `{Get{WhereTest` + whereQuery + `{numbers}}}`;

    new Getter(mockClient)
      .withClassName('WhereTest')
      .withFields('numbers')
      .withWhere({
        operator,
        path: ['numbers'],
        valueNumberArray: [1.1, 2.1],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test.each(operators)('valueIntArray with %s', (operator) => {
    const whereQuery = `(where:{operator:` + operator + `,valueInt:[1],path:["numbers"]})`;
    const expectedQuery = `{Get{WhereTest` + whereQuery + `{numbers}}}`;

    new Getter(mockClient)
      .withClassName('WhereTest')
      .withFields('numbers')
      .withWhere({
        operator,
        path: ['numbers'],
        valueIntArray: [1],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test.each(operators)('valueDateArray with %s', (operator) => {
    const whereQuery =
      `(where:{operator:` + operator + `,valueDate:["2009-11-01T23:00:00Z"],path:["dates"]})`;
    const expectedQuery = `{Get{WhereTest` + whereQuery + `{dates}}}`;

    new Getter(mockClient)
      .withClassName('WhereTest')
      .withFields('dates')
      .withWhere({
        operator,
        path: ['dates'],
        valueDateArray: ['2009-11-01T23:00:00Z'],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });

  test.each(operators)('valueBooleanArray with %s', (operator) => {
    const whereQuery = `(where:{operator:` + operator + `,valueBoolean:[true,false],path:["bools"]})`;
    const expectedQuery = `{Get{WhereTest` + whereQuery + `{bools}}}`;

    new Getter(mockClient)
      .withClassName('WhereTest')
      .withFields('bools')
      .withWhere({
        operator,
        path: ['bools'],
        valueBooleanArray: [true, false],
      })
      .do();

    expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
  });
});



---
File: /src/graphql/getter.ts
---

import Connection from '../connection/index.js';
import { ConsistencyLevel } from '../data/index.js';
import { WhereFilter } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import Ask, { AskArgs } from './ask.js';
import Bm25, { Bm25Args } from './bm25.js';
import { GenerateArgs, GraphQLGenerate } from './generate.js';
import Group, { GroupArgs } from './group.js';
import GroupBy, { GroupByArgs } from './groupBy.js';
import Hybrid, { HybridArgs } from './hybrid.js';
import NearImage, { NearImageArgs } from './nearImage.js';
import NearMedia, {
  NearAudioArgs,
  NearDepthArgs,
  NearIMUArgs,
  NearMediaArgs,
  NearMediaType,
  NearThermalArgs,
  NearVideoArgs,
} from './nearMedia.js';
import NearObject, { NearObjectArgs } from './nearObject.js';
import NearText, { NearTextArgs } from './nearText.js';
import NearVector, { NearVectorArgs } from './nearVector.js';
import Sort, { SortArgs } from './sort.js';
import Where from './where.js';

export { FusionType } from './hybrid.js';
export default class GraphQLGetter extends CommandBase {
  private after?: string;
  private askString?: string;
  private bm25String?: string;
  private className?: string;
  private fields?: string;
  private groupString?: string;
  private hybridString?: string;
  private includesNearMediaFilter: boolean;
  private limit?: number;
  private nearImageNotSet?: boolean;
  private nearMediaString?: string;
  private nearMediaType?: NearMediaType;
  private nearObjectString?: string;
  private nearTextString?: string;
  private nearVectorString?: string;
  private offset?: number;
  private sortString?: string;
  private whereString?: string;
  private generateString?: string;
  private consistencyLevel?: ConsistencyLevel;
  private groupByString?: string;
  private tenant?: string;
  private autocut?: number;

  constructor(client: Connection) {
    super(client);
    this.includesNearMediaFilter = false;
  }

  withFields = (fields: string) => {
    this.fields = fields;
    return this;
  };

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withAfter = (id: string) => {
    this.after = id;
    return this;
  };

  withGroup = (args: GroupArgs) => {
    try {
      this.groupString = new Group(args).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }

    return this;
  };

  withWhere = (whereObj: WhereFilter) => {
    try {
      this.whereString = new Where(whereObj).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withNearText = (args: NearTextArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }

    this.nearTextString = new NearText(args).toString();
    this.includesNearMediaFilter = true;

    return this;
  };

  withBm25 = (args: Bm25Args) => {
    try {
      this.bm25String = new Bm25(args).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }

    return this;
  };

  withHybrid = (args: HybridArgs) => {
    try {
      this.hybridString = new Hybrid(args).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }

    return this;
  };

  withNearObject = (args: NearObjectArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }

    try {
      this.nearObjectString = new NearObject(args).toString();
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }

    return this;
  };

  withAsk = (askObj: AskArgs) => {
    try {
      this.askString = new Ask(askObj).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  private withNearMedia = (args: NearMediaArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearMediaString = new NearMedia(args).toString();
      this.nearMediaType = args.type;
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withNearImage = (args: NearImageArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }
    try {
      this.nearMediaString = new NearImage(args).toString();
      this.nearMediaType = NearMediaType.Image;
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withNearAudio = (args: NearAudioArgs) => {
    return this.withNearMedia({
      ...args,
      type: NearMediaType.Audio,
      media: args.audio,
    });
  };

  withNearVideo = (args: NearVideoArgs) => {
    return this.withNearMedia({
      ...args,
      type: NearMediaType.Video,
      media: args.video,
    });
  };

  withNearThermal = (args: NearThermalArgs) => {
    return this.withNearMedia({
      ...args,
      type: NearMediaType.Thermal,
      media: args.thermal,
    });
  };

  withNearDepth = (args: NearDepthArgs) => {
    return this.withNearMedia({
      ...args,
      type: NearMediaType.Depth,
      media: args.depth,
    });
  };

  withNearIMU = (args: NearIMUArgs) => {
    return this.withNearMedia({
      ...args,
      type: NearMediaType.IMU,
      media: args.imu,
    });
  };

  withNearVector = (args: NearVectorArgs) => {
    if (this.includesNearMediaFilter) {
      throw new Error('cannot use multiple near<Media> filters in a single query');
    }

    try {
      this.nearVectorString = new NearVector(args).toString();
      this.includesNearMediaFilter = true;
    } catch (e: any) {
      this.addError(e.toString());
    }

    return this;
  };

  withLimit = (limit: number) => {
    this.limit = limit;
    return this;
  };

  withOffset = (offset: number) => {
    this.offset = offset;
    return this;
  };

  withAutocut = (autocut: number) => {
    this.autocut = autocut;
    return this;
  };

  withSort = (args: SortArgs[]) => {
    this.sortString = new Sort(args).toString();
    return this;
  };

  withGenerate = (args: GenerateArgs) => {
    this.generateString = new GraphQLGenerate(args).toString();
    return this;
  };

  withConsistencyLevel = (level: ConsistencyLevel) => {
    this.consistencyLevel = level;
    return this;
  };

  withGroupBy = (args: GroupByArgs) => {
    try {
      this.groupByString = new GroupBy(args).toString();
    } catch (e: any) {
      this.addError(e.toString());
    }
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = () => {
    this.validateIsSet(this.className, 'className', '.withClassName(className)');
    this.validateIsSet(this.fields, 'fields', '.withFields(fields)');
  };

  do = () => {
    let params = '';

    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    let args: string[] = [];
    if (this.whereString) {
      args = [...args, `where:${this.whereString}`];
    }

    if (this.nearTextString) {
      args = [...args, `nearText:${this.nearTextString}`];
    }

    if (this.nearObjectString) {
      args = [...args, `nearObject:${this.nearObjectString}`];
    }

    if (this.askString) {
      args = [...args, `ask:${this.askString}`];
    }

    if (this.nearMediaString) {
      args = [...args, `near${this.nearMediaType}:${this.nearMediaString}`];
    }

    if (this.nearVectorString) {
      args = [...args, `nearVector:${this.nearVectorString}`];
    }

    if (this.bm25String) {
      args = [...args, `bm25:${this.bm25String}`];
    }

    if (this.hybridString) {
      args = [...args, `hybrid:${this.hybridString}`];
    }

    if (this.groupString) {
      args = [...args, `group:${this.groupString}`];
    }

    if (this.limit) {
      args = [...args, `limit:${this.limit}`];
    }

    if (this.offset) {
      args = [...args, `offset:${this.offset}`];
    }

    if (this.autocut) {
      args = [...args, `autocut:${this.autocut}`];
    }

    if (this.sortString) {
      args = [...args, `sort:[${this.sortString}]`];
    }

    if (this.after) {
      args = [...args, `after:"${this.after}"`];
    }

    if (this.generateString) {
      if (this.fields?.includes('_additional')) {
        this.fields.replace('_additional{', `_additional{${this.generateString}`);
      } else {
        this.fields = this.fields?.concat(` _additional{${this.generateString}}`);
      }
    }

    if (this.consistencyLevel) {
      args = [...args, `consistencyLevel:${this.consistencyLevel}`];
    }

    if (this.groupByString) {
      args = [...args, `groupBy:${this.groupByString}`];
    }

    if (this.tenant) {
      args = [...args, `tenant:"${this.tenant}"`];
    }

    if (args.length > 0) {
      params = `(${args.join(',')})`;
    }

    return this.client.query(`{Get{${this.className}${params}{${this.fields}}}}`);
  };
}



---
File: /src/graphql/group.ts
---

export interface GroupArgs {
  type: string;
  force: number;
}

export default class GraphQLGroup {
  private args: GroupArgs;

  constructor(args: GroupArgs) {
    this.args = args;
  }

  toString() {
    let parts: any[] = [];

    if (this.args.type) {
      // value is a graphQL enum, so doesn't need to be quoted
      parts = [...parts, `type:${this.args.type}`];
    }

    if (this.args.force) {
      parts = [...parts, `force:${this.args.force}`];
    }

    return `{${parts.join(',')}}`;
  }
}



---
File: /src/graphql/groupBy.ts
---

export interface GroupByArgs {
  path: string[];
  groups: number;
  objectsPerGroup: number;
}

export default class GraphQLGroupBy {
  private args: GroupByArgs;

  constructor(args: GroupByArgs) {
    this.args = args;
  }

  toString() {
    let parts: string[] = [];

    if (this.args.path) {
      parts = [...parts, `path:${JSON.stringify(this.args.path)}`];
    }

    if (this.args.groups) {
      parts = [...parts, `groups:${this.args.groups}`];
    }

    if (this.args.objectsPerGroup) {
      parts = [...parts, `objectsPerGroup:${this.args.objectsPerGroup}`];
    }

    return `{${parts.join(',')}}`;
  }
}



---
File: /src/graphql/hybrid.ts
---

import { Move, parseMove } from './nearText.js';

export interface HybridArgs {
  alpha?: number;
  query: string;
  vector?: number[];
  properties?: string[];
  targetVectors?: string[];
  fusionType?: FusionType;
  searches?: HybridSubSearch[];
}

export interface NearTextSubSearch {
  concepts: string[];
  certainty?: number;
  distance?: number;
  moveAwayFrom?: Move;
  moveTo?: Move;
}

export interface NearVectorSubSearch {
  vector: number[];
  certainty?: number;
  distance?: number;
  targetVectors?: string[];
}

export interface HybridSubSearch {
  nearText?: NearTextSubSearch;
  nearVector?: NearVectorSubSearch;
}

export enum FusionType {
  rankedFusion = 'rankedFusion',
  relativeScoreFusion = 'relativeScoreFusion',
}

class GraphQLHybridSubSearch {
  private nearText?: NearTextSubSearch;
  private nearVector?: NearVectorSubSearch;

  constructor(args: HybridSubSearch) {
    this.nearText = args.nearText;
    this.nearVector = args.nearVector;
  }

  toString(): string {
    let outer: string[] = [];
    if (this.nearText !== undefined) {
      let inner = [`concepts:${JSON.stringify(this.nearText.concepts)}`];
      if (this.nearText.certainty) {
        inner = [...inner, `certainty:${this.nearText.certainty}`];
      }
      if (this.nearText.distance) {
        inner = [...inner, `distance:${this.nearText.distance}`];
      }
      if (this.nearText.moveTo) {
        inner = [...inner, parseMove('moveTo', this.nearText.moveTo)];
      }
      if (this.nearText.moveAwayFrom) {
        inner = [...inner, parseMove('moveAwayFrom', this.nearText.moveAwayFrom)];
      }
      outer = [...outer, `nearText:{${inner.join(',')}}`];
    }
    if (this.nearVector !== undefined) {
      let inner = [`vector:${JSON.stringify(this.nearVector.vector)}`];
      if (this.nearVector.certainty) {
        inner = [...inner, `certainty:${this.nearVector.certainty}`];
      }
      if (this.nearVector.distance) {
        inner = [...inner, `distance:${this.nearVector.distance}`];
      }
      if (this.nearVector.targetVectors && this.nearVector.targetVectors.length > 0) {
        inner = [...inner, `targetVectors:${JSON.stringify(this.nearVector.targetVectors)}`];
      }
      outer = [...outer, `nearVector:{${inner.join(',')}}`];
    }
    return `{${outer.join(',')}}`;
  }
}

export default class GraphQLHybrid {
  private alpha?: number;
  private query: string;
  private vector?: number[];
  private properties?: string[];
  private targetVectors?: string[];
  private fusionType?: FusionType;
  private searches?: GraphQLHybridSubSearch[];

  constructor(args: HybridArgs) {
    this.alpha = args.alpha;
    this.query = args.query;
    this.vector = args.vector;
    this.properties = args.properties;
    this.targetVectors = args.targetVectors;
    this.fusionType = args.fusionType;
    this.searches = args.searches?.map((search) => new GraphQLHybridSubSearch(search));
  }

  toString() {
    let args = [`query:${JSON.stringify(this.query)}`]; // query must always be set

    if (this.alpha !== undefined) {
      args = [...args, `alpha:${JSON.stringify(this.alpha)}`];
    }

    if (this.vector !== undefined) {
      args = [...args, `vector:${JSON.stringify(this.vector)}`];
    }

    if (this.properties && this.properties.length > 0) {
      args = [...args, `properties:${JSON.stringify(this.properties)}`];
    }

    if (this.targetVectors && this.targetVectors.length > 0) {
      args = [...args, `targetVectors:${JSON.stringify(this.targetVectors)}`];
    }

    if (this.fusionType !== undefined) {
      args = [...args, `fusionType:${this.fusionType}`];
    }

    if (this.searches !== undefined) {
      args = [...args, `searches:[${this.searches.map((search) => search.toString()).join(',')}]`];
    }

    return `{${args.join(',')}}`;
  }
}



---
File: /src/graphql/index.ts
---

import Connection from '../connection/index.js';
import Aggregator from './aggregator.js';
import Explorer from './explorer.js';
import GraphQLGetter from './getter.js';
import Raw from './raw.js';

export interface GraphQL {
  get: () => GraphQLGetter;
  aggregate: () => Aggregator;
  explore: () => Explorer;
  raw: () => Raw;
}

const graphql = (client: Connection): GraphQL => {
  return {
    get: () => new GraphQLGetter(client),
    aggregate: () => new Aggregator(client),
    explore: () => new Explorer(client),
    raw: () => new Raw(client),
  };
};

export default graphql;
export { default as Aggregator } from './aggregator.js';
export { default as Explorer } from './explorer.js';
export { FusionType, default as GraphQLGetter } from './getter.js';
export { default as Raw } from './raw.js';



---
File: /src/graphql/journey.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import weaviate, {
  Meta,
  Reference,
  ReferenceCreator,
  Tenant,
  WeaviateClass,
  WeaviateClient,
  WeaviateError,
  WeaviateObject,
  WhereFilter,
} from '../v2/index.js';
import { FusionType } from './hybrid.js';

describe('the graphql journey', () => {
  let client: WeaviateClient;
  let versionLessThan125: boolean;

  beforeEach(async () => {
    client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });
    versionLessThan125 = await client.misc
      .metaGetter()
      .do()
      .then((res: Meta) => res.version!.localeCompare('1.25.0') < 0);
  });

  it('creates a schema class', () => {
    // this is just test setup, not part of what we want to test here
    return setup(client);
  });

  test('graphql raw method', () => {
    return client.graphql
      .raw()
      .withQuery('{Get{Article{title url wordCount}}}')
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toEqual(3);
      });
  });

  test('graphql get method with minimal fields', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('title url wordCount')
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toEqual(3);
      });
  });

  test('graphql get objects after id (Cursor API)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withLimit(10)
      .withAfter('abefd256-8574-442b-9293-9205193737e0')
      .withFields('title url wordCount')
      .do()
      .then(function (result) {
        // one fewer than all
        expect(result.data.Get.Article.length).toEqual(2);
      });
  });

  test('graphql get method with optional fields (with certainty)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('title url wordCount')
      .withNearText({ concepts: ['news'], certainty: 0.1 })
      .withWhere({
        operator: 'GreaterThanEqual',
        path: ['wordCount'],
        valueInt: 50,
      })
      .withLimit(7)
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toBeLessThan(3);
        expect(result.data.Get.Article[0].title.length).toBeGreaterThan(0);
        expect(result.data.Get.Article[0].url.length).toBeGreaterThan(0);
        expect(result.data.Get.Article[0].wordCount).toBeGreaterThanOrEqual(50);
      });
  });

  test('graphql get method with optional fields (with distance)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('title url wordCount')
      .withNearText({ concepts: ['news'], distance: 0.9 })
      .withWhere({
        operator: 'GreaterThanEqual',
        path: ['wordCount'],
        valueInt: 50,
      })
      .withLimit(7)
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toBeLessThan(3);
        expect(result.data.Get.Article[0].title.length).toBeGreaterThan(0);
        expect(result.data.Get.Article[0].url.length).toBeGreaterThan(0);
        expect(result.data.Get.Article[0].wordCount).toBeGreaterThanOrEqual(50);
      });
  });

  test('graphql get with group', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('title url wordCount')
      .withGroup({ type: 'merge', force: 1.0 })
      .withLimit(7)
      .do()
      .then(function (result) {
        // merging with a force of 1 means we merge everyting into a single
        // element
        expect(result.data.Get.Article.length).toBe(1);
      });
  });

  test('graphql get with nearVector (with certainty)', () => {
    const searchVec = [
      -0.15047126, 0.061322376, -0.17812507, 0.12811552, 0.36847013, -0.50840724, -0.10406531, 0.11413283,
      0.2997712, 0.7039331, 0.22155242, 0.1413957, 0.025396502, 0.14802167, 0.26640236, 0.15965445,
      -0.45570126, -0.5215438, 0.14628491, 0.10946681, 0.0040095793, 0.017442623, -0.1988451, -0.05362646,
      0.104278944, -0.2506941, 0.2667653, 0.36438593, -0.44370207, 0.07204353, 0.077371456, 0.14557181,
      0.6026817, 0.45073593, 0.09438019, 0.03936342, -0.20441438, 0.12333719, -0.20247602, 0.5078446,
      -0.06079732, -0.02166342, 0.02165861, -0.11712191, 0.0493167, -0.012123002, 0.26458082, -0.10784768,
      -0.26852348, 0.049759883, -0.39999008, -0.08977922, 0.003169497, -0.36184034, -0.069065355, 0.18940343,
      0.5684866, -0.24626277, -0.2326087, 0.090373255, 0.33161184, -1.0541122, -0.039116446, -0.17496277,
      -0.16834813, -0.0765323, -0.16189013, -0.062876746, -0.19826415, 0.07437007, -0.018362755, 0.23634757,
      -0.19062655, -0.26524994, 0.33691254, -0.1926698, 0.018848037, 0.1735524, 0.34301907, -0.014238952,
      -0.07596742, -0.61302894, -0.044652265, 0.1545376, 0.67256856, 0.08630557, 0.50236076, 0.23438522,
      0.27686095, 0.13633616, -0.27525797, 0.04282576, 0.18319897, -0.008353968, -0.27330264, 0.12624736,
      -0.17051372, -0.35854533, -0.008455927, 0.154786, -0.20306401, -0.09021733, 0.80594194, 0.036562894,
      -0.48894945, -0.27981675, -0.5001396, -0.3581464, -0.057082724, -0.0051904973, -0.3209166, 0.057098284,
      0.111587055, -0.09097725, -0.213181, -0.5038173, -0.024070809, -0.05350453, 0.13345918, -0.42136985,
      0.24050911, -0.2556207, 0.03156968, 0.4381214, 0.053237516, -0.20783865, 1.885739, 0.28429136,
      -0.12231187, -0.30934808, 0.032250155, -0.32959512, 0.08670603, -0.60112613, -0.43010503, 0.70870006,
      0.3548015, -0.010406012, 0.036294986, 0.0030629474, -0.017579105, 0.28948352, -0.48063236, -0.39739868,
      0.17860937, 0.5099417, -0.24304488, -0.12671146, -0.018249692, -0.32057074, -0.08146134, 0.3572229,
      -0.47601065, 0.35100546, -0.19663939, 0.34194613, -0.04653828, 0.47278664, -0.8723091, -0.19756387,
      -0.5890681, 0.16688067, -0.23709822, -0.26478595, -0.18792373, 0.2204168, 0.030987943, 0.15885714,
      -0.38817936, -0.4194334, -0.3287098, 0.15394142, -0.09496768, 0.6561987, -0.39340565, -0.5479265,
      -0.22363484, -0.1193662, 0.2014849, 0.31138006, -0.45485613, -0.9879565, 0.3708223, 0.17318928,
      0.21229307, 0.042776756, -0.077399045, 0.42621315, -0.09917796, 0.34220153, 0.06380378, 0.14129028,
      -0.14563583, -0.07081333, 0.026335392, 0.10566285, -0.28074324, -0.059861198, -0.24855351, 0.13623764,
      -0.8228192, -0.15095113, 0.16250934, 0.031107651, -0.1504525, 0.20840737, 0.12919411, -0.0926323,
      0.30937102, 0.16636328, -0.36754072, 0.035581365, -0.2799259, 0.1446048, -0.11680267, 0.13226685,
      0.175023, -0.18840964, 0.27609056, -0.09350581, 0.08284562, 0.45897093, 0.13188471, -0.07115303,
      0.18009436, 0.16689545, -0.6991295, 0.26496106, -0.29619592, -0.19242188, -0.6362671, -0.16330126,
      0.2474778, 0.37738156, -0.12921557, -0.07843309, 0.28509396, 0.5658691, 0.16096894, 0.095068075,
      0.02419672, -0.30691084, 0.21180221, 0.21670066, 0.0027263877, 0.30853105, -0.16187873, 0.20786561,
      0.22136153, -0.008828387, -0.011165021, 0.60076475, 0.0089871045, 0.6179727, -0.38049766, -0.08179336,
      -0.15306218, -0.13186441, -0.5360041, -0.06123339, -0.06399122, 0.21292226, -0.18383273, -0.21540102,
      0.28566808, -0.29953584, -0.36946672, 0.03341637, -0.08435299, -0.5381947, -0.28651953, 0.08704594,
      -0.25493965, 0.0019178925, -0.7242109, 0.3578676, -0.55617595, -0.01930952, 0.32922924, 0.14903364,
      0.21613406, -0.11927183, 0.15165499, -0.10101261, 0.2499076, -0.18526322, -0.057230365, 0.10008554,
      0.16178907, 0.39356324, -0.03106238, 0.09375929, 0.17185533, 0.10400415, -0.36850816, 0.18424486,
      -0.081376314, 0.23645392, 0.05198973, 0.09471436,
    ];

    return client.graphql
      .get()
      .withClassName('Article')
      .withNearVector({ vector: searchVec, certainty: 0.7 })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get with nearVector (with distance)', () => {
    const searchVec = [
      -0.15047126, 0.061322376, -0.17812507, 0.12811552, 0.36847013, -0.50840724, -0.10406531, 0.11413283,
      0.2997712, 0.7039331, 0.22155242, 0.1413957, 0.025396502, 0.14802167, 0.26640236, 0.15965445,
      -0.45570126, -0.5215438, 0.14628491, 0.10946681, 0.0040095793, 0.017442623, -0.1988451, -0.05362646,
      0.104278944, -0.2506941, 0.2667653, 0.36438593, -0.44370207, 0.07204353, 0.077371456, 0.14557181,
      0.6026817, 0.45073593, 0.09438019, 0.03936342, -0.20441438, 0.12333719, -0.20247602, 0.5078446,
      -0.06079732, -0.02166342, 0.02165861, -0.11712191, 0.0493167, -0.012123002, 0.26458082, -0.10784768,
      -0.26852348, 0.049759883, -0.39999008, -0.08977922, 0.003169497, -0.36184034, -0.069065355, 0.18940343,
      0.5684866, -0.24626277, -0.2326087, 0.090373255, 0.33161184, -1.0541122, -0.039116446, -0.17496277,
      -0.16834813, -0.0765323, -0.16189013, -0.062876746, -0.19826415, 0.07437007, -0.018362755, 0.23634757,
      -0.19062655, -0.26524994, 0.33691254, -0.1926698, 0.018848037, 0.1735524, 0.34301907, -0.014238952,
      -0.07596742, -0.61302894, -0.044652265, 0.1545376, 0.67256856, 0.08630557, 0.50236076, 0.23438522,
      0.27686095, 0.13633616, -0.27525797, 0.04282576, 0.18319897, -0.008353968, -0.27330264, 0.12624736,
      -0.17051372, -0.35854533, -0.008455927, 0.154786, -0.20306401, -0.09021733, 0.80594194, 0.036562894,
      -0.48894945, -0.27981675, -0.5001396, -0.3581464, -0.057082724, -0.0051904973, -0.3209166, 0.057098284,
      0.111587055, -0.09097725, -0.213181, -0.5038173, -0.024070809, -0.05350453, 0.13345918, -0.42136985,
      0.24050911, -0.2556207, 0.03156968, 0.4381214, 0.053237516, -0.20783865, 1.885739, 0.28429136,
      -0.12231187, -0.30934808, 0.032250155, -0.32959512, 0.08670603, -0.60112613, -0.43010503, 0.70870006,
      0.3548015, -0.010406012, 0.036294986, 0.0030629474, -0.017579105, 0.28948352, -0.48063236, -0.39739868,
      0.17860937, 0.5099417, -0.24304488, -0.12671146, -0.018249692, -0.32057074, -0.08146134, 0.3572229,
      -0.47601065, 0.35100546, -0.19663939, 0.34194613, -0.04653828, 0.47278664, -0.8723091, -0.19756387,
      -0.5890681, 0.16688067, -0.23709822, -0.26478595, -0.18792373, 0.2204168, 0.030987943, 0.15885714,
      -0.38817936, -0.4194334, -0.3287098, 0.15394142, -0.09496768, 0.6561987, -0.39340565, -0.5479265,
      -0.22363484, -0.1193662, 0.2014849, 0.31138006, -0.45485613, -0.9879565, 0.3708223, 0.17318928,
      0.21229307, 0.042776756, -0.077399045, 0.42621315, -0.09917796, 0.34220153, 0.06380378, 0.14129028,
      -0.14563583, -0.07081333, 0.026335392, 0.10566285, -0.28074324, -0.059861198, -0.24855351, 0.13623764,
      -0.8228192, -0.15095113, 0.16250934, 0.031107651, -0.1504525, 0.20840737, 0.12919411, -0.0926323,
      0.30937102, 0.16636328, -0.36754072, 0.035581365, -0.2799259, 0.1446048, -0.11680267, 0.13226685,
      0.175023, -0.18840964, 0.27609056, -0.09350581, 0.08284562, 0.45897093, 0.13188471, -0.07115303,
      0.18009436, 0.16689545, -0.6991295, 0.26496106, -0.29619592, -0.19242188, -0.6362671, -0.16330126,
      0.2474778, 0.37738156, -0.12921557, -0.07843309, 0.28509396, 0.5658691, 0.16096894, 0.095068075,
      0.02419672, -0.30691084, 0.21180221, 0.21670066, 0.0027263877, 0.30853105, -0.16187873, 0.20786561,
      0.22136153, -0.008828387, -0.011165021, 0.60076475, 0.0089871045, 0.6179727, -0.38049766, -0.08179336,
      -0.15306218, -0.13186441, -0.5360041, -0.06123339, -0.06399122, 0.21292226, -0.18383273, -0.21540102,
      0.28566808, -0.29953584, -0.36946672, 0.03341637, -0.08435299, -0.5381947, -0.28651953, 0.08704594,
      -0.25493965, 0.0019178925, -0.7242109, 0.3578676, -0.55617595, -0.01930952, 0.32922924, 0.14903364,
      0.21613406, -0.11927183, 0.15165499, -0.10101261, 0.2499076, -0.18526322, -0.057230365, 0.10008554,
      0.16178907, 0.39356324, -0.03106238, 0.09375929, 0.17185533, 0.10400415, -0.36850816, 0.18424486,
      -0.081376314, 0.23645392, 0.05198973, 0.09471436,
    ];

    return client.graphql
      .get()
      .withClassName('Article')
      .withNearVector({ vector: searchVec, distance: 0.3 })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get with nearObject (with certainty)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withNearObject({
        id: 'abefd256-8574-442b-9293-9205193737e0',
        certainty: 0.7,
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get with nearObject (with distance)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withNearObject({
        id: 'abefd256-8574-442b-9293-9205193737e0',
        distance: 0.3,
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get bm25 with query (without properties)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withBm25({ query: 'Article' })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get bm25 with query (with properties)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withBm25({ query: 'Apple', properties: ['title', 'url'] })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get bm25 with query (with properties not having searched query)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withBm25({ query: 'Apple', properties: ['url'] })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(0);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get bm25 with query and groupby', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withBm25({ query: 'Apple' })
      .withGroupBy({
        path: ['title'],
        objectsPerGroup: 1,
        groups: 1,
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get nearText with autocut', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'] })
      .withAutocut(3)
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query (no vector, alpha 0)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({ query: 'apple', alpha: 0 })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query (no vector, alpha 0.5)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({ query: 'Apple', alpha: 0.5 })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query (with vector)', () => {
    const dummyVec300x0 = Array.from({ length: 300 }, () => 0);

    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({ query: 'Apple', alpha: 0.5, vector: dummyVec300x0 })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query, alpha, and properties', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({ query: 'Apple', properties: ['title'], alpha: 0 })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query, alpha, properties and fushionType: rankedFusion', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({ query: 'Apple', properties: ['title'], alpha: 0, fusionType: FusionType.rankedFusion })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query, alpha, properties and fushionType: relativeScoreFusion', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({
        query: 'Apple',
        properties: ['title'],
        alpha: 0,
        fusionType: FusionType.relativeScoreFusion,
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query and groupby', () => {
    if (versionLessThan125) {
      return Promise.resolve();
    }
    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({ query: 'Apple', properties: ['title'], alpha: 0 })
      .withGroupBy({
        path: ['title'],
        objectsPerGroup: 1,
        groups: 1,
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query and nearText subsearch', () => {
    if (versionLessThan125) {
      return Promise.resolve();
    }
    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({
        query: '',
        searches: [
          {
            nearText: {
              concepts: ['Article'],
              certainty: 0.7,
            },
          },
        ],
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get hybrid with query and nearVector subsearch', () => {
    const searchVec = [
      -0.15047126, 0.061322376, -0.17812507, 0.12811552, 0.36847013, -0.50840724, -0.10406531, 0.11413283,
      0.2997712, 0.7039331, 0.22155242, 0.1413957, 0.025396502, 0.14802167, 0.26640236, 0.15965445,
      -0.45570126, -0.5215438, 0.14628491, 0.10946681, 0.0040095793, 0.017442623, -0.1988451, -0.05362646,
      0.104278944, -0.2506941, 0.2667653, 0.36438593, -0.44370207, 0.07204353, 0.077371456, 0.14557181,
      0.6026817, 0.45073593, 0.09438019, 0.03936342, -0.20441438, 0.12333719, -0.20247602, 0.5078446,
      -0.06079732, -0.02166342, 0.02165861, -0.11712191, 0.0493167, -0.012123002, 0.26458082, -0.10784768,
      -0.26852348, 0.049759883, -0.39999008, -0.08977922, 0.003169497, -0.36184034, -0.069065355, 0.18940343,
      0.5684866, -0.24626277, -0.2326087, 0.090373255, 0.33161184, -1.0541122, -0.039116446, -0.17496277,
      -0.16834813, -0.0765323, -0.16189013, -0.062876746, -0.19826415, 0.07437007, -0.018362755, 0.23634757,
      -0.19062655, -0.26524994, 0.33691254, -0.1926698, 0.018848037, 0.1735524, 0.34301907, -0.014238952,
      -0.07596742, -0.61302894, -0.044652265, 0.1545376, 0.67256856, 0.08630557, 0.50236076, 0.23438522,
      0.27686095, 0.13633616, -0.27525797, 0.04282576, 0.18319897, -0.008353968, -0.27330264, 0.12624736,
      -0.17051372, -0.35854533, -0.008455927, 0.154786, -0.20306401, -0.09021733, 0.80594194, 0.036562894,
      -0.48894945, -0.27981675, -0.5001396, -0.3581464, -0.057082724, -0.0051904973, -0.3209166, 0.057098284,
      0.111587055, -0.09097725, -0.213181, -0.5038173, -0.024070809, -0.05350453, 0.13345918, -0.42136985,
      0.24050911, -0.2556207, 0.03156968, 0.4381214, 0.053237516, -0.20783865, 1.885739, 0.28429136,
      -0.12231187, -0.30934808, 0.032250155, -0.32959512, 0.08670603, -0.60112613, -0.43010503, 0.70870006,
      0.3548015, -0.010406012, 0.036294986, 0.0030629474, -0.017579105, 0.28948352, -0.48063236, -0.39739868,
      0.17860937, 0.5099417, -0.24304488, -0.12671146, -0.018249692, -0.32057074, -0.08146134, 0.3572229,
      -0.47601065, 0.35100546, -0.19663939, 0.34194613, -0.04653828, 0.47278664, -0.8723091, -0.19756387,
      -0.5890681, 0.16688067, -0.23709822, -0.26478595, -0.18792373, 0.2204168, 0.030987943, 0.15885714,
      -0.38817936, -0.4194334, -0.3287098, 0.15394142, -0.09496768, 0.6561987, -0.39340565, -0.5479265,
      -0.22363484, -0.1193662, 0.2014849, 0.31138006, -0.45485613, -0.9879565, 0.3708223, 0.17318928,
      0.21229307, 0.042776756, -0.077399045, 0.42621315, -0.09917796, 0.34220153, 0.06380378, 0.14129028,
      -0.14563583, -0.07081333, 0.026335392, 0.10566285, -0.28074324, -0.059861198, -0.24855351, 0.13623764,
      -0.8228192, -0.15095113, 0.16250934, 0.031107651, -0.1504525, 0.20840737, 0.12919411, -0.0926323,
      0.30937102, 0.16636328, -0.36754072, 0.035581365, -0.2799259, 0.1446048, -0.11680267, 0.13226685,
      0.175023, -0.18840964, 0.27609056, -0.09350581, 0.08284562, 0.45897093, 0.13188471, -0.07115303,
      0.18009436, 0.16689545, -0.6991295, 0.26496106, -0.29619592, -0.19242188, -0.6362671, -0.16330126,
      0.2474778, 0.37738156, -0.12921557, -0.07843309, 0.28509396, 0.5658691, 0.16096894, 0.095068075,
      0.02419672, -0.30691084, 0.21180221, 0.21670066, 0.0027263877, 0.30853105, -0.16187873, 0.20786561,
      0.22136153, -0.008828387, -0.011165021, 0.60076475, 0.0089871045, 0.6179727, -0.38049766, -0.08179336,
      -0.15306218, -0.13186441, -0.5360041, -0.06123339, -0.06399122, 0.21292226, -0.18383273, -0.21540102,
      0.28566808, -0.29953584, -0.36946672, 0.03341637, -0.08435299, -0.5381947, -0.28651953, 0.08704594,
      -0.25493965, 0.0019178925, -0.7242109, 0.3578676, -0.55617595, -0.01930952, 0.32922924, 0.14903364,
      0.21613406, -0.11927183, 0.15165499, -0.10101261, 0.2499076, -0.18526322, -0.057230365, 0.10008554,
      0.16178907, 0.39356324, -0.03106238, 0.09375929, 0.17185533, 0.10400415, -0.36850816, 0.18424486,
      -0.081376314, 0.23645392, 0.05198973, 0.09471436,
    ];

    if (versionLessThan125) {
      return Promise.resolve();
    }

    return client.graphql
      .get()
      .withClassName('Article')
      .withHybrid({
        query: '',
        searches: [
          {
            nearVector: {
              vector: searchVec,
              certainty: 0.7,
            },
          },
        ],
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get with nearText (with certainty)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'], certainty: 0.7 })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get with nearText (with distance)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'], distance: 0.3 })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get with nearText with moveTo and moveAwayFrom (with certainty)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withNearText({
        concepts: ['Article'],
        certainty: 0.7,
        moveTo: {
          objects: [{ id: 'abefd256-8574-442b-9293-9205193737e2' }],
          force: 0.7,
        },
        moveAwayFrom: {
          objects: [{ id: 'abefd256-8574-442b-9293-9205193737e1' }],
          force: 0.5,
        },
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get with nearText with moveTo and moveAwayFrom (with distance)', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withNearText({
        concepts: ['Article'],
        distance: 0.3,
        moveTo: {
          objects: [{ id: 'abefd256-8574-442b-9293-9205193737e2' }],
          force: 0.7,
        },
        moveAwayFrom: {
          objects: [{ id: 'abefd256-8574-442b-9293-9205193737e1' }],
          force: 0.5,
        },
      })
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBe(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get expected failure - multiple nearMedia filters (with certainty)', () => {
    return expect(() => {
      client.graphql
        .get()
        .withClassName('Article')
        .withNearText({ concepts: ['iphone'] })
        .withNearObject({
          id: 'abefd256-8574-442b-9293-9205193737e0',
          certainty: 0.65,
        })
        .do();
    }).toThrow('cannot use multiple near<Media> filters in a single query');
  });

  test('graphql get expected failure - multiple nearMedia filters (with distance)', () => {
    return expect(() => {
      client.graphql
        .get()
        .withClassName('Article')
        .withNearText({ concepts: ['iphone'] })
        .withNearObject({
          id: 'abefd256-8574-442b-9293-9205193737e0',
          distance: 0.35,
        })
        .do();
    }).toThrow('cannot use multiple near<Media> filters in a single query');
  });

  test('graphql aggregate method with minimal fields', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method optional fields', () => {
    // Note this test is ignoring `.withGroupBy()` due to
    // https://github.com/semi-technologies/weaviate/issues/1238

    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withWhere({
        path: ['title'],
        valueText: 'apple',
        operator: 'Equal',
      })
      .withLimit(10)
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with nearVector (with certainty)', () => {
    const searchVec = [
      -0.15047126, 0.061322376, -0.17812507, 0.12811552, 0.36847013, -0.50840724, -0.10406531, 0.11413283,
      0.2997712, 0.7039331, 0.22155242, 0.1413957, 0.025396502, 0.14802167, 0.26640236, 0.15965445,
      -0.45570126, -0.5215438, 0.14628491, 0.10946681, 0.0040095793, 0.017442623, -0.1988451, -0.05362646,
      0.104278944, -0.2506941, 0.2667653, 0.36438593, -0.44370207, 0.07204353, 0.077371456, 0.14557181,
      0.6026817, 0.45073593, 0.09438019, 0.03936342, -0.20441438, 0.12333719, -0.20247602, 0.5078446,
      -0.06079732, -0.02166342, 0.02165861, -0.11712191, 0.0493167, -0.012123002, 0.26458082, -0.10784768,
      -0.26852348, 0.049759883, -0.39999008, -0.08977922, 0.003169497, -0.36184034, -0.069065355, 0.18940343,
      0.5684866, -0.24626277, -0.2326087, 0.090373255, 0.33161184, -1.0541122, -0.039116446, -0.17496277,
      -0.16834813, -0.0765323, -0.16189013, -0.062876746, -0.19826415, 0.07437007, -0.018362755, 0.23634757,
      -0.19062655, -0.26524994, 0.33691254, -0.1926698, 0.018848037, 0.1735524, 0.34301907, -0.014238952,
      -0.07596742, -0.61302894, -0.044652265, 0.1545376, 0.67256856, 0.08630557, 0.50236076, 0.23438522,
      0.27686095, 0.13633616, -0.27525797, 0.04282576, 0.18319897, -0.008353968, -0.27330264, 0.12624736,
      -0.17051372, -0.35854533, -0.008455927, 0.154786, -0.20306401, -0.09021733, 0.80594194, 0.036562894,
      -0.48894945, -0.27981675, -0.5001396, -0.3581464, -0.057082724, -0.0051904973, -0.3209166, 0.057098284,
      0.111587055, -0.09097725, -0.213181, -0.5038173, -0.024070809, -0.05350453, 0.13345918, -0.42136985,
      0.24050911, -0.2556207, 0.03156968, 0.4381214, 0.053237516, -0.20783865, 1.885739, 0.28429136,
      -0.12231187, -0.30934808, 0.032250155, -0.32959512, 0.08670603, -0.60112613, -0.43010503, 0.70870006,
      0.3548015, -0.010406012, 0.036294986, 0.0030629474, -0.017579105, 0.28948352, -0.48063236, -0.39739868,
      0.17860937, 0.5099417, -0.24304488, -0.12671146, -0.018249692, -0.32057074, -0.08146134, 0.3572229,
      -0.47601065, 0.35100546, -0.19663939, 0.34194613, -0.04653828, 0.47278664, -0.8723091, -0.19756387,
      -0.5890681, 0.16688067, -0.23709822, -0.26478595, -0.18792373, 0.2204168, 0.030987943, 0.15885714,
      -0.38817936, -0.4194334, -0.3287098, 0.15394142, -0.09496768, 0.6561987, -0.39340565, -0.5479265,
      -0.22363484, -0.1193662, 0.2014849, 0.31138006, -0.45485613, -0.9879565, 0.3708223, 0.17318928,
      0.21229307, 0.042776756, -0.077399045, 0.42621315, -0.09917796, 0.34220153, 0.06380378, 0.14129028,
      -0.14563583, -0.07081333, 0.026335392, 0.10566285, -0.28074324, -0.059861198, -0.24855351, 0.13623764,
      -0.8228192, -0.15095113, 0.16250934, 0.031107651, -0.1504525, 0.20840737, 0.12919411, -0.0926323,
      0.30937102, 0.16636328, -0.36754072, 0.035581365, -0.2799259, 0.1446048, -0.11680267, 0.13226685,
      0.175023, -0.18840964, 0.27609056, -0.09350581, 0.08284562, 0.45897093, 0.13188471, -0.07115303,
      0.18009436, 0.16689545, -0.6991295, 0.26496106, -0.29619592, -0.19242188, -0.6362671, -0.16330126,
      0.2474778, 0.37738156, -0.12921557, -0.07843309, 0.28509396, 0.5658691, 0.16096894, 0.095068075,
      0.02419672, -0.30691084, 0.21180221, 0.21670066, 0.0027263877, 0.30853105, -0.16187873, 0.20786561,
      0.22136153, -0.008828387, -0.011165021, 0.60076475, 0.0089871045, 0.6179727, -0.38049766, -0.08179336,
      -0.15306218, -0.13186441, -0.5360041, -0.06123339, -0.06399122, 0.21292226, -0.18383273, -0.21540102,
      0.28566808, -0.29953584, -0.36946672, 0.03341637, -0.08435299, -0.5381947, -0.28651953, 0.08704594,
      -0.25493965, 0.0019178925, -0.7242109, 0.3578676, -0.55617595, -0.01930952, 0.32922924, 0.14903364,
      0.21613406, -0.11927183, 0.15165499, -0.10101261, 0.2499076, -0.18526322, -0.057230365, 0.10008554,
      0.16178907, 0.39356324, -0.03106238, 0.09375929, 0.17185533, 0.10400415, -0.36850816, 0.18424486,
      -0.081376314, 0.23645392, 0.05198973, 0.09471436,
    ];

    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearVector({ vector: searchVec, certainty: 0.7 })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with nearVector (with distance)', () => {
    const searchVec = [
      -0.15047126, 0.061322376, -0.17812507, 0.12811552, 0.36847013, -0.50840724, -0.10406531, 0.11413283,
      0.2997712, 0.7039331, 0.22155242, 0.1413957, 0.025396502, 0.14802167, 0.26640236, 0.15965445,
      -0.45570126, -0.5215438, 0.14628491, 0.10946681, 0.0040095793, 0.017442623, -0.1988451, -0.05362646,
      0.104278944, -0.2506941, 0.2667653, 0.36438593, -0.44370207, 0.07204353, 0.077371456, 0.14557181,
      0.6026817, 0.45073593, 0.09438019, 0.03936342, -0.20441438, 0.12333719, -0.20247602, 0.5078446,
      -0.06079732, -0.02166342, 0.02165861, -0.11712191, 0.0493167, -0.012123002, 0.26458082, -0.10784768,
      -0.26852348, 0.049759883, -0.39999008, -0.08977922, 0.003169497, -0.36184034, -0.069065355, 0.18940343,
      0.5684866, -0.24626277, -0.2326087, 0.090373255, 0.33161184, -1.0541122, -0.039116446, -0.17496277,
      -0.16834813, -0.0765323, -0.16189013, -0.062876746, -0.19826415, 0.07437007, -0.018362755, 0.23634757,
      -0.19062655, -0.26524994, 0.33691254, -0.1926698, 0.018848037, 0.1735524, 0.34301907, -0.014238952,
      -0.07596742, -0.61302894, -0.044652265, 0.1545376, 0.67256856, 0.08630557, 0.50236076, 0.23438522,
      0.27686095, 0.13633616, -0.27525797, 0.04282576, 0.18319897, -0.008353968, -0.27330264, 0.12624736,
      -0.17051372, -0.35854533, -0.008455927, 0.154786, -0.20306401, -0.09021733, 0.80594194, 0.036562894,
      -0.48894945, -0.27981675, -0.5001396, -0.3581464, -0.057082724, -0.0051904973, -0.3209166, 0.057098284,
      0.111587055, -0.09097725, -0.213181, -0.5038173, -0.024070809, -0.05350453, 0.13345918, -0.42136985,
      0.24050911, -0.2556207, 0.03156968, 0.4381214, 0.053237516, -0.20783865, 1.885739, 0.28429136,
      -0.12231187, -0.30934808, 0.032250155, -0.32959512, 0.08670603, -0.60112613, -0.43010503, 0.70870006,
      0.3548015, -0.010406012, 0.036294986, 0.0030629474, -0.017579105, 0.28948352, -0.48063236, -0.39739868,
      0.17860937, 0.5099417, -0.24304488, -0.12671146, -0.018249692, -0.32057074, -0.08146134, 0.3572229,
      -0.47601065, 0.35100546, -0.19663939, 0.34194613, -0.04653828, 0.47278664, -0.8723091, -0.19756387,
      -0.5890681, 0.16688067, -0.23709822, -0.26478595, -0.18792373, 0.2204168, 0.030987943, 0.15885714,
      -0.38817936, -0.4194334, -0.3287098, 0.15394142, -0.09496768, 0.6561987, -0.39340565, -0.5479265,
      -0.22363484, -0.1193662, 0.2014849, 0.31138006, -0.45485613, -0.9879565, 0.3708223, 0.17318928,
      0.21229307, 0.042776756, -0.077399045, 0.42621315, -0.09917796, 0.34220153, 0.06380378, 0.14129028,
      -0.14563583, -0.07081333, 0.026335392, 0.10566285, -0.28074324, -0.059861198, -0.24855351, 0.13623764,
      -0.8228192, -0.15095113, 0.16250934, 0.031107651, -0.1504525, 0.20840737, 0.12919411, -0.0926323,
      0.30937102, 0.16636328, -0.36754072, 0.035581365, -0.2799259, 0.1446048, -0.11680267, 0.13226685,
      0.175023, -0.18840964, 0.27609056, -0.09350581, 0.08284562, 0.45897093, 0.13188471, -0.07115303,
      0.18009436, 0.16689545, -0.6991295, 0.26496106, -0.29619592, -0.19242188, -0.6362671, -0.16330126,
      0.2474778, 0.37738156, -0.12921557, -0.07843309, 0.28509396, 0.5658691, 0.16096894, 0.095068075,
      0.02419672, -0.30691084, 0.21180221, 0.21670066, 0.0027263877, 0.30853105, -0.16187873, 0.20786561,
      0.22136153, -0.008828387, -0.011165021, 0.60076475, 0.0089871045, 0.6179727, -0.38049766, -0.08179336,
      -0.15306218, -0.13186441, -0.5360041, -0.06123339, -0.06399122, 0.21292226, -0.18383273, -0.21540102,
      0.28566808, -0.29953584, -0.36946672, 0.03341637, -0.08435299, -0.5381947, -0.28651953, 0.08704594,
      -0.25493965, 0.0019178925, -0.7242109, 0.3578676, -0.55617595, -0.01930952, 0.32922924, 0.14903364,
      0.21613406, -0.11927183, 0.15165499, -0.10101261, 0.2499076, -0.18526322, -0.057230365, 0.10008554,
      0.16178907, 0.39356324, -0.03106238, 0.09375929, 0.17185533, 0.10400415, -0.36850816, 0.18424486,
      -0.081376314, 0.23645392, 0.05198973, 0.09471436,
    ];

    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearVector({ vector: searchVec, distance: 0.3 })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with nearObject (with certainty)', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearObject({
        id: 'abefd256-8574-442b-9293-9205193737e0',
        certainty: 0.7,
      })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with nearObject (with distance)', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearObject({
        id: 'abefd256-8574-442b-9293-9205193737e0',
        distance: 0.3,
      })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with nearText (with certainty)', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'], certainty: 0.7 })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with nearText (with distance)', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'], distance: 0.3 })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(3);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method expected failure - multiple nearMedia filters (with certainty)', () => {
    return expect(() => {
      client.graphql
        .aggregate()
        .withClassName('Article')
        .withNearText({ concepts: ['iphone'] })
        .withNearObject({
          id: 'abefd256-8574-442b-9293-9205193737e0',
          certainty: 0.65,
        })
        .do();
    }).toThrow('cannot use multiple near<Media> filters in a single query');
  });

  test('graphql aggregate method expected failure - multiple nearMedia filters (with distance)', () => {
    return expect(() => {
      client.graphql
        .aggregate()
        .withClassName('Article')
        .withNearText({ concepts: ['iphone'] })
        .withNearObject({
          id: 'abefd256-8574-442b-9293-9205193737e0',
          distance: 0.35,
        })
        .do();
    }).toThrow('cannot use multiple near<Media> filters in a single query');
  });

  test('graphql aggregate method with where and nearVector (with certainty)', () => {
    const searchVec = [
      -0.15047126, 0.061322376, -0.17812507, 0.12811552, 0.36847013, -0.50840724, -0.10406531, 0.11413283,
      0.2997712, 0.7039331, 0.22155242, 0.1413957, 0.025396502, 0.14802167, 0.26640236, 0.15965445,
      -0.45570126, -0.5215438, 0.14628491, 0.10946681, 0.0040095793, 0.017442623, -0.1988451, -0.05362646,
      0.104278944, -0.2506941, 0.2667653, 0.36438593, -0.44370207, 0.07204353, 0.077371456, 0.14557181,
      0.6026817, 0.45073593, 0.09438019, 0.03936342, -0.20441438, 0.12333719, -0.20247602, 0.5078446,
      -0.06079732, -0.02166342, 0.02165861, -0.11712191, 0.0493167, -0.012123002, 0.26458082, -0.10784768,
      -0.26852348, 0.049759883, -0.39999008, -0.08977922, 0.003169497, -0.36184034, -0.069065355, 0.18940343,
      0.5684866, -0.24626277, -0.2326087, 0.090373255, 0.33161184, -1.0541122, -0.039116446, -0.17496277,
      -0.16834813, -0.0765323, -0.16189013, -0.062876746, -0.19826415, 0.07437007, -0.018362755, 0.23634757,
      -0.19062655, -0.26524994, 0.33691254, -0.1926698, 0.018848037, 0.1735524, 0.34301907, -0.014238952,
      -0.07596742, -0.61302894, -0.044652265, 0.1545376, 0.67256856, 0.08630557, 0.50236076, 0.23438522,
      0.27686095, 0.13633616, -0.27525797, 0.04282576, 0.18319897, -0.008353968, -0.27330264, 0.12624736,
      -0.17051372, -0.35854533, -0.008455927, 0.154786, -0.20306401, -0.09021733, 0.80594194, 0.036562894,
      -0.48894945, -0.27981675, -0.5001396, -0.3581464, -0.057082724, -0.0051904973, -0.3209166, 0.057098284,
      0.111587055, -0.09097725, -0.213181, -0.5038173, -0.024070809, -0.05350453, 0.13345918, -0.42136985,
      0.24050911, -0.2556207, 0.03156968, 0.4381214, 0.053237516, -0.20783865, 1.885739, 0.28429136,
      -0.12231187, -0.30934808, 0.032250155, -0.32959512, 0.08670603, -0.60112613, -0.43010503, 0.70870006,
      0.3548015, -0.010406012, 0.036294986, 0.0030629474, -0.017579105, 0.28948352, -0.48063236, -0.39739868,
      0.17860937, 0.5099417, -0.24304488, -0.12671146, -0.018249692, -0.32057074, -0.08146134, 0.3572229,
      -0.47601065, 0.35100546, -0.19663939, 0.34194613, -0.04653828, 0.47278664, -0.8723091, -0.19756387,
      -0.5890681, 0.16688067, -0.23709822, -0.26478595, -0.18792373, 0.2204168, 0.030987943, 0.15885714,
      -0.38817936, -0.4194334, -0.3287098, 0.15394142, -0.09496768, 0.6561987, -0.39340565, -0.5479265,
      -0.22363484, -0.1193662, 0.2014849, 0.31138006, -0.45485613, -0.9879565, 0.3708223, 0.17318928,
      0.21229307, 0.042776756, -0.077399045, 0.42621315, -0.09917796, 0.34220153, 0.06380378, 0.14129028,
      -0.14563583, -0.07081333, 0.026335392, 0.10566285, -0.28074324, -0.059861198, -0.24855351, 0.13623764,
      -0.8228192, -0.15095113, 0.16250934, 0.031107651, -0.1504525, 0.20840737, 0.12919411, -0.0926323,
      0.30937102, 0.16636328, -0.36754072, 0.035581365, -0.2799259, 0.1446048, -0.11680267, 0.13226685,
      0.175023, -0.18840964, 0.27609056, -0.09350581, 0.08284562, 0.45897093, 0.13188471, -0.07115303,
      0.18009436, 0.16689545, -0.6991295, 0.26496106, -0.29619592, -0.19242188, -0.6362671, -0.16330126,
      0.2474778, 0.37738156, -0.12921557, -0.07843309, 0.28509396, 0.5658691, 0.16096894, 0.095068075,
      0.02419672, -0.30691084, 0.21180221, 0.21670066, 0.0027263877, 0.30853105, -0.16187873, 0.20786561,
      0.22136153, -0.008828387, -0.011165021, 0.60076475, 0.0089871045, 0.6179727, -0.38049766, -0.08179336,
      -0.15306218, -0.13186441, -0.5360041, -0.06123339, -0.06399122, 0.21292226, -0.18383273, -0.21540102,
      0.28566808, -0.29953584, -0.36946672, 0.03341637, -0.08435299, -0.5381947, -0.28651953, 0.08704594,
      -0.25493965, 0.0019178925, -0.7242109, 0.3578676, -0.55617595, -0.01930952, 0.32922924, 0.14903364,
      0.21613406, -0.11927183, 0.15165499, -0.10101261, 0.2499076, -0.18526322, -0.057230365, 0.10008554,
      0.16178907, 0.39356324, -0.03106238, 0.09375929, 0.17185533, 0.10400415, -0.36850816, 0.18424486,
      -0.081376314, 0.23645392, 0.05198973, 0.09471436,
    ];

    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearVector({ vector: searchVec, certainty: 0.7 })
      .withWhere({
        operator: 'Equal',
        path: ['_id'],
        valueText: 'abefd256-8574-442b-9293-9205193737e0',
      })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with where and nearVector (with distance)', () => {
    const searchVec = [
      -0.15047126, 0.061322376, -0.17812507, 0.12811552, 0.36847013, -0.50840724, -0.10406531, 0.11413283,
      0.2997712, 0.7039331, 0.22155242, 0.1413957, 0.025396502, 0.14802167, 0.26640236, 0.15965445,
      -0.45570126, -0.5215438, 0.14628491, 0.10946681, 0.0040095793, 0.017442623, -0.1988451, -0.05362646,
      0.104278944, -0.2506941, 0.2667653, 0.36438593, -0.44370207, 0.07204353, 0.077371456, 0.14557181,
      0.6026817, 0.45073593, 0.09438019, 0.03936342, -0.20441438, 0.12333719, -0.20247602, 0.5078446,
      -0.06079732, -0.02166342, 0.02165861, -0.11712191, 0.0493167, -0.012123002, 0.26458082, -0.10784768,
      -0.26852348, 0.049759883, -0.39999008, -0.08977922, 0.003169497, -0.36184034, -0.069065355, 0.18940343,
      0.5684866, -0.24626277, -0.2326087, 0.090373255, 0.33161184, -1.0541122, -0.039116446, -0.17496277,
      -0.16834813, -0.0765323, -0.16189013, -0.062876746, -0.19826415, 0.07437007, -0.018362755, 0.23634757,
      -0.19062655, -0.26524994, 0.33691254, -0.1926698, 0.018848037, 0.1735524, 0.34301907, -0.014238952,
      -0.07596742, -0.61302894, -0.044652265, 0.1545376, 0.67256856, 0.08630557, 0.50236076, 0.23438522,
      0.27686095, 0.13633616, -0.27525797, 0.04282576, 0.18319897, -0.008353968, -0.27330264, 0.12624736,
      -0.17051372, -0.35854533, -0.008455927, 0.154786, -0.20306401, -0.09021733, 0.80594194, 0.036562894,
      -0.48894945, -0.27981675, -0.5001396, -0.3581464, -0.057082724, -0.0051904973, -0.3209166, 0.057098284,
      0.111587055, -0.09097725, -0.213181, -0.5038173, -0.024070809, -0.05350453, 0.13345918, -0.42136985,
      0.24050911, -0.2556207, 0.03156968, 0.4381214, 0.053237516, -0.20783865, 1.885739, 0.28429136,
      -0.12231187, -0.30934808, 0.032250155, -0.32959512, 0.08670603, -0.60112613, -0.43010503, 0.70870006,
      0.3548015, -0.010406012, 0.036294986, 0.0030629474, -0.017579105, 0.28948352, -0.48063236, -0.39739868,
      0.17860937, 0.5099417, -0.24304488, -0.12671146, -0.018249692, -0.32057074, -0.08146134, 0.3572229,
      -0.47601065, 0.35100546, -0.19663939, 0.34194613, -0.04653828, 0.47278664, -0.8723091, -0.19756387,
      -0.5890681, 0.16688067, -0.23709822, -0.26478595, -0.18792373, 0.2204168, 0.030987943, 0.15885714,
      -0.38817936, -0.4194334, -0.3287098, 0.15394142, -0.09496768, 0.6561987, -0.39340565, -0.5479265,
      -0.22363484, -0.1193662, 0.2014849, 0.31138006, -0.45485613, -0.9879565, 0.3708223, 0.17318928,
      0.21229307, 0.042776756, -0.077399045, 0.42621315, -0.09917796, 0.34220153, 0.06380378, 0.14129028,
      -0.14563583, -0.07081333, 0.026335392, 0.10566285, -0.28074324, -0.059861198, -0.24855351, 0.13623764,
      -0.8228192, -0.15095113, 0.16250934, 0.031107651, -0.1504525, 0.20840737, 0.12919411, -0.0926323,
      0.30937102, 0.16636328, -0.36754072, 0.035581365, -0.2799259, 0.1446048, -0.11680267, 0.13226685,
      0.175023, -0.18840964, 0.27609056, -0.09350581, 0.08284562, 0.45897093, 0.13188471, -0.07115303,
      0.18009436, 0.16689545, -0.6991295, 0.26496106, -0.29619592, -0.19242188, -0.6362671, -0.16330126,
      0.2474778, 0.37738156, -0.12921557, -0.07843309, 0.28509396, 0.5658691, 0.16096894, 0.095068075,
      0.02419672, -0.30691084, 0.21180221, 0.21670066, 0.0027263877, 0.30853105, -0.16187873, 0.20786561,
      0.22136153, -0.008828387, -0.011165021, 0.60076475, 0.0089871045, 0.6179727, -0.38049766, -0.08179336,
      -0.15306218, -0.13186441, -0.5360041, -0.06123339, -0.06399122, 0.21292226, -0.18383273, -0.21540102,
      0.28566808, -0.29953584, -0.36946672, 0.03341637, -0.08435299, -0.5381947, -0.28651953, 0.08704594,
      -0.25493965, 0.0019178925, -0.7242109, 0.3578676, -0.55617595, -0.01930952, 0.32922924, 0.14903364,
      0.21613406, -0.11927183, 0.15165499, -0.10101261, 0.2499076, -0.18526322, -0.057230365, 0.10008554,
      0.16178907, 0.39356324, -0.03106238, 0.09375929, 0.17185533, 0.10400415, -0.36850816, 0.18424486,
      -0.081376314, 0.23645392, 0.05198973, 0.09471436,
    ];

    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearVector({ vector: searchVec, distance: 0.3 })
      .withWhere({
        operator: 'Equal',
        path: ['_id'],
        valueText: 'abefd256-8574-442b-9293-9205193737e0',
      })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with where and nearObject (with certainty)', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearObject({
        id: 'abefd256-8574-442b-9293-9205193737e0',
        certainty: 0.7,
      })
      .withWhere({
        operator: 'Equal',
        path: ['_id'],
        valueText: 'abefd256-8574-442b-9293-9205193737e0',
      })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with where and nearObject (with distance)', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearObject({
        id: 'abefd256-8574-442b-9293-9205193737e0',
        distance: 0.3,
      })
      .withWhere({
        operator: 'Equal',
        path: ['_id'],
        valueText: 'abefd256-8574-442b-9293-9205193737e0',
      })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with where and nearText (with certainty)', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'], certainty: 0.7 })
      .withWhere({
        operator: 'Equal',
        path: ['_id'],
        valueText: 'abefd256-8574-442b-9293-9205193737e0',
      })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with where and nearText (with distance)', () => {
    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'], distance: 0.3 })
      .withWhere({
        operator: 'Equal',
        path: ['_id'],
        valueText: 'abefd256-8574-442b-9293-9205193737e0',
      })
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with objectLimit (with certainty)', () => {
    const objectLimit = 1;

    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'], certainty: 0.7 })
      .withObjectLimit(objectLimit)
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(objectLimit);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with objectLimit (with distance)', () => {
    const objectLimit = 1;

    return client.graphql
      .aggregate()
      .withClassName('Article')
      .withNearText({ concepts: ['Article'], distance: 0.3 })
      .withObjectLimit(objectLimit)
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        const count = res.data.Aggregate.Article[0].meta.count;
        expect(count).toEqual(objectLimit);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql aggregate method with bad objectLimit input (with certainty)', () => {
    const objectLimit = -1.1;

    return expect(() => {
      client.graphql
        .aggregate()
        .withClassName('Article')
        .withNearText({ concepts: ['Article'], certainty: 0.7 })
        .withObjectLimit(objectLimit)
        .withFields('meta { count }')
        .do();
    }).toThrow('objectLimit must be a non-negative integer');
  });

  test('graphql aggregate method with bad objectLimit input (with distance)', () => {
    const objectLimit = -1.1;

    return expect(() => {
      client.graphql
        .aggregate()
        .withClassName('Article')
        .withNearText({ concepts: ['Article'], distance: 0.3 })
        .withObjectLimit(objectLimit)
        .withFields('meta { count }')
        .do();
    }).toThrow('objectLimit must be a non-negative integer');
  });

  test('graphql explore with minimal fields', () => {
    return client.graphql
      .explore()
      .withNearText({ concepts: ['iphone'] })
      .withFields('beacon certainty className')
      .do()
      .then((res: any) => {
        expect(res.data.Explore.length).toBeGreaterThan(0);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql explore with optional fields', () => {
    return client.graphql
      .explore()
      .withNearText({ concepts: ['iphone'] })
      .withFields('beacon certainty distance className')
      .withLimit(1)
      .do()
      .then((res: any) => {
        expect(res.data.Explore.length).toEqual(1);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql explore with nearObject field', () => {
    return client.graphql
      .explore()
      .withNearObject({ id: 'abefd256-8574-442b-9293-9205193737e0' })
      .withFields('beacon certainty distance className')
      .do()
      .then((res: any) => {
        expect(res.data.Explore.length).toBeGreaterThan(0);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord' + e);
      });
  });

  test('graphql get method with sort filter: wordCount asc', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('wordCount')
      .withSort([{ path: ['wordCount'] }])
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toBe(3);
        expect(result.data.Get.Article[0].wordCount).toEqual(40);
        expect(result.data.Get.Article[1].wordCount).toEqual(60);
        expect(result.data.Get.Article[2].wordCount).toEqual(600);
      });
  });

  test('graphql get method with [sort] filter: wordCount asc', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('wordCount')
      .withSort([{ path: ['wordCount'], order: 'asc' }])
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toBe(3);
        expect(result.data.Get.Article[0].wordCount).toEqual(40);
        expect(result.data.Get.Article[1].wordCount).toEqual(60);
        expect(result.data.Get.Article[2].wordCount).toEqual(600);
      });
  });

  test('graphql get method with sort filter: title desc', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('title')
      .withSort([{ path: ['title'], order: 'desc' }])
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toBe(3);
        expect(result.data.Get.Article[0].title).toEqual('Article about Apple');
        expect(result.data.Get.Article[1].title).toEqual('Article 2');
        expect(result.data.Get.Article[2].title).toEqual('Article 1');
      });
  });

  test('graphql get method with [sort] filter: title desc', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('title')
      .withSort([{ path: ['title'], order: 'desc' }])
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toBe(3);
        expect(result.data.Get.Article[0].title).toEqual('Article about Apple');
        expect(result.data.Get.Article[1].title).toEqual('Article 2');
        expect(result.data.Get.Article[2].title).toEqual('Article 1');
      });
  });

  test('graphql get method with [sort] filters', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('title')
      .withSort([
        { path: ['wordCount'], order: 'asc' },
        { path: ['title'], order: 'desc' },
      ])
      .do()
      .then(function (result) {
        expect(result.data.Get.Article.length).toBe(3);
        expect(result.data.Get.Article[0].title).toEqual('Article 2');
        expect(result.data.Get.Article[1].title).toEqual('Article 1');
        expect(result.data.Get.Article[2].title).toEqual('Article about Apple');
      });
  });

  test('graphql get method with creationTimeUnix filter', async () => {
    const expected = await client.graphql
      .get()
      .withClassName('Article')
      .withFields('_additional { creationTimeUnix }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBeGreaterThan(0);
        return res;
      });

    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('_additional { id creationTimeUnix }')
      .withWhere({
        path: ['_creationTimeUnix'],
        operator: 'Equal',
        valueText: expected.data.Get.Article[0]._additional.creationTimeUnix,
      })
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBeGreaterThan(0);
        expect(res.data.Get.Article[0]._additional.creationTimeUnix).toEqual(
          expected.data.Get.Article[0]._additional.creationTimeUnix
        );
      });
  });

  test('graphql get method with lastUpdateTimeUnix filter', async () => {
    const expected = await client.graphql
      .get()
      .withClassName('Article')
      .withFields('_additional { lastUpdateTimeUnix }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBeGreaterThan(0);
        return res;
      });

    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('_additional { id lastUpdateTimeUnix }')
      .withWhere({
        path: ['_lastUpdateTimeUnix'],
        operator: 'Equal',
        valueText: expected.data.Get.Article[0]._additional.lastUpdateTimeUnix,
      })
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBeGreaterThan(0);
        expect(res.data.Get.Article[0]._additional.lastUpdateTimeUnix).toEqual(
          expected.data.Get.Article[0]._additional.lastUpdateTimeUnix
        );
      });
  });

  it('search object with uuid and uuid props', async () => {
    const client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });

    const className = 'ClassUUID';
    const id = 'abefd256-8574-442b-9293-9205193737ee';

    await client.schema
      .classCreator()
      .withClass({
        class: className,
        properties: [
          {
            dataType: ['uuid'],
            name: 'uuidProp',
          },
          {
            dataType: ['uuid[]'],
            name: 'uuidArrayProp',
          },
        ],
      })
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toBeTruthy();
      });

    await client.data
      .creator()
      .withClassName(className)
      .withId(id)
      .withProperties({
        uuidProp: '7aaa79d3-a564-45db-8fa8-c49e20b8a39a',
        uuidArrayProp: ['f70512a3-26cb-4ae4-9369-204555917f15', '9e516f40-fd54-4083-a476-f4675b2b5f92'],
      })
      .do()
      .then((res: WeaviateObject) => {
        expect(res).toBeTruthy();
      });

    const expectObjectFound = async (propName: string, value: string) => {
      await client.graphql
        .get()
        .withClassName(className)
        .withFields('_additional { id }')
        .withWhere({
          path: [propName],
          operator: 'Equal',
          valueText: value,
        })
        .do()
        .then((res: any) => {
          expect(res.data.Get[className].length).toBeGreaterThan(0);
          expect(res.data.Get[className][0]._additional.id).toEqual(id);
        });
    };

    await expectObjectFound('uuidProp', '7aaa79d3-a564-45db-8fa8-c49e20b8a39a');
    await expectObjectFound('uuidArrayProp', 'f70512a3-26cb-4ae4-9369-204555917f15');
    await expectObjectFound('uuidArrayProp', '9e516f40-fd54-4083-a476-f4675b2b5f92');

    return client.schema
      .classDeleter()
      .withClassName(className)
      .do()
      .then((res: void) => {
        expect(res).toEqual(undefined);
      });
  });

  it('tears down and cleans up', () => {
    return Promise.all([client.schema.classDeleter().withClassName('Article').do()]);
  });
});

describe('query with generative search', () => {
  jest.setTimeout(30000);

  if (process.env.OPENAI_APIKEY == undefined || process.env.OPENAI_APIKEY == '') {
    console.warn('Skipping because `WCS_DUMMY_CI_PW` is not set');
    return;
  }

  const client = weaviate.client({
    host: 'localhost:8086',
    scheme: 'http',
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    headers: { 'X-OpenAI-Api-Key': process.env.OPENAI_APIKEY! },
  });

  it('sets up the test environment', async () => {
    await client.schema
      .classCreator()
      .withClass({
        class: 'Wine',
        properties: [
          { name: 'name', dataType: ['string'] },
          { name: 'review', dataType: ['string'] },
        ],
        moduleConfig: {
          'generative-openai': {},
        },
      })
      .do()
      .catch((e: any) => {
        throw new Error(`unexpected error with class creation: ${JSON.stringify(e)}`);
      });

    await client.data
      .creator()
      .withClassName('Wine')
      .withProperties({ name: 'Super expensive wine', review: 'Tastes like a fresh ocean breeze' })
      .do()
      .catch((e: any) => {
        throw new Error(`unexpected error with object creation: ${JSON.stringify(e)}`);
      });

    return client.data
      .creator()
      .withClassName('Wine')
      .withProperties({ name: 'cheap wine', review: 'Tastes like forest' })
      .do()
      .catch((e: any) => {
        throw new Error(`unexpected error with object creation: ${JSON.stringify(e)}`);
      });
  });

  test('singlePrompt', async () => {
    await client.graphql
      .get()
      .withClassName('Wine')
      .withFields('name review')
      .withGenerate({
        singlePrompt: `Describe the following as a Facebook Ad:
Tastes like a fresh ocean breeze: {review}`,
      })
      .do()
      .then((res: any) => {
        expect(res.data.Get.Wine[0]._additional.generate.singleResult).toBeDefined();
        expect(res.data.Get.Wine[0]._additional.generate.error).toBeNull();
      });
  });

  test('groupedTask', async () => {
    await client.graphql
      .get()
      .withClassName('Wine')
      .withFields('name review')
      .withGenerate({
        groupedTask: 'Describe the following as a LinkedIn Ad: {review}',
      })
      .do()
      .then((res: any) => {
        expect(res.data.Get.Wine[0]._additional.generate.groupedResult).toBeDefined();
        expect(res.data.Get.Wine[0]._additional.generate.error).toBeNull();
      });
  });

  test('groupedTask with groupedProperties', async () => {
    await client.graphql
      .get()
      .withClassName('Wine')
      .withFields('name review')
      .withGenerate({
        groupedTask: 'Describe the following as a LinkedIn Ad:',
        groupedProperties: ['name', 'review'],
      })
      .do()
      .then((res: any) => {
        expect(res.data.Get.Wine[0]._additional.generate.groupedResult).toBeDefined();
        expect(res.data.Get.Wine[0]._additional.generate.error).toBeNull();
      });
  });

  test('singlePrompt and groupedTask', async () => {
    await client.graphql
      .get()
      .withClassName('Wine')
      .withFields('name review')
      .withGenerate({
        singlePrompt: 'Describe the following as a Twitter Ad: {review}',
        groupedTask: 'Describe the following as a Mastodon Ad: {review}',
      })
      .do()
      .then((res: any) => {
        expect(res.data.Get.Wine[0]._additional.generate.singleResult).toBeDefined();
        expect(res.data.Get.Wine[0]._additional.generate.groupedResult).toBeDefined();
        expect(res.data.Get.Wine[0]._additional.generate.error).toBeNull();
      });
  });

  it('tears down schema', () => {
    return Promise.all([client.schema.classDeleter().withClassName('Wine').do()]);
  });
});

describe('query cluster with consistency level', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8087',
  });

  it('sets up replicated class', () => {
    return setupReplicated(client);
  });

  test('One', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('_additional { id isConsistent }')
      .withConsistencyLevel('ONE')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBeGreaterThan(0);
        res.data.Get.Article.forEach((article: any) => {
          expect(article._additional.isConsistent).toBeTruthy();
        });
        return res;
      })
      .catch((e: any) => {
        throw new Error(`unexpected error: ${JSON.stringify(e)}`);
      });
  });

  test('Quorum', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('_additional { id isConsistent }')
      .withConsistencyLevel('QUORUM')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBeGreaterThan(0);
        res.data.Get.Article.forEach((article: any) => {
          expect(article._additional.isConsistent).toBeTruthy();
        });
      })
      .catch((e: any) => {
        throw new Error(`unexpected error: ${JSON.stringify(e)}`);
      });
  });

  test('All', () => {
    return client.graphql
      .get()
      .withClassName('Article')
      .withFields('_additional { id isConsistent }')
      .withConsistencyLevel('ALL')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Article.length).toBeGreaterThan(0);
        res.data.Get.Article.forEach((article: any) => {
          expect(article._additional.isConsistent).toBeTruthy();
        });
      })
      .catch((e: any) => {
        throw new Error(`unexpected error: ${JSON.stringify(e)}`);
      });
  });

  it('tears down cluster schema', () => {
    return Promise.all([client.schema.classDeleter().withClassName('Article').do()]);
  });
});

describe.skip('query with group by SKIPPED BECAUSE OF XREFS RETURN OPTIMISATION BUG', () => {
  let client: WeaviateClient;

  beforeEach(() => {
    client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });
  });

  it('creates Document Passage schema classes', () => {
    // this is just test setup, not part of what we want to test here
    return setupGroupBy(client);
  });

  test('should return 3 groups', async () => {
    interface GroupHit {
      passageIds: string[];
      ofDocumentId: string;
    }
    const hits = 'hits{ofDocument{... on Document{_additional{id}}} _additional{id distance}}';
    const group = `group{id groupedBy{value path} count maxDistance minDistance ${hits}}`;
    const _additional = `_additional{${group}}`;
    const expectedGroupHits1: GroupHit = {
      passageIds: [
        '00000000-0000-0000-0000-000000000001',
        '00000000-0000-0000-0000-000000000009',
        '00000000-0000-0000-0000-000000000007',
        '00000000-0000-0000-0000-000000000008',
        '00000000-0000-0000-0000-000000000006',
        '00000000-0000-0000-0000-000000000010',
        '00000000-0000-0000-0000-000000000005',
        '00000000-0000-0000-0000-000000000004',
        '00000000-0000-0000-0000-000000000003',
        '00000000-0000-0000-0000-000000000002',
      ],
      ofDocumentId: '00000000-0000-0000-0000-00000000000a',
    };
    const expectedGroupHits2: GroupHit = {
      passageIds: [
        '00000000-0000-0000-0000-000000000011',
        '00000000-0000-0000-0000-000000000013',
        '00000000-0000-0000-0000-000000000012',
        '00000000-0000-0000-0000-000000000014',
      ],
      ofDocumentId: '00000000-0000-0000-0000-00000000000b',
    };
    const expectedGroupHits: GroupHit[] = [expectedGroupHits1, expectedGroupHits2];

    await client.graphql
      .get()
      .withClassName('Passage')
      .withGroupBy({ path: ['ofDocument'], groups: 3, objectsPerGroup: 10 })
      .withNearObject({ id: '00000000-0000-0000-0000-000000000001' })
      .withFields(_additional)
      .do()
      .then((res: any) => {
        expect(res.data.Get.Passage).toHaveLength(3);
        expect(res.data.Get.Passage[0]._additional.group.hits).toHaveLength(10);
        expect(res.data.Get.Passage[1]._additional.group.hits).toHaveLength(4);
        expect(res.data.Get.Passage[2]._additional.group.hits).toHaveLength(6);
        for (let i = 0; i < 3; i++) {
          expect(res.data.Get.Passage[i]._additional.group).toBeDefined();
          expect(res.data.Get.Passage[i]._additional.group.minDistance).toBe(
            res.data.Get.Passage[i]._additional.group.hits[0]._additional.distance
          );
          expect(res.data.Get.Passage[i]._additional.group.maxDistance).toBe(
            res.data.Get.Passage[i]._additional.group.hits[
              res.data.Get.Passage[i]._additional.group.hits.length - 1
            ]._additional.distance
          );
        }
        for (let i = 0; i < 2; i++) {
          const expectedResults = expectedGroupHits[i];
          const hits = res.data.Get.Passage[i]._additional.group.hits;
          for (let j = 0; j < hits.length; j++) {
            expect(hits[j]._additional.id).toBe(expectedResults.passageIds[j]);
            expect(hits[j].ofDocument[0]._additional.id).toBe(expectedResults.ofDocumentId);
          }
        }
      });
  });

  it('tears down Document Passage schema', () => {
    return Promise.all([
      client.schema.classDeleter().withClassName('Passage').do(),
      client.schema.classDeleter().withClassName('Document').do(),
    ]);
  });
});

describe('multi tenancy', () => {
  let client: WeaviateClient;

  beforeEach(() => {
    client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });
  });

  const tenants: Array<Tenant> = [{ name: 'tenantA' }, { name: 'tenantB' }];

  it('creates Document Passage schema classes with tenants', () => {
    // this is just test setup, not part of what we want to test here
    return setupMultiTenancy(client, tenants);
  });

  it('should not be able to Get results without a tenant parameter', () => {
    return client.graphql
      .get()
      .withClassName('Passage')
      .withFields('_additional { id }')
      .do()
      .catch((e: WeaviateError) => {
        expect(e).toBeDefined();
      });
  });

  it('should not be able to Get results without a tenant parameter', () => {
    return client.graphql
      .aggregate()
      .withClassName('Passage')
      .withFields('meta { count }')
      .do()
      .catch((e: WeaviateError) => {
        expect(e).toBeDefined();
      });
  });

  it('should not be able to Explore results', () => {
    return client.graphql
      .explore()
      .withNearText({ concepts: ['SpaceX'] })
      .withFields('beacon certainty className')
      .do()
      .catch((e: WeaviateError) => {
        expect(e).toBeDefined();
      });
  });

  it('should Get results with a proper tenant assigned to Passage objects', () => {
    return client.graphql
      .get()
      .withClassName('Passage')
      .withTenant(tenants[0].name!)
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Passage).toHaveLength(20);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('should Aggregate results with a proper tenant assigned to Passage objects', () => {
    return client.graphql
      .aggregate()
      .withClassName('Passage')
      .withTenant(tenants[0].name!)
      .withFields('meta { count }')
      .do()
      .then((res: any) => {
        expect(res.data.Aggregate.Passage).toHaveLength(1);
        expect(res.data.Aggregate.Passage[0].meta.count).toBe(20);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('should Aggregate results with a tenant that has no objects', () => {
    return client.graphql
      .aggregate()
      .withClassName('Passage')
      .withTenant(tenants[1].name!)
      .withFields('meta{count}')
      .do()
      .then((res: any) => {
        expect(res.data.Aggregate.Passage).toHaveLength(1);
        expect(res.data.Aggregate.Passage[0].meta.count).toBe(0);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('should Get results with tenants and nearText', () => {
    return client.graphql
      .get()
      .withClassName('Passage')
      .withTenant(tenants[0].name!)
      .withNearText({ concepts: ['SpaceX'] })
      .withLimit(2)
      .withFields('_additional { id }')
      .do()
      .then((res: any) => {
        expect(res.data.Get.Passage).toHaveLength(2);
      })
      .catch((e: WeaviateError) => {
        throw new Error('it should not have errord ' + e);
      });
  });

  it('tears down Document Passage schema with tenants', () => {
    return Promise.all([
      client.schema.classDeleter().withClassName('Passage').do(),
      client.schema.classDeleter().withClassName('Document').do(),
    ]);
  });
});

describe('where test', () => {
  let client: WeaviateClient;

  beforeEach(() => {
    client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });
  });

  const className = 'WhereTest';
  const id1 = '00000000-0000-0000-0000-000000000001';
  const id2 = '00000000-0000-0000-0000-000000000002';
  const id3 = '00000000-0000-0000-0000-000000000003';
  const ids: Array<string> = [id1, id2, id3];

  describe('setup', () => {
    it('should create WhereTest class', () => {
      const whereTest = {
        class: className,
        invertedIndexConfig: { indexTimestamps: true },
        properties: [
          {
            name: 'color',
            dataType: ['text'],
          },
          {
            name: 'colors',
            dataType: ['text[]'],
          },
          {
            name: 'author',
            dataType: ['string'],
          },
          {
            name: 'authors',
            dataType: ['string[]'],
          },
          {
            name: 'number',
            dataType: ['number'],
          },
          {
            name: 'numbers',
            dataType: ['number[]'],
          },
          {
            name: 'int',
            dataType: ['int'],
          },
          {
            name: 'ints',
            dataType: ['int[]'],
          },
          {
            name: 'date',
            dataType: ['date'],
          },
          {
            name: 'dates',
            dataType: ['date[]'],
          },
          {
            name: 'bool',
            dataType: ['boolean'],
          },
          {
            name: 'bools',
            dataType: ['boolean[]'],
          },
          {
            name: 'uuid',
            dataType: ['uuid'],
          },
          {
            name: 'uuids',
            dataType: ['uuid[]'],
          },
        ],
      };
      return client.schema.classCreator().withClass(whereTest).do();
    });

    it('should insert WhereTest data', () => {
      const authors = ['John', 'Jenny', 'Joseph'];
      const authorsArray = [['John', 'Jenny', 'Joseph'], ['John', 'Jenny'], ['John']];
      const colors = ['red', 'blue', 'green'];
      const colorssArray = [['red', 'blue', 'green'], ['red', 'blue'], ['red']];
      const numbers = [1.1, 2.2, 3.3];
      const numbersArray = [[1.1, 2.2, 3.3], [1.1, 2.2], [1.1]];
      const ints = [1, 2, 3];
      const intsArray = [[1, 2, 3], [1, 2], [1]];
      const uuids = [id1, id2, id3];
      const uuidsArray = [[id1, id2, id3], [id1, id2], [id1]];
      const dates = ['2009-11-01T23:00:00Z', '2009-11-02T23:00:00Z', '2009-11-03T23:00:00Z'];
      const datesArray = [
        ['2009-11-01T23:00:00Z', '2009-11-02T23:00:00Z', '2009-11-03T23:00:00Z'],
        ['2009-11-01T23:00:00Z', '2009-11-02T23:00:00Z'],
        ['2009-11-01T23:00:00Z'],
      ];
      const bools = [true, false, true];
      const boolsArray = [[true, false, true], [true, false], [true]];

      const objects: WeaviateObject[] = [];
      for (let i = 0; i < ids.length; i++) {
        const obj: WeaviateObject = {
          id: ids[i],
          class: className,
          properties: {
            color: colors[i],
            colors: colorssArray[i],
            author: authors[i],
            authors: authorsArray[i],
            number: numbers[i],
            numbers: numbersArray[i],
            int: ints[i],
            ints: intsArray[i],
            uuid: uuids[i],
            uuids: uuidsArray[i],
            date: dates[i],
            dates: datesArray[i],
            bool: bools[i],
            bools: boolsArray[i],
          },
        };
        objects.push(obj);
      }
      let batch = client.batch.objectsBatcher();
      objects.forEach((elem) => {
        batch = batch.withObject(elem);
      });
      return batch.do();
    });
  });

  describe('test contains operators', () => {
    interface testCase {
      name: string;
      where: WhereFilter;
      expectedIds: Array<string>;
    }
    const testCases: Array<testCase> = [
      // arrays
      {
        name: 'contains all authors with string array',
        where: {
          path: ['authors'],
          operator: 'ContainsAll',
          valueStringArray: ['John', 'Jenny', 'Joseph'],
        },
        expectedIds: [id1],
      },
      {
        name: 'contains any authors with string array',
        where: {
          path: ['authors'],
          operator: 'ContainsAny',
          valueStringArray: ['John', 'Jenny', 'Joseph'],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains all colors with text array',
        where: {
          path: ['colors'],
          operator: 'ContainsAll',
          valueTextArray: ['red', 'blue', 'green'],
        },
        expectedIds: [id1],
      },
      {
        name: 'contains any colors with text array',
        where: {
          path: ['colors'],
          operator: 'ContainsAny',
          valueTextArray: ['red', 'blue', 'green'],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains all numbers with number array',
        where: {
          path: ['numbers'],
          operator: 'ContainsAll',
          valueNumberArray: [1.1, 2.2, 3.3],
        },
        expectedIds: [id1],
      },
      {
        name: 'contains any numbers with number array',
        where: {
          path: ['numbers'],
          operator: 'ContainsAny',
          valueNumberArray: [1.1, 2.2, 3.3],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains all ints with int array',
        where: {
          path: ['ints'],
          operator: 'ContainsAll',
          valueIntArray: [1, 2, 3],
        },
        expectedIds: [id1],
      },
      {
        name: 'contains any ints with int array',
        where: {
          path: ['ints'],
          operator: 'ContainsAny',
          valueIntArray: [1, 2, 3],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains all uuids with uuid array',
        where: {
          path: ['uuids'],
          operator: 'ContainsAll',
          valueTextArray: [id1, id2, id3],
        },
        expectedIds: [id1],
      },
      {
        name: 'contains any uuids with uuid array',
        where: {
          path: ['uuids'],
          operator: 'ContainsAny',
          valueTextArray: [id1, id2, id3],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains all dates with date array',
        where: {
          path: ['dates'],
          operator: 'ContainsAll',
          valueDateArray: ['2009-11-01T23:00:00Z', '2009-11-02T23:00:00Z', '2009-11-03T23:00:00Z'],
        },
        expectedIds: [id1],
      },
      {
        name: 'contains any dates with date array',
        where: {
          path: ['dates'],
          operator: 'ContainsAny',
          valueDateArray: ['2009-11-01T23:00:00Z', '2009-11-02T23:00:00Z', '2009-11-03T23:00:00Z'],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'complex contains all ints and all numbers with AND on int array',
        where: {
          path: ['dates'],
          operator: 'And',
          operands: [
            {
              path: ['ints'],
              operator: 'ContainsAll',
              valueIntArray: [1, 2, 3],
            },
            {
              path: ['ints'],
              operator: 'ContainsAll',
              valueIntArray: [1, 2, 3],
            },
          ],
        },
        expectedIds: [id1],
      },
      {
        name: 'complex contains any ints and all numbers with OR on int array',
        where: {
          path: ['dates'],
          operator: 'Or',
          operands: [
            {
              path: ['ints'],
              operator: 'ContainsAll',
              valueIntArray: [1, 2, 3],
            },
            {
              path: ['ints'],
              operator: 'ContainsAny',
              valueIntArray: [1, 2, 3],
            },
          ],
        },
        expectedIds: [id1, id2, id3],
      },
      // primitives
      {
        name: 'contains any author with string',
        where: {
          path: ['author'],
          operator: 'ContainsAny',
          valueStringArray: ['John', 'Jenny', 'Joseph'],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains any color with text',
        where: {
          path: ['color'],
          operator: 'ContainsAny',
          valueTextArray: ['red', 'blue', 'green'],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains any number with number',
        where: {
          path: ['number'],
          operator: 'ContainsAny',
          valueNumberArray: [1.1, 2.2, 3.3],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains any int with int',
        where: {
          path: ['int'],
          operator: 'ContainsAny',
          valueIntArray: [1, 2, 3],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains any uuid with uuid',
        where: {
          path: ['uuid'],
          operator: 'ContainsAny',
          valueTextArray: [id1, id2, id3],
        },
        expectedIds: [id1, id2, id3],
      },
      {
        name: 'contains any date with date',
        where: {
          path: ['date'],
          operator: 'ContainsAny',
          valueDateArray: ['2009-11-01T23:00:00Z', '2009-11-02T23:00:00Z', '2009-11-03T23:00:00Z'],
        },
        expectedIds: [id1, id2, id3],
      },
    ];
    it.each(testCases.map((tc) => [tc.name, tc]))('%s', (_, t) => {
      const tc = t as testCase;
      return client.graphql
        .get()
        .withClassName(className)
        .withWhere(tc.where)
        .withFields('_additional { id }')
        .do()
        .then((res: any) => {
          expect(res.data.Get.WhereTest.length).toBe(tc.expectedIds.length);
          const result: Array<string> = [];
          for (let i = 0; i < tc.expectedIds.length; i++) {
            result.push(res.data.Get.WhereTest[i]._additional.id);
          }
          for (const expectedId of tc.expectedIds) {
            expect(result).toContainEqual(expectedId);
          }
        })
        .catch((e: any) => {
          throw new Error('it should not have errord' + e);
        });
    });
  });

  describe('destroy', () => {
    it('tears down WhereTest class', () => {
      return client.schema.classDeleter().withClassName(className).do();
    });
  });
});

describe('named vectors test', () => {
  let client: WeaviateClient;

  beforeEach(() => {
    client = weaviate.client({
      scheme: 'http',
      host: 'localhost:8080',
    });
  });

  const className = 'VectorTest';
  const oneUUID = 'abefd256-8574-442b-9293-9205193737e1';

  describe('setup', () => {
    it(`should create ${className} class`, () => {
      const namedVectorTest: WeaviateClass = {
        class: className,
        properties: [
          {
            name: 'title',
            dataType: ['text'],
          },
          {
            name: 'rating',
            dataType: ['text'],
          },
        ],
        vectorConfig: {
          title: {
            vectorIndexType: 'hnsw',
            vectorizer: {
              'text2vec-contextionary': {
                vectorizeClassName: false,
                properties: ['title'],
              },
            },
          },
          rating: {
            vectorIndexType: 'hnsw',
            vectorizer: {
              'text2vec-contextionary': {
                vectorizeClassName: false,
                properties: ['rating'],
              },
            },
          },
        },
      };
      return client.schema.classCreator().withClass(namedVectorTest).do();
    });

    it('should insert VectorTest data', () => {
      const objects: WeaviateObject[] = [
        {
          class: className,
          properties: {
            title: 'One',
            rating: 'Good',
          },
          id: oneUUID,
        },
        {
          class: className,
          properties: {
            title: 'Two',
            rating: 'Better',
          },
        },
        {
          class: className,
          properties: {
            title: 'Three',
            rating: 'Best',
          },
        },
      ];
      let batch = client.batch.objectsBatcher();
      objects.forEach((elem) => {
        batch = batch.withObject(elem);
      });
      return batch.do();
    });

    it('should perform a nearText query on the title vector', () => {
      return client.graphql
        .get()
        .withClassName(className)
        .withNearText({
          concepts: ['Two'],
          targetVectors: ['title'],
        })
        .withFields('title')
        .do()
        .then((res) => {
          expect(res.data.Get.VectorTest).toHaveLength(3);
          expect(res.data.Get.VectorTest[0].title).toBe('Two');
        });
    });

    it('should perform a nearObject query on the rating vector', () => {
      return client.graphql
        .get()
        .withClassName(className)
        .withNearObject({
          id: oneUUID,
          targetVectors: ['rating'],
        })
        .withFields('rating')
        .do()
        .then((res) => {
          expect(res.data.Get.VectorTest).toHaveLength(3);
          expect(res.data.Get.VectorTest[0].rating).toBe('Good');
        });
    });
  });

  it('should perform a nearVector query on the title vector', () => {
    return client.data
      .getterById()
      .withClassName(className)
      .withId(oneUUID)
      .withVector()
      .do()
      .then((res) =>
        client.graphql
          .get()
          .withClassName(className)
          .withNearVector({
            vector: res.vectors?.title as number[],
            targetVectors: ['title'],
          })
          .withFields('title')
          .do()
      )
      .then((res) => {
        expect(res.data.Get.VectorTest).toHaveLength(3);
        expect(res.data.Get.VectorTest[0].title).toBe('One');
      });
  });

  it('should perform a hybrid query on the rating vector', () => {
    return client.graphql
      .get()
      .withClassName(className)
      .withHybrid({
        query: 'Best',
        targetVectors: ['rating'],
      })
      .withFields('rating')
      .do()
      .then((res) => {
        expect(res.data.Get.VectorTest).toHaveLength(3);
        expect(res.data.Get.VectorTest[0].rating).toBe('Best');
      });
  });

  describe('destroy', () => {
    it('tears down VectorTest class', () => {
      return client.schema.classDeleter().withClassName(className).do();
    });
  });
});

const setup = async (client: WeaviateClient) => {
  const thing = {
    class: 'Article',
    invertedIndexConfig: { indexTimestamps: true },
    properties: [
      {
        name: 'title',
        dataType: ['text'],
      },
      {
        name: 'url',
        dataType: ['string'],
      },
      {
        name: 'wordCount',
        dataType: ['int'],
      },
    ],
  };

  await Promise.all([client.schema.classCreator().withClass(thing).do()]);

  // Note that the UUIDs are in ascending order. This is on purpose as the
  // Cursor API test relies on this fact.
  const toImport = [
    {
      id: 'abefd256-8574-442b-9293-9205193737e0',
      class: 'Article',
      properties: {
        wordCount: 60,
        url: 'http://articles.local/my-article-1',
        title: 'Article 1',
      },
    },
    {
      id: 'abefd256-8574-442b-9293-9205193737e1',
      class: 'Article',
      properties: {
        wordCount: 40,
        url: 'http://articles.local/my-article-2',
        title: 'Article 2',
      },
    },
    {
      id: 'abefd256-8574-442b-9293-9205193737e2',
      class: 'Article',
      properties: {
        wordCount: 600,
        url: 'http://articles.local/my-article-3',
        title: 'Article about Apple',
      },
    },
  ];

  let batch = client.batch.objectsBatcher();

  toImport.forEach((elem) => {
    batch = batch.withObject(elem);
  });

  await batch.do();
  return new Promise((resolve) => setTimeout(resolve, 1000));
};

const setupReplicated = async (client: WeaviateClient) => {
  const thing = {
    class: 'Article',
    invertedIndexConfig: { indexTimestamps: true },
    replicationConfig: {
      factor: 2,
    },
    properties: [
      {
        name: 'title',
        dataType: ['text'],
      },
      {
        name: 'url',
        dataType: ['string'],
      },
      {
        name: 'wordCount',
        dataType: ['int'],
      },
    ],
  };

  await Promise.all([client.schema.classCreator().withClass(thing).do()]);

  // Note that the UUIDs are in ascending order. This is on purpose as the
  // Cursor API test relies on this fact.
  const toImport = [
    {
      id: 'abefd256-8574-442b-9293-9205193737e0',
      class: 'Article',
      properties: {
        wordCount: 60,
        url: 'http://articles.local/my-article-1',
        title: 'Article 1',
      },
    },
    {
      id: 'abefd256-8574-442b-9293-9205193737e1',
      class: 'Article',
      properties: {
        wordCount: 40,
        url: 'http://articles.local/my-article-2',
        title: 'Article 2',
      },
    },
    {
      id: 'abefd256-8574-442b-9293-9205193737e2',
      class: 'Article',
      properties: {
        wordCount: 600,
        url: 'http://articles.local/my-article-3',
        title: 'Article about Apple',
      },
    },
  ];

  let batch = client.batch.objectsBatcher();

  toImport.forEach((elem) => {
    batch = batch.withObject(elem);
  });

  await batch.do();
  return new Promise((resolve) => setTimeout(resolve, 1000));
};

const setupGroupBy = async (client: WeaviateClient) => {
  const res = await setupDocumentPassageSchema(client, false);
  return res;
};

const setupMultiTenancy = async (client: WeaviateClient, tenants: Array<Tenant>) => {
  const res = await setupDocumentPassageSchema(client, true, tenants);
  return res;
};

const setupDocumentPassageSchema = async (
  client: WeaviateClient,
  multiTenancyEnabled: boolean,
  tenants?: Array<Tenant>
) => {
  const document: WeaviateClass = {
    class: 'Document',
    invertedIndexConfig: { indexTimestamps: true },
    properties: [
      {
        name: 'title',
        dataType: ['text'],
      },
    ],
    multiTenancyConfig: {
      enabled: multiTenancyEnabled,
    },
  };

  const passage: WeaviateClass = {
    class: 'Passage',
    invertedIndexConfig: { indexTimestamps: true },
    properties: [
      {
        name: 'content',
        dataType: ['text'],
      },
      {
        name: 'type',
        dataType: ['text'],
      },
      {
        name: 'ofDocument',
        dataType: ['Document'],
      },
    ],
    multiTenancyConfig: {
      enabled: multiTenancyEnabled,
    },
  };

  await Promise.all([client.schema.classCreator().withClass(document).do()]);
  await Promise.all([client.schema.classCreator().withClass(passage).do()]);

  if (tenants) {
    const documentTenants = await client.schema.tenantsCreator(document.class!, tenants).do();
    expect(documentTenants).toBeDefined();
    expect(documentTenants).toHaveLength(tenants.length);

    const passageTenants = await client.schema.tenantsCreator(passage.class!, tenants).do();
    expect(passageTenants).toBeDefined();
    expect(passageTenants).toHaveLength(tenants.length);
  }

  // document, passage uuids
  const documentIds: string[] = [
    '00000000-0000-0000-0000-00000000000a',
    '00000000-0000-0000-0000-00000000000b',
    '00000000-0000-0000-0000-00000000000c',
    '00000000-0000-0000-0000-00000000000d',
  ];

  const passageIds: string[] = [
    '00000000-0000-0000-0000-000000000001',
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000003',
    '00000000-0000-0000-0000-000000000004',
    '00000000-0000-0000-0000-000000000005',
    '00000000-0000-0000-0000-000000000006',
    '00000000-0000-0000-0000-000000000007',
    '00000000-0000-0000-0000-000000000008',
    '00000000-0000-0000-0000-000000000009',
    '00000000-0000-0000-0000-000000000010',
    '00000000-0000-0000-0000-000000000011',
    '00000000-0000-0000-0000-000000000012',
    '00000000-0000-0000-0000-000000000013',
    '00000000-0000-0000-0000-000000000014',
    '00000000-0000-0000-0000-000000000015',
    '00000000-0000-0000-0000-000000000016',
    '00000000-0000-0000-0000-000000000017',
    '00000000-0000-0000-0000-000000000018',
    '00000000-0000-0000-0000-000000000019',
    '00000000-0000-0000-0000-000000000020',
  ];

  const documents: WeaviateObject[] = [];
  for (let i = 0; i < documentIds.length; i++) {
    const obj: WeaviateObject = {
      id: documentIds[i],
      class: 'Document',
      properties: {
        title: `Title of the document ${i}`,
      },
    };
    if (tenants) {
      obj.tenant = tenants[0].name!;
    }
    documents.push(obj);
  }

  const passages: WeaviateObject[] = [];
  for (let i = 0; i < passageIds.length; i++) {
    const obj: WeaviateObject = {
      id: passageIds[i],
      class: 'Passage',
      properties: {
        content: `Passage content ${i}`,
        type: 'document-passage',
      },
    };
    if (tenants) {
      obj.tenant = tenants[0].name!;
    }
    passages.push(obj);
  }

  let batch = client.batch.objectsBatcher();
  [...documents, ...passages].forEach((elem) => {
    batch = batch.withObject(elem);
  });
  await batch.do();

  const createReferences = (
    client: WeaviateClient,
    document: WeaviateObject,
    passages: WeaviateObject[],
    tenants?: Array<Tenant>
  ): void => {
    const ref: Reference = client.data
      .referencePayloadBuilder()
      .withId(document.id!)
      .withClassName(document.class!)
      .payload();
    for (const passage of passages) {
      const refCreator: ReferenceCreator = client.data
        .referenceCreator()
        .withId(passage.id!)
        .withClassName(passage.class!)
        .withReferenceProperty('ofDocument')
        .withReference(ref);
      if (tenants) {
        refCreator.withTenant(tenants[0].name!);
      }
      refCreator.do().catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
    }
  };

  createReferences(client, documents[0], passages.slice(0, 10), tenants);
  createReferences(client, documents[1], passages.slice(10, 14), tenants);

  return new Promise((resolve) => setTimeout(resolve, 1000));
};

const setupWhereTestSchema = async (
  client: WeaviateClient,
  multiTenancyEnabled: boolean,
  tenants?: Array<Tenant>
) => {
  const document: WeaviateClass = {
    class: 'Document',
    invertedIndexConfig: { indexTimestamps: true },
    properties: [
      {
        name: 'title',
        dataType: ['text'],
      },
    ],
    multiTenancyConfig: {
      enabled: multiTenancyEnabled,
    },
  };

  const passage: WeaviateClass = {
    class: 'Passage',
    invertedIndexConfig: { indexTimestamps: true },
    properties: [
      {
        name: 'content',
        dataType: ['text'],
      },
      {
        name: 'type',
        dataType: ['text'],
      },
      {
        name: 'ofDocument',
        dataType: ['Document'],
      },
    ],
    multiTenancyConfig: {
      enabled: multiTenancyEnabled,
    },
  };

  await Promise.all([client.schema.classCreator().withClass(document).do()]);
  await Promise.all([client.schema.classCreator().withClass(passage).do()]);

  if (tenants) {
    const documentTenants = await client.schema.tenantsCreator(document.class!, tenants).do();
    expect(documentTenants).toBeDefined();
    expect(documentTenants).toHaveLength(tenants.length);

    const passageTenants = await client.schema.tenantsCreator(passage.class!, tenants).do();
    expect(passageTenants).toBeDefined();
    expect(passageTenants).toHaveLength(tenants.length);
  }

  // document, passage uuids
  const documentIds: string[] = [
    '00000000-0000-0000-0000-00000000000a',
    '00000000-0000-0000-0000-00000000000b',
    '00000000-0000-0000-0000-00000000000c',
    '00000000-0000-0000-0000-00000000000d',
  ];

  const passageIds: string[] = [
    '00000000-0000-0000-0000-000000000001',
    '00000000-0000-0000-0000-000000000002',
    '00000000-0000-0000-0000-000000000003',
    '00000000-0000-0000-0000-000000000004',
    '00000000-0000-0000-0000-000000000005',
    '00000000-0000-0000-0000-000000000006',
    '00000000-0000-0000-0000-000000000007',
    '00000000-0000-0000-0000-000000000008',
    '00000000-0000-0000-0000-000000000009',
    '00000000-0000-0000-0000-000000000010',
    '00000000-0000-0000-0000-000000000011',
    '00000000-0000-0000-0000-000000000012',
    '00000000-0000-0000-0000-000000000013',
    '00000000-0000-0000-0000-000000000014',
    '00000000-0000-0000-0000-000000000015',
    '00000000-0000-0000-0000-000000000016',
    '00000000-0000-0000-0000-000000000017',
    '00000000-0000-0000-0000-000000000018',
    '00000000-0000-0000-0000-000000000019',
    '00000000-0000-0000-0000-000000000020',
  ];

  const documents: WeaviateObject[] = [];
  for (let i = 0; i < documentIds.length; i++) {
    const obj: WeaviateObject = {
      id: documentIds[i],
      class: 'Document',
      properties: {
        title: `Title of the document ${i}`,
      },
    };
    if (tenants) {
      obj.tenant = tenants[0].name!;
    }
    documents.push(obj);
  }

  const passages: WeaviateObject[] = [];
  for (let i = 0; i < passageIds.length; i++) {
    const obj: WeaviateObject = {
      id: passageIds[i],
      class: 'Passage',
      properties: {
        content: `Passage content ${i}`,
        type: 'document-passage',
      },
    };
    if (tenants) {
      obj.tenant = tenants[0].name!;
    }
    passages.push(obj);
  }

  let batch = client.batch.objectsBatcher();
  [...documents, ...passages].forEach((elem) => {
    batch = batch.withObject(elem);
  });
  await batch.do();

  const createReferences = (
    client: WeaviateClient,
    document: WeaviateObject,
    passages: WeaviateObject[],
    tenants?: Array<Tenant>
  ): void => {
    const ref: Reference = client.data
      .referencePayloadBuilder()
      .withId(document.id!)
      .withClassName(document.class!)
      .payload();
    for (const passage of passages) {
      const refCreator: ReferenceCreator = client.data
        .referenceCreator()
        .withId(passage.id!)
        .withClassName(passage.class!)
        .withReferenceProperty('ofDocument')
        .withReference(ref);
      if (tenants) {
        refCreator.withTenant(tenants[0].name!);
      }
      refCreator.do().catch((e: WeaviateError) => {
        throw new Error('it should not have errord: ' + e);
      });
    }
  };

  createReferences(client, documents[0], passages.slice(0, 10), tenants);
  createReferences(client, documents[1], passages.slice(10, 14), tenants);

  return new Promise((resolve) => setTimeout(resolve, 1000));
};



---
File: /src/graphql/nearImage.ts
---

import { NearMediaBase } from './nearMedia.js';

export interface NearImageArgs extends NearMediaBase {
  image?: string;
  targetVectors?: string[];
}

export default class GraphQLNearImage {
  private certainty?: number;
  private distance?: number;
  private image?: string;
  private targetVectors?: string[];

  constructor(args: NearImageArgs) {
    this.certainty = args.certainty;
    this.distance = args.distance;
    this.image = args.image;
    this.targetVectors = args.targetVectors;
  }

  toString(wrap = true) {
    this.validate();

    let args: string[] = [];

    if (this.image) {
      let img = this.image;
      if (img.startsWith('data:')) {
        const base64part = ';base64,';
        img = img.substring(img.indexOf(base64part) + base64part.length);
      }
      args = [...args, `image:${JSON.stringify(img)}`];
    }

    if (this.certainty) {
      args = [...args, `certainty:${this.certainty}`];
    }

    if (this.distance) {
      args = [...args, `distance:${this.distance}`];
    }

    if (this.targetVectors && this.targetVectors.length > 0) {
      args = [...args, `targetVectors:${JSON.stringify(this.targetVectors)}`];
    }

    if (!wrap) {
      return `${args.join(',')}`;
    }
    return `{${args.join(',')}}`;
  }

  validate() {
    if (!this.image) {
      throw new Error('nearImage filter: image field must be present');
    }
  }
}



---
File: /src/graphql/nearMedia.ts
---

export interface NearMediaBase {
  certainty?: number;
  distance?: number;
  targetVectors?: string[];
}
export interface NearMediaArgs extends NearMediaBase {
  media: string;
  type: NearMediaType;
}
export interface NearImageArgs extends NearMediaBase {
  image: string;
}
export interface NearAudioArgs extends NearMediaBase {
  audio: string;
}
export interface NearVideoArgs extends NearMediaBase {
  video: string;
}
export interface NearThermalArgs extends NearMediaBase {
  thermal: string;
}
export interface NearDepthArgs extends NearMediaBase {
  depth: string;
}
export interface NearIMUArgs extends NearMediaBase {
  imu: string;
}

export enum NearMediaType {
  Image = 'Image',
  Audio = 'Audio',
  Video = 'Video',
  Thermal = 'Thermal',
  Depth = 'Depth',
  IMU = 'IMU',
}

export default class GraphQLNearMedia {
  private certainty?: number;
  private distance?: number;
  private media: string;
  private type: NearMediaType;
  private targetVectors?: string[];

  constructor(args: NearMediaArgs) {
    this.certainty = args.certainty;
    this.distance = args.distance;
    this.media = args.media;
    this.type = args.type;
    this.targetVectors = args.targetVectors;
  }

  toString(wrap = true) {
    let args: string[] = [];

    if (this.media.startsWith('data:')) {
      const base64part = ';base64,';
      this.media = this.media.substring(this.media.indexOf(base64part) + base64part.length);
    }
    args = [...args, `${this.type.toLowerCase()}:${JSON.stringify(this.media)}`];

    if (this.certainty) {
      args = [...args, `certainty:${this.certainty}`];
    }

    if (this.distance) {
      args = [...args, `distance:${this.distance}`];
    }

    if (this.targetVectors && this.targetVectors.length > 0) {
      args = [...args, `targetVectors:${JSON.stringify(this.targetVectors)}`];
    }

    if (!wrap) {
      return `${args.join(',')}`;
    }
    return `{${args.join(',')}}`;
  }
}



---
File: /src/graphql/nearObject.ts
---

export interface NearObjectArgs {
  beacon?: string;
  certainty?: number;
  distance?: number;
  id?: string;
  targetVectors?: string[];
}

export default class GraphQLNearObject {
  private beacon?: string;
  private certainty?: number;
  private distance?: number;
  private id?: string;
  private targetVectors?: string[];

  constructor(args: NearObjectArgs) {
    this.beacon = args.beacon;
    this.certainty = args.certainty;
    this.distance = args.distance;
    this.id = args.id;
    this.targetVectors = args.targetVectors;
  }

  toString(wrap = true) {
    this.validate();

    let args: any[] = [];

    if (this.id) {
      args = [...args, `id:${JSON.stringify(this.id)}`];
    }

    if (this.beacon) {
      args = [...args, `beacon:${JSON.stringify(this.beacon)}`];
    }

    if (this.certainty) {
      args = [...args, `certainty:${this.certainty}`];
    }

    if (this.distance) {
      args = [...args, `distance:${this.distance}`];
    }

    if (this.targetVectors && this.targetVectors.length > 0) {
      args = [...args, `targetVectors:${JSON.stringify(this.targetVectors)}`];
    }

    if (!wrap) {
      return `${args.join(',')}`;
    }
    return `{${args.join(',')}}`;
  }

  validate() {
    if (!this.id && !this.beacon) {
      throw new Error('nearObject filter: id or beacon needs to be set');
    }
  }
}



---
File: /src/graphql/nearText.ts
---

export interface NearTextArgs {
  autocorrect?: boolean;
  certainty?: number;
  concepts: string[];
  distance?: number;
  moveAwayFrom?: Move;
  moveTo?: Move;
  targetVectors?: string[];
}

export interface Move {
  objects?: MoveObject[];
  concepts?: string[];
  force?: number;
}

export interface MoveObject {
  beacon?: string;
  id?: string;
}

export default class GraphQLNearText {
  private autocorrect?: boolean;
  private certainty?: number;
  private concepts: string[];
  private distance?: number;
  private moveAwayFrom?: any;
  private moveTo?: any;
  private targetVectors?: string[];

  constructor(args: NearTextArgs) {
    this.autocorrect = args.autocorrect;
    this.certainty = args.certainty;
    this.concepts = args.concepts;
    this.distance = args.distance;
    this.moveAwayFrom = args.moveAwayFrom;
    this.moveTo = args.moveTo;
    this.targetVectors = args.targetVectors;
  }

  toString(): string {
    this.validate();

    let args = [`concepts:${JSON.stringify(this.concepts)}`];

    if (this.certainty) {
      args = [...args, `certainty:${this.certainty}`];
    }

    if (this.distance) {
      args = [...args, `distance:${this.distance}`];
    }

    if (this.targetVectors && this.targetVectors.length > 0) {
      args = [...args, `targetVectors:${JSON.stringify(this.targetVectors)}`];
    }

    if (this.moveTo) {
      args = [...args, parseMove('moveTo', this.moveTo)];
    }

    if (this.moveAwayFrom) {
      args = [...args, parseMove('moveAwayFrom', this.moveAwayFrom)];
    }

    if (this.autocorrect !== undefined) {
      args = [...args, `autocorrect:${this.autocorrect}`];
    }

    return `{${args.join(',')}}`;
  }

  validate() {
    if (this.moveTo) {
      if (!this.moveTo.concepts && !this.moveTo.objects) {
        throw new Error('nearText filter: moveTo.concepts or moveTo.objects must be present');
      }
      if (!this.moveTo.force || (!this.moveTo.concepts && !this.moveTo.objects)) {
        throw new Error("nearText filter: moveTo must have fields 'concepts' or 'objects' and 'force'");
      }
    }

    if (this.moveAwayFrom) {
      if (!this.moveAwayFrom.concepts && !this.moveAwayFrom.objects) {
        throw new Error('nearText filter: moveAwayFrom.concepts or moveAwayFrom.objects must be present');
      }
      if (!this.moveAwayFrom.force || (!this.moveAwayFrom.concepts && !this.moveAwayFrom.objects)) {
        throw new Error("nearText filter: moveAwayFrom must have fields 'concepts' or 'objects' and 'force'");
      }
    }
  }
}

type MoveType = 'moveTo' | 'moveAwayFrom';

export function parseMoveObjects(move: MoveType, objects: MoveObject[]): string {
  const moveObjects: string[] = [];
  for (const i in objects) {
    if (!objects[i].id && !objects[i].beacon) {
      throw new Error(`nearText: ${move}.objects[${i}].id or ${move}.objects[${i}].beacon must be present`);
    }
    const objs = [];
    if (objects[i].id) {
      objs.push(`id:"${objects[i].id}"`);
    }
    if (objects[i].beacon) {
      objs.push(`beacon:"${objects[i].beacon}"`);
    }
    moveObjects.push(`{${objs.join(',')}}`);
  }
  return `[${moveObjects.join(',')}]`;
}

export function parseMove(move: MoveType, args: Move): string {
  let moveArgs: string[] = [];
  if (args.concepts) {
    moveArgs = [...moveArgs, `concepts:${JSON.stringify(args.concepts)}`];
  }
  if (args.objects) {
    moveArgs = [...moveArgs, `objects:${parseMoveObjects(move, args.objects)}`];
  }
  if (args.force) {
    moveArgs = [...moveArgs, `force:${args.force}`];
  }
  return `${move}:{${moveArgs.join(',')}}`;
}



---
File: /src/graphql/nearVector.ts
---

export interface NearVectorArgs {
  certainty?: number;
  distance?: number;
  vector: number[];
  targetVectors?: string[];
}

export default class GraphQLNearVector {
  private certainty?: number;
  private distance?: number;
  private vector: number[];
  private targetVectors?: string[];

  constructor(args: NearVectorArgs) {
    this.certainty = args.certainty;
    this.distance = args.distance;
    this.vector = args.vector;
    this.targetVectors = args.targetVectors;
  }

  toString(wrap = true) {
    let args = [`vector:${JSON.stringify(this.vector)}`]; // vector must always be set

    if (this.certainty) {
      args = [...args, `certainty:${this.certainty}`];
    }

    if (this.distance) {
      args = [...args, `distance:${this.distance}`];
    }

    if (this.targetVectors && this.targetVectors.length > 0) {
      args = [...args, `targetVectors:${JSON.stringify(this.targetVectors)}`];
    }

    if (!wrap) {
      return `${args.join(',')}`;
    }
    return `{${args.join(',')}}`;
  }
}



---
File: /src/graphql/raw.test.ts
---

import Raw from './raw.js';

test('a simple raw query', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  const expectedQuery = `{Get{Person{name}}}`;

  new Raw(mockClient).withQuery(expectedQuery).do();

  expect(mockClient.query).toHaveBeenCalledWith(expectedQuery);
});

test('reject empty raw query', () => {
  const mockClient: any = {
    query: jest.fn(),
  };

  new Raw(mockClient).do().catch((err: Error) => {
    expect(err.message).toEqual('invalid usage: query must be set - set with .raw().withQuery(query)');
  });
});



---
File: /src/graphql/raw.ts
---

import Connection from '../connection/index.js';
import { CommandBase } from '../validation/commandBase.js';

export default class RawGraphQL extends CommandBase {
  private query?: string;

  constructor(client: Connection) {
    super(client);
  }

  withQuery = (query: string) => {
    this.query = query;
    return this;
  };

  validateIsSet = (prop: string | undefined | null, name: string, setter: string) => {
    if (prop == undefined || prop == null || prop.length == 0) {
      this.addError(`${name} must be set - set with ${setter}`);
    }
  };

  validate = () => {
    this.validateIsSet(this.query, 'query', '.raw().withQuery(query)');
  };

  do = (): Promise<any> => {
    const params = '';

    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }

    if (this.query) {
      return this.client.query(this.query);
    }

    return Promise.resolve(undefined);
  };
}



---
File: /src/graphql/sort.ts
---

export interface SortArgs {
  path: string[];
  order?: string;
}

export type SortOrder = 'asc' | 'desc';

export default class GraphQLSort {
  private args: SortArgs[];

  constructor(args: SortArgs[]) {
    this.args = args;
  }

  toString(): string {
    const parts: string[] = [];

    for (const arg of this.args) {
      let part = `{path:${JSON.stringify(arg.path)}`;
      if (arg.order) {
        part = part.concat(`,order:${arg.order}}`);
      } else {
        part = part.concat('}');
      }
      parts.push(part);
    }

    return parts.join(',');
  }
}



---
File: /src/graphql/where.ts
---

import { WhereFilter } from '../openapi/types.js';

export default class GraphQLWhere {
  private operands?: string;
  private operator?: string;
  private path?: string[];
  private readonly source: any;
  private valueContent: any;
  private valueType?: string;

  constructor(whereObj: WhereFilter) {
    this.source = whereObj;
  }

  toString() {
    this.parse();
    this.validate();
    if (this.operands) {
      return `{operator:${this.operator},operands:[${this.operands}]}`;
    } else {
      // this is an on-value filter

      const valueType = this.getValueType();
      const valueContent = this.marshalValueContent();
      return (
        `{` +
        `operator:${this.operator},` +
        `${valueType}:${valueContent},` +
        `path:${JSON.stringify(this.path)}` +
        `}`
      );
    }
  }

  marshalValueContent() {
    if (this.valueType == 'valueGeoRange') {
      return this.marshalValueGeoRange();
    }

    return JSON.stringify(this.valueContent);
  }

  getValueType() {
    switch (this.valueType) {
      case 'valueStringArray': {
        return 'valueString';
      }
      case 'valueTextArray': {
        return 'valueText';
      }
      case 'valueIntArray': {
        return 'valueInt';
      }
      case 'valueNumberArray': {
        return 'valueNumber';
      }
      case 'valueDateArray': {
        return 'valueDate';
      }
      case 'valueBooleanArray': {
        return 'valueBoolean';
      }
      default: {
        return this.valueType;
      }
    }
  }

  marshalValueGeoRange() {
    let parts: any[] = [];

    const gc = this.valueContent.geoCoordinates;
    if (gc) {
      let gcParts: any[] = [];

      if (gc.latitude) {
        gcParts = [...gcParts, `latitude:${gc.latitude}`];
      }

      if (gc.longitude) {
        gcParts = [...gcParts, `longitude:${gc.longitude}`];
      }
      parts = [...parts, `geoCoordinates:{${gcParts.join(',')}}`];
    }

    const d = this.valueContent.distance;
    if (d) {
      let dParts: any[] = [];
      if (d.max) {
        dParts = [...dParts, `max:${d.max}`];
      }

      parts = [...parts, `distance:{${dParts.join(',')}}`];
    }

    return `{${parts.join(',')}}`;
  }

  validate() {
    if (!this.operator) {
      throw new Error('where filter: operator cannot be empty');
    }

    if (!this.operands) {
      if (!this.valueType) {
        throw new Error('where filter: value<Type> cannot be empty');
      }

      if (!this.path) {
        throw new Error('where filter: path cannot be empty');
      }
    }
  }

  parse() {
    for (const key in this.source) {
      switch (key) {
        case 'operator':
          this.parseOperator(this.source[key]);
          break;
        case 'operands':
          this.parseOperands(this.source[key]);
          break;
        case 'path':
          this.parsePath(this.source[key]);
          break;
        default:
          if (key.indexOf('value') != 0) {
            throw new Error("where filter: unrecognized key '" + key + "'");
          }
          this.parseValue(key, this.source[key]);
      }
    }
  }

  parseOperator(op: string) {
    if (typeof op !== 'string') {
      throw new Error('where filter: operator must be a string');
    }

    this.operator = op;
  }

  parsePath(path: string[]) {
    if (!Array.isArray(path)) {
      throw new Error('where filter: path must be an array');
    }

    this.path = path;
  }

  parseValue(key: string, value: any) {
    switch (key) {
      case 'valueString':
      case 'valueText':
      case 'valueInt':
      case 'valueNumber':
      case 'valueDate':
      case 'valueBoolean':
      case 'valueStringArray':
      case 'valueTextArray':
      case 'valueIntArray':
      case 'valueNumberArray':
      case 'valueDateArray':
      case 'valueBooleanArray':
      case 'valueGeoRange':
        break;
      default:
        throw new Error("where filter: unrecognized value prop '" + key + "'");
    }
    this.valueType = key;
    this.valueContent = value;
  }

  parseOperands(ops: any[]) {
    if (!Array.isArray(ops)) {
      throw new Error('where filter: operands must be an array');
    }

    this.operands = ops
      .map((element) => {
        return new GraphQLWhere(element).toString();
      })
      .join(',');
  }
}



---
File: /src/grpc/base.ts
---

import { isAbortError } from 'abort-controller-x';
import { ConsistencyLevel } from '../data/index.js';

import { Metadata } from 'nice-grpc';
import { RetryOptions } from 'nice-grpc-client-middleware-retry';
import { WeaviateRequestTimeoutError } from '../errors.js';
import { ConsistencyLevel as ConsistencyLevelGRPC } from '../proto/v1/base.js';
import { WeaviateClient } from '../proto/v1/weaviate.js';

export default class Base {
  protected connection: WeaviateClient<RetryOptions>;
  protected collection: string;
  protected timeout: number;
  protected consistencyLevel?: ConsistencyLevelGRPC;
  protected tenant?: string;
  protected metadata?: Metadata;

  protected constructor(
    connection: WeaviateClient<RetryOptions>,
    collection: string,
    metadata: Metadata,
    timeout: number,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ) {
    this.connection = connection;
    this.collection = collection;
    this.metadata = metadata;
    this.timeout = timeout;
    this.consistencyLevel = this.mapConsistencyLevel(consistencyLevel);
    this.tenant = tenant;
  }

  private mapConsistencyLevel(consistencyLevel?: ConsistencyLevel): ConsistencyLevelGRPC {
    switch (consistencyLevel) {
      case 'ALL':
        return ConsistencyLevelGRPC.CONSISTENCY_LEVEL_ALL;
      case 'QUORUM':
        return ConsistencyLevelGRPC.CONSISTENCY_LEVEL_QUORUM;
      case 'ONE':
        return ConsistencyLevelGRPC.CONSISTENCY_LEVEL_ONE;
      default:
        return ConsistencyLevelGRPC.CONSISTENCY_LEVEL_UNSPECIFIED;
    }
  }

  protected sendWithTimeout = <T>(send: (signal: AbortSignal) => Promise<T>): Promise<T> => {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout * 1000);
    return send(controller.signal)
      .catch((error) => {
        if (isAbortError(error)) {
          throw new WeaviateRequestTimeoutError(`timed out after ${this.timeout}ms`);
        }
        throw error;
      })
      .finally(() => clearTimeout(timeoutId));
  };
}



---
File: /src/grpc/batcher.ts
---

import { Metadata } from 'nice-grpc';

import { ConsistencyLevel } from '../data/index.js';

import { BatchObject, BatchObjectsReply, BatchObjectsRequest } from '../proto/v1/batch.js';
import { WeaviateClient } from '../proto/v1/weaviate.js';

import { RetryOptions } from 'nice-grpc-client-middleware-retry';
import { WeaviateBatchError, WeaviateDeleteManyError } from '../errors.js';
import { Filters } from '../proto/v1/base.js';
import { BatchDeleteReply, BatchDeleteRequest } from '../proto/v1/batch_delete.js';
import Base from './base.js';

import { retryOptions } from './retry.js';

export interface Batch {
  withDelete: (args: BatchDeleteArgs) => Promise<BatchDeleteReply>;
  withObjects: (args: BatchObjectsArgs) => Promise<BatchObjectsReply>;
}

export interface BatchObjectsArgs {
  objects: BatchObject[];
}

export interface BatchDeleteArgs {
  filters: Filters | undefined;
  verbose?: boolean;
  dryRun?: boolean;
}

export default class Batcher extends Base implements Batch {
  public static use(
    connection: WeaviateClient<RetryOptions>,
    collection: string,
    metadata: Metadata,
    timeout: number,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ): Batch {
    return new Batcher(connection, collection, metadata, timeout, consistencyLevel, tenant);
  }

  public withDelete = (args: BatchDeleteArgs) => this.callDelete(BatchDeleteRequest.fromPartial(args));
  public withObjects = (args: BatchObjectsArgs) => this.callObjects(BatchObjectsRequest.fromPartial(args));

  private callDelete(message: BatchDeleteRequest) {
    return this.sendWithTimeout((signal: AbortSignal) =>
      this.connection.batchDelete(
        {
          ...message,
          collection: this.collection,
          consistencyLevel: this.consistencyLevel,
          tenant: this.tenant,
        },
        {
          metadata: this.metadata,
          signal,
        }
      )
    ).catch((err) => {
      throw new WeaviateDeleteManyError(err.message);
    });
  }

  private callObjects(message: BatchObjectsRequest) {
    return this.sendWithTimeout((signal: AbortSignal) =>
      this.connection
        .batchObjects(
          {
            ...message,
            consistencyLevel: this.consistencyLevel,
          },
          {
            metadata: this.metadata,
            signal,
            ...retryOptions,
          }
        )
        .catch((err) => {
          throw new WeaviateBatchError(err.message);
        })
    );
  }
}



---
File: /src/grpc/retry.ts
---

import { ClientError, Status } from 'nice-grpc';
import { RetryOptions } from 'nice-grpc-client-middleware-retry';

export const retryOptions: RetryOptions = {
  retry: true,
  retryMaxAttempts: 5,
  retryableStatuses: [Status.UNAVAILABLE],
  onRetryableError(error: ClientError, attempt: number, delayMs: number) {
    console.warn(error, `Attempt ${attempt} failed. Retrying in ${delayMs}ms.`);
  },
};



---
File: /src/grpc/searcher.ts
---

import { ConsistencyLevel } from '../data/index.js';

import { Metadata } from 'nice-grpc';
import { Filters } from '../proto/v1/base.js';
import {
  BM25,
  GroupBy,
  Hybrid,
  MetadataRequest,
  NearAudioSearch,
  NearDepthSearch,
  NearImageSearch,
  NearIMUSearch,
  NearObject,
  NearTextSearch,
  NearThermalSearch,
  NearVector,
  NearVideoSearch,
  PropertiesRequest,
  Rerank,
  SearchReply,
  SearchRequest,
  SortBy,
} from '../proto/v1/search_get.js';
import { WeaviateClient } from '../proto/v1/weaviate.js';

import { RetryOptions } from 'nice-grpc-client-middleware-retry';
import { WeaviateQueryError } from '../errors.js';
import { GenerativeSearch } from '../proto/v1/generative.js';
import Base from './base.js';
import { retryOptions } from './retry.js';

export type SearchFetchArgs = {
  limit?: number;
  offset?: number;
  after?: string;
  filters?: Filters;
  sortBy?: SortBy[];
  metadata?: MetadataRequest;
  properties?: PropertiesRequest;
  generative?: GenerativeSearch;
  groupBy?: GroupBy;
};

export type BaseSearchArgs = {
  limit?: number;
  offset?: number;
  autocut?: number;
  filters?: Filters;
  rerank?: Rerank;
  metadata?: MetadataRequest;
  properties?: PropertiesRequest;
  generative?: GenerativeSearch;
  groupBy?: GroupBy;
};

export type SearchBm25Args = BaseSearchArgs & {
  bm25Search: BM25;
};

export type SearchHybridArgs = BaseSearchArgs & {
  hybridSearch: Hybrid;
};

export type SearchNearAudioArgs = BaseSearchArgs & {
  nearAudio: NearAudioSearch;
};

export type SearchNearDepthArgs = BaseSearchArgs & {
  nearDepth: NearDepthSearch;
};

export type SearchNearImageArgs = BaseSearchArgs & {
  nearImage: NearImageSearch;
};

export type SearchNearIMUArgs = BaseSearchArgs & {
  nearIMU: NearIMUSearch;
};

export type SearchNearObjectArgs = BaseSearchArgs & {
  nearObject: NearObject;
};

export type SearchNearTextArgs = BaseSearchArgs & {
  nearText: NearTextSearch;
};

export type SearchNearThermalArgs = BaseSearchArgs & {
  nearThermal: NearThermalSearch;
};

export type SearchNearVectorArgs = BaseSearchArgs & {
  nearVector: NearVector;
};

export type SearchNearVideoArgs = BaseSearchArgs & {
  nearVideo: NearVideoSearch;
};

export interface Search {
  withFetch: (args: SearchFetchArgs) => Promise<SearchReply>;
  withBm25: (args: SearchBm25Args) => Promise<SearchReply>;
  withHybrid: (args: SearchHybridArgs) => Promise<SearchReply>;
  withNearAudio: (args: SearchNearAudioArgs) => Promise<SearchReply>;
  withNearDepth: (args: SearchNearDepthArgs) => Promise<SearchReply>;
  withNearImage: (args: SearchNearImageArgs) => Promise<SearchReply>;
  withNearIMU: (args: SearchNearIMUArgs) => Promise<SearchReply>;
  withNearObject: (args: SearchNearObjectArgs) => Promise<SearchReply>;
  withNearText: (args: SearchNearTextArgs) => Promise<SearchReply>;
  withNearThermal: (args: SearchNearThermalArgs) => Promise<SearchReply>;
  withNearVector: (args: SearchNearVectorArgs) => Promise<SearchReply>;
  withNearVideo: (args: SearchNearVideoArgs) => Promise<SearchReply>;
}

export default class Searcher extends Base implements Search {
  public static use(
    connection: WeaviateClient<RetryOptions>,
    collection: string,
    metadata: Metadata,
    timeout: number,
    consistencyLevel?: ConsistencyLevel,
    tenant?: string
  ): Search {
    return new Searcher(connection, collection, metadata, timeout, consistencyLevel, tenant);
  }

  public withFetch = (args: SearchFetchArgs) => this.call(SearchRequest.fromPartial(args));
  public withBm25 = (args: SearchBm25Args) => this.call(SearchRequest.fromPartial(args));
  public withHybrid = (args: SearchHybridArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearAudio = (args: SearchNearAudioArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearDepth = (args: SearchNearDepthArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearImage = (args: SearchNearImageArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearIMU = (args: SearchNearIMUArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearObject = (args: SearchNearObjectArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearText = (args: SearchNearTextArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearThermal = (args: SearchNearThermalArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearVector = (args: SearchNearVectorArgs) => this.call(SearchRequest.fromPartial(args));
  public withNearVideo = (args: SearchNearVideoArgs) => this.call(SearchRequest.fromPartial(args));

  private call = (message: SearchRequest) =>
    this.sendWithTimeout((signal: AbortSignal) =>
      this.connection
        .search(
          {
            ...message,
            collection: this.collection,
            consistencyLevel: this.consistencyLevel,
            tenant: this.tenant,
            uses123Api: true,
            uses125Api: true,
          },
          {
            metadata: this.metadata,
            signal,
            ...retryOptions,
          }
        )
        .catch((err) => {
          throw new WeaviateQueryError(err.message, 'gRPC');
        })
    );
}



---
File: /src/grpc/tenantsManager.ts
---

import { Metadata } from 'nice-grpc';
import { RetryOptions } from 'nice-grpc-client-middleware-retry';
import { TenantsGetReply, TenantsGetRequest } from '../proto/v1/tenants.js';
import { WeaviateClient } from '../proto/v1/weaviate.js';
import Base from './base.js';
import { retryOptions } from './retry.js';

export type TenantsGetArgs = {
  names?: string[];
};

export interface Tenants {
  withGet: (args: TenantsGetArgs) => Promise<TenantsGetReply>;
}

export default class TenantsManager extends Base implements Tenants {
  public static use(
    connection: WeaviateClient<RetryOptions>,
    collection: string,
    metadata: Metadata,
    timeout: number
  ): Tenants {
    return new TenantsManager(connection, collection, metadata, timeout);
  }

  public withGet = (args: TenantsGetArgs) =>
    this.call(TenantsGetRequest.fromPartial({ names: args.names ? { values: args.names } : undefined }));

  private call(message: TenantsGetRequest) {
    return this.sendWithTimeout((signal: AbortSignal) =>
      this.connection.tenantsGet(
        {
          ...message,
          collection: this.collection,
        },
        {
          metadata: this.metadata,
          signal,
          ...retryOptions,
        }
      )
    );
  }
}



---
File: /src/misc/index.ts
---

import Connection from '../connection/index.js';
import { DbVersionProvider } from '../utils/dbVersion.js';
import LiveChecker from './liveChecker.js';
import MetaGetter from './metaGetter.js';
import OpenidConfigurationGetter from './openidConfigurationGetter.js';
import ReadyChecker from './readyChecker.js';

export interface Misc {
  liveChecker: () => LiveChecker;
  readyChecker: () => ReadyChecker;
  metaGetter: () => MetaGetter;
  openidConfigurationGetter: () => OpenidConfigurationGetter;
}

const misc = (client: Connection, dbVersionProvider: DbVersionProvider): Misc => {
  return {
    liveChecker: () => new LiveChecker(client, dbVersionProvider),
    readyChecker: () => new ReadyChecker(client, dbVersionProvider),
    metaGetter: () => new MetaGetter(client),
    openidConfigurationGetter: () => new OpenidConfigurationGetter(client.http),
  };
};

export default misc;
export { default as LiveChecker } from './liveChecker.js';
export { default as MetaGetter } from './metaGetter.js';
export { default as OpenidConfigurationGetter } from './openidConfigurationGetter.js';
export { default as ReadyChecker } from './readyChecker.js';



---
File: /src/misc/journey.test.ts
---

import weaviate from '../v2/index.js';

describe('misc endpoints', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  const authClient = weaviate.client({
    scheme: 'http',
    host: 'localhost:8085',
  });

  it('reports as live', () => {
    return client.misc
      .liveChecker()
      .do()
      .then((res: any) => expect(res).toEqual(true))
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('reports as not live with a broken url', () => {
    const brokenClient = weaviate.client({
      scheme: 'http',
      host: 'localhost:12345', // note the incorrect port
    });

    return brokenClient.misc
      .liveChecker()
      .do()
      .then((res: any) => expect(res).toEqual(false))
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('reports as ready', () => {
    return client.misc
      .readyChecker()
      .do()
      .then((res: any) => expect(res).toEqual(true))
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('reports as not ready with a broken url', () => {
    const brokenClient = weaviate.client({
      scheme: 'http',
      host: 'localhost:12345', // note the incorrect port
    });

    return brokenClient.misc
      .readyChecker()
      .do()
      .then((res: any) => expect(res).toEqual(false))
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('displays meta info', () => {
    return client.misc
      .metaGetter()
      .do()
      .then((res: any) => {
        expect(res.version).toBeDefined();
        expect(res.modules['text2vec-contextionary'].wordCount).toBeDefined();
        expect(res.modules['text2vec-contextionary'].wordCount).toBeGreaterThan(100);
      })
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('shows oidc config as undefined when not set', () => {
    return client.misc
      .openidConfigurationGetter()
      .do()
      .then((res: any) => {
        expect(res).toBeUndefined();
      })
      .catch((e: any) => {
        throw new Error('it should not have errord: ' + e);
      });
  });

  it('shows oidc config when set', () => {
    return authClient.misc
      .openidConfigurationGetter()
      .do()
      .then((res: any) => {
        expect(res.clientId).toEqual('wcs');
        expect(res.href).toContain('.well-known/openid-configuration');
        expect(res.scopes).toEqual(['openid', 'email']);
      });
  });
});



---
File: /src/misc/liveChecker.ts
---

import Connection from '../connection/index.js';
import { DbVersionProvider } from '../utils/dbVersion.js';
import { CommandBase } from '../validation/commandBase.js';

export default class LiveChecker extends CommandBase {
  private dbVersionProvider: DbVersionProvider;

  constructor(client: Connection, dbVersionProvider: DbVersionProvider) {
    super(client);
    this.dbVersionProvider = dbVersionProvider;
  }

  validate() {
    // nothing to validate
  }

  do = () => {
    return this.client
      .get('/.well-known/live', false)
      .then(() => {
        setTimeout(() => this.dbVersionProvider.refresh());
        return Promise.resolve(true);
      })
      .catch(() => Promise.resolve(false));
  };
}



---
File: /src/misc/metaGetter.ts
---

import Connection from '../connection/index.js';
import { Meta } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class MetaGetter extends CommandBase {
  constructor(client: Connection) {
    super(client);
  }

  validate() {
    // nothing to validate
  }

  do = (): Promise<Meta> => {
    return this.client.get('/meta', true);
  };
}



---
File: /src/misc/openidConfigurationGetter.ts
---

import { HttpClient } from '../connection/http.js';

export default class OpenidConfigurationGetterGetter {
  private client: HttpClient;
  constructor(client: HttpClient) {
    this.client = client;
  }

  do = () => {
    return this.client
      .getRaw('/.well-known/openid-configuration')
      .then((res: { status: number; json: () => any }) => {
        if (res.status < 400) {
          return res.json();
        }

        if (res.status == 404) {
          // OIDC is not configured
          return Promise.resolve(undefined);
        }

        return Promise.reject(new Error(`unexpected status code: ${res.status}`));
      });
  };
}



---
File: /src/misc/readyChecker.ts
---

import Connection from '../connection/index.js';
import { DbVersionProvider } from '../utils/dbVersion.js';
import { CommandBase } from '../validation/commandBase.js';

export default class ReadyChecker extends CommandBase {
  private dbVersionProvider: DbVersionProvider;

  constructor(client: Connection, dbVersionProvider: DbVersionProvider) {
    super(client);
    this.dbVersionProvider = dbVersionProvider;
  }

  validate() {
    // nothing to validate
  }

  do = () => {
    return this.client
      .get('/.well-known/ready', false)
      .then(() => {
        setTimeout(() => this.dbVersionProvider.refresh());
        return Promise.resolve(true);
      })
      .catch(() => Promise.resolve(false));
  };
}



---
File: /src/openapi/schema.ts
---

/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/': {
    /** Home. Discover the REST API */
    get: operations['weaviate.root'];
  };
  '/.well-known/live': {
    /** Determines whether the application is alive. Can be used for kubernetes liveness probe */
    get: operations['weaviate.wellknown.liveness'];
  };
  '/.well-known/ready': {
    /** Determines whether the application is ready to receive traffic. Can be used for kubernetes readiness probe. */
    get: operations['weaviate.wellknown.readiness'];
  };
  '/.well-known/openid-configuration': {
    /** OIDC Discovery page, redirects to the token issuer if one is configured */
    get: {
      responses: {
        /** Successful response, inspect body */
        200: {
          schema: {
            /** @description The Location to redirect to */
            href?: string;
            /** @description OAuth Client ID */
            clientId?: string;
            /** @description OAuth Scopes */
            scopes?: string[];
          };
        };
        /** Not found, no oidc provider present */
        404: unknown;
        /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
        500: {
          schema: definitions['ErrorResponse'];
        };
      };
    };
  };
  '/objects': {
    /** Lists all Objects in reverse order of creation, owned by the user that belongs to the used token. */
    get: operations['objects.list'];
    /** Registers a new Object. Provided meta-data and schema values are validated. */
    post: operations['objects.create'];
  };
  '/objects/{id}': {
    /** Lists Objects. */
    get: operations['objects.get'];
    /** Updates an Object's data. Given meta-data and schema values are validated. LastUpdateTime is set to the time this function is called. */
    put: operations['objects.update'];
    /** Deletes an Object from the system. */
    delete: operations['objects.delete'];
    /** Checks if an Object exists in the system. */
    head: operations['objects.head'];
    /** Updates an Object. This method supports json-merge style patch semantics (RFC 7396). Provided meta-data and schema values are validated. LastUpdateTime is set to the time this function is called. */
    patch: operations['objects.patch'];
  };
  '/objects/{className}/{id}': {
    /** Get a single data object */
    get: operations['objects.class.get'];
    /** Update an individual data object based on its class and uuid. */
    put: operations['objects.class.put'];
    /** Delete a single data object. */
    delete: operations['objects.class.delete'];
    /** Checks if a data object exists without retrieving it. */
    head: operations['objects.class.head'];
    /** Update an individual data object based on its class and uuid. This method supports json-merge style patch semantics (RFC 7396). Provided meta-data and schema values are validated. LastUpdateTime is set to the time this function is called. */
    patch: operations['objects.class.patch'];
  };
  '/objects/{id}/references/{propertyName}': {
    /** Replace all references to a class-property. */
    put: operations['objects.references.update'];
    /** Add a single reference to a class-property. */
    post: operations['objects.references.create'];
    /** Delete the single reference that is given in the body from the list of references that this property has. */
    delete: operations['objects.references.delete'];
  };
  '/objects/{className}/{id}/references/{propertyName}': {
    /** Update all references of a property of a data object. */
    put: operations['objects.class.references.put'];
    /** Add a single reference to a class-property. */
    post: operations['objects.class.references.create'];
    /** Delete the single reference that is given in the body from the list of references that this property of a data object has */
    delete: operations['objects.class.references.delete'];
  };
  '/objects/validate': {
    /** Validate an Object's schema and meta-data. It has to be based on a schema, which is related to the given Object to be accepted by this validation. */
    post: operations['objects.validate'];
  };
  '/batch/objects': {
    /** Register new Objects in bulk. Provided meta-data and schema values are validated. */
    post: operations['batch.objects.create'];
    /** Delete Objects in bulk that match a certain filter. */
    delete: operations['batch.objects.delete'];
  };
  '/batch/references': {
    /** Register cross-references between any class items (objects or objects) in bulk. */
    post: operations['batch.references.create'];
  };
  '/graphql': {
    /** Get an object based on GraphQL */
    post: operations['graphql.post'];
  };
  '/graphql/batch': {
    /** Perform a batched GraphQL query */
    post: operations['graphql.batch'];
  };
  '/meta': {
    /** Gives meta information about the server and can be used to provide information to another Weaviate instance that wants to interact with the current instance. */
    get: operations['meta.get'];
  };
  '/schema': {
    get: operations['schema.dump'];
    post: operations['schema.objects.create'];
  };
  '/schema/{className}': {
    get: operations['schema.objects.get'];
    /** Use this endpoint to alter an existing class in the schema. Note that not all settings are mutable. If an error about immutable fields is returned and you still need to update this particular setting, you will have to delete the class (and the underlying data) and recreate. This endpoint cannot be used to modify properties. Instead use POST /v1/schema/{className}/properties. A typical use case for this endpoint is to update configuration, such as the vectorIndexConfig. Note that even in mutable sections, such as vectorIndexConfig, some fields may be immutable. */
    put: operations['schema.objects.update'];
    delete: operations['schema.objects.delete'];
  };
  '/schema/{className}/properties': {
    post: operations['schema.objects.properties.add'];
  };
  '/schema/{className}/shards': {
    get: operations['schema.objects.shards.get'];
  };
  '/schema/{className}/shards/{shardName}': {
    /** Update shard status of an Object Class */
    put: operations['schema.objects.shards.update'];
  };
  '/schema/{className}/tenants': {
    /** get all tenants from a specific class */
    get: operations['tenants.get'];
    /** Update tenant of a specific class */
    put: operations['tenants.update'];
    /** Create a new tenant for a specific class */
    post: operations['tenants.create'];
    /** delete tenants from a specific class */
    delete: operations['tenants.delete'];
  };
  '/schema/{className}/tenants/{tenantName}': {
    /** Check if a tenant exists for a specific class */
    head: operations['tenant.exists'];
  };
  '/backups/{backend}': {
    /** [Coming soon] List all backups in progress not implemented yet. */
    get: operations['backups.list'];
    /** Starts a process of creating a backup for a set of classes */
    post: operations['backups.create'];
  };
  '/backups/{backend}/{id}': {
    /** Returns status of backup creation attempt for a set of classes */
    get: operations['backups.create.status'];
    /** Cancel created backup with specified ID */
    delete: operations['backups.cancel'];
  };
  '/backups/{backend}/{id}/restore': {
    /** Returns status of a backup restoration attempt for a set of classes */
    get: operations['backups.restore.status'];
    /** Starts a process of restoring a backup for a set of classes */
    post: operations['backups.restore'];
  };
  '/cluster/statistics': {
    /** Returns Raft cluster statistics of Weaviate DB. */
    get: operations['cluster.get.statistics'];
  };
  '/nodes': {
    /** Returns status of Weaviate DB. */
    get: operations['nodes.get'];
  };
  '/nodes/{className}': {
    /** Returns status of Weaviate DB. */
    get: operations['nodes.get.class'];
  };
  '/classifications/': {
    /** Trigger a classification based on the specified params. Classifications will run in the background, use GET /classifications/<id> to retrieve the status of your classification. */
    post: operations['classifications.post'];
  };
  '/classifications/{id}': {
    /** Get status, results and metadata of a previously created classification */
    get: operations['classifications.get'];
  };
}

export interface definitions {
  Link: {
    /** @description target of the link */
    href?: string;
    /** @description relationship if both resources are related, e.g. 'next', 'previous', 'parent', etc. */
    rel?: string;
    /** @description human readable name of the resource group */
    name?: string;
    /** @description weaviate documentation about this resource group */
    documentationHref?: string;
  };
  Principal: {
    /** @description The username that was extracted either from the authentication information */
    username?: string;
    groups?: string[];
  };
  /** @description An array of available words and contexts. */
  C11yWordsResponse: {
    /** @description Weighted results for all words */
    concatenatedWord?: {
      concatenatedWord?: string;
      singleWords?: unknown[];
      concatenatedVector?: definitions['C11yVector'];
      concatenatedNearestNeighbors?: definitions['C11yNearestNeighbors'];
    };
    /** @description Weighted results for per individual word */
    individualWords?: {
      word?: string;
      present?: boolean;
      info?: {
        vector?: definitions['C11yVector'];
        nearestNeighbors?: definitions['C11yNearestNeighbors'];
      };
    }[];
  };
  /** @description A resource describing an extension to the contextinoary, containing both the identifier and the definition of the extension */
  C11yExtension: {
    /**
     * @description The new concept you want to extend. Must be an all-lowercase single word, or a space delimited compound word. Examples: 'foobarium', 'my custom concept'
     * @example foobarium
     */
    concept?: string;
    /** @description A list of space-delimited words or a sentence describing what the custom concept is about. Avoid using the custom concept itself. An Example definition for the custom concept 'foobarium': would be 'a naturally occurring element which can only be seen by programmers' */
    definition?: string;
    /**
     * Format: float
     * @description Weight of the definition of the new concept where 1='override existing definition entirely' and 0='ignore custom definition'. Note that if the custom concept is not present in the contextionary yet, the weight cannot be less than 1.
     */
    weight?: number;
  };
  /** @description C11y function to show the nearest neighbors to a word. */
  C11yNearestNeighbors: {
    word?: string;
    /** Format: float */
    distance?: number;
  }[];
  /** @description A Vector in the Contextionary */
  C11yVector: number[];
  /** @description A Vector object */
  Vector: number[];
  /** @description A Multi Vector map of named vectors */
  Vectors: { [key: string]: definitions['Vector'] };
  /** @description Receive question based on array of classes, properties and values. */
  C11yVectorBasedQuestion: {
    /** @description Vectorized classname. */
    classVectors?: number[];
    /** @description Vectorized properties. */
    classProps?: {
      propsVectors?: number[];
      /** @description String with valuename. */
      value?: string;
    }[];
  }[];
  Deprecation: {
    /** @description The id that uniquely identifies this particular deprecations (mostly used internally) */
    id?: string;
    /** @description Whether the problematic API functionality is deprecated (planned to be removed) or already removed */
    status?: string;
    /** @description Describes which API is effected, usually one of: REST, GraphQL */
    apiType?: string;
    /** @description What this deprecation is about */
    msg?: string;
    /** @description User-required object to not be affected by the (planned) removal */
    mitigation?: string;
    /** @description The deprecation was introduced in this version */
    sinceVersion?: string;
    /** @description A best-effort guess of which upcoming version will remove the feature entirely */
    plannedRemovalVersion?: string;
    /** @description If the feature has already been removed, it was removed in this version */
    removedIn?: string;
    /**
     * Format: date-time
     * @description If the feature has already been removed, it was removed at this timestamp
     */
    removedTime?: string;
    /**
     * Format: date-time
     * @description The deprecation was introduced in this version
     */
    sinceTime?: string;
    /** @description The locations within the specified API affected by this deprecation */
    locations?: string[];
  };
  /** @description An error response given by Weaviate end-points. */
  ErrorResponse: {
    error?: {
      message?: string;
    }[];
  };
  /** @description An error response caused by a GraphQL query. */
  GraphQLError: {
    locations?: {
      /** Format: int64 */
      column?: number;
      /** Format: int64 */
      line?: number;
    }[];
    message?: string;
    path?: string[];
  };
  /** @description GraphQL query based on: http://facebook.github.io/graphql/. */
  GraphQLQuery: {
    /** @description The name of the operation if multiple exist in the query. */
    operationName?: string;
    /** @description Query based on GraphQL syntax. */
    query?: string;
    /** @description Additional variables for the query. */
    variables?: { [key: string]: unknown };
  };
  /** @description A list of GraphQL queries. */
  GraphQLQueries: definitions['GraphQLQuery'][];
  /** @description GraphQL based response: http://facebook.github.io/graphql/. */
  GraphQLResponse: {
    /** @description GraphQL data object. */
    data?: { [key: string]: definitions['JsonObject'] };
    /** @description Array with errors. */
    errors?: definitions['GraphQLError'][];
  };
  /** @description A list of GraphQL responses. */
  GraphQLResponses: definitions['GraphQLResponse'][];
  /** @description Configure the inverted index built into Weaviate */
  InvertedIndexConfig: {
    /**
     * Format: int
     * @description Asynchronous index clean up happens every n seconds
     */
    cleanupIntervalSeconds?: number;
    bm25?: definitions['BM25Config'];
    stopwords?: definitions['StopwordConfig'];
    /** @description Index each object by its internal timestamps */
    indexTimestamps?: boolean;
    /** @description Index each object with the null state */
    indexNullState?: boolean;
    /** @description Index length of properties */
    indexPropertyLength?: boolean;
  };
  /** @description Configure how replication is executed in a cluster */
  ReplicationConfig: {
    /** @description Number of times a class is replicated */
    factor?: number;
    /** @description Enable asynchronous replication */
    asyncEnabled?: boolean;
    /**
     * @description Conflict resolution strategy for deleted objects
     * @enum {string}
     */
    deletionStrategy?: 'NoAutomatedResolution' | 'DeleteOnConflict';
  };
  /** @description tuning parameters for the BM25 algorithm */
  BM25Config: {
    /**
     * Format: float
     * @description calibrates term-weight scaling based on the term frequency within a document
     */
    k1?: number;
    /**
     * Format: float
     * @description calibrates term-weight scaling based on the document length
     */
    b?: number;
  };
  /** @description fine-grained control over stopword list usage */
  StopwordConfig: {
    /** @description pre-existing list of common words by language */
    preset?: string;
    /** @description stopwords to be considered additionally */
    additions?: string[];
    /** @description stopwords to be removed from consideration */
    removals?: string[];
  };
  /** @description Configuration related to multi-tenancy within a class */
  MultiTenancyConfig: {
    /** @description Whether or not multi-tenancy is enabled for this class */
    enabled?: boolean;
    /** @description Nonexistent tenants should (not) be created implicitly */
    autoTenantCreation?: boolean;
    /** @description Existing tenants should (not) be turned HOT implicitly when they are accessed and in another activity status */
    autoTenantActivation?: boolean;
  };
  /** @description JSON object value. */
  JsonObject: { [key: string]: unknown };
  /** @description Contains meta information of the current Weaviate instance. */
  Meta: {
    /**
     * Format: url
     * @description The url of the host.
     */
    hostname?: string;
    /** @description Version of weaviate you are currently running */
    version?: string;
    /** @description Module-specific meta information */
    modules?: { [key: string]: unknown };
    /** @description Max message size for GRPC connection in bytes */
    grpcMaxMessageSize?: number;
  };
  /** @description Multiple instances of references to other objects. */
  MultipleRef: definitions['SingleRef'][];
  /** @description Either a JSONPatch document as defined by RFC 6902 (from, op, path, value), or a merge document (RFC 7396). */
  PatchDocumentObject: {
    /** @description A string containing a JSON Pointer value. */
    from?: string;
    /**
     * @description The operation to be performed.
     * @enum {string}
     */
    op: 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
    /** @description A JSON-Pointer. */
    path: string;
    /** @description The value to be used within the operations. */
    value?: { [key: string]: unknown };
    merge?: definitions['Object'];
  };
  /** @description Either a JSONPatch document as defined by RFC 6902 (from, op, path, value), or a merge document (RFC 7396). */
  PatchDocumentAction: {
    /** @description A string containing a JSON Pointer value. */
    from?: string;
    /**
     * @description The operation to be performed.
     * @enum {string}
     */
    op: 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
    /** @description A JSON-Pointer. */
    path: string;
    /** @description The value to be used within the operations. */
    value?: { [key: string]: unknown };
    merge?: definitions['Object'];
  };
  /** @description A single peer in the network. */
  PeerUpdate: {
    /**
     * Format: uuid
     * @description The session ID of the peer.
     */
    id?: string;
    /** @description Human readable name. */
    name?: string;
    /**
     * Format: uri
     * @description The location where the peer is exposed to the internet.
     */
    uri?: string;
    /** @description The latest known hash of the peer's schema. */
    schemaHash?: string;
  };
  /** @description List of known peers. */
  PeerUpdateList: definitions['PeerUpdate'][];
  /** @description Allow custom overrides of vector weights as math expressions. E.g. "pancake": "7" will set the weight for the word pancake to 7 in the vectorization, whereas "w * 3" would triple the originally calculated word. This is an open object, with OpenAPI Specification 3.0 this will be more detailed. See Weaviate docs for more info. In the future this will become a key/value (string/string) object. */
  VectorWeights: { [key: string]: unknown };
  /** @description This is an open object, with OpenAPI Specification 3.0 this will be more detailed. See Weaviate docs for more info. In the future this will become a key/value OR a SingleRef definition. */
  PropertySchema: { [key: string]: unknown };
  /** @description This is an open object, with OpenAPI Specification 3.0 this will be more detailed. See Weaviate docs for more info. In the future this will become a key/value OR a SingleRef definition. */
  SchemaHistory: { [key: string]: unknown };
  /** @description Definitions of semantic schemas (also see: https://github.com/weaviate/weaviate-semantic-schemas). */
  Schema: {
    /** @description Semantic classes that are available. */
    classes?: definitions['Class'][];
    /**
     * Format: email
     * @description Email of the maintainer.
     */
    maintainer?: string;
    /** @description Name of the schema. */
    name?: string;
  };
  /** @description Indicates the health of the schema in a cluster. */
  SchemaClusterStatus: {
    /** @description True if the cluster is in sync, false if there is an issue (see error). */
    healthy?: boolean;
    /** @description Contains the sync check error if one occurred */
    error?: string;
    /** @description Hostname of the coordinating node, i.e. the one that received the cluster. This can be useful information if the error message contains phrases such as 'other nodes agree, but local does not', etc. */
    hostname?: string;
    /**
     * Format: int
     * @description Number of nodes that participated in the sync check
     */
    nodeCount?: number;
    /** @description The cluster check at startup can be ignored (to recover from an out-of-sync situation). */
    ignoreSchemaSync?: boolean;
  };
  Class: {
    /** @description Name of the class as URI relative to the schema URL. */
    class?: string;
    vectorConfig?: { [key: string]: definitions['VectorConfig'] };
    /** @description Name of the vector index to use, eg. (HNSW) */
    vectorIndexType?: string;
    /** @description Vector-index config, that is specific to the type of index selected in vectorIndexType */
    vectorIndexConfig?: { [key: string]: unknown };
    /** @description Manage how the index should be sharded and distributed in the cluster */
    shardingConfig?: { [key: string]: unknown };
    replicationConfig?: definitions['ReplicationConfig'];
    invertedIndexConfig?: definitions['InvertedIndexConfig'];
    multiTenancyConfig?: definitions['MultiTenancyConfig'];
    /** @description Specify how the vectors for this class should be determined. The options are either 'none' - this means you have to import a vector with each object yourself - or the name of a module that provides vectorization capabilities, such as 'text2vec-contextionary'. If left empty, it will use the globally configured default which can itself either be 'none' or a specific module. */
    vectorizer?: string;
    /** @description Configuration specific to modules this Weaviate instance has installed */
    moduleConfig?: { [key: string]: unknown };
    /** @description Description of the class. */
    description?: string;
    /** @description The properties of the class. */
    properties?: definitions['Property'][];
  };
  Property: {
    /** @description Can be a reference to another type when it starts with a capital (for example Person), otherwise "string" or "int". */
    dataType?: string[];
    /** @description Description of the property. */
    description?: string;
    /** @description Configuration specific to modules this Weaviate instance has installed */
    moduleConfig?: { [key: string]: unknown };
    /** @description Name of the property as URI relative to the schema URL. */
    name?: string;
    /** @description Optional. Should this property be indexed in the inverted index. Defaults to true. If you choose false, you will not be able to use this property in where filters, bm25 or hybrid search. This property has no affect on vectorization decisions done by modules (deprecated as of v1.19; use indexFilterable or/and indexSearchable instead) */
    indexInverted?: boolean;
    /** @description Optional. Should this property be indexed in the inverted index. Defaults to true. If you choose false, you will not be able to use this property in where filters. This property has no affect on vectorization decisions done by modules */
    indexFilterable?: boolean;
    /** @description Optional. Should this property be indexed in the inverted index. Defaults to true. Applicable only to properties of data type text and text[]. If you choose false, you will not be able to use this property in bm25 or hybrid search. This property has no affect on vectorization decisions done by modules */
    indexSearchable?: boolean;
    /** @description Optional. Should this property be indexed in the inverted index. Defaults to false. Provides better performance for range queries compared to filterable index in large datasets. Applicable only to properties of data type int, number, date. */
    indexRangeFilters?: boolean;
    /**
     * @description Determines tokenization of the property as separate words or whole field. Optional. Applies to text and text[] data types. Allowed values are `word` (default; splits on any non-alphanumerical, lowercases), `lowercase` (splits on white spaces, lowercases), `whitespace` (splits on white spaces), `field` (trims). Not supported for remaining data types
     * @enum {string}
     */
    tokenization?: 'word' | 'lowercase' | 'whitespace' | 'field' | 'trigram' | 'gse' | 'kagome_kr';
    /** @description The properties of the nested object(s). Applies to object and object[] data types. */
    nestedProperties?: definitions['NestedProperty'][];
  };
  VectorConfig: {
    /** @description Configuration of a specific vectorizer used by this vector */
    vectorizer?: { [key: string]: unknown };
    /** @description Name of the vector index to use, eg. (HNSW) */
    vectorIndexType?: string;
    /** @description Vector-index config, that is specific to the type of index selected in vectorIndexType */
    vectorIndexConfig?: { [key: string]: unknown };
  };
  NestedProperty: {
    dataType?: string[];
    description?: string;
    name?: string;
    indexFilterable?: boolean;
    indexSearchable?: boolean;
    indexRangeFilters?: boolean;
    /** @enum {string} */
    tokenization?: 'word' | 'lowercase' | 'whitespace' | 'field';
    nestedProperties?: definitions['NestedProperty'][];
  };
  /** @description The status of all the shards of a Class */
  ShardStatusList: definitions['ShardStatusGetResponse'][];
  /** @description Response body of shard status get request */
  ShardStatusGetResponse: {
    /** @description Name of the shard */
    name?: string;
    /** @description Status of the shard */
    status?: string;
    /** @description Size of the vector queue of the shard */
    vectorQueueSize?: number;
  };
  /** @description The status of a single shard */
  ShardStatus: {
    /** @description Status of the shard */
    status?: string;
  };
  /** @description The definition of a backup create metadata */
  BackupCreateStatusResponse: {
    /** @description The ID of the backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
    id?: string;
    /** @description Backup backend name e.g. filesystem, gcs, s3. */
    backend?: string;
    /** @description destination path of backup files proper to selected backend */
    path?: string;
    /** @description error message if creation failed */
    error?: string;
    /**
     * @description phase of backup creation process
     * @default STARTED
     * @enum {string}
     */
    status?: 'STARTED' | 'TRANSFERRING' | 'TRANSFERRED' | 'SUCCESS' | 'FAILED' | 'CANCELED';
  };
  /** @description The definition of a backup restore metadata */
  BackupRestoreStatusResponse: {
    /** @description The ID of the backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
    id?: string;
    /** @description Backup backend name e.g. filesystem, gcs, s3. */
    backend?: string;
    /** @description destination path of backup files proper to selected backup backend */
    path?: string;
    /** @description error message if restoration failed */
    error?: string;
    /**
     * @description phase of backup restoration process
     * @default STARTED
     * @enum {string}
     */
    status?: 'STARTED' | 'TRANSFERRING' | 'TRANSFERRED' | 'SUCCESS' | 'FAILED' | 'CANCELED';
  };
  /** @description Backup custom configuration */
  BackupConfig: {
    /**
     * @description Desired CPU core utilization ranging from 1%-80%
     * @default 50
     */
    CPUPercentage?: number;
    /**
     * @description Weaviate will attempt to come close the specified size, with a minimum of 2MB, default of 128MB, and a maximum of 512MB
     * @default 128
     */
    ChunkSize?: number;
    /**
     * @description compression level used by compression algorithm
     * @default DefaultCompression
     * @enum {string}
     */
    CompressionLevel?: 'DefaultCompression' | 'BestSpeed' | 'BestCompression';
  };
  /** @description Backup custom configuration */
  RestoreConfig: {
    /**
     * @description Desired CPU core utilization ranging from 1%-80%
     * @default 50
     */
    CPUPercentage?: number;
  };
  /** @description Request body for creating a backup of a set of classes */
  BackupCreateRequest: {
    /** @description The ID of the backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
    id?: string;
    /** @description Custom configuration for the backup creation process */
    config?: definitions['BackupConfig'];
    /** @description List of classes to include in the backup creation process */
    include?: string[];
    /** @description List of classes to exclude from the backup creation process */
    exclude?: string[];
  };
  /** @description The definition of a backup create response body */
  BackupCreateResponse: {
    /** @description The ID of the backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
    id?: string;
    /** @description The list of classes for which the backup creation process was started */
    classes?: string[];
    /** @description Backup backend name e.g. filesystem, gcs, s3. */
    backend?: string;
    /** @description destination path of backup files proper to selected backend */
    path?: string;
    /** @description error message if creation failed */
    error?: string;
    /**
     * @description phase of backup creation process
     * @default STARTED
     * @enum {string}
     */
    status?: 'STARTED' | 'TRANSFERRING' | 'TRANSFERRED' | 'SUCCESS' | 'FAILED' | 'CANCELED';
  };
  /** @description The definition of a backup create response body */
  BackupListResponse: {
    /** @description The ID of the backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
    id?: string;
    /** @description destination path of backup files proper to selected backend */
    path?: string;
    /** @description The list of classes for which the existed backup process */
    classes?: string[];
    /**
     * @description status of backup process
     * @enum {string}
     */
    status?: 'STARTED' | 'TRANSFERRING' | 'TRANSFERRED' | 'SUCCESS' | 'FAILED' | 'CANCELED';
  }[];
  /** @description Request body for restoring a backup for a set of classes */
  BackupRestoreRequest: {
    /** @description Custom configuration for the backup restoration process */
    config?: definitions['RestoreConfig'];
    /** @description List of classes to include in the backup restoration process */
    include?: string[];
    /** @description List of classes to exclude from the backup restoration process */
    exclude?: string[];
    /** @description Allows overriding the node names stored in the backup with different ones. Useful when restoring backups to a different environment. */
    node_mapping?: { [key: string]: string };
  };
  /** @description The definition of a backup restore response body */
  BackupRestoreResponse: {
    /** @description The ID of the backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
    id?: string;
    /** @description The list of classes for which the backup restoration process was started */
    classes?: string[];
    /** @description Backup backend name e.g. filesystem, gcs, s3. */
    backend?: string;
    /** @description destination path of backup files proper to selected backend */
    path?: string;
    /** @description error message if restoration failed */
    error?: string;
    /**
     * @description phase of backup restoration process
     * @default STARTED
     * @enum {string}
     */
    status?: 'STARTED' | 'TRANSFERRING' | 'TRANSFERRED' | 'SUCCESS' | 'FAILED' | 'CANCELED';
  };
  /** @description The summary of Weaviate's statistics. */
  NodeStats: {
    /**
     * Format: int
     * @description The count of Weaviate's shards.
     */
    shardCount?: number;
    /**
     * Format: int64
     * @description The total number of objects in DB.
     */
    objectCount?: number;
  };
  /** @description The summary of a nodes batch queue congestion status. */
  BatchStats: {
    /**
     * Format: int
     * @description How many objects are currently in the batch queue.
     */
    queueLength?: number;
    /**
     * Format: int
     * @description How many objects are approximately processed from the batch queue per second.
     */
    ratePerSecond?: number;
  };
  /** @description The definition of a node shard status response body */
  NodeShardStatus: {
    /** @description The name of the shard. */
    name?: string;
    /** @description The name of shard's class. */
    class?: string;
    /**
     * Format: int64
     * @description The number of objects in shard.
     */
    objectCount?: number;
    /**
     * Format: string
     * @description The status of the vector indexing process.
     */
    vectorIndexingStatus?: unknown;
    /**
     * Format: boolean
     * @description The status of vector compression/quantization.
     */
    compressed?: unknown;
    /**
     * Format: int64
     * @description The length of the vector indexing queue.
     */
    vectorQueueLength?: number;
    /** @description The load status of the shard. */
    loaded?: boolean;
  };
  /** @description The definition of a backup node status response body */
  NodeStatus: {
    /** @description The name of the node. */
    name?: string;
    /**
     * @description Node's status.
     * @default HEALTHY
     * @enum {string}
     */
    status?: 'HEALTHY' | 'UNHEALTHY' | 'UNAVAILABLE' | 'TIMEOUT';
    /** @description The version of Weaviate. */
    version?: string;
    /** @description The gitHash of Weaviate. */
    gitHash?: string;
    /** @description Weaviate overall statistics. */
    stats?: definitions['NodeStats'];
    /** @description Weaviate batch statistics. */
    batchStats?: definitions['BatchStats'];
    /** @description The list of the shards with it's statistics. */
    shards?: definitions['NodeShardStatus'][];
  };
  /** @description The status of all of the Weaviate nodes */
  NodesStatusResponse: {
    nodes?: definitions['NodeStatus'][];
  };
  /** @description The definition of Raft statistics. */
  RaftStatistics: {
    appliedIndex?: string;
    commitIndex?: string;
    fsmPending?: string;
    lastContact?: string;
    lastLogIndex?: string;
    lastLogTerm?: string;
    lastSnapshotIndex?: string;
    lastSnapshotTerm?: string;
    /** @description Weaviate Raft nodes. */
    latestConfiguration?: { [key: string]: unknown };
    latestConfigurationIndex?: string;
    numPeers?: string;
    protocolVersion?: string;
    protocolVersionMax?: string;
    protocolVersionMin?: string;
    snapshotVersionMax?: string;
    snapshotVersionMin?: string;
    state?: string;
    term?: string;
  };
  /** @description The definition of node statistics. */
  Statistics: {
    /** @description The name of the node. */
    name?: string;
    /**
     * @description Node's status.
     * @default HEALTHY
     * @enum {string}
     */
    status?: 'HEALTHY' | 'UNHEALTHY' | 'UNAVAILABLE' | 'TIMEOUT';
    bootstrapped?: boolean;
    dbLoaded?: boolean;
    /** Format: uint64 */
    initialLastAppliedIndex?: number;
    lastAppliedIndex?: number;
    isVoter?: boolean;
    leaderId?: { [key: string]: unknown };
    leaderAddress?: { [key: string]: unknown };
    open?: boolean;
    ready?: boolean;
    candidates?: { [key: string]: unknown };
    /** @description Weaviate Raft statistics. */
    raft?: definitions['RaftStatistics'];
  };
  /** @description The cluster statistics of all of the Weaviate nodes */
  ClusterStatisticsResponse: {
    statistics?: definitions['Statistics'][];
    synchronized?: boolean;
  };
  /** @description Either set beacon (direct reference) or set class and schema (concept reference) */
  SingleRef: {
    /**
     * Format: uri
     * @description If using a concept reference (rather than a direct reference), specify the desired class name here
     */
    class?: string;
    /** @description If using a concept reference (rather than a direct reference), specify the desired properties here */
    schema?: definitions['PropertySchema'];
    /**
     * Format: uri
     * @description If using a direct reference, specify the URI to point to the cross-ref here. Should be in the form of weaviate://localhost/<uuid> for the example of a local cross-ref to an object
     */
    beacon?: string;
    /**
     * Format: uri
     * @description If using a direct reference, this read-only fields provides a link to the referenced resource. If 'origin' is globally configured, an absolute URI is shown - a relative URI otherwise.
     */
    href?: string;
    /** @description Additional Meta information about classifications if the item was part of one */
    classification?: definitions['ReferenceMetaClassification'];
  };
  /** @description Additional Meta information about a single object object. */
  AdditionalProperties: { [key: string]: { [key: string]: unknown } };
  /** @description This meta field contains additional info about the classified reference property */
  ReferenceMetaClassification: {
    /**
     * Format: int64
     * @description overall neighbors checked as part of the classification. In most cases this will equal k, but could be lower than k - for example if not enough data was present
     */
    overallCount?: number;
    /**
     * Format: int64
     * @description size of the winning group, a number between 1..k
     */
    winningCount?: number;
    /**
     * Format: int64
     * @description size of the losing group, can be 0 if the winning group size equals k
     */
    losingCount?: number;
    /**
     * Format: float32
     * @description The lowest distance of any neighbor, regardless of whether they were in the winning or losing group
     */
    closestOverallDistance?: number;
    /**
     * Format: float32
     * @description deprecated - do not use, to be removed in 0.23.0
     */
    winningDistance?: number;
    /**
     * Format: float32
     * @description Mean distance of all neighbors from the winning group
     */
    meanWinningDistance?: number;
    /**
     * Format: float32
     * @description Closest distance of a neighbor from the winning group
     */
    closestWinningDistance?: number;
    /**
     * Format: float32
     * @description The lowest distance of a neighbor in the losing group. Optional. If k equals the size of the winning group, there is no losing group
     */
    closestLosingDistance?: number;
    /**
     * Format: float32
     * @description deprecated - do not use, to be removed in 0.23.0
     */
    losingDistance?: number;
    /**
     * Format: float32
     * @description Mean distance of all neighbors from the losing group. Optional. If k equals the size of the winning group, there is no losing group.
     */
    meanLosingDistance?: number;
  };
  BatchReference: {
    /**
     * Format: uri
     * @description Long-form beacon-style URI to identify the source of the cross-ref including the property name. Should be in the form of weaviate://localhost/<kinds>/<uuid>/<className>/<propertyName>, where <kinds> must be one of 'objects', 'objects' and <className> and <propertyName> must represent the cross-ref property of source class to be used.
     * @example weaviate://localhost/Zoo/a5d09582-4239-4702-81c9-92a6e0122bb4/hasAnimals
     */
    from?: string;
    /**
     * Format: uri
     * @description Short-form URI to point to the cross-ref. Should be in the form of weaviate://localhost/<uuid> for the example of a local cross-ref to an object
     * @example weaviate://localhost/97525810-a9a5-4eb0-858a-71449aeb007f
     */
    to?: string;
    /** @description Name of the reference tenant. */
    tenant?: string;
  };
  BatchReferenceResponse: definitions['BatchReference'] & {
    /**
     * Format: object
     * @description Results for this specific reference.
     */
    result?: {
      /**
       * @default SUCCESS
       * @enum {string}
       */
      status?: 'SUCCESS' | 'PENDING' | 'FAILED';
      errors?: definitions['ErrorResponse'];
    };
  };
  GeoCoordinates: {
    /**
     * Format: float
     * @description The latitude of the point on earth in decimal form
     */
    latitude?: number;
    /**
     * Format: float
     * @description The longitude of the point on earth in decimal form
     */
    longitude?: number;
  };
  PhoneNumber: {
    /** @description The raw input as the phone number is present in your raw data set. It will be parsed into the standardized formats if valid. */
    input?: string;
    /** @description Read-only. Parsed result in the international format (e.g. +49 123 ...) */
    internationalFormatted?: string;
    /** @description Optional. The ISO 3166-1 alpha-2 country code. This is used to figure out the correct countryCode and international format if only a national number (e.g. 0123 4567) is provided */
    defaultCountry?: string;
    /**
     * Format: uint64
     * @description Read-only. The numerical country code (e.g. 49)
     */
    countryCode?: number;
    /**
     * Format: uint64
     * @description Read-only. The numerical representation of the national part
     */
    national?: number;
    /** @description Read-only. Parsed result in the national format (e.g. 0123 456789) */
    nationalFormatted?: string;
    /** @description Read-only. Indicates whether the parsed number is a valid phone number */
    valid?: boolean;
  };
  Object: {
    /** @description Class of the Object, defined in the schema. */
    class?: string;
    vectorWeights?: definitions['VectorWeights'];
    properties?: definitions['PropertySchema'];
    /**
     * Format: uuid
     * @description ID of the Object.
     */
    id?: string;
    /**
     * Format: int64
     * @description Timestamp of creation of this Object in milliseconds since epoch UTC.
     */
    creationTimeUnix?: number;
    /**
     * Format: int64
     * @description Timestamp of the last Object update in milliseconds since epoch UTC.
     */
    lastUpdateTimeUnix?: number;
    /** @description This field returns vectors associated with the Object. C11yVector, Vector or Vectors values are possible. */
    vector?: definitions['C11yVector'];
    /** @description This field returns vectors associated with the Object. */
    vectors?: definitions['Vectors'];
    /** @description Name of the Objects tenant. */
    tenant?: string;
    additional?: definitions['AdditionalProperties'];
  };
  ObjectsGetResponse: definitions['Object'] & {
    deprecations?: definitions['Deprecation'][];
  } & {
    /**
     * Format: object
     * @description Results for this specific Object.
     */
    result?: {
      /**
       * @default SUCCESS
       * @enum {string}
       */
      status?: 'SUCCESS' | 'PENDING' | 'FAILED';
      errors?: definitions['ErrorResponse'];
    };
  };
  BatchDelete: {
    /** @description Outlines how to find the objects to be deleted. */
    match?: {
      /**
       * @description Class (name) which objects will be deleted.
       * @example City
       */
      class?: string;
      /** @description Filter to limit the objects to be deleted. */
      where?: definitions['WhereFilter'];
    };
    /**
     * @description Controls the verbosity of the output, possible values are: "minimal", "verbose". Defaults to "minimal".
     * @default minimal
     */
    output?: string;
    /**
     * @description If true, objects will not be deleted yet, but merely listed. Defaults to false.
     * @default false
     */
    dryRun?: boolean;
  };
  /** @description Delete Objects response. */
  BatchDeleteResponse: {
    /** @description Outlines how to find the objects to be deleted. */
    match?: {
      /**
       * @description Class (name) which objects will be deleted.
       * @example City
       */
      class?: string;
      /** @description Filter to limit the objects to be deleted. */
      where?: definitions['WhereFilter'];
    };
    /**
     * @description Controls the verbosity of the output, possible values are: "minimal", "verbose". Defaults to "minimal".
     * @default minimal
     */
    output?: string;
    /**
     * @description If true, objects will not be deleted yet, but merely listed. Defaults to false.
     * @default false
     */
    dryRun?: boolean;
    results?: {
      /**
       * Format: int64
       * @description How many objects were matched by the filter.
       */
      matches?: number;
      /**
       * Format: int64
       * @description The most amount of objects that can be deleted in a single query, equals QUERY_MAXIMUM_RESULTS.
       */
      limit?: number;
      /**
       * Format: int64
       * @description How many objects were successfully deleted in this round.
       */
      successful?: number;
      /**
       * Format: int64
       * @description How many objects should have been deleted but could not be deleted.
       */
      failed?: number;
      /** @description With output set to "minimal" only objects with error occurred will the be described. Successfully deleted objects would be omitted. Output set to "verbose" will list all of the objets with their respective statuses. */
      objects?: {
        /**
         * Format: uuid
         * @description ID of the Object.
         */
        id?: string;
        /**
         * @default SUCCESS
         * @enum {string}
         */
        status?: 'SUCCESS' | 'DRYRUN' | 'FAILED';
        errors?: definitions['ErrorResponse'];
      }[];
    };
  };
  /** @description List of Objects. */
  ObjectsListResponse: {
    /** @description The actual list of Objects. */
    objects?: definitions['Object'][];
    deprecations?: definitions['Deprecation'][];
    /**
     * Format: int64
     * @description The total number of Objects for the query. The number of items in a response may be smaller due to paging.
     */
    totalResults?: number;
  };
  /** @description Manage classifications, trigger them and view status of past classifications. */
  Classification: {
    /**
     * Format: uuid
     * @description ID to uniquely identify this classification run
     * @example ee722219-b8ec-4db1-8f8d-5150bb1a9e0c
     */
    id?: string;
    /**
     * @description class (name) which is used in this classification
     * @example City
     */
    class?: string;
    /**
     * @description which ref-property to set as part of the classification
     * @example [
     *   "inCountry"
     * ]
     */
    classifyProperties?: string[];
    /**
     * @description base the text-based classification on these fields (of type text)
     * @example [
     *   "description"
     * ]
     */
    basedOnProperties?: string[];
    /**
     * @description status of this classification
     * @example running
     * @enum {string}
     */
    status?: 'running' | 'completed' | 'failed';
    /** @description additional meta information about the classification */
    meta?: definitions['ClassificationMeta'];
    /** @description which algorithm to use for classifications */
    type?: string;
    /** @description classification-type specific settings */
    settings?: { [key: string]: unknown };
    /**
     * @description error message if status == failed
     * @default
     * @example classify xzy: something went wrong
     */
    error?: string;
    filters?: {
      /** @description limit the objects to be classified */
      sourceWhere?: definitions['WhereFilter'];
      /** @description Limit the training objects to be considered during the classification. Can only be used on types with explicit training sets, such as 'knn' */
      trainingSetWhere?: definitions['WhereFilter'];
      /** @description Limit the possible sources when using an algorithm which doesn't really on training data, e.g. 'contextual'. When using an algorithm with a training set, such as 'knn', limit the training set instead */
      targetWhere?: definitions['WhereFilter'];
    };
  };
  /** @description Additional information to a specific classification */
  ClassificationMeta: {
    /**
     * Format: date-time
     * @description time when this classification was started
     * @example 2017-07-21T17:32:28Z
     */
    started?: string;
    /**
     * Format: date-time
     * @description time when this classification finished
     * @example 2017-07-21T17:32:28Z
     */
    completed?: string;
    /**
     * @description number of objects which were taken into consideration for classification
     * @example 147
     */
    count?: number;
    /**
     * @description number of objects successfully classified
     * @example 140
     */
    countSucceeded?: number;
    /**
     * @description number of objects which could not be classified - see error message for details
     * @example 7
     */
    countFailed?: number;
  };
  /** @description Filter search results using a where filter */
  WhereFilter: {
    /** @description combine multiple where filters, requires 'And' or 'Or' operator */
    operands?: definitions['WhereFilter'][];
    /**
     * @description operator to use
     * @example GreaterThanEqual
     * @enum {string}
     */
    operator?:
      | 'And'
      | 'Or'
      | 'Equal'
      | 'Like'
      | 'NotEqual'
      | 'GreaterThan'
      | 'GreaterThanEqual'
      | 'LessThan'
      | 'LessThanEqual'
      | 'WithinGeoRange'
      | 'IsNull'
      | 'ContainsAny'
      | 'ContainsAll';
    /**
     * @description path to the property currently being filtered
     * @example [
     *   "inCity",
     *   "City",
     *   "name"
     * ]
     */
    path?: string[];
    /**
     * Format: int64
     * @description value as integer
     * @example 2000
     */
    valueInt?: number;
    /**
     * Format: float64
     * @description value as number/float
     * @example 3.14
     */
    valueNumber?: number;
    /**
     * @description value as boolean
     * @example false
     */
    valueBoolean?: boolean;
    /**
     * @description value as text (deprecated as of v1.19; alias for valueText)
     * @example my search term
     */
    valueString?: string;
    /**
     * @description value as text
     * @example my search term
     */
    valueText?: string;
    /**
     * @description value as date (as string)
     * @example TODO
     */
    valueDate?: string;
    /**
     * @description value as integer
     * @example [100, 200]
     */
    valueIntArray?: number[];
    /**
     * @description value as number/float
     * @example [
     *   3.14
     * ]
     */
    valueNumberArray?: number[];
    /**
     * @description value as boolean
     * @example [
     *   true,
     *   false
     * ]
     */
    valueBooleanArray?: boolean[];
    /**
     * @description value as text (deprecated as of v1.19; alias for valueText)
     * @example [
     *   "my search term"
     * ]
     */
    valueStringArray?: string[];
    /**
     * @description value as text
     * @example [
     *   "my search term"
     * ]
     */
    valueTextArray?: string[];
    /**
     * @description value as date (as string)
     * @example TODO
     */
    valueDateArray?: string[];
    /** @description value as geo coordinates and distance */
    valueGeoRange?: definitions['WhereFilterGeoRange'];
  };
  /** @description filter within a distance of a georange */
  WhereFilterGeoRange: {
    geoCoordinates?: definitions['GeoCoordinates'];
    distance?: {
      /** Format: float64 */
      max?: number;
    };
  };
  /** @description attributes representing a single tenant within weaviate */
  Tenant: {
    /** @description name of the tenant */
    name?: string;
    /**
     * @description activity status of the tenant's shard. Optional for creating tenant (implicit `ACTIVE`) and required for updating tenant. For creation, allowed values are `ACTIVE` - tenant is fully active and `INACTIVE` - tenant is inactive; no actions can be performed on tenant, tenant's files are stored locally. For updating, `ACTIVE`, `INACTIVE` and also `OFFLOADED` - as INACTIVE, but files are stored on cloud storage. The following values are read-only and are set by the server for internal use: `OFFLOADING` - tenant is transitioning from ACTIVE/INACTIVE to OFFLOADED, `ONLOADING` - tenant is transitioning from OFFLOADED to ACTIVE/INACTIVE. We still accept deprecated names `HOT` (now `ACTIVE`), `COLD` (now `INACTIVE`), `FROZEN` (now `OFFLOADED`), `FREEZING` (now `OFFLOADING`), `UNFREEZING` (now `ONLOADING`).
     * @enum {string}
     */
    activityStatus?:
      | 'ACTIVE'
      | 'INACTIVE'
      | 'OFFLOADED'
      | 'OFFLOADING'
      | 'ONLOADING'
      | 'HOT'
      | 'COLD'
      | 'FROZEN'
      | 'FREEZING'
      | 'UNFREEZING';
  };
}

export interface parameters {
  /** @description The starting ID of the result window. */
  CommonAfterParameterQuery: string;
  /**
   * Format: int64
   * @description The starting index of the result window. Default value is 0.
   * @default 0
   */
  CommonOffsetParameterQuery: number;
  /**
   * Format: int64
   * @description The maximum number of items to be returned per page. Default value is set in Weaviate config.
   */
  CommonLimitParameterQuery: number;
  /** @description Include additional information, such as classification infos. Allowed values include: classification, vector, interpretation */
  CommonIncludeParameterQuery: string;
  /** @description Determines how many replicas must acknowledge a request before it is considered successful */
  CommonConsistencyLevelParameterQuery: string;
  /** @description Specifies the tenant in a request targeting a multi-tenant class */
  CommonTenantParameterQuery: string;
  /** @description The target node which should fulfill the request */
  CommonNodeNameParameterQuery: string;
  /** @description Sort parameter to pass an information about the names of the sort fields */
  CommonSortParameterQuery: string;
  /** @description Order parameter to tell how to order (asc or desc) data within given field */
  CommonOrderParameterQuery: string;
  /** @description Class parameter specifies the class from which to query objects */
  CommonClassParameterQuery: string;
  /**
   * @description Controls the verbosity of the output, possible values are: "minimal", "verbose". Defaults to "minimal".
   * @default minimal
   */
  CommonOutputVerbosityParameterQuery: string;
}

export interface operations {
  /** Home. Discover the REST API */
  'weaviate.root': {
    responses: {
      /** Weaviate is alive and ready to serve content */
      200: {
        schema: {
          links?: definitions['Link'][];
        };
      };
    };
  };
  /** Determines whether the application is alive. Can be used for kubernetes liveness probe */
  'weaviate.wellknown.liveness': {
    responses: {
      /** The application is able to respond to HTTP requests */
      200: unknown;
    };
  };
  /** Determines whether the application is ready to receive traffic. Can be used for kubernetes readiness probe. */
  'weaviate.wellknown.readiness': {
    responses: {
      /** The application has completed its start-up routine and is ready to accept traffic. */
      200: unknown;
      /** The application is currently not able to serve traffic. If other horizontal replicas of weaviate are available and they are capable of receiving traffic, all traffic should be redirected there instead. */
      503: unknown;
    };
  };
  /** Lists all Objects in reverse order of creation, owned by the user that belongs to the used token. */
  'objects.list': {
    parameters: {
      query: {
        /** The starting ID of the result window. */
        after?: parameters['CommonAfterParameterQuery'];
        /** The starting index of the result window. Default value is 0. */
        offset?: parameters['CommonOffsetParameterQuery'];
        /** The maximum number of items to be returned per page. Default value is set in Weaviate config. */
        limit?: parameters['CommonLimitParameterQuery'];
        /** Include additional information, such as classification infos. Allowed values include: classification, vector, interpretation */
        include?: parameters['CommonIncludeParameterQuery'];
        /** Sort parameter to pass an information about the names of the sort fields */
        sort?: parameters['CommonSortParameterQuery'];
        /** Order parameter to tell how to order (asc or desc) data within given field */
        order?: parameters['CommonOrderParameterQuery'];
        /** Class parameter specifies the class from which to query objects */
        class?: parameters['CommonClassParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successful response. */
      200: {
        schema: definitions['ObjectsListResponse'];
      };
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Registers a new Object. Provided meta-data and schema values are validated. */
  'objects.create': {
    parameters: {
      body: {
        body: definitions['Object'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
      };
    };
    responses: {
      /** Object created. */
      200: {
        schema: definitions['Object'];
      };
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Lists Objects. */
  'objects.get': {
    parameters: {
      path: {
        /** Unique ID of the Object. */
        id: string;
      };
      query: {
        /** Include additional information, such as classification infos. Allowed values include: classification, vector, interpretation */
        include?: parameters['CommonIncludeParameterQuery'];
      };
    };
    responses: {
      /** Successful response. */
      200: {
        schema: definitions['Object'];
      };
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Updates an Object's data. Given meta-data and schema values are validated. LastUpdateTime is set to the time this function is called. */
  'objects.update': {
    parameters: {
      path: {
        /** Unique ID of the Object. */
        id: string;
      };
      body: {
        body: definitions['Object'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
      };
    };
    responses: {
      /** Successfully received. */
      200: {
        schema: definitions['Object'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Deletes an Object from the system. */
  'objects.delete': {
    parameters: {
      path: {
        /** Unique ID of the Object. */
        id: string;
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successfully deleted. */
      204: never;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Checks if an Object exists in the system. */
  'objects.head': {
    parameters: {
      path: {
        /** Unique ID of the Object. */
        id: string;
      };
    };
    responses: {
      /** Object exists. */
      204: never;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Object doesn't exist. */
      404: unknown;
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Updates an Object. This method supports json-merge style patch semantics (RFC 7396). Provided meta-data and schema values are validated. LastUpdateTime is set to the time this function is called. */
  'objects.patch': {
    parameters: {
      path: {
        /** Unique ID of the Object. */
        id: string;
      };
      body: {
        /** RFC 7396-style patch, the body contains the object to merge into the existing object. */
        body?: definitions['Object'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
      };
    };
    responses: {
      /** Successfully applied. No content provided. */
      204: never;
      /** The patch-JSON is malformed. */
      400: unknown;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** The patch-JSON is valid but unprocessable. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Get a single data object */
  'objects.class.get': {
    parameters: {
      path: {
        className: string;
        /** Unique ID of the Object. */
        id: string;
      };
      query: {
        /** Include additional information, such as classification infos. Allowed values include: classification, vector, interpretation */
        include?: parameters['CommonIncludeParameterQuery'];
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
        /** The target node which should fulfill the request */
        node_name?: parameters['CommonNodeNameParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successful response. */
      200: {
        schema: definitions['Object'];
      };
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** Request is well-formed (i.e., syntactically correct), but erroneous. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Update an individual data object based on its class and uuid. */
  'objects.class.put': {
    parameters: {
      path: {
        className: string;
        /** The uuid of the data object to update. */
        id: string;
      };
      body: {
        body: definitions['Object'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
      };
    };
    responses: {
      /** Successfully received. */
      200: {
        schema: definitions['Object'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Delete a single data object. */
  'objects.class.delete': {
    parameters: {
      path: {
        className: string;
        /** Unique ID of the Object. */
        id: string;
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successfully deleted. */
      204: never;
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** Request is well-formed (i.e., syntactically correct), but erroneous. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Checks if a data object exists without retrieving it. */
  'objects.class.head': {
    parameters: {
      path: {
        /** The class name as defined in the schema */
        className: string;
        /** The uuid of the data object */
        id: string;
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Object exists. */
      204: never;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Object doesn't exist. */
      404: unknown;
      /** Request is well-formed (i.e., syntactically correct), but erroneous. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Update an individual data object based on its class and uuid. This method supports json-merge style patch semantics (RFC 7396). Provided meta-data and schema values are validated. LastUpdateTime is set to the time this function is called. */
  'objects.class.patch': {
    parameters: {
      path: {
        /** The class name as defined in the schema */
        className: string;
        /** The uuid of the data object to update. */
        id: string;
      };
      body: {
        /** RFC 7396-style patch, the body contains the object to merge into the existing object. */
        body?: definitions['Object'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
      };
    };
    responses: {
      /** Successfully applied. No content provided. */
      204: never;
      /** The patch-JSON is malformed. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: unknown;
      /** The patch-JSON is valid but unprocessable. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Replace all references to a class-property. */
  'objects.references.update': {
    parameters: {
      path: {
        /** Unique ID of the Object. */
        id: string;
        /** Unique name of the property related to the Object. */
        propertyName: string;
      };
      body: {
        body: definitions['MultipleRef'];
      };
      query: {
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successfully replaced all the references. */
      200: unknown;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Add a single reference to a class-property. */
  'objects.references.create': {
    parameters: {
      path: {
        /** Unique ID of the Object. */
        id: string;
        /** Unique name of the property related to the Object. */
        propertyName: string;
      };
      body: {
        body: definitions['SingleRef'];
      };
      query: {
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successfully added the reference. */
      200: unknown;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Delete the single reference that is given in the body from the list of references that this property has. */
  'objects.references.delete': {
    parameters: {
      path: {
        /** Unique ID of the Object. */
        id: string;
        /** Unique name of the property related to the Object. */
        propertyName: string;
      };
      body: {
        body: definitions['SingleRef'];
      };
      query: {
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successfully deleted. */
      204: never;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Update all references of a property of a data object. */
  'objects.class.references.put': {
    parameters: {
      path: {
        /** The class name as defined in the schema */
        className: string;
        /** Unique ID of the Object. */
        id: string;
        /** Unique name of the property related to the Object. */
        propertyName: string;
      };
      body: {
        body: definitions['MultipleRef'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successfully replaced all the references. */
      200: unknown;
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Source object doesn't exist. */
      404: unknown;
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Add a single reference to a class-property. */
  'objects.class.references.create': {
    parameters: {
      path: {
        /** The class name as defined in the schema */
        className: string;
        /** Unique ID of the Object. */
        id: string;
        /** Unique name of the property related to the Object. */
        propertyName: string;
      };
      body: {
        body: definitions['SingleRef'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successfully added the reference. */
      200: unknown;
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Source object doesn't exist. */
      404: unknown;
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Delete the single reference that is given in the body from the list of references that this property of a data object has */
  'objects.class.references.delete': {
    parameters: {
      path: {
        /** The class name as defined in the schema */
        className: string;
        /** Unique ID of the Object. */
        id: string;
        /** Unique name of the property related to the Object. */
        propertyName: string;
      };
      body: {
        body: definitions['SingleRef'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Successfully deleted. */
      204: never;
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Successful query result but no resource was found. */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the property exists or that it is a class? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Validate an Object's schema and meta-data. It has to be based on a schema, which is related to the given Object to be accepted by this validation. */
  'objects.validate': {
    parameters: {
      body: {
        body: definitions['Object'];
      };
    };
    responses: {
      /** Successfully validated. */
      200: unknown;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Register new Objects in bulk. Provided meta-data and schema values are validated. */
  'batch.objects.create': {
    parameters: {
      body: {
        body: {
          /** @description Define which fields need to be returned. Default value is ALL */
          fields?: ('ALL' | 'class' | 'schema' | 'id' | 'creationTimeUnix')[];
          objects?: definitions['Object'][];
        };
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
      };
    };
    responses: {
      /** Request succeeded, see response body to get detailed information about each batched item. */
      200: {
        schema: definitions['ObjectsGetResponse'][];
      };
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Delete Objects in bulk that match a certain filter. */
  'batch.objects.delete': {
    parameters: {
      body: {
        body: definitions['BatchDelete'];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
        /** Specifies the tenant in a request targeting a multi-tenant class */
        tenant?: parameters['CommonTenantParameterQuery'];
      };
    };
    responses: {
      /** Request succeeded, see response body to get detailed information about each batched item. */
      200: {
        schema: definitions['BatchDeleteResponse'];
      };
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Register cross-references between any class items (objects or objects) in bulk. */
  'batch.references.create': {
    parameters: {
      body: {
        /** A list of references to be batched. The ideal size depends on the used database connector. Please see the documentation of the used connector for help */
        body: definitions['BatchReference'][];
      };
      query: {
        /** Determines how many replicas must acknowledge a request before it is considered successful */
        consistency_level?: parameters['CommonConsistencyLevelParameterQuery'];
      };
    };
    responses: {
      /** Request Successful. Warning: A successful request does not guarantee that every batched reference was successfully created. Inspect the response body to see which references succeeded and which failed. */
      200: {
        schema: definitions['BatchReferenceResponse'][];
      };
      /** Malformed request. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Get an object based on GraphQL */
  'graphql.post': {
    parameters: {
      body: {
        /** The GraphQL query request parameters. */
        body: definitions['GraphQLQuery'];
      };
    };
    responses: {
      /** Successful query (with select). */
      200: {
        schema: definitions['GraphQLResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Perform a batched GraphQL query */
  'graphql.batch': {
    parameters: {
      body: {
        /** The GraphQL queries. */
        body: definitions['GraphQLQueries'];
      };
    };
    responses: {
      /** Successful query (with select). */
      200: {
        schema: definitions['GraphQLResponses'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Request body is well-formed (i.e., syntactically correct), but semantically erroneous. Are you sure the class is defined in the configuration file? */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Gives meta information about the server and can be used to provide information to another Weaviate instance that wants to interact with the current instance. */
  'meta.get': {
    responses: {
      /** Successful response. */
      200: {
        schema: definitions['Meta'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  'schema.dump': {
    parameters: {
      header: {
        /** If consistency is true, the request will be proxied to the leader to ensure strong schema consistency */
        consistency?: boolean;
      };
    };
    responses: {
      /** Successfully dumped the database schema. */
      200: {
        schema: definitions['Schema'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  'schema.objects.create': {
    parameters: {
      body: {
        objectClass: definitions['Class'];
      };
    };
    responses: {
      /** Added the new Object class to the schema. */
      200: {
        schema: definitions['Class'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid Object class */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  'schema.objects.get': {
    parameters: {
      path: {
        className: string;
      };
      header: {
        /** If consistency is true, the request will be proxied to the leader to ensure strong schema consistency */
        consistency?: boolean;
      };
    };
    responses: {
      /** Found the Class, returned as body */
      200: {
        schema: definitions['Class'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** This class does not exist */
      404: unknown;
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Use this endpoint to alter an existing class in the schema. Note that not all settings are mutable. If an error about immutable fields is returned and you still need to update this particular setting, you will have to delete the class (and the underlying data) and recreate. This endpoint cannot be used to modify properties. Instead use POST /v1/schema/{className}/properties. A typical use case for this endpoint is to update configuration, such as the vectorIndexConfig. Note that even in mutable sections, such as vectorIndexConfig, some fields may be immutable. */
  'schema.objects.update': {
    parameters: {
      path: {
        className: string;
      };
      body: {
        objectClass: definitions['Class'];
      };
    };
    responses: {
      /** Class was updated successfully */
      200: {
        schema: definitions['Class'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Class to be updated does not exist */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid update attempt */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  'schema.objects.delete': {
    parameters: {
      path: {
        className: string;
      };
    };
    responses: {
      /** Removed the Object class from the schema. */
      200: unknown;
      /** Could not delete the Object class. */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  'schema.objects.properties.add': {
    parameters: {
      path: {
        className: string;
      };
      body: {
        body: definitions['Property'];
      };
    };
    responses: {
      /** Added the property. */
      200: {
        schema: definitions['Property'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid property. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  'schema.objects.shards.get': {
    parameters: {
      path: {
        className: string;
      };
      query: {
        tenant?: string;
      };
    };
    responses: {
      /** Found the status of the shards, returned as body */
      200: {
        schema: definitions['ShardStatusList'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** This class does not exist */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Update shard status of an Object Class */
  'schema.objects.shards.update': {
    parameters: {
      path: {
        className: string;
        shardName: string;
      };
      body: {
        body: definitions['ShardStatus'];
      };
    };
    responses: {
      /** Shard status was updated successfully */
      200: {
        schema: definitions['ShardStatus'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Shard to be updated does not exist */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid update attempt */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** get all tenants from a specific class */
  'tenants.get': {
    parameters: {
      path: {
        className: string;
      };
      header: {
        /** If consistency is true, the request will be proxied to the leader to ensure strong schema consistency */
        consistency?: boolean;
      };
    };
    responses: {
      /** tenants from specified class. */
      200: {
        schema: definitions['Tenant'][];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid Tenant class */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Update tenant of a specific class */
  'tenants.update': {
    parameters: {
      path: {
        className: string;
      };
      body: {
        body: definitions['Tenant'][];
      };
    };
    responses: {
      /** Updated tenants of the specified class */
      200: {
        schema: definitions['Tenant'][];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid Tenant class */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Create a new tenant for a specific class */
  'tenants.create': {
    parameters: {
      path: {
        className: string;
      };
      body: {
        body: definitions['Tenant'][];
      };
    };
    responses: {
      /** Added new tenants to the specified class */
      200: {
        schema: definitions['Tenant'][];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid Tenant class */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** delete tenants from a specific class */
  'tenants.delete': {
    parameters: {
      path: {
        className: string;
      };
      body: {
        tenants: string[];
      };
    };
    responses: {
      /** Deleted tenants from specified class. */
      200: unknown;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid Tenant class */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Check if a tenant exists for a specific class */
  'tenant.exists': {
    parameters: {
      path: {
        className: string;
        tenantName: string;
      };
      header: {
        /** If consistency is true, the request will be proxied to the leader to ensure strong schema consistency */
        consistency?: boolean;
      };
    };
    responses: {
      /** The tenant exists in the specified class */
      200: unknown;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** The tenant not found */
      404: unknown;
      /** Invalid Tenant class */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** [Coming soon] List all backups in progress not implemented yet. */
  'backups.list': {
    parameters: {
      path: {
        /** Backup backend name e.g. filesystem, gcs, s3. */
        backend: string;
      };
    };
    responses: {
      /** Existed backups */
      200: {
        schema: definitions['BackupListResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid backup list. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Starts a process of creating a backup for a set of classes */
  'backups.create': {
    parameters: {
      path: {
        /** Backup backend name e.g. filesystem, gcs, s3. */
        backend: string;
      };
      body: {
        body: definitions['BackupCreateRequest'];
      };
    };
    responses: {
      /** Backup create process successfully started. */
      200: {
        schema: definitions['BackupCreateResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid backup creation attempt. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Returns status of backup creation attempt for a set of classes */
  'backups.create.status': {
    parameters: {
      path: {
        /** Backup backend name e.g. filesystem, gcs, s3. */
        backend: string;
        /** The ID of a backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
        id: string;
      };
    };
    responses: {
      /** Backup creation status successfully returned */
      200: {
        schema: definitions['BackupCreateStatusResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Not Found - Backup does not exist */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid backup restoration status attempt. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Cancel created backup with specified ID */
  'backups.cancel': {
    parameters: {
      path: {
        /** Backup backend name e.g. filesystem, gcs, s3. */
        backend: string;
        /** The ID of a backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
        id: string;
      };
    };
    responses: {
      /** Successfully deleted. */
      204: never;
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid backup cancellation attempt. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Returns status of a backup restoration attempt for a set of classes */
  'backups.restore.status': {
    parameters: {
      path: {
        /** Backup backend name e.g. filesystem, gcs, s3. */
        backend: string;
        /** The ID of a backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
        id: string;
      };
    };
    responses: {
      /** Backup restoration status successfully returned */
      200: {
        schema: definitions['BackupRestoreStatusResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Not Found - Backup does not exist */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Starts a process of restoring a backup for a set of classes */
  'backups.restore': {
    parameters: {
      path: {
        /** Backup backend name e.g. filesystem, gcs, s3. */
        backend: string;
        /** The ID of a backup. Must be URL-safe and work as a filesystem path, only lowercase, numbers, underscore, minus characters allowed. */
        id: string;
      };
      body: {
        body: definitions['BackupRestoreRequest'];
      };
    };
    responses: {
      /** Backup restoration process successfully started. */
      200: {
        schema: definitions['BackupRestoreResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Not Found - Backup does not exist */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid backup restoration attempt. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Returns Raft cluster statistics of Weaviate DB. */
  'cluster.get.statistics': {
    responses: {
      /** Cluster statistics successfully returned */
      200: {
        schema: definitions['ClusterStatisticsResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid backup restoration status attempt. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Returns status of Weaviate DB. */
  'nodes.get': {
    parameters: {
      query: {
        /** Controls the verbosity of the output, possible values are: "minimal", "verbose". Defaults to "minimal". */
        output?: parameters['CommonOutputVerbosityParameterQuery'];
      };
    };
    responses: {
      /** Nodes status successfully returned */
      200: {
        schema: definitions['NodesStatusResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Not Found - Backup does not exist */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid backup restoration status attempt. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Returns status of Weaviate DB. */
  'nodes.get.class': {
    parameters: {
      path: {
        className: string;
      };
      query: {
        /** Controls the verbosity of the output, possible values are: "minimal", "verbose". Defaults to "minimal". */
        output?: parameters['CommonOutputVerbosityParameterQuery'];
      };
    };
    responses: {
      /** Nodes status successfully returned */
      200: {
        schema: definitions['NodesStatusResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Not Found - Backup does not exist */
      404: {
        schema: definitions['ErrorResponse'];
      };
      /** Invalid backup restoration status attempt. */
      422: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Trigger a classification based on the specified params. Classifications will run in the background, use GET /classifications/<id> to retrieve the status of your classification. */
  'classifications.post': {
    parameters: {
      body: {
        /** parameters to start a classification */
        params: definitions['Classification'];
      };
    };
    responses: {
      /** Successfully started classification. */
      201: {
        schema: definitions['Classification'];
      };
      /** Incorrect request */
      400: {
        schema: definitions['ErrorResponse'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
  /** Get status, results and metadata of a previously created classification */
  'classifications.get': {
    parameters: {
      path: {
        /** classification id */
        id: string;
      };
    };
    responses: {
      /** Found the classification, returned as body */
      200: {
        schema: definitions['Classification'];
      };
      /** Unauthorized or invalid credentials. */
      401: unknown;
      /** Forbidden */
      403: {
        schema: definitions['ErrorResponse'];
      };
      /** Not Found - Classification does not exist */
      404: unknown;
      /** An error has occurred while trying to fulfill the request. Most likely the ErrorResponse will contain more information about the error. */
      500: {
        schema: definitions['ErrorResponse'];
      };
    };
  };
}

export interface external {}



---
File: /src/openapi/types.ts
---

import { definitions } from './schema.js';

type Override<T1, T2> = Omit<T1, keyof T2> & T2;
type DefaultProperties = { [key: string]: unknown };

export type WeaviateObject<T = DefaultProperties> = Override<definitions['Object'], { properties?: T }>;
export type WeaviateObjectsList = definitions['ObjectsListResponse'];
export type WeaviateObjectsGet = definitions['ObjectsGetResponse'];
export type Reference = definitions['SingleRef'];
export type WeaviateError = definitions['ErrorResponse'];
export type Properties = definitions['PropertySchema'];
export type Property = definitions['Property'];
export type DataObject = definitions['Object'];
// Backup
export type BackupCreateRequest = definitions['BackupCreateRequest'];
export type BackupCreateResponse = definitions['BackupCreateResponse'];
export type BackupCreateStatusResponse = definitions['BackupCreateStatusResponse'];
export type BackupRestoreRequest = definitions['BackupRestoreRequest'];
export type BackupRestoreResponse = definitions['BackupRestoreResponse'];
export type BackupRestoreStatusResponse = definitions['BackupRestoreStatusResponse'];
export type BackupConfig = definitions['BackupConfig'];
export type RestoreConfig = definitions['RestoreConfig'];
// Batch
export type BatchDelete = definitions['BatchDelete'];
export type BatchDeleteResponse = definitions['BatchDeleteResponse'];
export type BatchRequest = {
  fields?: ('ALL' | 'class' | 'schema' | 'id' | 'creationTimeUnix')[];
  objects?: WeaviateObject<any>[];
};
export type BatchReference = definitions['BatchReference'];
export type BatchReferenceResponse = definitions['BatchReferenceResponse'];
// C11y
export type C11yWordsResponse = definitions['C11yWordsResponse'];
export type C11yExtension = definitions['C11yExtension'];
// Classifications
export type Classification = definitions['Classification'];
// GraphQL
export type WhereFilter = definitions['WhereFilter'];
// Schema
export type WeaviateSchema = definitions['Schema'];
export type WeaviateClass = definitions['Class'];
export type WeaviateProperty = definitions['Property'];
export type WeaviateNestedProperty = definitions['NestedProperty'];
export type ShardStatus = definitions['ShardStatus'];
export type ShardStatusList = definitions['ShardStatusList'];
export type Tenant = definitions['Tenant'];
export type TenantActivityStatus = Tenant['activityStatus'];
export type SchemaClusterStatus = definitions['SchemaClusterStatus'];
export type WeaviateModuleConfig = WeaviateClass['moduleConfig'];
export type WeaviateInvertedIndexConfig = WeaviateClass['invertedIndexConfig'];
export type WeaviateBM25Config = definitions['BM25Config'];
export type WeaviateStopwordConfig = definitions['StopwordConfig'];
export type WeaviateMultiTenancyConfig = WeaviateClass['multiTenancyConfig'];
export type WeaviateReplicationConfig = WeaviateClass['replicationConfig'];
export type WeaviateShardingConfig = WeaviateClass['shardingConfig'];
export type WeaviateShardStatus = definitions['ShardStatusGetResponse'];
export type WeaviateVectorIndexConfig = WeaviateClass['vectorIndexConfig'];
export type WeaviateVectorsConfig = WeaviateClass['vectorConfig'];
export type WeaviateVectorConfig = definitions['VectorConfig'];
// Nodes
export type NodesStatusResponse = definitions['NodesStatusResponse'];
export type NodeStats = definitions['NodeStats'];
export type BatchStats = definitions['BatchStats'];
export type NodeShardStatus = definitions['NodeShardStatus'];
// Meta
export type Meta = definitions['Meta'];



---
File: /src/proto/google/health/v1/health.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: health.proto

/* eslint-disable */
import { type CallContext, type CallOptions } from "nice-grpc-common";
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "grpc.health.v1";

export interface HealthCheckRequest {
  service: string;
}

export interface HealthCheckResponse {
  status: HealthCheckResponse_ServingStatus;
}

export enum HealthCheckResponse_ServingStatus {
  UNKNOWN = 0,
  SERVING = 1,
  NOT_SERVING = 2,
  /** SERVICE_UNKNOWN - Used only by the Watch method. */
  SERVICE_UNKNOWN = 3,
  UNRECOGNIZED = -1,
}

export function healthCheckResponse_ServingStatusFromJSON(object: any): HealthCheckResponse_ServingStatus {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return HealthCheckResponse_ServingStatus.UNKNOWN;
    case 1:
    case "SERVING":
      return HealthCheckResponse_ServingStatus.SERVING;
    case 2:
    case "NOT_SERVING":
      return HealthCheckResponse_ServingStatus.NOT_SERVING;
    case 3:
    case "SERVICE_UNKNOWN":
      return HealthCheckResponse_ServingStatus.SERVICE_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HealthCheckResponse_ServingStatus.UNRECOGNIZED;
  }
}

export function healthCheckResponse_ServingStatusToJSON(object: HealthCheckResponse_ServingStatus): string {
  switch (object) {
    case HealthCheckResponse_ServingStatus.UNKNOWN:
      return "UNKNOWN";
    case HealthCheckResponse_ServingStatus.SERVING:
      return "SERVING";
    case HealthCheckResponse_ServingStatus.NOT_SERVING:
      return "NOT_SERVING";
    case HealthCheckResponse_ServingStatus.SERVICE_UNKNOWN:
      return "SERVICE_UNKNOWN";
    case HealthCheckResponse_ServingStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return { service: "" };
}

export const HealthCheckRequest = {
  encode(message: HealthCheckRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.service !== "") {
      writer.uint32(10).string(message.service);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.service = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckRequest {
    return { service: isSet(object.service) ? globalThis.String(object.service) : "" };
  },

  toJSON(message: HealthCheckRequest): unknown {
    const obj: any = {};
    if (message.service !== "") {
      obj.service = message.service;
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckRequest>): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    message.service = object.service ?? "";
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { status: 0 };
}

export const HealthCheckResponse = {
  encode(message: HealthCheckResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return { status: isSet(object.status) ? healthCheckResponse_ServingStatusFromJSON(object.status) : 0 };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = healthCheckResponse_ServingStatusToJSON(message.status);
    }
    return obj;
  },

  create(base?: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HealthCheckResponse>): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.status = object.status ?? 0;
    return message;
  },
};

export type HealthDefinition = typeof HealthDefinition;
export const HealthDefinition = {
  name: "Health",
  fullName: "grpc.health.v1.Health",
  methods: {
    /**
     * If the requested service is unknown, the call will fail with status
     * NOT_FOUND.
     */
    check: {
      name: "Check",
      requestType: HealthCheckRequest,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Performs a watch for the serving status of the requested service.
     * The server will immediately send back a message indicating the current
     * serving status.  It will then subsequently send a new message whenever
     * the service's serving status changes.
     *
     * If the requested service is unknown when the call is received, the
     * server will send a message setting the serving status to
     * SERVICE_UNKNOWN but will *not* terminate the call.  If at some
     * future point, the serving status of the service becomes known, the
     * server will send a new message with the service's serving status.
     *
     * If the call terminates with status UNIMPLEMENTED, then clients
     * should assume this method is not supported and should not retry the
     * call.  If the call terminates with any other status (including OK),
     * clients should retry the call with appropriate exponential backoff.
     */
    watch: {
      name: "Watch",
      requestType: HealthCheckRequest,
      requestStream: false,
      responseType: HealthCheckResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface HealthServiceImplementation<CallContextExt = {}> {
  /**
   * If the requested service is unknown, the call will fail with status
   * NOT_FOUND.
   */
  check(request: HealthCheckRequest, context: CallContext & CallContextExt): Promise<DeepPartial<HealthCheckResponse>>;
  /**
   * Performs a watch for the serving status of the requested service.
   * The server will immediately send back a message indicating the current
   * serving status.  It will then subsequently send a new message whenever
   * the service's serving status changes.
   *
   * If the requested service is unknown when the call is received, the
   * server will send a message setting the serving status to
   * SERVICE_UNKNOWN but will *not* terminate the call.  If at some
   * future point, the serving status of the service becomes known, the
   * server will send a new message with the service's serving status.
   *
   * If the call terminates with status UNIMPLEMENTED, then clients
   * should assume this method is not supported and should not retry the
   * call.  If the call terminates with any other status (including OK),
   * clients should retry the call with appropriate exponential backoff.
   */
  watch(
    request: HealthCheckRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<HealthCheckResponse>>;
}

export interface HealthClient<CallOptionsExt = {}> {
  /**
   * If the requested service is unknown, the call will fail with status
   * NOT_FOUND.
   */
  check(request: DeepPartial<HealthCheckRequest>, options?: CallOptions & CallOptionsExt): Promise<HealthCheckResponse>;
  /**
   * Performs a watch for the serving status of the requested service.
   * The server will immediately send back a message indicating the current
   * serving status.  It will then subsequently send a new message whenever
   * the service's serving status changes.
   *
   * If the requested service is unknown when the call is received, the
   * server will send a message setting the serving status to
   * SERVICE_UNKNOWN but will *not* terminate the call.  If at some
   * future point, the serving status of the service becomes known, the
   * server will send a new message with the service's serving status.
   *
   * If the call terminates with status UNIMPLEMENTED, then clients
   * should assume this method is not supported and should not retry the
   * call.  If the call terminates with any other status (including OK),
   * clients should retry the call with appropriate exponential backoff.
   */
  watch(
    request: DeepPartial<HealthCheckRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<HealthCheckResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };



---
File: /src/proto/google/protobuf/struct.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: google/protobuf/struct.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "google.protobuf";

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 *  The JSON representation for `NullValue` is JSON `null`.
 */
export enum NullValue {
  /** NULL_VALUE - Null value. */
  NULL_VALUE = 0,
  UNRECOGNIZED = -1,
}

export function nullValueFromJSON(object: any): NullValue {
  switch (object) {
    case 0:
    case "NULL_VALUE":
      return NullValue.NULL_VALUE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NullValue.UNRECOGNIZED;
  }
}

export function nullValueToJSON(object: NullValue): string {
  switch (object) {
    case NullValue.NULL_VALUE:
      return "NULL_VALUE";
    case NullValue.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * `Struct` represents a structured data value, consisting of fields
 * which map to dynamically typed values. In some languages, `Struct`
 * might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an
 * object. The details of that representation are described together
 * with the proto support for the language.
 *
 * The JSON representation for `Struct` is JSON object.
 */
export interface Struct {
  /** Unordered map of dynamically typed values. */
  fields: { [key: string]: any | undefined };
}

export interface Struct_FieldsEntry {
  key: string;
  value: any | undefined;
}

/**
 * `Value` represents a dynamically typed value which can be either
 * null, a number, a string, a boolean, a recursive struct value, or a
 * list of values. A producer of value is expected to set one of these
 * variants. Absence of any variant indicates an error.
 *
 * The JSON representation for `Value` is JSON value.
 */
export interface Value {
  /** Represents a null value. */
  nullValue?:
    | NullValue
    | undefined;
  /** Represents a double value. */
  numberValue?:
    | number
    | undefined;
  /** Represents a string value. */
  stringValue?:
    | string
    | undefined;
  /** Represents a boolean value. */
  boolValue?:
    | boolean
    | undefined;
  /** Represents a structured value. */
  structValue?:
    | { [key: string]: any }
    | undefined;
  /** Represents a repeated `Value`. */
  listValue?: Array<any> | undefined;
}

/**
 * `ListValue` is a wrapper around a repeated field of values.
 *
 * The JSON representation for `ListValue` is JSON array.
 */
export interface ListValue {
  /** Repeated field of dynamically typed values. */
  values: any[];
}

function createBaseStruct(): Struct {
  return { fields: {} };
}

export const Struct = {
  encode(message: Struct, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== undefined) {
        Struct_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
      }
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Struct {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Struct {
    return {
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {
          acc[key] = value as any | undefined;
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Struct): unknown {
    const obj: any = {};
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Struct>): Struct {
    return Struct.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Struct>): Struct {
    const message = createBaseStruct();
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: any | undefined }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    return message;
  },

  wrap(object: { [key: string]: any } | undefined): Struct {
    const struct = createBaseStruct();

    if (object !== undefined) {
      for (const key of Object.keys(object)) {
        struct.fields[key] = object[key];
      }
    }
    return struct;
  },

  unwrap(message: Struct): { [key: string]: any } {
    const object: { [key: string]: any } = {};
    if (message.fields) {
      for (const key of Object.keys(message.fields)) {
        object[key] = message.fields[key];
      }
    }
    return object;
  },
};

function createBaseStruct_FieldsEntry(): Struct_FieldsEntry {
  return { key: "", value: undefined };
}

export const Struct_FieldsEntry = {
  encode(message: Struct_FieldsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Struct_FieldsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStruct_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Struct_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Struct_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Struct_FieldsEntry>): Struct_FieldsEntry {
    return Struct_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Struct_FieldsEntry>): Struct_FieldsEntry {
    const message = createBaseStruct_FieldsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseValue(): Value {
  return {
    nullValue: undefined,
    numberValue: undefined,
    stringValue: undefined,
    boolValue: undefined,
    structValue: undefined,
    listValue: undefined,
  };
}

export const Value = {
  encode(message: Value, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nullValue !== undefined) {
      writer.uint32(8).int32(message.nullValue);
    }
    if (message.numberValue !== undefined) {
      writer.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== undefined) {
      Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).ldelim();
    }
    if (message.listValue !== undefined) {
      ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Value {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.nullValue = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.numberValue = reader.double();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      nullValue: isSet(object.nullValue) ? nullValueFromJSON(object.nullValue) : undefined,
      numberValue: isSet(object.numberValue) ? globalThis.Number(object.numberValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      structValue: isObject(object.structValue) ? object.structValue : undefined,
      listValue: globalThis.Array.isArray(object.listValue) ? [...object.listValue] : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.nullValue !== undefined) {
      obj.nullValue = nullValueToJSON(message.nullValue);
    }
    if (message.numberValue !== undefined) {
      obj.numberValue = message.numberValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.structValue !== undefined) {
      obj.structValue = message.structValue;
    }
    if (message.listValue !== undefined) {
      obj.listValue = message.listValue;
    }
    return obj;
  },

  create(base?: DeepPartial<Value>): Value {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Value>): Value {
    const message = createBaseValue();
    message.nullValue = object.nullValue ?? undefined;
    message.numberValue = object.numberValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.structValue = object.structValue ?? undefined;
    message.listValue = object.listValue ?? undefined;
    return message;
  },

  wrap(value: any): Value {
    const result = createBaseValue();
    if (value === null) {
      result.nullValue = NullValue.NULL_VALUE;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (globalThis.Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new globalThis.Error("Unsupported any value type: " + typeof value);
    }
    return result;
  },

  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined {
    if (message.stringValue !== undefined) {
      return message.stringValue;
    } else if (message?.numberValue !== undefined) {
      return message.numberValue;
    } else if (message?.boolValue !== undefined) {
      return message.boolValue;
    } else if (message?.structValue !== undefined) {
      return message.structValue as any;
    } else if (message?.listValue !== undefined) {
      return message.listValue;
    } else if (message?.nullValue !== undefined) {
      return null;
    }
    return undefined;
  },
};

function createBaseListValue(): ListValue {
  return { values: [] };
}

export const ListValue = {
  encode(message: ListValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      Value.encode(Value.wrap(v!), writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListValue {
    return { values: globalThis.Array.isArray(object?.values) ? [...object.values] : [] };
  },

  toJSON(message: ListValue): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<ListValue>): ListValue {
    return ListValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListValue>): ListValue {
    const message = createBaseListValue();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },

  wrap(array: Array<any> | undefined): ListValue {
    const result = createBaseListValue();
    result.values = array ?? [];
    return result;
  },

  unwrap(message: ListValue): Array<any> {
    if (message?.hasOwnProperty("values") && globalThis.Array.isArray(message.values)) {
      return message.values;
    } else {
      return message as any;
    }
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}



---
File: /src/proto/v1/base.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/base.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Struct } from "../google/protobuf/struct.js";

export const protobufPackage = "weaviate.v1";

export enum ConsistencyLevel {
  CONSISTENCY_LEVEL_UNSPECIFIED = 0,
  CONSISTENCY_LEVEL_ONE = 1,
  CONSISTENCY_LEVEL_QUORUM = 2,
  CONSISTENCY_LEVEL_ALL = 3,
  UNRECOGNIZED = -1,
}

export function consistencyLevelFromJSON(object: any): ConsistencyLevel {
  switch (object) {
    case 0:
    case "CONSISTENCY_LEVEL_UNSPECIFIED":
      return ConsistencyLevel.CONSISTENCY_LEVEL_UNSPECIFIED;
    case 1:
    case "CONSISTENCY_LEVEL_ONE":
      return ConsistencyLevel.CONSISTENCY_LEVEL_ONE;
    case 2:
    case "CONSISTENCY_LEVEL_QUORUM":
      return ConsistencyLevel.CONSISTENCY_LEVEL_QUORUM;
    case 3:
    case "CONSISTENCY_LEVEL_ALL":
      return ConsistencyLevel.CONSISTENCY_LEVEL_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConsistencyLevel.UNRECOGNIZED;
  }
}

export function consistencyLevelToJSON(object: ConsistencyLevel): string {
  switch (object) {
    case ConsistencyLevel.CONSISTENCY_LEVEL_UNSPECIFIED:
      return "CONSISTENCY_LEVEL_UNSPECIFIED";
    case ConsistencyLevel.CONSISTENCY_LEVEL_ONE:
      return "CONSISTENCY_LEVEL_ONE";
    case ConsistencyLevel.CONSISTENCY_LEVEL_QUORUM:
      return "CONSISTENCY_LEVEL_QUORUM";
    case ConsistencyLevel.CONSISTENCY_LEVEL_ALL:
      return "CONSISTENCY_LEVEL_ALL";
    case ConsistencyLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface NumberArrayProperties {
  /**
   * will be removed in the future, use vector_bytes
   *
   * @deprecated
   */
  values: number[];
  propName: string;
  valuesBytes: Uint8Array;
}

export interface IntArrayProperties {
  values: number[];
  propName: string;
}

export interface TextArrayProperties {
  values: string[];
  propName: string;
}

export interface BooleanArrayProperties {
  values: boolean[];
  propName: string;
}

export interface ObjectPropertiesValue {
  nonRefProperties: { [key: string]: any } | undefined;
  numberArrayProperties: NumberArrayProperties[];
  intArrayProperties: IntArrayProperties[];
  textArrayProperties: TextArrayProperties[];
  booleanArrayProperties: BooleanArrayProperties[];
  objectProperties: ObjectProperties[];
  objectArrayProperties: ObjectArrayProperties[];
  emptyListProps: string[];
}

export interface ObjectArrayProperties {
  values: ObjectPropertiesValue[];
  propName: string;
}

export interface ObjectProperties {
  value: ObjectPropertiesValue | undefined;
  propName: string;
}

export interface TextArray {
  values: string[];
}

export interface IntArray {
  values: number[];
}

export interface NumberArray {
  values: number[];
}

export interface BooleanArray {
  values: boolean[];
}

export interface Filters {
  operator: Filters_Operator;
  /**
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   *
   * @deprecated
   */
  on: string[];
  filters: Filters[];
  valueText?: string | undefined;
  valueInt?: number | undefined;
  valueBoolean?: boolean | undefined;
  valueNumber?: number | undefined;
  valueTextArray?: TextArray | undefined;
  valueIntArray?: IntArray | undefined;
  valueBooleanArray?: BooleanArray | undefined;
  valueNumberArray?: NumberArray | undefined;
  valueGeo?:
    | GeoCoordinatesFilter
    | undefined;
  /** leave space for more filter values */
  target: FilterTarget | undefined;
}

export enum Filters_Operator {
  OPERATOR_UNSPECIFIED = 0,
  OPERATOR_EQUAL = 1,
  OPERATOR_NOT_EQUAL = 2,
  OPERATOR_GREATER_THAN = 3,
  OPERATOR_GREATER_THAN_EQUAL = 4,
  OPERATOR_LESS_THAN = 5,
  OPERATOR_LESS_THAN_EQUAL = 6,
  OPERATOR_AND = 7,
  OPERATOR_OR = 8,
  OPERATOR_WITHIN_GEO_RANGE = 9,
  OPERATOR_LIKE = 10,
  OPERATOR_IS_NULL = 11,
  OPERATOR_CONTAINS_ANY = 12,
  OPERATOR_CONTAINS_ALL = 13,
  UNRECOGNIZED = -1,
}

export function filters_OperatorFromJSON(object: any): Filters_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return Filters_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "OPERATOR_EQUAL":
      return Filters_Operator.OPERATOR_EQUAL;
    case 2:
    case "OPERATOR_NOT_EQUAL":
      return Filters_Operator.OPERATOR_NOT_EQUAL;
    case 3:
    case "OPERATOR_GREATER_THAN":
      return Filters_Operator.OPERATOR_GREATER_THAN;
    case 4:
    case "OPERATOR_GREATER_THAN_EQUAL":
      return Filters_Operator.OPERATOR_GREATER_THAN_EQUAL;
    case 5:
    case "OPERATOR_LESS_THAN":
      return Filters_Operator.OPERATOR_LESS_THAN;
    case 6:
    case "OPERATOR_LESS_THAN_EQUAL":
      return Filters_Operator.OPERATOR_LESS_THAN_EQUAL;
    case 7:
    case "OPERATOR_AND":
      return Filters_Operator.OPERATOR_AND;
    case 8:
    case "OPERATOR_OR":
      return Filters_Operator.OPERATOR_OR;
    case 9:
    case "OPERATOR_WITHIN_GEO_RANGE":
      return Filters_Operator.OPERATOR_WITHIN_GEO_RANGE;
    case 10:
    case "OPERATOR_LIKE":
      return Filters_Operator.OPERATOR_LIKE;
    case 11:
    case "OPERATOR_IS_NULL":
      return Filters_Operator.OPERATOR_IS_NULL;
    case 12:
    case "OPERATOR_CONTAINS_ANY":
      return Filters_Operator.OPERATOR_CONTAINS_ANY;
    case 13:
    case "OPERATOR_CONTAINS_ALL":
      return Filters_Operator.OPERATOR_CONTAINS_ALL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Filters_Operator.UNRECOGNIZED;
  }
}

export function filters_OperatorToJSON(object: Filters_Operator): string {
  switch (object) {
    case Filters_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case Filters_Operator.OPERATOR_EQUAL:
      return "OPERATOR_EQUAL";
    case Filters_Operator.OPERATOR_NOT_EQUAL:
      return "OPERATOR_NOT_EQUAL";
    case Filters_Operator.OPERATOR_GREATER_THAN:
      return "OPERATOR_GREATER_THAN";
    case Filters_Operator.OPERATOR_GREATER_THAN_EQUAL:
      return "OPERATOR_GREATER_THAN_EQUAL";
    case Filters_Operator.OPERATOR_LESS_THAN:
      return "OPERATOR_LESS_THAN";
    case Filters_Operator.OPERATOR_LESS_THAN_EQUAL:
      return "OPERATOR_LESS_THAN_EQUAL";
    case Filters_Operator.OPERATOR_AND:
      return "OPERATOR_AND";
    case Filters_Operator.OPERATOR_OR:
      return "OPERATOR_OR";
    case Filters_Operator.OPERATOR_WITHIN_GEO_RANGE:
      return "OPERATOR_WITHIN_GEO_RANGE";
    case Filters_Operator.OPERATOR_LIKE:
      return "OPERATOR_LIKE";
    case Filters_Operator.OPERATOR_IS_NULL:
      return "OPERATOR_IS_NULL";
    case Filters_Operator.OPERATOR_CONTAINS_ANY:
      return "OPERATOR_CONTAINS_ANY";
    case Filters_Operator.OPERATOR_CONTAINS_ALL:
      return "OPERATOR_CONTAINS_ALL";
    case Filters_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface FilterReferenceSingleTarget {
  on: string;
  target: FilterTarget | undefined;
}

export interface FilterReferenceMultiTarget {
  on: string;
  target: FilterTarget | undefined;
  targetCollection: string;
}

export interface FilterReferenceCount {
  on: string;
}

export interface FilterTarget {
  property?: string | undefined;
  singleTarget?: FilterReferenceSingleTarget | undefined;
  multiTarget?: FilterReferenceMultiTarget | undefined;
  count?: FilterReferenceCount | undefined;
}

export interface GeoCoordinatesFilter {
  latitude: number;
  longitude: number;
  distance: number;
}

export interface Vectors {
  name: string;
  /** for multi-vec */
  index: number;
  vectorBytes: Uint8Array;
}

function createBaseNumberArrayProperties(): NumberArrayProperties {
  return { values: [], propName: "", valuesBytes: new Uint8Array(0) };
}

export const NumberArrayProperties = {
  encode(message: NumberArrayProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.double(v);
    }
    writer.ldelim();
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    if (message.valuesBytes.length !== 0) {
      writer.uint32(26).bytes(message.valuesBytes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NumberArrayProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberArrayProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.double());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.valuesBytes = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberArrayProperties {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
      valuesBytes: isSet(object.valuesBytes) ? bytesFromBase64(object.valuesBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: NumberArrayProperties): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    if (message.valuesBytes.length !== 0) {
      obj.valuesBytes = base64FromBytes(message.valuesBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<NumberArrayProperties>): NumberArrayProperties {
    return NumberArrayProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumberArrayProperties>): NumberArrayProperties {
    const message = createBaseNumberArrayProperties();
    message.values = object.values?.map((e) => e) || [];
    message.propName = object.propName ?? "";
    message.valuesBytes = object.valuesBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseIntArrayProperties(): IntArrayProperties {
  return { values: [], propName: "" };
}

export const IntArrayProperties = {
  encode(message: IntArrayProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.int64(v);
    }
    writer.ldelim();
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IntArrayProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntArrayProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.values.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntArrayProperties {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
    };
  },

  toJSON(message: IntArrayProperties): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Math.round(e));
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    return obj;
  },

  create(base?: DeepPartial<IntArrayProperties>): IntArrayProperties {
    return IntArrayProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntArrayProperties>): IntArrayProperties {
    const message = createBaseIntArrayProperties();
    message.values = object.values?.map((e) => e) || [];
    message.propName = object.propName ?? "";
    return message;
  },
};

function createBaseTextArrayProperties(): TextArrayProperties {
  return { values: [], propName: "" };
}

export const TextArrayProperties = {
  encode(message: TextArrayProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TextArrayProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextArrayProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextArrayProperties {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
    };
  },

  toJSON(message: TextArrayProperties): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    return obj;
  },

  create(base?: DeepPartial<TextArrayProperties>): TextArrayProperties {
    return TextArrayProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextArrayProperties>): TextArrayProperties {
    const message = createBaseTextArrayProperties();
    message.values = object.values?.map((e) => e) || [];
    message.propName = object.propName ?? "";
    return message;
  },
};

function createBaseBooleanArrayProperties(): BooleanArrayProperties {
  return { values: [], propName: "" };
}

export const BooleanArrayProperties = {
  encode(message: BooleanArrayProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.bool(v);
    }
    writer.ldelim();
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BooleanArrayProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBooleanArrayProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.values.push(reader.bool());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.bool());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BooleanArrayProperties {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Boolean(e)) : [],
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
    };
  },

  toJSON(message: BooleanArrayProperties): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    return obj;
  },

  create(base?: DeepPartial<BooleanArrayProperties>): BooleanArrayProperties {
    return BooleanArrayProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BooleanArrayProperties>): BooleanArrayProperties {
    const message = createBaseBooleanArrayProperties();
    message.values = object.values?.map((e) => e) || [];
    message.propName = object.propName ?? "";
    return message;
  },
};

function createBaseObjectPropertiesValue(): ObjectPropertiesValue {
  return {
    nonRefProperties: undefined,
    numberArrayProperties: [],
    intArrayProperties: [],
    textArrayProperties: [],
    booleanArrayProperties: [],
    objectProperties: [],
    objectArrayProperties: [],
    emptyListProps: [],
  };
}

export const ObjectPropertiesValue = {
  encode(message: ObjectPropertiesValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nonRefProperties !== undefined) {
      Struct.encode(Struct.wrap(message.nonRefProperties), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.numberArrayProperties) {
      NumberArrayProperties.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.intArrayProperties) {
      IntArrayProperties.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.textArrayProperties) {
      TextArrayProperties.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.booleanArrayProperties) {
      BooleanArrayProperties.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.objectProperties) {
      ObjectProperties.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.objectArrayProperties) {
      ObjectArrayProperties.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.emptyListProps) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ObjectPropertiesValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectPropertiesValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nonRefProperties = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.numberArrayProperties.push(NumberArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.intArrayProperties.push(IntArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.textArrayProperties.push(TextArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.booleanArrayProperties.push(BooleanArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.objectProperties.push(ObjectProperties.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.objectArrayProperties.push(ObjectArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.emptyListProps.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectPropertiesValue {
    return {
      nonRefProperties: isObject(object.nonRefProperties) ? object.nonRefProperties : undefined,
      numberArrayProperties: globalThis.Array.isArray(object?.numberArrayProperties)
        ? object.numberArrayProperties.map((e: any) => NumberArrayProperties.fromJSON(e))
        : [],
      intArrayProperties: globalThis.Array.isArray(object?.intArrayProperties)
        ? object.intArrayProperties.map((e: any) => IntArrayProperties.fromJSON(e))
        : [],
      textArrayProperties: globalThis.Array.isArray(object?.textArrayProperties)
        ? object.textArrayProperties.map((e: any) => TextArrayProperties.fromJSON(e))
        : [],
      booleanArrayProperties: globalThis.Array.isArray(object?.booleanArrayProperties)
        ? object.booleanArrayProperties.map((e: any) => BooleanArrayProperties.fromJSON(e))
        : [],
      objectProperties: globalThis.Array.isArray(object?.objectProperties)
        ? object.objectProperties.map((e: any) => ObjectProperties.fromJSON(e))
        : [],
      objectArrayProperties: globalThis.Array.isArray(object?.objectArrayProperties)
        ? object.objectArrayProperties.map((e: any) => ObjectArrayProperties.fromJSON(e))
        : [],
      emptyListProps: globalThis.Array.isArray(object?.emptyListProps)
        ? object.emptyListProps.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ObjectPropertiesValue): unknown {
    const obj: any = {};
    if (message.nonRefProperties !== undefined) {
      obj.nonRefProperties = message.nonRefProperties;
    }
    if (message.numberArrayProperties?.length) {
      obj.numberArrayProperties = message.numberArrayProperties.map((e) => NumberArrayProperties.toJSON(e));
    }
    if (message.intArrayProperties?.length) {
      obj.intArrayProperties = message.intArrayProperties.map((e) => IntArrayProperties.toJSON(e));
    }
    if (message.textArrayProperties?.length) {
      obj.textArrayProperties = message.textArrayProperties.map((e) => TextArrayProperties.toJSON(e));
    }
    if (message.booleanArrayProperties?.length) {
      obj.booleanArrayProperties = message.booleanArrayProperties.map((e) => BooleanArrayProperties.toJSON(e));
    }
    if (message.objectProperties?.length) {
      obj.objectProperties = message.objectProperties.map((e) => ObjectProperties.toJSON(e));
    }
    if (message.objectArrayProperties?.length) {
      obj.objectArrayProperties = message.objectArrayProperties.map((e) => ObjectArrayProperties.toJSON(e));
    }
    if (message.emptyListProps?.length) {
      obj.emptyListProps = message.emptyListProps;
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectPropertiesValue>): ObjectPropertiesValue {
    return ObjectPropertiesValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectPropertiesValue>): ObjectPropertiesValue {
    const message = createBaseObjectPropertiesValue();
    message.nonRefProperties = object.nonRefProperties ?? undefined;
    message.numberArrayProperties = object.numberArrayProperties?.map((e) => NumberArrayProperties.fromPartial(e)) ||
      [];
    message.intArrayProperties = object.intArrayProperties?.map((e) => IntArrayProperties.fromPartial(e)) || [];
    message.textArrayProperties = object.textArrayProperties?.map((e) => TextArrayProperties.fromPartial(e)) || [];
    message.booleanArrayProperties = object.booleanArrayProperties?.map((e) => BooleanArrayProperties.fromPartial(e)) ||
      [];
    message.objectProperties = object.objectProperties?.map((e) => ObjectProperties.fromPartial(e)) || [];
    message.objectArrayProperties = object.objectArrayProperties?.map((e) => ObjectArrayProperties.fromPartial(e)) ||
      [];
    message.emptyListProps = object.emptyListProps?.map((e) => e) || [];
    return message;
  },
};

function createBaseObjectArrayProperties(): ObjectArrayProperties {
  return { values: [], propName: "" };
}

export const ObjectArrayProperties = {
  encode(message: ObjectArrayProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      ObjectPropertiesValue.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ObjectArrayProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectArrayProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(ObjectPropertiesValue.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectArrayProperties {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => ObjectPropertiesValue.fromJSON(e))
        : [],
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
    };
  },

  toJSON(message: ObjectArrayProperties): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => ObjectPropertiesValue.toJSON(e));
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectArrayProperties>): ObjectArrayProperties {
    return ObjectArrayProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectArrayProperties>): ObjectArrayProperties {
    const message = createBaseObjectArrayProperties();
    message.values = object.values?.map((e) => ObjectPropertiesValue.fromPartial(e)) || [];
    message.propName = object.propName ?? "";
    return message;
  },
};

function createBaseObjectProperties(): ObjectProperties {
  return { value: undefined, propName: "" };
}

export const ObjectProperties = {
  encode(message: ObjectProperties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.value !== undefined) {
      ObjectPropertiesValue.encode(message.value, writer.uint32(10).fork()).ldelim();
    }
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ObjectProperties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = ObjectPropertiesValue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectProperties {
    return {
      value: isSet(object.value) ? ObjectPropertiesValue.fromJSON(object.value) : undefined,
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
    };
  },

  toJSON(message: ObjectProperties): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = ObjectPropertiesValue.toJSON(message.value);
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectProperties>): ObjectProperties {
    return ObjectProperties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectProperties>): ObjectProperties {
    const message = createBaseObjectProperties();
    message.value = (object.value !== undefined && object.value !== null)
      ? ObjectPropertiesValue.fromPartial(object.value)
      : undefined;
    message.propName = object.propName ?? "";
    return message;
  },
};

function createBaseTextArray(): TextArray {
  return { values: [] };
}

export const TextArray = {
  encode(message: TextArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TextArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TextArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<TextArray>): TextArray {
    return TextArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextArray>): TextArray {
    const message = createBaseTextArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseIntArray(): IntArray {
  return { values: [] };
}

export const IntArray = {
  encode(message: IntArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.int64(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IntArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.values.push(longToNumber(reader.int64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(longToNumber(reader.int64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: IntArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Math.round(e));
    }
    return obj;
  },

  create(base?: DeepPartial<IntArray>): IntArray {
    return IntArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntArray>): IntArray {
    const message = createBaseIntArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseNumberArray(): NumberArray {
  return { values: [] };
}

export const NumberArray = {
  encode(message: NumberArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.double(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NumberArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 9) {
            message.values.push(reader.double());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.double());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: NumberArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<NumberArray>): NumberArray {
    return NumberArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumberArray>): NumberArray {
    const message = createBaseNumberArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseBooleanArray(): BooleanArray {
  return { values: [] };
}

export const BooleanArray = {
  encode(message: BooleanArray, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.bool(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BooleanArray {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBooleanArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.values.push(reader.bool());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.bool());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BooleanArray {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Boolean(e)) : [],
    };
  },

  toJSON(message: BooleanArray): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<BooleanArray>): BooleanArray {
    return BooleanArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BooleanArray>): BooleanArray {
    const message = createBaseBooleanArray();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseFilters(): Filters {
  return {
    operator: 0,
    on: [],
    filters: [],
    valueText: undefined,
    valueInt: undefined,
    valueBoolean: undefined,
    valueNumber: undefined,
    valueTextArray: undefined,
    valueIntArray: undefined,
    valueBooleanArray: undefined,
    valueNumberArray: undefined,
    valueGeo: undefined,
    target: undefined,
  };
}

export const Filters = {
  encode(message: Filters, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    for (const v of message.on) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.filters) {
      Filters.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.valueText !== undefined) {
      writer.uint32(34).string(message.valueText);
    }
    if (message.valueInt !== undefined) {
      writer.uint32(40).int64(message.valueInt);
    }
    if (message.valueBoolean !== undefined) {
      writer.uint32(48).bool(message.valueBoolean);
    }
    if (message.valueNumber !== undefined) {
      writer.uint32(57).double(message.valueNumber);
    }
    if (message.valueTextArray !== undefined) {
      TextArray.encode(message.valueTextArray, writer.uint32(74).fork()).ldelim();
    }
    if (message.valueIntArray !== undefined) {
      IntArray.encode(message.valueIntArray, writer.uint32(82).fork()).ldelim();
    }
    if (message.valueBooleanArray !== undefined) {
      BooleanArray.encode(message.valueBooleanArray, writer.uint32(90).fork()).ldelim();
    }
    if (message.valueNumberArray !== undefined) {
      NumberArray.encode(message.valueNumberArray, writer.uint32(98).fork()).ldelim();
    }
    if (message.valueGeo !== undefined) {
      GeoCoordinatesFilter.encode(message.valueGeo, writer.uint32(106).fork()).ldelim();
    }
    if (message.target !== undefined) {
      FilterTarget.encode(message.target, writer.uint32(162).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Filters {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.on.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.filters.push(Filters.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.valueText = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.valueInt = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.valueBoolean = reader.bool();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.valueNumber = reader.double();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.valueTextArray = TextArray.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.valueIntArray = IntArray.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.valueBooleanArray = BooleanArray.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.valueNumberArray = NumberArray.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.valueGeo = GeoCoordinatesFilter.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.target = FilterTarget.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filters {
    return {
      operator: isSet(object.operator) ? filters_OperatorFromJSON(object.operator) : 0,
      on: globalThis.Array.isArray(object?.on) ? object.on.map((e: any) => globalThis.String(e)) : [],
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filters.fromJSON(e)) : [],
      valueText: isSet(object.valueText) ? globalThis.String(object.valueText) : undefined,
      valueInt: isSet(object.valueInt) ? globalThis.Number(object.valueInt) : undefined,
      valueBoolean: isSet(object.valueBoolean) ? globalThis.Boolean(object.valueBoolean) : undefined,
      valueNumber: isSet(object.valueNumber) ? globalThis.Number(object.valueNumber) : undefined,
      valueTextArray: isSet(object.valueTextArray) ? TextArray.fromJSON(object.valueTextArray) : undefined,
      valueIntArray: isSet(object.valueIntArray) ? IntArray.fromJSON(object.valueIntArray) : undefined,
      valueBooleanArray: isSet(object.valueBooleanArray) ? BooleanArray.fromJSON(object.valueBooleanArray) : undefined,
      valueNumberArray: isSet(object.valueNumberArray) ? NumberArray.fromJSON(object.valueNumberArray) : undefined,
      valueGeo: isSet(object.valueGeo) ? GeoCoordinatesFilter.fromJSON(object.valueGeo) : undefined,
      target: isSet(object.target) ? FilterTarget.fromJSON(object.target) : undefined,
    };
  },

  toJSON(message: Filters): unknown {
    const obj: any = {};
    if (message.operator !== 0) {
      obj.operator = filters_OperatorToJSON(message.operator);
    }
    if (message.on?.length) {
      obj.on = message.on;
    }
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filters.toJSON(e));
    }
    if (message.valueText !== undefined) {
      obj.valueText = message.valueText;
    }
    if (message.valueInt !== undefined) {
      obj.valueInt = Math.round(message.valueInt);
    }
    if (message.valueBoolean !== undefined) {
      obj.valueBoolean = message.valueBoolean;
    }
    if (message.valueNumber !== undefined) {
      obj.valueNumber = message.valueNumber;
    }
    if (message.valueTextArray !== undefined) {
      obj.valueTextArray = TextArray.toJSON(message.valueTextArray);
    }
    if (message.valueIntArray !== undefined) {
      obj.valueIntArray = IntArray.toJSON(message.valueIntArray);
    }
    if (message.valueBooleanArray !== undefined) {
      obj.valueBooleanArray = BooleanArray.toJSON(message.valueBooleanArray);
    }
    if (message.valueNumberArray !== undefined) {
      obj.valueNumberArray = NumberArray.toJSON(message.valueNumberArray);
    }
    if (message.valueGeo !== undefined) {
      obj.valueGeo = GeoCoordinatesFilter.toJSON(message.valueGeo);
    }
    if (message.target !== undefined) {
      obj.target = FilterTarget.toJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<Filters>): Filters {
    return Filters.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Filters>): Filters {
    const message = createBaseFilters();
    message.operator = object.operator ?? 0;
    message.on = object.on?.map((e) => e) || [];
    message.filters = object.filters?.map((e) => Filters.fromPartial(e)) || [];
    message.valueText = object.valueText ?? undefined;
    message.valueInt = object.valueInt ?? undefined;
    message.valueBoolean = object.valueBoolean ?? undefined;
    message.valueNumber = object.valueNumber ?? undefined;
    message.valueTextArray = (object.valueTextArray !== undefined && object.valueTextArray !== null)
      ? TextArray.fromPartial(object.valueTextArray)
      : undefined;
    message.valueIntArray = (object.valueIntArray !== undefined && object.valueIntArray !== null)
      ? IntArray.fromPartial(object.valueIntArray)
      : undefined;
    message.valueBooleanArray = (object.valueBooleanArray !== undefined && object.valueBooleanArray !== null)
      ? BooleanArray.fromPartial(object.valueBooleanArray)
      : undefined;
    message.valueNumberArray = (object.valueNumberArray !== undefined && object.valueNumberArray !== null)
      ? NumberArray.fromPartial(object.valueNumberArray)
      : undefined;
    message.valueGeo = (object.valueGeo !== undefined && object.valueGeo !== null)
      ? GeoCoordinatesFilter.fromPartial(object.valueGeo)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? FilterTarget.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBaseFilterReferenceSingleTarget(): FilterReferenceSingleTarget {
  return { on: "", target: undefined };
}

export const FilterReferenceSingleTarget = {
  encode(message: FilterReferenceSingleTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.on !== "") {
      writer.uint32(10).string(message.on);
    }
    if (message.target !== undefined) {
      FilterTarget.encode(message.target, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilterReferenceSingleTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterReferenceSingleTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.on = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = FilterTarget.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterReferenceSingleTarget {
    return {
      on: isSet(object.on) ? globalThis.String(object.on) : "",
      target: isSet(object.target) ? FilterTarget.fromJSON(object.target) : undefined,
    };
  },

  toJSON(message: FilterReferenceSingleTarget): unknown {
    const obj: any = {};
    if (message.on !== "") {
      obj.on = message.on;
    }
    if (message.target !== undefined) {
      obj.target = FilterTarget.toJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<FilterReferenceSingleTarget>): FilterReferenceSingleTarget {
    return FilterReferenceSingleTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterReferenceSingleTarget>): FilterReferenceSingleTarget {
    const message = createBaseFilterReferenceSingleTarget();
    message.on = object.on ?? "";
    message.target = (object.target !== undefined && object.target !== null)
      ? FilterTarget.fromPartial(object.target)
      : undefined;
    return message;
  },
};

function createBaseFilterReferenceMultiTarget(): FilterReferenceMultiTarget {
  return { on: "", target: undefined, targetCollection: "" };
}

export const FilterReferenceMultiTarget = {
  encode(message: FilterReferenceMultiTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.on !== "") {
      writer.uint32(10).string(message.on);
    }
    if (message.target !== undefined) {
      FilterTarget.encode(message.target, writer.uint32(18).fork()).ldelim();
    }
    if (message.targetCollection !== "") {
      writer.uint32(26).string(message.targetCollection);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilterReferenceMultiTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterReferenceMultiTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.on = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.target = FilterTarget.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetCollection = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterReferenceMultiTarget {
    return {
      on: isSet(object.on) ? globalThis.String(object.on) : "",
      target: isSet(object.target) ? FilterTarget.fromJSON(object.target) : undefined,
      targetCollection: isSet(object.targetCollection) ? globalThis.String(object.targetCollection) : "",
    };
  },

  toJSON(message: FilterReferenceMultiTarget): unknown {
    const obj: any = {};
    if (message.on !== "") {
      obj.on = message.on;
    }
    if (message.target !== undefined) {
      obj.target = FilterTarget.toJSON(message.target);
    }
    if (message.targetCollection !== "") {
      obj.targetCollection = message.targetCollection;
    }
    return obj;
  },

  create(base?: DeepPartial<FilterReferenceMultiTarget>): FilterReferenceMultiTarget {
    return FilterReferenceMultiTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterReferenceMultiTarget>): FilterReferenceMultiTarget {
    const message = createBaseFilterReferenceMultiTarget();
    message.on = object.on ?? "";
    message.target = (object.target !== undefined && object.target !== null)
      ? FilterTarget.fromPartial(object.target)
      : undefined;
    message.targetCollection = object.targetCollection ?? "";
    return message;
  },
};

function createBaseFilterReferenceCount(): FilterReferenceCount {
  return { on: "" };
}

export const FilterReferenceCount = {
  encode(message: FilterReferenceCount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.on !== "") {
      writer.uint32(10).string(message.on);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilterReferenceCount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterReferenceCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.on = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterReferenceCount {
    return { on: isSet(object.on) ? globalThis.String(object.on) : "" };
  },

  toJSON(message: FilterReferenceCount): unknown {
    const obj: any = {};
    if (message.on !== "") {
      obj.on = message.on;
    }
    return obj;
  },

  create(base?: DeepPartial<FilterReferenceCount>): FilterReferenceCount {
    return FilterReferenceCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterReferenceCount>): FilterReferenceCount {
    const message = createBaseFilterReferenceCount();
    message.on = object.on ?? "";
    return message;
  },
};

function createBaseFilterTarget(): FilterTarget {
  return { property: undefined, singleTarget: undefined, multiTarget: undefined, count: undefined };
}

export const FilterTarget = {
  encode(message: FilterTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.property !== undefined) {
      writer.uint32(10).string(message.property);
    }
    if (message.singleTarget !== undefined) {
      FilterReferenceSingleTarget.encode(message.singleTarget, writer.uint32(18).fork()).ldelim();
    }
    if (message.multiTarget !== undefined) {
      FilterReferenceMultiTarget.encode(message.multiTarget, writer.uint32(26).fork()).ldelim();
    }
    if (message.count !== undefined) {
      FilterReferenceCount.encode(message.count, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FilterTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.singleTarget = FilterReferenceSingleTarget.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.multiTarget = FilterReferenceMultiTarget.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.count = FilterReferenceCount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FilterTarget {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : undefined,
      singleTarget: isSet(object.singleTarget) ? FilterReferenceSingleTarget.fromJSON(object.singleTarget) : undefined,
      multiTarget: isSet(object.multiTarget) ? FilterReferenceMultiTarget.fromJSON(object.multiTarget) : undefined,
      count: isSet(object.count) ? FilterReferenceCount.fromJSON(object.count) : undefined,
    };
  },

  toJSON(message: FilterTarget): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = message.property;
    }
    if (message.singleTarget !== undefined) {
      obj.singleTarget = FilterReferenceSingleTarget.toJSON(message.singleTarget);
    }
    if (message.multiTarget !== undefined) {
      obj.multiTarget = FilterReferenceMultiTarget.toJSON(message.multiTarget);
    }
    if (message.count !== undefined) {
      obj.count = FilterReferenceCount.toJSON(message.count);
    }
    return obj;
  },

  create(base?: DeepPartial<FilterTarget>): FilterTarget {
    return FilterTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterTarget>): FilterTarget {
    const message = createBaseFilterTarget();
    message.property = object.property ?? undefined;
    message.singleTarget = (object.singleTarget !== undefined && object.singleTarget !== null)
      ? FilterReferenceSingleTarget.fromPartial(object.singleTarget)
      : undefined;
    message.multiTarget = (object.multiTarget !== undefined && object.multiTarget !== null)
      ? FilterReferenceMultiTarget.fromPartial(object.multiTarget)
      : undefined;
    message.count = (object.count !== undefined && object.count !== null)
      ? FilterReferenceCount.fromPartial(object.count)
      : undefined;
    return message;
  },
};

function createBaseGeoCoordinatesFilter(): GeoCoordinatesFilter {
  return { latitude: 0, longitude: 0, distance: 0 };
}

export const GeoCoordinatesFilter = {
  encode(message: GeoCoordinatesFilter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.latitude !== 0) {
      writer.uint32(13).float(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(21).float(message.longitude);
    }
    if (message.distance !== 0) {
      writer.uint32(29).float(message.distance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GeoCoordinatesFilter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoCoordinatesFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.latitude = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.longitude = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.distance = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoCoordinatesFilter {
    return {
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
    };
  },

  toJSON(message: GeoCoordinatesFilter): unknown {
    const obj: any = {};
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    return obj;
  },

  create(base?: DeepPartial<GeoCoordinatesFilter>): GeoCoordinatesFilter {
    return GeoCoordinatesFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoCoordinatesFilter>): GeoCoordinatesFilter {
    const message = createBaseGeoCoordinatesFilter();
    message.latitude = object.latitude ?? 0;
    message.longitude = object.longitude ?? 0;
    message.distance = object.distance ?? 0;
    return message;
  },
};

function createBaseVectors(): Vectors {
  return { name: "", index: 0, vectorBytes: new Uint8Array(0) };
}

export const Vectors = {
  encode(message: Vectors, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.index !== 0) {
      writer.uint32(16).uint64(message.index);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(26).bytes(message.vectorBytes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Vectors {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVectors();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.index = longToNumber(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vectors {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: Vectors): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<Vectors>): Vectors {
    return Vectors.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Vectors>): Vectors {
    const message = createBaseVectors();
    message.name = object.name ?? "";
    message.index = object.index ?? 0;
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}



---
File: /src/proto/v1/batch_delete.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/batch_delete.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { ConsistencyLevel, consistencyLevelFromJSON, consistencyLevelToJSON, Filters } from "./base.js";

export const protobufPackage = "weaviate.v1";

export interface BatchDeleteRequest {
  collection: string;
  filters: Filters | undefined;
  verbose: boolean;
  dryRun: boolean;
  consistencyLevel?: ConsistencyLevel | undefined;
  tenant?: string | undefined;
}

export interface BatchDeleteReply {
  took: number;
  failed: number;
  matches: number;
  successful: number;
  objects: BatchDeleteObject[];
}

export interface BatchDeleteObject {
  uuid: Uint8Array;
  successful: boolean;
  /** empty string means no error */
  error?: string | undefined;
}

function createBaseBatchDeleteRequest(): BatchDeleteRequest {
  return {
    collection: "",
    filters: undefined,
    verbose: false,
    dryRun: false,
    consistencyLevel: undefined,
    tenant: undefined,
  };
}

export const BatchDeleteRequest = {
  encode(message: BatchDeleteRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.filters !== undefined) {
      Filters.encode(message.filters, writer.uint32(18).fork()).ldelim();
    }
    if (message.verbose !== false) {
      writer.uint32(24).bool(message.verbose);
    }
    if (message.dryRun !== false) {
      writer.uint32(32).bool(message.dryRun);
    }
    if (message.consistencyLevel !== undefined) {
      writer.uint32(40).int32(message.consistencyLevel);
    }
    if (message.tenant !== undefined) {
      writer.uint32(50).string(message.tenant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchDeleteRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.filters = Filters.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.verbose = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.consistencyLevel = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.tenant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      filters: isSet(object.filters) ? Filters.fromJSON(object.filters) : undefined,
      verbose: isSet(object.verbose) ? globalThis.Boolean(object.verbose) : false,
      dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : false,
      consistencyLevel: isSet(object.consistencyLevel) ? consistencyLevelFromJSON(object.consistencyLevel) : undefined,
      tenant: isSet(object.tenant) ? globalThis.String(object.tenant) : undefined,
    };
  },

  toJSON(message: BatchDeleteRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.filters !== undefined) {
      obj.filters = Filters.toJSON(message.filters);
    }
    if (message.verbose !== false) {
      obj.verbose = message.verbose;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    if (message.consistencyLevel !== undefined) {
      obj.consistencyLevel = consistencyLevelToJSON(message.consistencyLevel);
    }
    if (message.tenant !== undefined) {
      obj.tenant = message.tenant;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteRequest>): BatchDeleteRequest {
    return BatchDeleteRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteRequest>): BatchDeleteRequest {
    const message = createBaseBatchDeleteRequest();
    message.collection = object.collection ?? "";
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? Filters.fromPartial(object.filters)
      : undefined;
    message.verbose = object.verbose ?? false;
    message.dryRun = object.dryRun ?? false;
    message.consistencyLevel = object.consistencyLevel ?? undefined;
    message.tenant = object.tenant ?? undefined;
    return message;
  },
};

function createBaseBatchDeleteReply(): BatchDeleteReply {
  return { took: 0, failed: 0, matches: 0, successful: 0, objects: [] };
}

export const BatchDeleteReply = {
  encode(message: BatchDeleteReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.took !== 0) {
      writer.uint32(13).float(message.took);
    }
    if (message.failed !== 0) {
      writer.uint32(16).int64(message.failed);
    }
    if (message.matches !== 0) {
      writer.uint32(24).int64(message.matches);
    }
    if (message.successful !== 0) {
      writer.uint32(32).int64(message.successful);
    }
    for (const v of message.objects) {
      BatchDeleteObject.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchDeleteReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.took = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.failed = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.matches = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.successful = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.objects.push(BatchDeleteObject.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteReply {
    return {
      took: isSet(object.took) ? globalThis.Number(object.took) : 0,
      failed: isSet(object.failed) ? globalThis.Number(object.failed) : 0,
      matches: isSet(object.matches) ? globalThis.Number(object.matches) : 0,
      successful: isSet(object.successful) ? globalThis.Number(object.successful) : 0,
      objects: globalThis.Array.isArray(object?.objects)
        ? object.objects.map((e: any) => BatchDeleteObject.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchDeleteReply): unknown {
    const obj: any = {};
    if (message.took !== 0) {
      obj.took = message.took;
    }
    if (message.failed !== 0) {
      obj.failed = Math.round(message.failed);
    }
    if (message.matches !== 0) {
      obj.matches = Math.round(message.matches);
    }
    if (message.successful !== 0) {
      obj.successful = Math.round(message.successful);
    }
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => BatchDeleteObject.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteReply>): BatchDeleteReply {
    return BatchDeleteReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteReply>): BatchDeleteReply {
    const message = createBaseBatchDeleteReply();
    message.took = object.took ?? 0;
    message.failed = object.failed ?? 0;
    message.matches = object.matches ?? 0;
    message.successful = object.successful ?? 0;
    message.objects = object.objects?.map((e) => BatchDeleteObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchDeleteObject(): BatchDeleteObject {
  return { uuid: new Uint8Array(0), successful: false, error: undefined };
}

export const BatchDeleteObject = {
  encode(message: BatchDeleteObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid.length !== 0) {
      writer.uint32(10).bytes(message.uuid);
    }
    if (message.successful !== false) {
      writer.uint32(16).bool(message.successful);
    }
    if (message.error !== undefined) {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchDeleteObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchDeleteObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.bytes();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.successful = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchDeleteObject {
    return {
      uuid: isSet(object.uuid) ? bytesFromBase64(object.uuid) : new Uint8Array(0),
      successful: isSet(object.successful) ? globalThis.Boolean(object.successful) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: BatchDeleteObject): unknown {
    const obj: any = {};
    if (message.uuid.length !== 0) {
      obj.uuid = base64FromBytes(message.uuid);
    }
    if (message.successful !== false) {
      obj.successful = message.successful;
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchDeleteObject>): BatchDeleteObject {
    return BatchDeleteObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchDeleteObject>): BatchDeleteObject {
    const message = createBaseBatchDeleteObject();
    message.uuid = object.uuid ?? new Uint8Array(0);
    message.successful = object.successful ?? false;
    message.error = object.error ?? undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}



---
File: /src/proto/v1/batch.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/batch.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Struct } from "../google/protobuf/struct.js";
import {
  BooleanArrayProperties,
  ConsistencyLevel,
  consistencyLevelFromJSON,
  consistencyLevelToJSON,
  IntArrayProperties,
  NumberArrayProperties,
  ObjectArrayProperties,
  ObjectProperties,
  TextArrayProperties,
  Vectors,
} from "./base.js";

export const protobufPackage = "weaviate.v1";

export interface BatchObjectsRequest {
  objects: BatchObject[];
  consistencyLevel?: ConsistencyLevel | undefined;
}

export interface BatchObject {
  uuid: string;
  /**
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   *
   * @deprecated
   */
  vector: number[];
  properties: BatchObject_Properties | undefined;
  collection: string;
  tenant: string;
  vectorBytes: Uint8Array;
  /** protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED */
  vectors: Vectors[];
}

export interface BatchObject_Properties {
  nonRefProperties: { [key: string]: any } | undefined;
  singleTargetRefProps: BatchObject_SingleTargetRefProps[];
  multiTargetRefProps: BatchObject_MultiTargetRefProps[];
  numberArrayProperties: NumberArrayProperties[];
  intArrayProperties: IntArrayProperties[];
  textArrayProperties: TextArrayProperties[];
  booleanArrayProperties: BooleanArrayProperties[];
  objectProperties: ObjectProperties[];
  objectArrayProperties: ObjectArrayProperties[];
  /**
   * empty lists do not have a type in many languages and clients do not know which datatype the property has.
   * Weaviate can get the datatype from its schema
   */
  emptyListProps: string[];
}

export interface BatchObject_SingleTargetRefProps {
  uuids: string[];
  propName: string;
}

export interface BatchObject_MultiTargetRefProps {
  uuids: string[];
  propName: string;
  targetCollection: string;
}

export interface BatchObjectsReply {
  took: number;
  errors: BatchObjectsReply_BatchError[];
}

export interface BatchObjectsReply_BatchError {
  index: number;
  error: string;
}

function createBaseBatchObjectsRequest(): BatchObjectsRequest {
  return { objects: [], consistencyLevel: undefined };
}

export const BatchObjectsRequest = {
  encode(message: BatchObjectsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.objects) {
      BatchObject.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.consistencyLevel !== undefined) {
      writer.uint32(16).int32(message.consistencyLevel);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchObjectsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchObjectsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.objects.push(BatchObject.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.consistencyLevel = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchObjectsRequest {
    return {
      objects: globalThis.Array.isArray(object?.objects) ? object.objects.map((e: any) => BatchObject.fromJSON(e)) : [],
      consistencyLevel: isSet(object.consistencyLevel) ? consistencyLevelFromJSON(object.consistencyLevel) : undefined,
    };
  },

  toJSON(message: BatchObjectsRequest): unknown {
    const obj: any = {};
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => BatchObject.toJSON(e));
    }
    if (message.consistencyLevel !== undefined) {
      obj.consistencyLevel = consistencyLevelToJSON(message.consistencyLevel);
    }
    return obj;
  },

  create(base?: DeepPartial<BatchObjectsRequest>): BatchObjectsRequest {
    return BatchObjectsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchObjectsRequest>): BatchObjectsRequest {
    const message = createBaseBatchObjectsRequest();
    message.objects = object.objects?.map((e) => BatchObject.fromPartial(e)) || [];
    message.consistencyLevel = object.consistencyLevel ?? undefined;
    return message;
  },
};

function createBaseBatchObject(): BatchObject {
  return {
    uuid: "",
    vector: [],
    properties: undefined,
    collection: "",
    tenant: "",
    vectorBytes: new Uint8Array(0),
    vectors: [],
  };
}

export const BatchObject = {
  encode(message: BatchObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.properties !== undefined) {
      BatchObject_Properties.encode(message.properties, writer.uint32(26).fork()).ldelim();
    }
    if (message.collection !== "") {
      writer.uint32(34).string(message.collection);
    }
    if (message.tenant !== "") {
      writer.uint32(42).string(message.tenant);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(50).bytes(message.vectorBytes);
    }
    for (const v of message.vectors) {
      Vectors.encode(v!, writer.uint32(186).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        case 2:
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.properties = BatchObject_Properties.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.collection = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.tenant = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.vectors.push(Vectors.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchObject {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      properties: isSet(object.properties) ? BatchObject_Properties.fromJSON(object.properties) : undefined,
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      tenant: isSet(object.tenant) ? globalThis.String(object.tenant) : "",
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
      vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e: any) => Vectors.fromJSON(e)) : [],
    };
  },

  toJSON(message: BatchObject): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.properties !== undefined) {
      obj.properties = BatchObject_Properties.toJSON(message.properties);
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.tenant !== "") {
      obj.tenant = message.tenant;
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    if (message.vectors?.length) {
      obj.vectors = message.vectors.map((e) => Vectors.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchObject>): BatchObject {
    return BatchObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchObject>): BatchObject {
    const message = createBaseBatchObject();
    message.uuid = object.uuid ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? BatchObject_Properties.fromPartial(object.properties)
      : undefined;
    message.collection = object.collection ?? "";
    message.tenant = object.tenant ?? "";
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    message.vectors = object.vectors?.map((e) => Vectors.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchObject_Properties(): BatchObject_Properties {
  return {
    nonRefProperties: undefined,
    singleTargetRefProps: [],
    multiTargetRefProps: [],
    numberArrayProperties: [],
    intArrayProperties: [],
    textArrayProperties: [],
    booleanArrayProperties: [],
    objectProperties: [],
    objectArrayProperties: [],
    emptyListProps: [],
  };
}

export const BatchObject_Properties = {
  encode(message: BatchObject_Properties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nonRefProperties !== undefined) {
      Struct.encode(Struct.wrap(message.nonRefProperties), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.singleTargetRefProps) {
      BatchObject_SingleTargetRefProps.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.multiTargetRefProps) {
      BatchObject_MultiTargetRefProps.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.numberArrayProperties) {
      NumberArrayProperties.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.intArrayProperties) {
      IntArrayProperties.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.textArrayProperties) {
      TextArrayProperties.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.booleanArrayProperties) {
      BooleanArrayProperties.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.objectProperties) {
      ObjectProperties.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.objectArrayProperties) {
      ObjectArrayProperties.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.emptyListProps) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchObject_Properties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchObject_Properties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nonRefProperties = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.singleTargetRefProps.push(BatchObject_SingleTargetRefProps.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.multiTargetRefProps.push(BatchObject_MultiTargetRefProps.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.numberArrayProperties.push(NumberArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.intArrayProperties.push(IntArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.textArrayProperties.push(TextArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.booleanArrayProperties.push(BooleanArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.objectProperties.push(ObjectProperties.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.objectArrayProperties.push(ObjectArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.emptyListProps.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchObject_Properties {
    return {
      nonRefProperties: isObject(object.nonRefProperties) ? object.nonRefProperties : undefined,
      singleTargetRefProps: globalThis.Array.isArray(object?.singleTargetRefProps)
        ? object.singleTargetRefProps.map((e: any) => BatchObject_SingleTargetRefProps.fromJSON(e))
        : [],
      multiTargetRefProps: globalThis.Array.isArray(object?.multiTargetRefProps)
        ? object.multiTargetRefProps.map((e: any) => BatchObject_MultiTargetRefProps.fromJSON(e))
        : [],
      numberArrayProperties: globalThis.Array.isArray(object?.numberArrayProperties)
        ? object.numberArrayProperties.map((e: any) => NumberArrayProperties.fromJSON(e))
        : [],
      intArrayProperties: globalThis.Array.isArray(object?.intArrayProperties)
        ? object.intArrayProperties.map((e: any) => IntArrayProperties.fromJSON(e))
        : [],
      textArrayProperties: globalThis.Array.isArray(object?.textArrayProperties)
        ? object.textArrayProperties.map((e: any) => TextArrayProperties.fromJSON(e))
        : [],
      booleanArrayProperties: globalThis.Array.isArray(object?.booleanArrayProperties)
        ? object.booleanArrayProperties.map((e: any) => BooleanArrayProperties.fromJSON(e))
        : [],
      objectProperties: globalThis.Array.isArray(object?.objectProperties)
        ? object.objectProperties.map((e: any) => ObjectProperties.fromJSON(e))
        : [],
      objectArrayProperties: globalThis.Array.isArray(object?.objectArrayProperties)
        ? object.objectArrayProperties.map((e: any) => ObjectArrayProperties.fromJSON(e))
        : [],
      emptyListProps: globalThis.Array.isArray(object?.emptyListProps)
        ? object.emptyListProps.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BatchObject_Properties): unknown {
    const obj: any = {};
    if (message.nonRefProperties !== undefined) {
      obj.nonRefProperties = message.nonRefProperties;
    }
    if (message.singleTargetRefProps?.length) {
      obj.singleTargetRefProps = message.singleTargetRefProps.map((e) => BatchObject_SingleTargetRefProps.toJSON(e));
    }
    if (message.multiTargetRefProps?.length) {
      obj.multiTargetRefProps = message.multiTargetRefProps.map((e) => BatchObject_MultiTargetRefProps.toJSON(e));
    }
    if (message.numberArrayProperties?.length) {
      obj.numberArrayProperties = message.numberArrayProperties.map((e) => NumberArrayProperties.toJSON(e));
    }
    if (message.intArrayProperties?.length) {
      obj.intArrayProperties = message.intArrayProperties.map((e) => IntArrayProperties.toJSON(e));
    }
    if (message.textArrayProperties?.length) {
      obj.textArrayProperties = message.textArrayProperties.map((e) => TextArrayProperties.toJSON(e));
    }
    if (message.booleanArrayProperties?.length) {
      obj.booleanArrayProperties = message.booleanArrayProperties.map((e) => BooleanArrayProperties.toJSON(e));
    }
    if (message.objectProperties?.length) {
      obj.objectProperties = message.objectProperties.map((e) => ObjectProperties.toJSON(e));
    }
    if (message.objectArrayProperties?.length) {
      obj.objectArrayProperties = message.objectArrayProperties.map((e) => ObjectArrayProperties.toJSON(e));
    }
    if (message.emptyListProps?.length) {
      obj.emptyListProps = message.emptyListProps;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchObject_Properties>): BatchObject_Properties {
    return BatchObject_Properties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchObject_Properties>): BatchObject_Properties {
    const message = createBaseBatchObject_Properties();
    message.nonRefProperties = object.nonRefProperties ?? undefined;
    message.singleTargetRefProps =
      object.singleTargetRefProps?.map((e) => BatchObject_SingleTargetRefProps.fromPartial(e)) || [];
    message.multiTargetRefProps =
      object.multiTargetRefProps?.map((e) => BatchObject_MultiTargetRefProps.fromPartial(e)) || [];
    message.numberArrayProperties = object.numberArrayProperties?.map((e) => NumberArrayProperties.fromPartial(e)) ||
      [];
    message.intArrayProperties = object.intArrayProperties?.map((e) => IntArrayProperties.fromPartial(e)) || [];
    message.textArrayProperties = object.textArrayProperties?.map((e) => TextArrayProperties.fromPartial(e)) || [];
    message.booleanArrayProperties = object.booleanArrayProperties?.map((e) => BooleanArrayProperties.fromPartial(e)) ||
      [];
    message.objectProperties = object.objectProperties?.map((e) => ObjectProperties.fromPartial(e)) || [];
    message.objectArrayProperties = object.objectArrayProperties?.map((e) => ObjectArrayProperties.fromPartial(e)) ||
      [];
    message.emptyListProps = object.emptyListProps?.map((e) => e) || [];
    return message;
  },
};

function createBaseBatchObject_SingleTargetRefProps(): BatchObject_SingleTargetRefProps {
  return { uuids: [], propName: "" };
}

export const BatchObject_SingleTargetRefProps = {
  encode(message: BatchObject_SingleTargetRefProps, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.uuids) {
      writer.uint32(10).string(v!);
    }
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchObject_SingleTargetRefProps {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchObject_SingleTargetRefProps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchObject_SingleTargetRefProps {
    return {
      uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e: any) => globalThis.String(e)) : [],
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
    };
  },

  toJSON(message: BatchObject_SingleTargetRefProps): unknown {
    const obj: any = {};
    if (message.uuids?.length) {
      obj.uuids = message.uuids;
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchObject_SingleTargetRefProps>): BatchObject_SingleTargetRefProps {
    return BatchObject_SingleTargetRefProps.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchObject_SingleTargetRefProps>): BatchObject_SingleTargetRefProps {
    const message = createBaseBatchObject_SingleTargetRefProps();
    message.uuids = object.uuids?.map((e) => e) || [];
    message.propName = object.propName ?? "";
    return message;
  },
};

function createBaseBatchObject_MultiTargetRefProps(): BatchObject_MultiTargetRefProps {
  return { uuids: [], propName: "", targetCollection: "" };
}

export const BatchObject_MultiTargetRefProps = {
  encode(message: BatchObject_MultiTargetRefProps, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.uuids) {
      writer.uint32(10).string(v!);
    }
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    if (message.targetCollection !== "") {
      writer.uint32(26).string(message.targetCollection);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchObject_MultiTargetRefProps {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchObject_MultiTargetRefProps();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.uuids.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetCollection = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchObject_MultiTargetRefProps {
    return {
      uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e: any) => globalThis.String(e)) : [],
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
      targetCollection: isSet(object.targetCollection) ? globalThis.String(object.targetCollection) : "",
    };
  },

  toJSON(message: BatchObject_MultiTargetRefProps): unknown {
    const obj: any = {};
    if (message.uuids?.length) {
      obj.uuids = message.uuids;
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    if (message.targetCollection !== "") {
      obj.targetCollection = message.targetCollection;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchObject_MultiTargetRefProps>): BatchObject_MultiTargetRefProps {
    return BatchObject_MultiTargetRefProps.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchObject_MultiTargetRefProps>): BatchObject_MultiTargetRefProps {
    const message = createBaseBatchObject_MultiTargetRefProps();
    message.uuids = object.uuids?.map((e) => e) || [];
    message.propName = object.propName ?? "";
    message.targetCollection = object.targetCollection ?? "";
    return message;
  },
};

function createBaseBatchObjectsReply(): BatchObjectsReply {
  return { took: 0, errors: [] };
}

export const BatchObjectsReply = {
  encode(message: BatchObjectsReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.took !== 0) {
      writer.uint32(13).float(message.took);
    }
    for (const v of message.errors) {
      BatchObjectsReply_BatchError.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchObjectsReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchObjectsReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.took = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errors.push(BatchObjectsReply_BatchError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchObjectsReply {
    return {
      took: isSet(object.took) ? globalThis.Number(object.took) : 0,
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => BatchObjectsReply_BatchError.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BatchObjectsReply): unknown {
    const obj: any = {};
    if (message.took !== 0) {
      obj.took = message.took;
    }
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => BatchObjectsReply_BatchError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<BatchObjectsReply>): BatchObjectsReply {
    return BatchObjectsReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchObjectsReply>): BatchObjectsReply {
    const message = createBaseBatchObjectsReply();
    message.took = object.took ?? 0;
    message.errors = object.errors?.map((e) => BatchObjectsReply_BatchError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBatchObjectsReply_BatchError(): BatchObjectsReply_BatchError {
  return { index: 0, error: "" };
}

export const BatchObjectsReply_BatchError = {
  encode(message: BatchObjectsReply_BatchError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.index !== 0) {
      writer.uint32(8).int32(message.index);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BatchObjectsReply_BatchError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBatchObjectsReply_BatchError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.index = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BatchObjectsReply_BatchError {
    return {
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: BatchObjectsReply_BatchError): unknown {
    const obj: any = {};
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create(base?: DeepPartial<BatchObjectsReply_BatchError>): BatchObjectsReply_BatchError {
    return BatchObjectsReply_BatchError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BatchObjectsReply_BatchError>): BatchObjectsReply_BatchError {
    const message = createBaseBatchObjectsReply_BatchError();
    message.index = object.index ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}



---
File: /src/proto/v1/generative.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/generative.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { TextArray } from "./base.js";

export const protobufPackage = "weaviate.v1";

export interface GenerativeSearch {
  /** @deprecated */
  singleResponsePrompt: string;
  /** @deprecated */
  groupedResponseTask: string;
  /** @deprecated */
  groupedProperties: string[];
  single: GenerativeSearch_Single | undefined;
  grouped: GenerativeSearch_Grouped | undefined;
}

export interface GenerativeSearch_Single {
  prompt: string;
  debug: boolean;
  /** only allow one at the beginning, but multiple in the future */
  queries: GenerativeProvider[];
}

export interface GenerativeSearch_Grouped {
  task: string;
  properties?:
    | TextArray
    | undefined;
  /** only allow one at the beginning, but multiple in the future */
  queries: GenerativeProvider[];
}

export interface GenerativeProvider {
  returnMetadata: boolean;
  anthropic?: GenerativeAnthropic | undefined;
  anyscale?: GenerativeAnyscale | undefined;
  aws?: GenerativeAWS | undefined;
  cohere?: GenerativeCohere | undefined;
  dummy?: GenerativeDummy | undefined;
  mistral?: GenerativeMistral | undefined;
  ollama?: GenerativeOllama | undefined;
  openai?: GenerativeOpenAI | undefined;
  google?: GenerativeGoogle | undefined;
  databricks?: GenerativeDatabricks | undefined;
  friendliai?: GenerativeFriendliAI | undefined;
}

export interface GenerativeAnthropic {
  baseUrl?: string | undefined;
  maxTokens?: number | undefined;
  model?: string | undefined;
  temperature?: number | undefined;
  topK?: number | undefined;
  topP?: number | undefined;
  stopSequences?: TextArray | undefined;
}

export interface GenerativeAnyscale {
  baseUrl?: string | undefined;
  model?: string | undefined;
  temperature?: number | undefined;
}

export interface GenerativeAWS {
  model?: string | undefined;
  temperature?: number | undefined;
  service?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  targetModel?: string | undefined;
  targetVariant?: string | undefined;
}

export interface GenerativeCohere {
  baseUrl?: string | undefined;
  frequencyPenalty?: number | undefined;
  maxTokens?: number | undefined;
  model?: string | undefined;
  k?: number | undefined;
  p?: number | undefined;
  presencePenalty?: number | undefined;
  stopSequences?: TextArray | undefined;
  temperature?: number | undefined;
}

export interface GenerativeDummy {
}

export interface GenerativeMistral {
  baseUrl?: string | undefined;
  maxTokens?: number | undefined;
  model?: string | undefined;
  temperature?: number | undefined;
  topP?: number | undefined;
}

export interface GenerativeOllama {
  apiEndpoint?: string | undefined;
  model?: string | undefined;
  temperature?: number | undefined;
}

export interface GenerativeOpenAI {
  frequencyPenalty?: number | undefined;
  maxTokens?: number | undefined;
  model: string;
  n?: number | undefined;
  presencePenalty?: number | undefined;
  stop?: TextArray | undefined;
  temperature?: number | undefined;
  topP?: number | undefined;
  baseUrl?: string | undefined;
  apiVersion?: string | undefined;
  resourceName?: string | undefined;
  deploymentId?: string | undefined;
  isAzure?: boolean | undefined;
}

export interface GenerativeGoogle {
  frequencyPenalty?: number | undefined;
  maxTokens?: number | undefined;
  model?: string | undefined;
  presencePenalty?: number | undefined;
  temperature?: number | undefined;
  topK?: number | undefined;
  topP?: number | undefined;
  stopSequences?: TextArray | undefined;
  apiEndpoint?: string | undefined;
  projectId?: string | undefined;
  endpointId?: string | undefined;
  region?: string | undefined;
}

export interface GenerativeDatabricks {
  endpoint?: string | undefined;
  model?: string | undefined;
  frequencyPenalty?: number | undefined;
  logProbs?: boolean | undefined;
  topLogProbs?: number | undefined;
  maxTokens?: number | undefined;
  n?: number | undefined;
  presencePenalty?: number | undefined;
  stop?: TextArray | undefined;
  temperature?: number | undefined;
  topP?: number | undefined;
}

export interface GenerativeFriendliAI {
  baseUrl?: string | undefined;
  model?: string | undefined;
  maxTokens?: number | undefined;
  temperature?: number | undefined;
  n?: number | undefined;
  topP?: number | undefined;
}

export interface GenerativeAnthropicMetadata {
  usage: GenerativeAnthropicMetadata_Usage | undefined;
}

export interface GenerativeAnthropicMetadata_Usage {
  inputTokens: number;
  outputTokens: number;
}

export interface GenerativeAnyscaleMetadata {
}

export interface GenerativeAWSMetadata {
}

export interface GenerativeCohereMetadata {
  apiVersion?: GenerativeCohereMetadata_ApiVersion | undefined;
  billedUnits?: GenerativeCohereMetadata_BilledUnits | undefined;
  tokens?: GenerativeCohereMetadata_Tokens | undefined;
  warnings?: TextArray | undefined;
}

export interface GenerativeCohereMetadata_ApiVersion {
  version?: string | undefined;
  isDeprecated?: boolean | undefined;
  isExperimental?: boolean | undefined;
}

export interface GenerativeCohereMetadata_BilledUnits {
  inputTokens?: number | undefined;
  outputTokens?: number | undefined;
  searchUnits?: number | undefined;
  classifications?: number | undefined;
}

export interface GenerativeCohereMetadata_Tokens {
  inputTokens?: number | undefined;
  outputTokens?: number | undefined;
}

export interface GenerativeDummyMetadata {
}

export interface GenerativeMistralMetadata {
  usage?: GenerativeMistralMetadata_Usage | undefined;
}

export interface GenerativeMistralMetadata_Usage {
  promptTokens?: number | undefined;
  completionTokens?: number | undefined;
  totalTokens?: number | undefined;
}

export interface GenerativeOllamaMetadata {
}

export interface GenerativeOpenAIMetadata {
  usage?: GenerativeOpenAIMetadata_Usage | undefined;
}

export interface GenerativeOpenAIMetadata_Usage {
  promptTokens?: number | undefined;
  completionTokens?: number | undefined;
  totalTokens?: number | undefined;
}

export interface GenerativeGoogleMetadata {
  metadata?: GenerativeGoogleMetadata_Metadata | undefined;
  usageMetadata?: GenerativeGoogleMetadata_UsageMetadata | undefined;
}

export interface GenerativeGoogleMetadata_TokenCount {
  totalBillableCharacters?: number | undefined;
  totalTokens?: number | undefined;
}

export interface GenerativeGoogleMetadata_TokenMetadata {
  inputTokenCount?: GenerativeGoogleMetadata_TokenCount | undefined;
  outputTokenCount?: GenerativeGoogleMetadata_TokenCount | undefined;
}

export interface GenerativeGoogleMetadata_Metadata {
  tokenMetadata?: GenerativeGoogleMetadata_TokenMetadata | undefined;
}

export interface GenerativeGoogleMetadata_UsageMetadata {
  promptTokenCount?: number | undefined;
  candidatesTokenCount?: number | undefined;
  totalTokenCount?: number | undefined;
}

export interface GenerativeDatabricksMetadata {
  usage?: GenerativeDatabricksMetadata_Usage | undefined;
}

export interface GenerativeDatabricksMetadata_Usage {
  promptTokens?: number | undefined;
  completionTokens?: number | undefined;
  totalTokens?: number | undefined;
}

export interface GenerativeFriendliAIMetadata {
  usage?: GenerativeFriendliAIMetadata_Usage | undefined;
}

export interface GenerativeFriendliAIMetadata_Usage {
  promptTokens?: number | undefined;
  completionTokens?: number | undefined;
  totalTokens?: number | undefined;
}

export interface GenerativeMetadata {
  anthropic?: GenerativeAnthropicMetadata | undefined;
  anyscale?: GenerativeAnyscaleMetadata | undefined;
  aws?: GenerativeAWSMetadata | undefined;
  cohere?: GenerativeCohereMetadata | undefined;
  dummy?: GenerativeDummyMetadata | undefined;
  mistral?: GenerativeMistralMetadata | undefined;
  ollama?: GenerativeOllamaMetadata | undefined;
  openai?: GenerativeOpenAIMetadata | undefined;
  google?: GenerativeGoogleMetadata | undefined;
  databricks?: GenerativeDatabricksMetadata | undefined;
  friendliai?: GenerativeFriendliAIMetadata | undefined;
}

export interface GenerativeReply {
  result: string;
  debug?: GenerativeDebug | undefined;
  metadata?: GenerativeMetadata | undefined;
}

export interface GenerativeResult {
  values: GenerativeReply[];
}

export interface GenerativeDebug {
  fullPrompt?: string | undefined;
}

function createBaseGenerativeSearch(): GenerativeSearch {
  return {
    singleResponsePrompt: "",
    groupedResponseTask: "",
    groupedProperties: [],
    single: undefined,
    grouped: undefined,
  };
}

export const GenerativeSearch = {
  encode(message: GenerativeSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.singleResponsePrompt !== "") {
      writer.uint32(10).string(message.singleResponsePrompt);
    }
    if (message.groupedResponseTask !== "") {
      writer.uint32(18).string(message.groupedResponseTask);
    }
    for (const v of message.groupedProperties) {
      writer.uint32(26).string(v!);
    }
    if (message.single !== undefined) {
      GenerativeSearch_Single.encode(message.single, writer.uint32(34).fork()).ldelim();
    }
    if (message.grouped !== undefined) {
      GenerativeSearch_Grouped.encode(message.grouped, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.singleResponsePrompt = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.groupedResponseTask = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groupedProperties.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.single = GenerativeSearch_Single.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.grouped = GenerativeSearch_Grouped.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeSearch {
    return {
      singleResponsePrompt: isSet(object.singleResponsePrompt) ? globalThis.String(object.singleResponsePrompt) : "",
      groupedResponseTask: isSet(object.groupedResponseTask) ? globalThis.String(object.groupedResponseTask) : "",
      groupedProperties: globalThis.Array.isArray(object?.groupedProperties)
        ? object.groupedProperties.map((e: any) => globalThis.String(e))
        : [],
      single: isSet(object.single) ? GenerativeSearch_Single.fromJSON(object.single) : undefined,
      grouped: isSet(object.grouped) ? GenerativeSearch_Grouped.fromJSON(object.grouped) : undefined,
    };
  },

  toJSON(message: GenerativeSearch): unknown {
    const obj: any = {};
    if (message.singleResponsePrompt !== "") {
      obj.singleResponsePrompt = message.singleResponsePrompt;
    }
    if (message.groupedResponseTask !== "") {
      obj.groupedResponseTask = message.groupedResponseTask;
    }
    if (message.groupedProperties?.length) {
      obj.groupedProperties = message.groupedProperties;
    }
    if (message.single !== undefined) {
      obj.single = GenerativeSearch_Single.toJSON(message.single);
    }
    if (message.grouped !== undefined) {
      obj.grouped = GenerativeSearch_Grouped.toJSON(message.grouped);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeSearch>): GenerativeSearch {
    return GenerativeSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeSearch>): GenerativeSearch {
    const message = createBaseGenerativeSearch();
    message.singleResponsePrompt = object.singleResponsePrompt ?? "";
    message.groupedResponseTask = object.groupedResponseTask ?? "";
    message.groupedProperties = object.groupedProperties?.map((e) => e) || [];
    message.single = (object.single !== undefined && object.single !== null)
      ? GenerativeSearch_Single.fromPartial(object.single)
      : undefined;
    message.grouped = (object.grouped !== undefined && object.grouped !== null)
      ? GenerativeSearch_Grouped.fromPartial(object.grouped)
      : undefined;
    return message;
  },
};

function createBaseGenerativeSearch_Single(): GenerativeSearch_Single {
  return { prompt: "", debug: false, queries: [] };
}

export const GenerativeSearch_Single = {
  encode(message: GenerativeSearch_Single, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.prompt !== "") {
      writer.uint32(10).string(message.prompt);
    }
    if (message.debug !== false) {
      writer.uint32(16).bool(message.debug);
    }
    for (const v of message.queries) {
      GenerativeProvider.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeSearch_Single {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeSearch_Single();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.prompt = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.debug = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.queries.push(GenerativeProvider.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeSearch_Single {
    return {
      prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
      debug: isSet(object.debug) ? globalThis.Boolean(object.debug) : false,
      queries: globalThis.Array.isArray(object?.queries)
        ? object.queries.map((e: any) => GenerativeProvider.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerativeSearch_Single): unknown {
    const obj: any = {};
    if (message.prompt !== "") {
      obj.prompt = message.prompt;
    }
    if (message.debug !== false) {
      obj.debug = message.debug;
    }
    if (message.queries?.length) {
      obj.queries = message.queries.map((e) => GenerativeProvider.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeSearch_Single>): GenerativeSearch_Single {
    return GenerativeSearch_Single.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeSearch_Single>): GenerativeSearch_Single {
    const message = createBaseGenerativeSearch_Single();
    message.prompt = object.prompt ?? "";
    message.debug = object.debug ?? false;
    message.queries = object.queries?.map((e) => GenerativeProvider.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerativeSearch_Grouped(): GenerativeSearch_Grouped {
  return { task: "", properties: undefined, queries: [] };
}

export const GenerativeSearch_Grouped = {
  encode(message: GenerativeSearch_Grouped, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.task !== "") {
      writer.uint32(10).string(message.task);
    }
    if (message.properties !== undefined) {
      TextArray.encode(message.properties, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.queries) {
      GenerativeProvider.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeSearch_Grouped {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeSearch_Grouped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.task = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.properties = TextArray.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.queries.push(GenerativeProvider.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeSearch_Grouped {
    return {
      task: isSet(object.task) ? globalThis.String(object.task) : "",
      properties: isSet(object.properties) ? TextArray.fromJSON(object.properties) : undefined,
      queries: globalThis.Array.isArray(object?.queries)
        ? object.queries.map((e: any) => GenerativeProvider.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerativeSearch_Grouped): unknown {
    const obj: any = {};
    if (message.task !== "") {
      obj.task = message.task;
    }
    if (message.properties !== undefined) {
      obj.properties = TextArray.toJSON(message.properties);
    }
    if (message.queries?.length) {
      obj.queries = message.queries.map((e) => GenerativeProvider.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeSearch_Grouped>): GenerativeSearch_Grouped {
    return GenerativeSearch_Grouped.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeSearch_Grouped>): GenerativeSearch_Grouped {
    const message = createBaseGenerativeSearch_Grouped();
    message.task = object.task ?? "";
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? TextArray.fromPartial(object.properties)
      : undefined;
    message.queries = object.queries?.map((e) => GenerativeProvider.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerativeProvider(): GenerativeProvider {
  return {
    returnMetadata: false,
    anthropic: undefined,
    anyscale: undefined,
    aws: undefined,
    cohere: undefined,
    dummy: undefined,
    mistral: undefined,
    ollama: undefined,
    openai: undefined,
    google: undefined,
    databricks: undefined,
    friendliai: undefined,
  };
}

export const GenerativeProvider = {
  encode(message: GenerativeProvider, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.returnMetadata !== false) {
      writer.uint32(8).bool(message.returnMetadata);
    }
    if (message.anthropic !== undefined) {
      GenerativeAnthropic.encode(message.anthropic, writer.uint32(18).fork()).ldelim();
    }
    if (message.anyscale !== undefined) {
      GenerativeAnyscale.encode(message.anyscale, writer.uint32(26).fork()).ldelim();
    }
    if (message.aws !== undefined) {
      GenerativeAWS.encode(message.aws, writer.uint32(34).fork()).ldelim();
    }
    if (message.cohere !== undefined) {
      GenerativeCohere.encode(message.cohere, writer.uint32(42).fork()).ldelim();
    }
    if (message.dummy !== undefined) {
      GenerativeDummy.encode(message.dummy, writer.uint32(50).fork()).ldelim();
    }
    if (message.mistral !== undefined) {
      GenerativeMistral.encode(message.mistral, writer.uint32(58).fork()).ldelim();
    }
    if (message.ollama !== undefined) {
      GenerativeOllama.encode(message.ollama, writer.uint32(66).fork()).ldelim();
    }
    if (message.openai !== undefined) {
      GenerativeOpenAI.encode(message.openai, writer.uint32(74).fork()).ldelim();
    }
    if (message.google !== undefined) {
      GenerativeGoogle.encode(message.google, writer.uint32(82).fork()).ldelim();
    }
    if (message.databricks !== undefined) {
      GenerativeDatabricks.encode(message.databricks, writer.uint32(90).fork()).ldelim();
    }
    if (message.friendliai !== undefined) {
      GenerativeFriendliAI.encode(message.friendliai, writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeProvider {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.returnMetadata = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.anthropic = GenerativeAnthropic.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.anyscale = GenerativeAnyscale.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.aws = GenerativeAWS.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.cohere = GenerativeCohere.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dummy = GenerativeDummy.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mistral = GenerativeMistral.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ollama = GenerativeOllama.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.openai = GenerativeOpenAI.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.google = GenerativeGoogle.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.databricks = GenerativeDatabricks.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.friendliai = GenerativeFriendliAI.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeProvider {
    return {
      returnMetadata: isSet(object.returnMetadata) ? globalThis.Boolean(object.returnMetadata) : false,
      anthropic: isSet(object.anthropic) ? GenerativeAnthropic.fromJSON(object.anthropic) : undefined,
      anyscale: isSet(object.anyscale) ? GenerativeAnyscale.fromJSON(object.anyscale) : undefined,
      aws: isSet(object.aws) ? GenerativeAWS.fromJSON(object.aws) : undefined,
      cohere: isSet(object.cohere) ? GenerativeCohere.fromJSON(object.cohere) : undefined,
      dummy: isSet(object.dummy) ? GenerativeDummy.fromJSON(object.dummy) : undefined,
      mistral: isSet(object.mistral) ? GenerativeMistral.fromJSON(object.mistral) : undefined,
      ollama: isSet(object.ollama) ? GenerativeOllama.fromJSON(object.ollama) : undefined,
      openai: isSet(object.openai) ? GenerativeOpenAI.fromJSON(object.openai) : undefined,
      google: isSet(object.google) ? GenerativeGoogle.fromJSON(object.google) : undefined,
      databricks: isSet(object.databricks) ? GenerativeDatabricks.fromJSON(object.databricks) : undefined,
      friendliai: isSet(object.friendliai) ? GenerativeFriendliAI.fromJSON(object.friendliai) : undefined,
    };
  },

  toJSON(message: GenerativeProvider): unknown {
    const obj: any = {};
    if (message.returnMetadata !== false) {
      obj.returnMetadata = message.returnMetadata;
    }
    if (message.anthropic !== undefined) {
      obj.anthropic = GenerativeAnthropic.toJSON(message.anthropic);
    }
    if (message.anyscale !== undefined) {
      obj.anyscale = GenerativeAnyscale.toJSON(message.anyscale);
    }
    if (message.aws !== undefined) {
      obj.aws = GenerativeAWS.toJSON(message.aws);
    }
    if (message.cohere !== undefined) {
      obj.cohere = GenerativeCohere.toJSON(message.cohere);
    }
    if (message.dummy !== undefined) {
      obj.dummy = GenerativeDummy.toJSON(message.dummy);
    }
    if (message.mistral !== undefined) {
      obj.mistral = GenerativeMistral.toJSON(message.mistral);
    }
    if (message.ollama !== undefined) {
      obj.ollama = GenerativeOllama.toJSON(message.ollama);
    }
    if (message.openai !== undefined) {
      obj.openai = GenerativeOpenAI.toJSON(message.openai);
    }
    if (message.google !== undefined) {
      obj.google = GenerativeGoogle.toJSON(message.google);
    }
    if (message.databricks !== undefined) {
      obj.databricks = GenerativeDatabricks.toJSON(message.databricks);
    }
    if (message.friendliai !== undefined) {
      obj.friendliai = GenerativeFriendliAI.toJSON(message.friendliai);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeProvider>): GenerativeProvider {
    return GenerativeProvider.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeProvider>): GenerativeProvider {
    const message = createBaseGenerativeProvider();
    message.returnMetadata = object.returnMetadata ?? false;
    message.anthropic = (object.anthropic !== undefined && object.anthropic !== null)
      ? GenerativeAnthropic.fromPartial(object.anthropic)
      : undefined;
    message.anyscale = (object.anyscale !== undefined && object.anyscale !== null)
      ? GenerativeAnyscale.fromPartial(object.anyscale)
      : undefined;
    message.aws = (object.aws !== undefined && object.aws !== null) ? GenerativeAWS.fromPartial(object.aws) : undefined;
    message.cohere = (object.cohere !== undefined && object.cohere !== null)
      ? GenerativeCohere.fromPartial(object.cohere)
      : undefined;
    message.dummy = (object.dummy !== undefined && object.dummy !== null)
      ? GenerativeDummy.fromPartial(object.dummy)
      : undefined;
    message.mistral = (object.mistral !== undefined && object.mistral !== null)
      ? GenerativeMistral.fromPartial(object.mistral)
      : undefined;
    message.ollama = (object.ollama !== undefined && object.ollama !== null)
      ? GenerativeOllama.fromPartial(object.ollama)
      : undefined;
    message.openai = (object.openai !== undefined && object.openai !== null)
      ? GenerativeOpenAI.fromPartial(object.openai)
      : undefined;
    message.google = (object.google !== undefined && object.google !== null)
      ? GenerativeGoogle.fromPartial(object.google)
      : undefined;
    message.databricks = (object.databricks !== undefined && object.databricks !== null)
      ? GenerativeDatabricks.fromPartial(object.databricks)
      : undefined;
    message.friendliai = (object.friendliai !== undefined && object.friendliai !== null)
      ? GenerativeFriendliAI.fromPartial(object.friendliai)
      : undefined;
    return message;
  },
};

function createBaseGenerativeAnthropic(): GenerativeAnthropic {
  return {
    baseUrl: undefined,
    maxTokens: undefined,
    model: undefined,
    temperature: undefined,
    topK: undefined,
    topP: undefined,
    stopSequences: undefined,
  };
}

export const GenerativeAnthropic = {
  encode(message: GenerativeAnthropic, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseUrl !== undefined) {
      writer.uint32(10).string(message.baseUrl);
    }
    if (message.maxTokens !== undefined) {
      writer.uint32(16).int64(message.maxTokens);
    }
    if (message.model !== undefined) {
      writer.uint32(26).string(message.model);
    }
    if (message.temperature !== undefined) {
      writer.uint32(33).double(message.temperature);
    }
    if (message.topK !== undefined) {
      writer.uint32(40).int64(message.topK);
    }
    if (message.topP !== undefined) {
      writer.uint32(49).double(message.topP);
    }
    if (message.stopSequences !== undefined) {
      TextArray.encode(message.stopSequences, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeAnthropic {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeAnthropic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTokens = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.temperature = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.topK = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.topP = reader.double();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.stopSequences = TextArray.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeAnthropic {
    return {
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : undefined,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : undefined,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : undefined,
      stopSequences: isSet(object.stopSequences) ? TextArray.fromJSON(object.stopSequences) : undefined,
    };
  },

  toJSON(message: GenerativeAnthropic): unknown {
    const obj: any = {};
    if (message.baseUrl !== undefined) {
      obj.baseUrl = message.baseUrl;
    }
    if (message.maxTokens !== undefined) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.topK !== undefined) {
      obj.topK = Math.round(message.topK);
    }
    if (message.topP !== undefined) {
      obj.topP = message.topP;
    }
    if (message.stopSequences !== undefined) {
      obj.stopSequences = TextArray.toJSON(message.stopSequences);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeAnthropic>): GenerativeAnthropic {
    return GenerativeAnthropic.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeAnthropic>): GenerativeAnthropic {
    const message = createBaseGenerativeAnthropic();
    message.baseUrl = object.baseUrl ?? undefined;
    message.maxTokens = object.maxTokens ?? undefined;
    message.model = object.model ?? undefined;
    message.temperature = object.temperature ?? undefined;
    message.topK = object.topK ?? undefined;
    message.topP = object.topP ?? undefined;
    message.stopSequences = (object.stopSequences !== undefined && object.stopSequences !== null)
      ? TextArray.fromPartial(object.stopSequences)
      : undefined;
    return message;
  },
};

function createBaseGenerativeAnyscale(): GenerativeAnyscale {
  return { baseUrl: undefined, model: undefined, temperature: undefined };
}

export const GenerativeAnyscale = {
  encode(message: GenerativeAnyscale, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseUrl !== undefined) {
      writer.uint32(10).string(message.baseUrl);
    }
    if (message.model !== undefined) {
      writer.uint32(18).string(message.model);
    }
    if (message.temperature !== undefined) {
      writer.uint32(25).double(message.temperature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeAnyscale {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeAnyscale();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.temperature = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeAnyscale {
    return {
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
    };
  },

  toJSON(message: GenerativeAnyscale): unknown {
    const obj: any = {};
    if (message.baseUrl !== undefined) {
      obj.baseUrl = message.baseUrl;
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeAnyscale>): GenerativeAnyscale {
    return GenerativeAnyscale.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeAnyscale>): GenerativeAnyscale {
    const message = createBaseGenerativeAnyscale();
    message.baseUrl = object.baseUrl ?? undefined;
    message.model = object.model ?? undefined;
    message.temperature = object.temperature ?? undefined;
    return message;
  },
};

function createBaseGenerativeAWS(): GenerativeAWS {
  return {
    model: undefined,
    temperature: undefined,
    service: undefined,
    region: undefined,
    endpoint: undefined,
    targetModel: undefined,
    targetVariant: undefined,
  };
}

export const GenerativeAWS = {
  encode(message: GenerativeAWS, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.model !== undefined) {
      writer.uint32(26).string(message.model);
    }
    if (message.temperature !== undefined) {
      writer.uint32(65).double(message.temperature);
    }
    if (message.service !== undefined) {
      writer.uint32(74).string(message.service);
    }
    if (message.region !== undefined) {
      writer.uint32(82).string(message.region);
    }
    if (message.endpoint !== undefined) {
      writer.uint32(90).string(message.endpoint);
    }
    if (message.targetModel !== undefined) {
      writer.uint32(98).string(message.targetModel);
    }
    if (message.targetVariant !== undefined) {
      writer.uint32(106).string(message.targetVariant);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeAWS {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeAWS();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.temperature = reader.double();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.service = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.region = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.targetModel = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.targetVariant = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeAWS {
    return {
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      service: isSet(object.service) ? globalThis.String(object.service) : undefined,
      region: isSet(object.region) ? globalThis.String(object.region) : undefined,
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : undefined,
      targetModel: isSet(object.targetModel) ? globalThis.String(object.targetModel) : undefined,
      targetVariant: isSet(object.targetVariant) ? globalThis.String(object.targetVariant) : undefined,
    };
  },

  toJSON(message: GenerativeAWS): unknown {
    const obj: any = {};
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.service !== undefined) {
      obj.service = message.service;
    }
    if (message.region !== undefined) {
      obj.region = message.region;
    }
    if (message.endpoint !== undefined) {
      obj.endpoint = message.endpoint;
    }
    if (message.targetModel !== undefined) {
      obj.targetModel = message.targetModel;
    }
    if (message.targetVariant !== undefined) {
      obj.targetVariant = message.targetVariant;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeAWS>): GenerativeAWS {
    return GenerativeAWS.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeAWS>): GenerativeAWS {
    const message = createBaseGenerativeAWS();
    message.model = object.model ?? undefined;
    message.temperature = object.temperature ?? undefined;
    message.service = object.service ?? undefined;
    message.region = object.region ?? undefined;
    message.endpoint = object.endpoint ?? undefined;
    message.targetModel = object.targetModel ?? undefined;
    message.targetVariant = object.targetVariant ?? undefined;
    return message;
  },
};

function createBaseGenerativeCohere(): GenerativeCohere {
  return {
    baseUrl: undefined,
    frequencyPenalty: undefined,
    maxTokens: undefined,
    model: undefined,
    k: undefined,
    p: undefined,
    presencePenalty: undefined,
    stopSequences: undefined,
    temperature: undefined,
  };
}

export const GenerativeCohere = {
  encode(message: GenerativeCohere, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseUrl !== undefined) {
      writer.uint32(10).string(message.baseUrl);
    }
    if (message.frequencyPenalty !== undefined) {
      writer.uint32(17).double(message.frequencyPenalty);
    }
    if (message.maxTokens !== undefined) {
      writer.uint32(24).int64(message.maxTokens);
    }
    if (message.model !== undefined) {
      writer.uint32(34).string(message.model);
    }
    if (message.k !== undefined) {
      writer.uint32(40).int64(message.k);
    }
    if (message.p !== undefined) {
      writer.uint32(49).double(message.p);
    }
    if (message.presencePenalty !== undefined) {
      writer.uint32(57).double(message.presencePenalty);
    }
    if (message.stopSequences !== undefined) {
      TextArray.encode(message.stopSequences, writer.uint32(66).fork()).ldelim();
    }
    if (message.temperature !== undefined) {
      writer.uint32(73).double(message.temperature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeCohere {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeCohere();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.frequencyPenalty = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxTokens = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.model = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.k = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.p = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.presencePenalty = reader.double();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stopSequences = TextArray.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.temperature = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeCohere {
    return {
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : undefined,
      frequencyPenalty: isSet(object.frequencyPenalty) ? globalThis.Number(object.frequencyPenalty) : undefined,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      k: isSet(object.k) ? globalThis.Number(object.k) : undefined,
      p: isSet(object.p) ? globalThis.Number(object.p) : undefined,
      presencePenalty: isSet(object.presencePenalty) ? globalThis.Number(object.presencePenalty) : undefined,
      stopSequences: isSet(object.stopSequences) ? TextArray.fromJSON(object.stopSequences) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
    };
  },

  toJSON(message: GenerativeCohere): unknown {
    const obj: any = {};
    if (message.baseUrl !== undefined) {
      obj.baseUrl = message.baseUrl;
    }
    if (message.frequencyPenalty !== undefined) {
      obj.frequencyPenalty = message.frequencyPenalty;
    }
    if (message.maxTokens !== undefined) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.k !== undefined) {
      obj.k = Math.round(message.k);
    }
    if (message.p !== undefined) {
      obj.p = message.p;
    }
    if (message.presencePenalty !== undefined) {
      obj.presencePenalty = message.presencePenalty;
    }
    if (message.stopSequences !== undefined) {
      obj.stopSequences = TextArray.toJSON(message.stopSequences);
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeCohere>): GenerativeCohere {
    return GenerativeCohere.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeCohere>): GenerativeCohere {
    const message = createBaseGenerativeCohere();
    message.baseUrl = object.baseUrl ?? undefined;
    message.frequencyPenalty = object.frequencyPenalty ?? undefined;
    message.maxTokens = object.maxTokens ?? undefined;
    message.model = object.model ?? undefined;
    message.k = object.k ?? undefined;
    message.p = object.p ?? undefined;
    message.presencePenalty = object.presencePenalty ?? undefined;
    message.stopSequences = (object.stopSequences !== undefined && object.stopSequences !== null)
      ? TextArray.fromPartial(object.stopSequences)
      : undefined;
    message.temperature = object.temperature ?? undefined;
    return message;
  },
};

function createBaseGenerativeDummy(): GenerativeDummy {
  return {};
}

export const GenerativeDummy = {
  encode(_: GenerativeDummy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeDummy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeDummy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerativeDummy {
    return {};
  },

  toJSON(_: GenerativeDummy): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GenerativeDummy>): GenerativeDummy {
    return GenerativeDummy.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GenerativeDummy>): GenerativeDummy {
    const message = createBaseGenerativeDummy();
    return message;
  },
};

function createBaseGenerativeMistral(): GenerativeMistral {
  return { baseUrl: undefined, maxTokens: undefined, model: undefined, temperature: undefined, topP: undefined };
}

export const GenerativeMistral = {
  encode(message: GenerativeMistral, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseUrl !== undefined) {
      writer.uint32(10).string(message.baseUrl);
    }
    if (message.maxTokens !== undefined) {
      writer.uint32(16).int64(message.maxTokens);
    }
    if (message.model !== undefined) {
      writer.uint32(26).string(message.model);
    }
    if (message.temperature !== undefined) {
      writer.uint32(33).double(message.temperature);
    }
    if (message.topP !== undefined) {
      writer.uint32(41).double(message.topP);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeMistral {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeMistral();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTokens = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.temperature = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.topP = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeMistral {
    return {
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : undefined,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : undefined,
    };
  },

  toJSON(message: GenerativeMistral): unknown {
    const obj: any = {};
    if (message.baseUrl !== undefined) {
      obj.baseUrl = message.baseUrl;
    }
    if (message.maxTokens !== undefined) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== undefined) {
      obj.topP = message.topP;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeMistral>): GenerativeMistral {
    return GenerativeMistral.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeMistral>): GenerativeMistral {
    const message = createBaseGenerativeMistral();
    message.baseUrl = object.baseUrl ?? undefined;
    message.maxTokens = object.maxTokens ?? undefined;
    message.model = object.model ?? undefined;
    message.temperature = object.temperature ?? undefined;
    message.topP = object.topP ?? undefined;
    return message;
  },
};

function createBaseGenerativeOllama(): GenerativeOllama {
  return { apiEndpoint: undefined, model: undefined, temperature: undefined };
}

export const GenerativeOllama = {
  encode(message: GenerativeOllama, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.apiEndpoint !== undefined) {
      writer.uint32(10).string(message.apiEndpoint);
    }
    if (message.model !== undefined) {
      writer.uint32(18).string(message.model);
    }
    if (message.temperature !== undefined) {
      writer.uint32(25).double(message.temperature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeOllama {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeOllama();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apiEndpoint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.temperature = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeOllama {
    return {
      apiEndpoint: isSet(object.apiEndpoint) ? globalThis.String(object.apiEndpoint) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
    };
  },

  toJSON(message: GenerativeOllama): unknown {
    const obj: any = {};
    if (message.apiEndpoint !== undefined) {
      obj.apiEndpoint = message.apiEndpoint;
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeOllama>): GenerativeOllama {
    return GenerativeOllama.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeOllama>): GenerativeOllama {
    const message = createBaseGenerativeOllama();
    message.apiEndpoint = object.apiEndpoint ?? undefined;
    message.model = object.model ?? undefined;
    message.temperature = object.temperature ?? undefined;
    return message;
  },
};

function createBaseGenerativeOpenAI(): GenerativeOpenAI {
  return {
    frequencyPenalty: undefined,
    maxTokens: undefined,
    model: "",
    n: undefined,
    presencePenalty: undefined,
    stop: undefined,
    temperature: undefined,
    topP: undefined,
    baseUrl: undefined,
    apiVersion: undefined,
    resourceName: undefined,
    deploymentId: undefined,
    isAzure: undefined,
  };
}

export const GenerativeOpenAI = {
  encode(message: GenerativeOpenAI, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frequencyPenalty !== undefined) {
      writer.uint32(9).double(message.frequencyPenalty);
    }
    if (message.maxTokens !== undefined) {
      writer.uint32(16).int64(message.maxTokens);
    }
    if (message.model !== "") {
      writer.uint32(26).string(message.model);
    }
    if (message.n !== undefined) {
      writer.uint32(32).int64(message.n);
    }
    if (message.presencePenalty !== undefined) {
      writer.uint32(41).double(message.presencePenalty);
    }
    if (message.stop !== undefined) {
      TextArray.encode(message.stop, writer.uint32(50).fork()).ldelim();
    }
    if (message.temperature !== undefined) {
      writer.uint32(57).double(message.temperature);
    }
    if (message.topP !== undefined) {
      writer.uint32(65).double(message.topP);
    }
    if (message.baseUrl !== undefined) {
      writer.uint32(74).string(message.baseUrl);
    }
    if (message.apiVersion !== undefined) {
      writer.uint32(82).string(message.apiVersion);
    }
    if (message.resourceName !== undefined) {
      writer.uint32(90).string(message.resourceName);
    }
    if (message.deploymentId !== undefined) {
      writer.uint32(98).string(message.deploymentId);
    }
    if (message.isAzure !== undefined) {
      writer.uint32(104).bool(message.isAzure);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeOpenAI {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeOpenAI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.frequencyPenalty = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTokens = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.n = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.presencePenalty = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.stop = TextArray.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.temperature = reader.double();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.topP = reader.double();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.resourceName = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.deploymentId = reader.string();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.isAzure = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeOpenAI {
    return {
      frequencyPenalty: isSet(object.frequencyPenalty) ? globalThis.Number(object.frequencyPenalty) : undefined,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : "",
      n: isSet(object.n) ? globalThis.Number(object.n) : undefined,
      presencePenalty: isSet(object.presencePenalty) ? globalThis.Number(object.presencePenalty) : undefined,
      stop: isSet(object.stop) ? TextArray.fromJSON(object.stop) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : undefined,
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : undefined,
      apiVersion: isSet(object.apiVersion) ? globalThis.String(object.apiVersion) : undefined,
      resourceName: isSet(object.resourceName) ? globalThis.String(object.resourceName) : undefined,
      deploymentId: isSet(object.deploymentId) ? globalThis.String(object.deploymentId) : undefined,
      isAzure: isSet(object.isAzure) ? globalThis.Boolean(object.isAzure) : undefined,
    };
  },

  toJSON(message: GenerativeOpenAI): unknown {
    const obj: any = {};
    if (message.frequencyPenalty !== undefined) {
      obj.frequencyPenalty = message.frequencyPenalty;
    }
    if (message.maxTokens !== undefined) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.model !== "") {
      obj.model = message.model;
    }
    if (message.n !== undefined) {
      obj.n = Math.round(message.n);
    }
    if (message.presencePenalty !== undefined) {
      obj.presencePenalty = message.presencePenalty;
    }
    if (message.stop !== undefined) {
      obj.stop = TextArray.toJSON(message.stop);
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== undefined) {
      obj.topP = message.topP;
    }
    if (message.baseUrl !== undefined) {
      obj.baseUrl = message.baseUrl;
    }
    if (message.apiVersion !== undefined) {
      obj.apiVersion = message.apiVersion;
    }
    if (message.resourceName !== undefined) {
      obj.resourceName = message.resourceName;
    }
    if (message.deploymentId !== undefined) {
      obj.deploymentId = message.deploymentId;
    }
    if (message.isAzure !== undefined) {
      obj.isAzure = message.isAzure;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeOpenAI>): GenerativeOpenAI {
    return GenerativeOpenAI.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeOpenAI>): GenerativeOpenAI {
    const message = createBaseGenerativeOpenAI();
    message.frequencyPenalty = object.frequencyPenalty ?? undefined;
    message.maxTokens = object.maxTokens ?? undefined;
    message.model = object.model ?? "";
    message.n = object.n ?? undefined;
    message.presencePenalty = object.presencePenalty ?? undefined;
    message.stop = (object.stop !== undefined && object.stop !== null) ? TextArray.fromPartial(object.stop) : undefined;
    message.temperature = object.temperature ?? undefined;
    message.topP = object.topP ?? undefined;
    message.baseUrl = object.baseUrl ?? undefined;
    message.apiVersion = object.apiVersion ?? undefined;
    message.resourceName = object.resourceName ?? undefined;
    message.deploymentId = object.deploymentId ?? undefined;
    message.isAzure = object.isAzure ?? undefined;
    return message;
  },
};

function createBaseGenerativeGoogle(): GenerativeGoogle {
  return {
    frequencyPenalty: undefined,
    maxTokens: undefined,
    model: undefined,
    presencePenalty: undefined,
    temperature: undefined,
    topK: undefined,
    topP: undefined,
    stopSequences: undefined,
    apiEndpoint: undefined,
    projectId: undefined,
    endpointId: undefined,
    region: undefined,
  };
}

export const GenerativeGoogle = {
  encode(message: GenerativeGoogle, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frequencyPenalty !== undefined) {
      writer.uint32(9).double(message.frequencyPenalty);
    }
    if (message.maxTokens !== undefined) {
      writer.uint32(16).int64(message.maxTokens);
    }
    if (message.model !== undefined) {
      writer.uint32(26).string(message.model);
    }
    if (message.presencePenalty !== undefined) {
      writer.uint32(33).double(message.presencePenalty);
    }
    if (message.temperature !== undefined) {
      writer.uint32(41).double(message.temperature);
    }
    if (message.topK !== undefined) {
      writer.uint32(48).int64(message.topK);
    }
    if (message.topP !== undefined) {
      writer.uint32(57).double(message.topP);
    }
    if (message.stopSequences !== undefined) {
      TextArray.encode(message.stopSequences, writer.uint32(66).fork()).ldelim();
    }
    if (message.apiEndpoint !== undefined) {
      writer.uint32(74).string(message.apiEndpoint);
    }
    if (message.projectId !== undefined) {
      writer.uint32(82).string(message.projectId);
    }
    if (message.endpointId !== undefined) {
      writer.uint32(90).string(message.endpointId);
    }
    if (message.region !== undefined) {
      writer.uint32(98).string(message.region);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeGoogle {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeGoogle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.frequencyPenalty = reader.double();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.maxTokens = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.model = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.presencePenalty = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.temperature = reader.double();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.topK = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.topP = reader.double();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.stopSequences = TextArray.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.apiEndpoint = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.projectId = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.endpointId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.region = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeGoogle {
    return {
      frequencyPenalty: isSet(object.frequencyPenalty) ? globalThis.Number(object.frequencyPenalty) : undefined,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      presencePenalty: isSet(object.presencePenalty) ? globalThis.Number(object.presencePenalty) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      topK: isSet(object.topK) ? globalThis.Number(object.topK) : undefined,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : undefined,
      stopSequences: isSet(object.stopSequences) ? TextArray.fromJSON(object.stopSequences) : undefined,
      apiEndpoint: isSet(object.apiEndpoint) ? globalThis.String(object.apiEndpoint) : undefined,
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : undefined,
      endpointId: isSet(object.endpointId) ? globalThis.String(object.endpointId) : undefined,
      region: isSet(object.region) ? globalThis.String(object.region) : undefined,
    };
  },

  toJSON(message: GenerativeGoogle): unknown {
    const obj: any = {};
    if (message.frequencyPenalty !== undefined) {
      obj.frequencyPenalty = message.frequencyPenalty;
    }
    if (message.maxTokens !== undefined) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.presencePenalty !== undefined) {
      obj.presencePenalty = message.presencePenalty;
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.topK !== undefined) {
      obj.topK = Math.round(message.topK);
    }
    if (message.topP !== undefined) {
      obj.topP = message.topP;
    }
    if (message.stopSequences !== undefined) {
      obj.stopSequences = TextArray.toJSON(message.stopSequences);
    }
    if (message.apiEndpoint !== undefined) {
      obj.apiEndpoint = message.apiEndpoint;
    }
    if (message.projectId !== undefined) {
      obj.projectId = message.projectId;
    }
    if (message.endpointId !== undefined) {
      obj.endpointId = message.endpointId;
    }
    if (message.region !== undefined) {
      obj.region = message.region;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeGoogle>): GenerativeGoogle {
    return GenerativeGoogle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeGoogle>): GenerativeGoogle {
    const message = createBaseGenerativeGoogle();
    message.frequencyPenalty = object.frequencyPenalty ?? undefined;
    message.maxTokens = object.maxTokens ?? undefined;
    message.model = object.model ?? undefined;
    message.presencePenalty = object.presencePenalty ?? undefined;
    message.temperature = object.temperature ?? undefined;
    message.topK = object.topK ?? undefined;
    message.topP = object.topP ?? undefined;
    message.stopSequences = (object.stopSequences !== undefined && object.stopSequences !== null)
      ? TextArray.fromPartial(object.stopSequences)
      : undefined;
    message.apiEndpoint = object.apiEndpoint ?? undefined;
    message.projectId = object.projectId ?? undefined;
    message.endpointId = object.endpointId ?? undefined;
    message.region = object.region ?? undefined;
    return message;
  },
};

function createBaseGenerativeDatabricks(): GenerativeDatabricks {
  return {
    endpoint: undefined,
    model: undefined,
    frequencyPenalty: undefined,
    logProbs: undefined,
    topLogProbs: undefined,
    maxTokens: undefined,
    n: undefined,
    presencePenalty: undefined,
    stop: undefined,
    temperature: undefined,
    topP: undefined,
  };
}

export const GenerativeDatabricks = {
  encode(message: GenerativeDatabricks, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.endpoint !== undefined) {
      writer.uint32(10).string(message.endpoint);
    }
    if (message.model !== undefined) {
      writer.uint32(18).string(message.model);
    }
    if (message.frequencyPenalty !== undefined) {
      writer.uint32(25).double(message.frequencyPenalty);
    }
    if (message.logProbs !== undefined) {
      writer.uint32(32).bool(message.logProbs);
    }
    if (message.topLogProbs !== undefined) {
      writer.uint32(40).int64(message.topLogProbs);
    }
    if (message.maxTokens !== undefined) {
      writer.uint32(48).int64(message.maxTokens);
    }
    if (message.n !== undefined) {
      writer.uint32(56).int64(message.n);
    }
    if (message.presencePenalty !== undefined) {
      writer.uint32(65).double(message.presencePenalty);
    }
    if (message.stop !== undefined) {
      TextArray.encode(message.stop, writer.uint32(74).fork()).ldelim();
    }
    if (message.temperature !== undefined) {
      writer.uint32(81).double(message.temperature);
    }
    if (message.topP !== undefined) {
      writer.uint32(89).double(message.topP);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeDatabricks {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeDatabricks();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.frequencyPenalty = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.logProbs = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.topLogProbs = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.maxTokens = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.n = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.presencePenalty = reader.double();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.stop = TextArray.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 81) {
            break;
          }

          message.temperature = reader.double();
          continue;
        case 11:
          if (tag !== 89) {
            break;
          }

          message.topP = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeDatabricks {
    return {
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      frequencyPenalty: isSet(object.frequencyPenalty) ? globalThis.Number(object.frequencyPenalty) : undefined,
      logProbs: isSet(object.logProbs) ? globalThis.Boolean(object.logProbs) : undefined,
      topLogProbs: isSet(object.topLogProbs) ? globalThis.Number(object.topLogProbs) : undefined,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
      n: isSet(object.n) ? globalThis.Number(object.n) : undefined,
      presencePenalty: isSet(object.presencePenalty) ? globalThis.Number(object.presencePenalty) : undefined,
      stop: isSet(object.stop) ? TextArray.fromJSON(object.stop) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : undefined,
    };
  },

  toJSON(message: GenerativeDatabricks): unknown {
    const obj: any = {};
    if (message.endpoint !== undefined) {
      obj.endpoint = message.endpoint;
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.frequencyPenalty !== undefined) {
      obj.frequencyPenalty = message.frequencyPenalty;
    }
    if (message.logProbs !== undefined) {
      obj.logProbs = message.logProbs;
    }
    if (message.topLogProbs !== undefined) {
      obj.topLogProbs = Math.round(message.topLogProbs);
    }
    if (message.maxTokens !== undefined) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.n !== undefined) {
      obj.n = Math.round(message.n);
    }
    if (message.presencePenalty !== undefined) {
      obj.presencePenalty = message.presencePenalty;
    }
    if (message.stop !== undefined) {
      obj.stop = TextArray.toJSON(message.stop);
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.topP !== undefined) {
      obj.topP = message.topP;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeDatabricks>): GenerativeDatabricks {
    return GenerativeDatabricks.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeDatabricks>): GenerativeDatabricks {
    const message = createBaseGenerativeDatabricks();
    message.endpoint = object.endpoint ?? undefined;
    message.model = object.model ?? undefined;
    message.frequencyPenalty = object.frequencyPenalty ?? undefined;
    message.logProbs = object.logProbs ?? undefined;
    message.topLogProbs = object.topLogProbs ?? undefined;
    message.maxTokens = object.maxTokens ?? undefined;
    message.n = object.n ?? undefined;
    message.presencePenalty = object.presencePenalty ?? undefined;
    message.stop = (object.stop !== undefined && object.stop !== null) ? TextArray.fromPartial(object.stop) : undefined;
    message.temperature = object.temperature ?? undefined;
    message.topP = object.topP ?? undefined;
    return message;
  },
};

function createBaseGenerativeFriendliAI(): GenerativeFriendliAI {
  return {
    baseUrl: undefined,
    model: undefined,
    maxTokens: undefined,
    temperature: undefined,
    n: undefined,
    topP: undefined,
  };
}

export const GenerativeFriendliAI = {
  encode(message: GenerativeFriendliAI, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.baseUrl !== undefined) {
      writer.uint32(10).string(message.baseUrl);
    }
    if (message.model !== undefined) {
      writer.uint32(18).string(message.model);
    }
    if (message.maxTokens !== undefined) {
      writer.uint32(24).int64(message.maxTokens);
    }
    if (message.temperature !== undefined) {
      writer.uint32(33).double(message.temperature);
    }
    if (message.n !== undefined) {
      writer.uint32(40).int64(message.n);
    }
    if (message.topP !== undefined) {
      writer.uint32(49).double(message.topP);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeFriendliAI {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeFriendliAI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.baseUrl = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.model = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.maxTokens = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.temperature = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.n = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.topP = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeFriendliAI {
    return {
      baseUrl: isSet(object.baseUrl) ? globalThis.String(object.baseUrl) : undefined,
      model: isSet(object.model) ? globalThis.String(object.model) : undefined,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : undefined,
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : undefined,
      n: isSet(object.n) ? globalThis.Number(object.n) : undefined,
      topP: isSet(object.topP) ? globalThis.Number(object.topP) : undefined,
    };
  },

  toJSON(message: GenerativeFriendliAI): unknown {
    const obj: any = {};
    if (message.baseUrl !== undefined) {
      obj.baseUrl = message.baseUrl;
    }
    if (message.model !== undefined) {
      obj.model = message.model;
    }
    if (message.maxTokens !== undefined) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.temperature !== undefined) {
      obj.temperature = message.temperature;
    }
    if (message.n !== undefined) {
      obj.n = Math.round(message.n);
    }
    if (message.topP !== undefined) {
      obj.topP = message.topP;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeFriendliAI>): GenerativeFriendliAI {
    return GenerativeFriendliAI.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeFriendliAI>): GenerativeFriendliAI {
    const message = createBaseGenerativeFriendliAI();
    message.baseUrl = object.baseUrl ?? undefined;
    message.model = object.model ?? undefined;
    message.maxTokens = object.maxTokens ?? undefined;
    message.temperature = object.temperature ?? undefined;
    message.n = object.n ?? undefined;
    message.topP = object.topP ?? undefined;
    return message;
  },
};

function createBaseGenerativeAnthropicMetadata(): GenerativeAnthropicMetadata {
  return { usage: undefined };
}

export const GenerativeAnthropicMetadata = {
  encode(message: GenerativeAnthropicMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.usage !== undefined) {
      GenerativeAnthropicMetadata_Usage.encode(message.usage, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeAnthropicMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeAnthropicMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.usage = GenerativeAnthropicMetadata_Usage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeAnthropicMetadata {
    return { usage: isSet(object.usage) ? GenerativeAnthropicMetadata_Usage.fromJSON(object.usage) : undefined };
  },

  toJSON(message: GenerativeAnthropicMetadata): unknown {
    const obj: any = {};
    if (message.usage !== undefined) {
      obj.usage = GenerativeAnthropicMetadata_Usage.toJSON(message.usage);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeAnthropicMetadata>): GenerativeAnthropicMetadata {
    return GenerativeAnthropicMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeAnthropicMetadata>): GenerativeAnthropicMetadata {
    const message = createBaseGenerativeAnthropicMetadata();
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? GenerativeAnthropicMetadata_Usage.fromPartial(object.usage)
      : undefined;
    return message;
  },
};

function createBaseGenerativeAnthropicMetadata_Usage(): GenerativeAnthropicMetadata_Usage {
  return { inputTokens: 0, outputTokens: 0 };
}

export const GenerativeAnthropicMetadata_Usage = {
  encode(message: GenerativeAnthropicMetadata_Usage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inputTokens !== 0) {
      writer.uint32(8).int64(message.inputTokens);
    }
    if (message.outputTokens !== 0) {
      writer.uint32(16).int64(message.outputTokens);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeAnthropicMetadata_Usage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeAnthropicMetadata_Usage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.inputTokens = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.outputTokens = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeAnthropicMetadata_Usage {
    return {
      inputTokens: isSet(object.inputTokens) ? globalThis.Number(object.inputTokens) : 0,
      outputTokens: isSet(object.outputTokens) ? globalThis.Number(object.outputTokens) : 0,
    };
  },

  toJSON(message: GenerativeAnthropicMetadata_Usage): unknown {
    const obj: any = {};
    if (message.inputTokens !== 0) {
      obj.inputTokens = Math.round(message.inputTokens);
    }
    if (message.outputTokens !== 0) {
      obj.outputTokens = Math.round(message.outputTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeAnthropicMetadata_Usage>): GenerativeAnthropicMetadata_Usage {
    return GenerativeAnthropicMetadata_Usage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeAnthropicMetadata_Usage>): GenerativeAnthropicMetadata_Usage {
    const message = createBaseGenerativeAnthropicMetadata_Usage();
    message.inputTokens = object.inputTokens ?? 0;
    message.outputTokens = object.outputTokens ?? 0;
    return message;
  },
};

function createBaseGenerativeAnyscaleMetadata(): GenerativeAnyscaleMetadata {
  return {};
}

export const GenerativeAnyscaleMetadata = {
  encode(_: GenerativeAnyscaleMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeAnyscaleMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeAnyscaleMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerativeAnyscaleMetadata {
    return {};
  },

  toJSON(_: GenerativeAnyscaleMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GenerativeAnyscaleMetadata>): GenerativeAnyscaleMetadata {
    return GenerativeAnyscaleMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GenerativeAnyscaleMetadata>): GenerativeAnyscaleMetadata {
    const message = createBaseGenerativeAnyscaleMetadata();
    return message;
  },
};

function createBaseGenerativeAWSMetadata(): GenerativeAWSMetadata {
  return {};
}

export const GenerativeAWSMetadata = {
  encode(_: GenerativeAWSMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeAWSMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeAWSMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerativeAWSMetadata {
    return {};
  },

  toJSON(_: GenerativeAWSMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GenerativeAWSMetadata>): GenerativeAWSMetadata {
    return GenerativeAWSMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GenerativeAWSMetadata>): GenerativeAWSMetadata {
    const message = createBaseGenerativeAWSMetadata();
    return message;
  },
};

function createBaseGenerativeCohereMetadata(): GenerativeCohereMetadata {
  return { apiVersion: undefined, billedUnits: undefined, tokens: undefined, warnings: undefined };
}

export const GenerativeCohereMetadata = {
  encode(message: GenerativeCohereMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.apiVersion !== undefined) {
      GenerativeCohereMetadata_ApiVersion.encode(message.apiVersion, writer.uint32(10).fork()).ldelim();
    }
    if (message.billedUnits !== undefined) {
      GenerativeCohereMetadata_BilledUnits.encode(message.billedUnits, writer.uint32(18).fork()).ldelim();
    }
    if (message.tokens !== undefined) {
      GenerativeCohereMetadata_Tokens.encode(message.tokens, writer.uint32(26).fork()).ldelim();
    }
    if (message.warnings !== undefined) {
      TextArray.encode(message.warnings, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeCohereMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeCohereMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.apiVersion = GenerativeCohereMetadata_ApiVersion.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.billedUnits = GenerativeCohereMetadata_BilledUnits.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.tokens = GenerativeCohereMetadata_Tokens.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.warnings = TextArray.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeCohereMetadata {
    return {
      apiVersion: isSet(object.apiVersion)
        ? GenerativeCohereMetadata_ApiVersion.fromJSON(object.apiVersion)
        : undefined,
      billedUnits: isSet(object.billedUnits)
        ? GenerativeCohereMetadata_BilledUnits.fromJSON(object.billedUnits)
        : undefined,
      tokens: isSet(object.tokens) ? GenerativeCohereMetadata_Tokens.fromJSON(object.tokens) : undefined,
      warnings: isSet(object.warnings) ? TextArray.fromJSON(object.warnings) : undefined,
    };
  },

  toJSON(message: GenerativeCohereMetadata): unknown {
    const obj: any = {};
    if (message.apiVersion !== undefined) {
      obj.apiVersion = GenerativeCohereMetadata_ApiVersion.toJSON(message.apiVersion);
    }
    if (message.billedUnits !== undefined) {
      obj.billedUnits = GenerativeCohereMetadata_BilledUnits.toJSON(message.billedUnits);
    }
    if (message.tokens !== undefined) {
      obj.tokens = GenerativeCohereMetadata_Tokens.toJSON(message.tokens);
    }
    if (message.warnings !== undefined) {
      obj.warnings = TextArray.toJSON(message.warnings);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeCohereMetadata>): GenerativeCohereMetadata {
    return GenerativeCohereMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeCohereMetadata>): GenerativeCohereMetadata {
    const message = createBaseGenerativeCohereMetadata();
    message.apiVersion = (object.apiVersion !== undefined && object.apiVersion !== null)
      ? GenerativeCohereMetadata_ApiVersion.fromPartial(object.apiVersion)
      : undefined;
    message.billedUnits = (object.billedUnits !== undefined && object.billedUnits !== null)
      ? GenerativeCohereMetadata_BilledUnits.fromPartial(object.billedUnits)
      : undefined;
    message.tokens = (object.tokens !== undefined && object.tokens !== null)
      ? GenerativeCohereMetadata_Tokens.fromPartial(object.tokens)
      : undefined;
    message.warnings = (object.warnings !== undefined && object.warnings !== null)
      ? TextArray.fromPartial(object.warnings)
      : undefined;
    return message;
  },
};

function createBaseGenerativeCohereMetadata_ApiVersion(): GenerativeCohereMetadata_ApiVersion {
  return { version: undefined, isDeprecated: undefined, isExperimental: undefined };
}

export const GenerativeCohereMetadata_ApiVersion = {
  encode(message: GenerativeCohereMetadata_ApiVersion, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== undefined) {
      writer.uint32(10).string(message.version);
    }
    if (message.isDeprecated !== undefined) {
      writer.uint32(16).bool(message.isDeprecated);
    }
    if (message.isExperimental !== undefined) {
      writer.uint32(24).bool(message.isExperimental);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeCohereMetadata_ApiVersion {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeCohereMetadata_ApiVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isDeprecated = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isExperimental = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeCohereMetadata_ApiVersion {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      isDeprecated: isSet(object.isDeprecated) ? globalThis.Boolean(object.isDeprecated) : undefined,
      isExperimental: isSet(object.isExperimental) ? globalThis.Boolean(object.isExperimental) : undefined,
    };
  },

  toJSON(message: GenerativeCohereMetadata_ApiVersion): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.isDeprecated !== undefined) {
      obj.isDeprecated = message.isDeprecated;
    }
    if (message.isExperimental !== undefined) {
      obj.isExperimental = message.isExperimental;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeCohereMetadata_ApiVersion>): GenerativeCohereMetadata_ApiVersion {
    return GenerativeCohereMetadata_ApiVersion.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeCohereMetadata_ApiVersion>): GenerativeCohereMetadata_ApiVersion {
    const message = createBaseGenerativeCohereMetadata_ApiVersion();
    message.version = object.version ?? undefined;
    message.isDeprecated = object.isDeprecated ?? undefined;
    message.isExperimental = object.isExperimental ?? undefined;
    return message;
  },
};

function createBaseGenerativeCohereMetadata_BilledUnits(): GenerativeCohereMetadata_BilledUnits {
  return { inputTokens: undefined, outputTokens: undefined, searchUnits: undefined, classifications: undefined };
}

export const GenerativeCohereMetadata_BilledUnits = {
  encode(message: GenerativeCohereMetadata_BilledUnits, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inputTokens !== undefined) {
      writer.uint32(9).double(message.inputTokens);
    }
    if (message.outputTokens !== undefined) {
      writer.uint32(17).double(message.outputTokens);
    }
    if (message.searchUnits !== undefined) {
      writer.uint32(25).double(message.searchUnits);
    }
    if (message.classifications !== undefined) {
      writer.uint32(33).double(message.classifications);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeCohereMetadata_BilledUnits {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeCohereMetadata_BilledUnits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.inputTokens = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.outputTokens = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.searchUnits = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.classifications = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeCohereMetadata_BilledUnits {
    return {
      inputTokens: isSet(object.inputTokens) ? globalThis.Number(object.inputTokens) : undefined,
      outputTokens: isSet(object.outputTokens) ? globalThis.Number(object.outputTokens) : undefined,
      searchUnits: isSet(object.searchUnits) ? globalThis.Number(object.searchUnits) : undefined,
      classifications: isSet(object.classifications) ? globalThis.Number(object.classifications) : undefined,
    };
  },

  toJSON(message: GenerativeCohereMetadata_BilledUnits): unknown {
    const obj: any = {};
    if (message.inputTokens !== undefined) {
      obj.inputTokens = message.inputTokens;
    }
    if (message.outputTokens !== undefined) {
      obj.outputTokens = message.outputTokens;
    }
    if (message.searchUnits !== undefined) {
      obj.searchUnits = message.searchUnits;
    }
    if (message.classifications !== undefined) {
      obj.classifications = message.classifications;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeCohereMetadata_BilledUnits>): GenerativeCohereMetadata_BilledUnits {
    return GenerativeCohereMetadata_BilledUnits.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeCohereMetadata_BilledUnits>): GenerativeCohereMetadata_BilledUnits {
    const message = createBaseGenerativeCohereMetadata_BilledUnits();
    message.inputTokens = object.inputTokens ?? undefined;
    message.outputTokens = object.outputTokens ?? undefined;
    message.searchUnits = object.searchUnits ?? undefined;
    message.classifications = object.classifications ?? undefined;
    return message;
  },
};

function createBaseGenerativeCohereMetadata_Tokens(): GenerativeCohereMetadata_Tokens {
  return { inputTokens: undefined, outputTokens: undefined };
}

export const GenerativeCohereMetadata_Tokens = {
  encode(message: GenerativeCohereMetadata_Tokens, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inputTokens !== undefined) {
      writer.uint32(9).double(message.inputTokens);
    }
    if (message.outputTokens !== undefined) {
      writer.uint32(17).double(message.outputTokens);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeCohereMetadata_Tokens {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeCohereMetadata_Tokens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.inputTokens = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.outputTokens = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeCohereMetadata_Tokens {
    return {
      inputTokens: isSet(object.inputTokens) ? globalThis.Number(object.inputTokens) : undefined,
      outputTokens: isSet(object.outputTokens) ? globalThis.Number(object.outputTokens) : undefined,
    };
  },

  toJSON(message: GenerativeCohereMetadata_Tokens): unknown {
    const obj: any = {};
    if (message.inputTokens !== undefined) {
      obj.inputTokens = message.inputTokens;
    }
    if (message.outputTokens !== undefined) {
      obj.outputTokens = message.outputTokens;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeCohereMetadata_Tokens>): GenerativeCohereMetadata_Tokens {
    return GenerativeCohereMetadata_Tokens.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeCohereMetadata_Tokens>): GenerativeCohereMetadata_Tokens {
    const message = createBaseGenerativeCohereMetadata_Tokens();
    message.inputTokens = object.inputTokens ?? undefined;
    message.outputTokens = object.outputTokens ?? undefined;
    return message;
  },
};

function createBaseGenerativeDummyMetadata(): GenerativeDummyMetadata {
  return {};
}

export const GenerativeDummyMetadata = {
  encode(_: GenerativeDummyMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeDummyMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeDummyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerativeDummyMetadata {
    return {};
  },

  toJSON(_: GenerativeDummyMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GenerativeDummyMetadata>): GenerativeDummyMetadata {
    return GenerativeDummyMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GenerativeDummyMetadata>): GenerativeDummyMetadata {
    const message = createBaseGenerativeDummyMetadata();
    return message;
  },
};

function createBaseGenerativeMistralMetadata(): GenerativeMistralMetadata {
  return { usage: undefined };
}

export const GenerativeMistralMetadata = {
  encode(message: GenerativeMistralMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.usage !== undefined) {
      GenerativeMistralMetadata_Usage.encode(message.usage, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeMistralMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeMistralMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.usage = GenerativeMistralMetadata_Usage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeMistralMetadata {
    return { usage: isSet(object.usage) ? GenerativeMistralMetadata_Usage.fromJSON(object.usage) : undefined };
  },

  toJSON(message: GenerativeMistralMetadata): unknown {
    const obj: any = {};
    if (message.usage !== undefined) {
      obj.usage = GenerativeMistralMetadata_Usage.toJSON(message.usage);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeMistralMetadata>): GenerativeMistralMetadata {
    return GenerativeMistralMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeMistralMetadata>): GenerativeMistralMetadata {
    const message = createBaseGenerativeMistralMetadata();
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? GenerativeMistralMetadata_Usage.fromPartial(object.usage)
      : undefined;
    return message;
  },
};

function createBaseGenerativeMistralMetadata_Usage(): GenerativeMistralMetadata_Usage {
  return { promptTokens: undefined, completionTokens: undefined, totalTokens: undefined };
}

export const GenerativeMistralMetadata_Usage = {
  encode(message: GenerativeMistralMetadata_Usage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptTokens !== undefined) {
      writer.uint32(8).int64(message.promptTokens);
    }
    if (message.completionTokens !== undefined) {
      writer.uint32(16).int64(message.completionTokens);
    }
    if (message.totalTokens !== undefined) {
      writer.uint32(24).int64(message.totalTokens);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeMistralMetadata_Usage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeMistralMetadata_Usage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.promptTokens = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completionTokens = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeMistralMetadata_Usage {
    return {
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : undefined,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : undefined,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : undefined,
    };
  },

  toJSON(message: GenerativeMistralMetadata_Usage): unknown {
    const obj: any = {};
    if (message.promptTokens !== undefined) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== undefined) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== undefined) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeMistralMetadata_Usage>): GenerativeMistralMetadata_Usage {
    return GenerativeMistralMetadata_Usage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeMistralMetadata_Usage>): GenerativeMistralMetadata_Usage {
    const message = createBaseGenerativeMistralMetadata_Usage();
    message.promptTokens = object.promptTokens ?? undefined;
    message.completionTokens = object.completionTokens ?? undefined;
    message.totalTokens = object.totalTokens ?? undefined;
    return message;
  },
};

function createBaseGenerativeOllamaMetadata(): GenerativeOllamaMetadata {
  return {};
}

export const GenerativeOllamaMetadata = {
  encode(_: GenerativeOllamaMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeOllamaMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeOllamaMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerativeOllamaMetadata {
    return {};
  },

  toJSON(_: GenerativeOllamaMetadata): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<GenerativeOllamaMetadata>): GenerativeOllamaMetadata {
    return GenerativeOllamaMetadata.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GenerativeOllamaMetadata>): GenerativeOllamaMetadata {
    const message = createBaseGenerativeOllamaMetadata();
    return message;
  },
};

function createBaseGenerativeOpenAIMetadata(): GenerativeOpenAIMetadata {
  return { usage: undefined };
}

export const GenerativeOpenAIMetadata = {
  encode(message: GenerativeOpenAIMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.usage !== undefined) {
      GenerativeOpenAIMetadata_Usage.encode(message.usage, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeOpenAIMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeOpenAIMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.usage = GenerativeOpenAIMetadata_Usage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeOpenAIMetadata {
    return { usage: isSet(object.usage) ? GenerativeOpenAIMetadata_Usage.fromJSON(object.usage) : undefined };
  },

  toJSON(message: GenerativeOpenAIMetadata): unknown {
    const obj: any = {};
    if (message.usage !== undefined) {
      obj.usage = GenerativeOpenAIMetadata_Usage.toJSON(message.usage);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeOpenAIMetadata>): GenerativeOpenAIMetadata {
    return GenerativeOpenAIMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeOpenAIMetadata>): GenerativeOpenAIMetadata {
    const message = createBaseGenerativeOpenAIMetadata();
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? GenerativeOpenAIMetadata_Usage.fromPartial(object.usage)
      : undefined;
    return message;
  },
};

function createBaseGenerativeOpenAIMetadata_Usage(): GenerativeOpenAIMetadata_Usage {
  return { promptTokens: undefined, completionTokens: undefined, totalTokens: undefined };
}

export const GenerativeOpenAIMetadata_Usage = {
  encode(message: GenerativeOpenAIMetadata_Usage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptTokens !== undefined) {
      writer.uint32(8).int64(message.promptTokens);
    }
    if (message.completionTokens !== undefined) {
      writer.uint32(16).int64(message.completionTokens);
    }
    if (message.totalTokens !== undefined) {
      writer.uint32(24).int64(message.totalTokens);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeOpenAIMetadata_Usage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeOpenAIMetadata_Usage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.promptTokens = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completionTokens = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeOpenAIMetadata_Usage {
    return {
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : undefined,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : undefined,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : undefined,
    };
  },

  toJSON(message: GenerativeOpenAIMetadata_Usage): unknown {
    const obj: any = {};
    if (message.promptTokens !== undefined) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== undefined) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== undefined) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeOpenAIMetadata_Usage>): GenerativeOpenAIMetadata_Usage {
    return GenerativeOpenAIMetadata_Usage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeOpenAIMetadata_Usage>): GenerativeOpenAIMetadata_Usage {
    const message = createBaseGenerativeOpenAIMetadata_Usage();
    message.promptTokens = object.promptTokens ?? undefined;
    message.completionTokens = object.completionTokens ?? undefined;
    message.totalTokens = object.totalTokens ?? undefined;
    return message;
  },
};

function createBaseGenerativeGoogleMetadata(): GenerativeGoogleMetadata {
  return { metadata: undefined, usageMetadata: undefined };
}

export const GenerativeGoogleMetadata = {
  encode(message: GenerativeGoogleMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.metadata !== undefined) {
      GenerativeGoogleMetadata_Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
    }
    if (message.usageMetadata !== undefined) {
      GenerativeGoogleMetadata_UsageMetadata.encode(message.usageMetadata, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeGoogleMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeGoogleMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metadata = GenerativeGoogleMetadata_Metadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.usageMetadata = GenerativeGoogleMetadata_UsageMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeGoogleMetadata {
    return {
      metadata: isSet(object.metadata) ? GenerativeGoogleMetadata_Metadata.fromJSON(object.metadata) : undefined,
      usageMetadata: isSet(object.usageMetadata)
        ? GenerativeGoogleMetadata_UsageMetadata.fromJSON(object.usageMetadata)
        : undefined,
    };
  },

  toJSON(message: GenerativeGoogleMetadata): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = GenerativeGoogleMetadata_Metadata.toJSON(message.metadata);
    }
    if (message.usageMetadata !== undefined) {
      obj.usageMetadata = GenerativeGoogleMetadata_UsageMetadata.toJSON(message.usageMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeGoogleMetadata>): GenerativeGoogleMetadata {
    return GenerativeGoogleMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeGoogleMetadata>): GenerativeGoogleMetadata {
    const message = createBaseGenerativeGoogleMetadata();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? GenerativeGoogleMetadata_Metadata.fromPartial(object.metadata)
      : undefined;
    message.usageMetadata = (object.usageMetadata !== undefined && object.usageMetadata !== null)
      ? GenerativeGoogleMetadata_UsageMetadata.fromPartial(object.usageMetadata)
      : undefined;
    return message;
  },
};

function createBaseGenerativeGoogleMetadata_TokenCount(): GenerativeGoogleMetadata_TokenCount {
  return { totalBillableCharacters: undefined, totalTokens: undefined };
}

export const GenerativeGoogleMetadata_TokenCount = {
  encode(message: GenerativeGoogleMetadata_TokenCount, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.totalBillableCharacters !== undefined) {
      writer.uint32(8).int64(message.totalBillableCharacters);
    }
    if (message.totalTokens !== undefined) {
      writer.uint32(16).int64(message.totalTokens);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeGoogleMetadata_TokenCount {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeGoogleMetadata_TokenCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalBillableCharacters = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeGoogleMetadata_TokenCount {
    return {
      totalBillableCharacters: isSet(object.totalBillableCharacters)
        ? globalThis.Number(object.totalBillableCharacters)
        : undefined,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : undefined,
    };
  },

  toJSON(message: GenerativeGoogleMetadata_TokenCount): unknown {
    const obj: any = {};
    if (message.totalBillableCharacters !== undefined) {
      obj.totalBillableCharacters = Math.round(message.totalBillableCharacters);
    }
    if (message.totalTokens !== undefined) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeGoogleMetadata_TokenCount>): GenerativeGoogleMetadata_TokenCount {
    return GenerativeGoogleMetadata_TokenCount.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeGoogleMetadata_TokenCount>): GenerativeGoogleMetadata_TokenCount {
    const message = createBaseGenerativeGoogleMetadata_TokenCount();
    message.totalBillableCharacters = object.totalBillableCharacters ?? undefined;
    message.totalTokens = object.totalTokens ?? undefined;
    return message;
  },
};

function createBaseGenerativeGoogleMetadata_TokenMetadata(): GenerativeGoogleMetadata_TokenMetadata {
  return { inputTokenCount: undefined, outputTokenCount: undefined };
}

export const GenerativeGoogleMetadata_TokenMetadata = {
  encode(message: GenerativeGoogleMetadata_TokenMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.inputTokenCount !== undefined) {
      GenerativeGoogleMetadata_TokenCount.encode(message.inputTokenCount, writer.uint32(10).fork()).ldelim();
    }
    if (message.outputTokenCount !== undefined) {
      GenerativeGoogleMetadata_TokenCount.encode(message.outputTokenCount, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeGoogleMetadata_TokenMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeGoogleMetadata_TokenMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.inputTokenCount = GenerativeGoogleMetadata_TokenCount.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.outputTokenCount = GenerativeGoogleMetadata_TokenCount.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeGoogleMetadata_TokenMetadata {
    return {
      inputTokenCount: isSet(object.inputTokenCount)
        ? GenerativeGoogleMetadata_TokenCount.fromJSON(object.inputTokenCount)
        : undefined,
      outputTokenCount: isSet(object.outputTokenCount)
        ? GenerativeGoogleMetadata_TokenCount.fromJSON(object.outputTokenCount)
        : undefined,
    };
  },

  toJSON(message: GenerativeGoogleMetadata_TokenMetadata): unknown {
    const obj: any = {};
    if (message.inputTokenCount !== undefined) {
      obj.inputTokenCount = GenerativeGoogleMetadata_TokenCount.toJSON(message.inputTokenCount);
    }
    if (message.outputTokenCount !== undefined) {
      obj.outputTokenCount = GenerativeGoogleMetadata_TokenCount.toJSON(message.outputTokenCount);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeGoogleMetadata_TokenMetadata>): GenerativeGoogleMetadata_TokenMetadata {
    return GenerativeGoogleMetadata_TokenMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeGoogleMetadata_TokenMetadata>): GenerativeGoogleMetadata_TokenMetadata {
    const message = createBaseGenerativeGoogleMetadata_TokenMetadata();
    message.inputTokenCount = (object.inputTokenCount !== undefined && object.inputTokenCount !== null)
      ? GenerativeGoogleMetadata_TokenCount.fromPartial(object.inputTokenCount)
      : undefined;
    message.outputTokenCount = (object.outputTokenCount !== undefined && object.outputTokenCount !== null)
      ? GenerativeGoogleMetadata_TokenCount.fromPartial(object.outputTokenCount)
      : undefined;
    return message;
  },
};

function createBaseGenerativeGoogleMetadata_Metadata(): GenerativeGoogleMetadata_Metadata {
  return { tokenMetadata: undefined };
}

export const GenerativeGoogleMetadata_Metadata = {
  encode(message: GenerativeGoogleMetadata_Metadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenMetadata !== undefined) {
      GenerativeGoogleMetadata_TokenMetadata.encode(message.tokenMetadata, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeGoogleMetadata_Metadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeGoogleMetadata_Metadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenMetadata = GenerativeGoogleMetadata_TokenMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeGoogleMetadata_Metadata {
    return {
      tokenMetadata: isSet(object.tokenMetadata)
        ? GenerativeGoogleMetadata_TokenMetadata.fromJSON(object.tokenMetadata)
        : undefined,
    };
  },

  toJSON(message: GenerativeGoogleMetadata_Metadata): unknown {
    const obj: any = {};
    if (message.tokenMetadata !== undefined) {
      obj.tokenMetadata = GenerativeGoogleMetadata_TokenMetadata.toJSON(message.tokenMetadata);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeGoogleMetadata_Metadata>): GenerativeGoogleMetadata_Metadata {
    return GenerativeGoogleMetadata_Metadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeGoogleMetadata_Metadata>): GenerativeGoogleMetadata_Metadata {
    const message = createBaseGenerativeGoogleMetadata_Metadata();
    message.tokenMetadata = (object.tokenMetadata !== undefined && object.tokenMetadata !== null)
      ? GenerativeGoogleMetadata_TokenMetadata.fromPartial(object.tokenMetadata)
      : undefined;
    return message;
  },
};

function createBaseGenerativeGoogleMetadata_UsageMetadata(): GenerativeGoogleMetadata_UsageMetadata {
  return { promptTokenCount: undefined, candidatesTokenCount: undefined, totalTokenCount: undefined };
}

export const GenerativeGoogleMetadata_UsageMetadata = {
  encode(message: GenerativeGoogleMetadata_UsageMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptTokenCount !== undefined) {
      writer.uint32(8).int64(message.promptTokenCount);
    }
    if (message.candidatesTokenCount !== undefined) {
      writer.uint32(16).int64(message.candidatesTokenCount);
    }
    if (message.totalTokenCount !== undefined) {
      writer.uint32(24).int64(message.totalTokenCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeGoogleMetadata_UsageMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeGoogleMetadata_UsageMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.promptTokenCount = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.candidatesTokenCount = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTokenCount = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeGoogleMetadata_UsageMetadata {
    return {
      promptTokenCount: isSet(object.promptTokenCount) ? globalThis.Number(object.promptTokenCount) : undefined,
      candidatesTokenCount: isSet(object.candidatesTokenCount)
        ? globalThis.Number(object.candidatesTokenCount)
        : undefined,
      totalTokenCount: isSet(object.totalTokenCount) ? globalThis.Number(object.totalTokenCount) : undefined,
    };
  },

  toJSON(message: GenerativeGoogleMetadata_UsageMetadata): unknown {
    const obj: any = {};
    if (message.promptTokenCount !== undefined) {
      obj.promptTokenCount = Math.round(message.promptTokenCount);
    }
    if (message.candidatesTokenCount !== undefined) {
      obj.candidatesTokenCount = Math.round(message.candidatesTokenCount);
    }
    if (message.totalTokenCount !== undefined) {
      obj.totalTokenCount = Math.round(message.totalTokenCount);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeGoogleMetadata_UsageMetadata>): GenerativeGoogleMetadata_UsageMetadata {
    return GenerativeGoogleMetadata_UsageMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeGoogleMetadata_UsageMetadata>): GenerativeGoogleMetadata_UsageMetadata {
    const message = createBaseGenerativeGoogleMetadata_UsageMetadata();
    message.promptTokenCount = object.promptTokenCount ?? undefined;
    message.candidatesTokenCount = object.candidatesTokenCount ?? undefined;
    message.totalTokenCount = object.totalTokenCount ?? undefined;
    return message;
  },
};

function createBaseGenerativeDatabricksMetadata(): GenerativeDatabricksMetadata {
  return { usage: undefined };
}

export const GenerativeDatabricksMetadata = {
  encode(message: GenerativeDatabricksMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.usage !== undefined) {
      GenerativeDatabricksMetadata_Usage.encode(message.usage, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeDatabricksMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeDatabricksMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.usage = GenerativeDatabricksMetadata_Usage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeDatabricksMetadata {
    return { usage: isSet(object.usage) ? GenerativeDatabricksMetadata_Usage.fromJSON(object.usage) : undefined };
  },

  toJSON(message: GenerativeDatabricksMetadata): unknown {
    const obj: any = {};
    if (message.usage !== undefined) {
      obj.usage = GenerativeDatabricksMetadata_Usage.toJSON(message.usage);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeDatabricksMetadata>): GenerativeDatabricksMetadata {
    return GenerativeDatabricksMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeDatabricksMetadata>): GenerativeDatabricksMetadata {
    const message = createBaseGenerativeDatabricksMetadata();
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? GenerativeDatabricksMetadata_Usage.fromPartial(object.usage)
      : undefined;
    return message;
  },
};

function createBaseGenerativeDatabricksMetadata_Usage(): GenerativeDatabricksMetadata_Usage {
  return { promptTokens: undefined, completionTokens: undefined, totalTokens: undefined };
}

export const GenerativeDatabricksMetadata_Usage = {
  encode(message: GenerativeDatabricksMetadata_Usage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptTokens !== undefined) {
      writer.uint32(8).int64(message.promptTokens);
    }
    if (message.completionTokens !== undefined) {
      writer.uint32(16).int64(message.completionTokens);
    }
    if (message.totalTokens !== undefined) {
      writer.uint32(24).int64(message.totalTokens);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeDatabricksMetadata_Usage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeDatabricksMetadata_Usage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.promptTokens = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completionTokens = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeDatabricksMetadata_Usage {
    return {
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : undefined,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : undefined,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : undefined,
    };
  },

  toJSON(message: GenerativeDatabricksMetadata_Usage): unknown {
    const obj: any = {};
    if (message.promptTokens !== undefined) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== undefined) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== undefined) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeDatabricksMetadata_Usage>): GenerativeDatabricksMetadata_Usage {
    return GenerativeDatabricksMetadata_Usage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeDatabricksMetadata_Usage>): GenerativeDatabricksMetadata_Usage {
    const message = createBaseGenerativeDatabricksMetadata_Usage();
    message.promptTokens = object.promptTokens ?? undefined;
    message.completionTokens = object.completionTokens ?? undefined;
    message.totalTokens = object.totalTokens ?? undefined;
    return message;
  },
};

function createBaseGenerativeFriendliAIMetadata(): GenerativeFriendliAIMetadata {
  return { usage: undefined };
}

export const GenerativeFriendliAIMetadata = {
  encode(message: GenerativeFriendliAIMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.usage !== undefined) {
      GenerativeFriendliAIMetadata_Usage.encode(message.usage, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeFriendliAIMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeFriendliAIMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.usage = GenerativeFriendliAIMetadata_Usage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeFriendliAIMetadata {
    return { usage: isSet(object.usage) ? GenerativeFriendliAIMetadata_Usage.fromJSON(object.usage) : undefined };
  },

  toJSON(message: GenerativeFriendliAIMetadata): unknown {
    const obj: any = {};
    if (message.usage !== undefined) {
      obj.usage = GenerativeFriendliAIMetadata_Usage.toJSON(message.usage);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeFriendliAIMetadata>): GenerativeFriendliAIMetadata {
    return GenerativeFriendliAIMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeFriendliAIMetadata>): GenerativeFriendliAIMetadata {
    const message = createBaseGenerativeFriendliAIMetadata();
    message.usage = (object.usage !== undefined && object.usage !== null)
      ? GenerativeFriendliAIMetadata_Usage.fromPartial(object.usage)
      : undefined;
    return message;
  },
};

function createBaseGenerativeFriendliAIMetadata_Usage(): GenerativeFriendliAIMetadata_Usage {
  return { promptTokens: undefined, completionTokens: undefined, totalTokens: undefined };
}

export const GenerativeFriendliAIMetadata_Usage = {
  encode(message: GenerativeFriendliAIMetadata_Usage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.promptTokens !== undefined) {
      writer.uint32(8).int64(message.promptTokens);
    }
    if (message.completionTokens !== undefined) {
      writer.uint32(16).int64(message.completionTokens);
    }
    if (message.totalTokens !== undefined) {
      writer.uint32(24).int64(message.totalTokens);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeFriendliAIMetadata_Usage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeFriendliAIMetadata_Usage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.promptTokens = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completionTokens = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTokens = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeFriendliAIMetadata_Usage {
    return {
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : undefined,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : undefined,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : undefined,
    };
  },

  toJSON(message: GenerativeFriendliAIMetadata_Usage): unknown {
    const obj: any = {};
    if (message.promptTokens !== undefined) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== undefined) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.totalTokens !== undefined) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeFriendliAIMetadata_Usage>): GenerativeFriendliAIMetadata_Usage {
    return GenerativeFriendliAIMetadata_Usage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeFriendliAIMetadata_Usage>): GenerativeFriendliAIMetadata_Usage {
    const message = createBaseGenerativeFriendliAIMetadata_Usage();
    message.promptTokens = object.promptTokens ?? undefined;
    message.completionTokens = object.completionTokens ?? undefined;
    message.totalTokens = object.totalTokens ?? undefined;
    return message;
  },
};

function createBaseGenerativeMetadata(): GenerativeMetadata {
  return {
    anthropic: undefined,
    anyscale: undefined,
    aws: undefined,
    cohere: undefined,
    dummy: undefined,
    mistral: undefined,
    ollama: undefined,
    openai: undefined,
    google: undefined,
    databricks: undefined,
    friendliai: undefined,
  };
}

export const GenerativeMetadata = {
  encode(message: GenerativeMetadata, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.anthropic !== undefined) {
      GenerativeAnthropicMetadata.encode(message.anthropic, writer.uint32(10).fork()).ldelim();
    }
    if (message.anyscale !== undefined) {
      GenerativeAnyscaleMetadata.encode(message.anyscale, writer.uint32(18).fork()).ldelim();
    }
    if (message.aws !== undefined) {
      GenerativeAWSMetadata.encode(message.aws, writer.uint32(26).fork()).ldelim();
    }
    if (message.cohere !== undefined) {
      GenerativeCohereMetadata.encode(message.cohere, writer.uint32(34).fork()).ldelim();
    }
    if (message.dummy !== undefined) {
      GenerativeDummyMetadata.encode(message.dummy, writer.uint32(42).fork()).ldelim();
    }
    if (message.mistral !== undefined) {
      GenerativeMistralMetadata.encode(message.mistral, writer.uint32(50).fork()).ldelim();
    }
    if (message.ollama !== undefined) {
      GenerativeOllamaMetadata.encode(message.ollama, writer.uint32(58).fork()).ldelim();
    }
    if (message.openai !== undefined) {
      GenerativeOpenAIMetadata.encode(message.openai, writer.uint32(66).fork()).ldelim();
    }
    if (message.google !== undefined) {
      GenerativeGoogleMetadata.encode(message.google, writer.uint32(74).fork()).ldelim();
    }
    if (message.databricks !== undefined) {
      GenerativeDatabricksMetadata.encode(message.databricks, writer.uint32(82).fork()).ldelim();
    }
    if (message.friendliai !== undefined) {
      GenerativeFriendliAIMetadata.encode(message.friendliai, writer.uint32(90).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeMetadata {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.anthropic = GenerativeAnthropicMetadata.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.anyscale = GenerativeAnyscaleMetadata.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.aws = GenerativeAWSMetadata.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.cohere = GenerativeCohereMetadata.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dummy = GenerativeDummyMetadata.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.mistral = GenerativeMistralMetadata.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ollama = GenerativeOllamaMetadata.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.openai = GenerativeOpenAIMetadata.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.google = GenerativeGoogleMetadata.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.databricks = GenerativeDatabricksMetadata.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.friendliai = GenerativeFriendliAIMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeMetadata {
    return {
      anthropic: isSet(object.anthropic) ? GenerativeAnthropicMetadata.fromJSON(object.anthropic) : undefined,
      anyscale: isSet(object.anyscale) ? GenerativeAnyscaleMetadata.fromJSON(object.anyscale) : undefined,
      aws: isSet(object.aws) ? GenerativeAWSMetadata.fromJSON(object.aws) : undefined,
      cohere: isSet(object.cohere) ? GenerativeCohereMetadata.fromJSON(object.cohere) : undefined,
      dummy: isSet(object.dummy) ? GenerativeDummyMetadata.fromJSON(object.dummy) : undefined,
      mistral: isSet(object.mistral) ? GenerativeMistralMetadata.fromJSON(object.mistral) : undefined,
      ollama: isSet(object.ollama) ? GenerativeOllamaMetadata.fromJSON(object.ollama) : undefined,
      openai: isSet(object.openai) ? GenerativeOpenAIMetadata.fromJSON(object.openai) : undefined,
      google: isSet(object.google) ? GenerativeGoogleMetadata.fromJSON(object.google) : undefined,
      databricks: isSet(object.databricks) ? GenerativeDatabricksMetadata.fromJSON(object.databricks) : undefined,
      friendliai: isSet(object.friendliai) ? GenerativeFriendliAIMetadata.fromJSON(object.friendliai) : undefined,
    };
  },

  toJSON(message: GenerativeMetadata): unknown {
    const obj: any = {};
    if (message.anthropic !== undefined) {
      obj.anthropic = GenerativeAnthropicMetadata.toJSON(message.anthropic);
    }
    if (message.anyscale !== undefined) {
      obj.anyscale = GenerativeAnyscaleMetadata.toJSON(message.anyscale);
    }
    if (message.aws !== undefined) {
      obj.aws = GenerativeAWSMetadata.toJSON(message.aws);
    }
    if (message.cohere !== undefined) {
      obj.cohere = GenerativeCohereMetadata.toJSON(message.cohere);
    }
    if (message.dummy !== undefined) {
      obj.dummy = GenerativeDummyMetadata.toJSON(message.dummy);
    }
    if (message.mistral !== undefined) {
      obj.mistral = GenerativeMistralMetadata.toJSON(message.mistral);
    }
    if (message.ollama !== undefined) {
      obj.ollama = GenerativeOllamaMetadata.toJSON(message.ollama);
    }
    if (message.openai !== undefined) {
      obj.openai = GenerativeOpenAIMetadata.toJSON(message.openai);
    }
    if (message.google !== undefined) {
      obj.google = GenerativeGoogleMetadata.toJSON(message.google);
    }
    if (message.databricks !== undefined) {
      obj.databricks = GenerativeDatabricksMetadata.toJSON(message.databricks);
    }
    if (message.friendliai !== undefined) {
      obj.friendliai = GenerativeFriendliAIMetadata.toJSON(message.friendliai);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeMetadata>): GenerativeMetadata {
    return GenerativeMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeMetadata>): GenerativeMetadata {
    const message = createBaseGenerativeMetadata();
    message.anthropic = (object.anthropic !== undefined && object.anthropic !== null)
      ? GenerativeAnthropicMetadata.fromPartial(object.anthropic)
      : undefined;
    message.anyscale = (object.anyscale !== undefined && object.anyscale !== null)
      ? GenerativeAnyscaleMetadata.fromPartial(object.anyscale)
      : undefined;
    message.aws = (object.aws !== undefined && object.aws !== null)
      ? GenerativeAWSMetadata.fromPartial(object.aws)
      : undefined;
    message.cohere = (object.cohere !== undefined && object.cohere !== null)
      ? GenerativeCohereMetadata.fromPartial(object.cohere)
      : undefined;
    message.dummy = (object.dummy !== undefined && object.dummy !== null)
      ? GenerativeDummyMetadata.fromPartial(object.dummy)
      : undefined;
    message.mistral = (object.mistral !== undefined && object.mistral !== null)
      ? GenerativeMistralMetadata.fromPartial(object.mistral)
      : undefined;
    message.ollama = (object.ollama !== undefined && object.ollama !== null)
      ? GenerativeOllamaMetadata.fromPartial(object.ollama)
      : undefined;
    message.openai = (object.openai !== undefined && object.openai !== null)
      ? GenerativeOpenAIMetadata.fromPartial(object.openai)
      : undefined;
    message.google = (object.google !== undefined && object.google !== null)
      ? GenerativeGoogleMetadata.fromPartial(object.google)
      : undefined;
    message.databricks = (object.databricks !== undefined && object.databricks !== null)
      ? GenerativeDatabricksMetadata.fromPartial(object.databricks)
      : undefined;
    message.friendliai = (object.friendliai !== undefined && object.friendliai !== null)
      ? GenerativeFriendliAIMetadata.fromPartial(object.friendliai)
      : undefined;
    return message;
  },
};

function createBaseGenerativeReply(): GenerativeReply {
  return { result: "", debug: undefined, metadata: undefined };
}

export const GenerativeReply = {
  encode(message: GenerativeReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.debug !== undefined) {
      GenerativeDebug.encode(message.debug, writer.uint32(18).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      GenerativeMetadata.encode(message.metadata, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.debug = GenerativeDebug.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = GenerativeMetadata.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeReply {
    return {
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      debug: isSet(object.debug) ? GenerativeDebug.fromJSON(object.debug) : undefined,
      metadata: isSet(object.metadata) ? GenerativeMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: GenerativeReply): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.debug !== undefined) {
      obj.debug = GenerativeDebug.toJSON(message.debug);
    }
    if (message.metadata !== undefined) {
      obj.metadata = GenerativeMetadata.toJSON(message.metadata);
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeReply>): GenerativeReply {
    return GenerativeReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeReply>): GenerativeReply {
    const message = createBaseGenerativeReply();
    message.result = object.result ?? "";
    message.debug = (object.debug !== undefined && object.debug !== null)
      ? GenerativeDebug.fromPartial(object.debug)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? GenerativeMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseGenerativeResult(): GenerativeResult {
  return { values: [] };
}

export const GenerativeResult = {
  encode(message: GenerativeResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      GenerativeReply.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(GenerativeReply.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeResult {
    return {
      values: globalThis.Array.isArray(object?.values)
        ? object.values.map((e: any) => GenerativeReply.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerativeResult): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => GenerativeReply.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeResult>): GenerativeResult {
    return GenerativeResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeResult>): GenerativeResult {
    const message = createBaseGenerativeResult();
    message.values = object.values?.map((e) => GenerativeReply.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerativeDebug(): GenerativeDebug {
  return { fullPrompt: undefined };
}

export const GenerativeDebug = {
  encode(message: GenerativeDebug, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fullPrompt !== undefined) {
      writer.uint32(10).string(message.fullPrompt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GenerativeDebug {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerativeDebug();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.fullPrompt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerativeDebug {
    return { fullPrompt: isSet(object.fullPrompt) ? globalThis.String(object.fullPrompt) : undefined };
  },

  toJSON(message: GenerativeDebug): unknown {
    const obj: any = {};
    if (message.fullPrompt !== undefined) {
      obj.fullPrompt = message.fullPrompt;
    }
    return obj;
  },

  create(base?: DeepPartial<GenerativeDebug>): GenerativeDebug {
    return GenerativeDebug.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerativeDebug>): GenerativeDebug {
    const message = createBaseGenerativeDebug();
    message.fullPrompt = object.fullPrompt ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}



---
File: /src/proto/v1/properties.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/properties.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { NullValue, nullValueFromJSON, nullValueToJSON } from "../google/protobuf/struct.js";

export const protobufPackage = "weaviate.v1";

export interface Properties {
  fields: { [key: string]: Value };
}

export interface Properties_FieldsEntry {
  key: string;
  value: Value | undefined;
}

export interface Value {
  numberValue?:
    | number
    | undefined;
  /** @deprecated */
  stringValue?: string | undefined;
  boolValue?: boolean | undefined;
  objectValue?: Properties | undefined;
  listValue?: ListValue | undefined;
  dateValue?: string | undefined;
  uuidValue?: string | undefined;
  intValue?: number | undefined;
  geoValue?: GeoCoordinate | undefined;
  blobValue?: string | undefined;
  phoneValue?: PhoneNumber | undefined;
  nullValue?: NullValue | undefined;
  textValue?: string | undefined;
}

export interface ListValue {
  /** @deprecated */
  values: Value[];
  numberValues?: NumberValues | undefined;
  boolValues?: BoolValues | undefined;
  objectValues?: ObjectValues | undefined;
  dateValues?: DateValues | undefined;
  uuidValues?: UuidValues | undefined;
  intValues?: IntValues | undefined;
  textValues?: TextValues | undefined;
}

export interface NumberValues {
  /**
   * The values are stored as a byte array, where each 8 bytes represent a single float64 value.
   * The byte array is stored in little-endian order using uint64 encoding.
   */
  values: Uint8Array;
}

export interface TextValues {
  values: string[];
}

export interface BoolValues {
  values: boolean[];
}

export interface ObjectValues {
  values: Properties[];
}

export interface DateValues {
  values: string[];
}

export interface UuidValues {
  values: string[];
}

export interface IntValues {
  /**
   * The values are stored as a byte array, where each 8 bytes represent a single int64 value.
   * The byte array is stored in little-endian order using uint64 encoding.
   */
  values: Uint8Array;
}

export interface GeoCoordinate {
  longitude: number;
  latitude: number;
}

export interface PhoneNumber {
  countryCode: number;
  defaultCountry: string;
  input: string;
  internationalFormatted: string;
  national: number;
  nationalFormatted: string;
  valid: boolean;
}

function createBaseProperties(): Properties {
  return { fields: {} };
}

export const Properties = {
  encode(message: Properties, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.fields).forEach(([key, value]) => {
      Properties_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Properties {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = Properties_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Properties {
    return {
      fields: isObject(object.fields)
        ? Object.entries(object.fields).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
          acc[key] = Value.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Properties): unknown {
    const obj: any = {};
    if (message.fields) {
      const entries = Object.entries(message.fields);
      if (entries.length > 0) {
        obj.fields = {};
        entries.forEach(([k, v]) => {
          obj.fields[k] = Value.toJSON(v);
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<Properties>): Properties {
    return Properties.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Properties>): Properties {
    const message = createBaseProperties();
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: Value }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseProperties_FieldsEntry(): Properties_FieldsEntry {
  return { key: "", value: undefined };
}

export const Properties_FieldsEntry = {
  encode(message: Properties_FieldsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Properties_FieldsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperties_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Value.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Properties_FieldsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Value.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: Properties_FieldsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Value.toJSON(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<Properties_FieldsEntry>): Properties_FieldsEntry {
    return Properties_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Properties_FieldsEntry>): Properties_FieldsEntry {
    const message = createBaseProperties_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Value.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseValue(): Value {
  return {
    numberValue: undefined,
    stringValue: undefined,
    boolValue: undefined,
    objectValue: undefined,
    listValue: undefined,
    dateValue: undefined,
    uuidValue: undefined,
    intValue: undefined,
    geoValue: undefined,
    blobValue: undefined,
    phoneValue: undefined,
    nullValue: undefined,
    textValue: undefined,
  };
}

export const Value = {
  encode(message: Value, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.numberValue !== undefined) {
      writer.uint32(9).double(message.numberValue);
    }
    if (message.stringValue !== undefined) {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.boolValue !== undefined) {
      writer.uint32(24).bool(message.boolValue);
    }
    if (message.objectValue !== undefined) {
      Properties.encode(message.objectValue, writer.uint32(34).fork()).ldelim();
    }
    if (message.listValue !== undefined) {
      ListValue.encode(message.listValue, writer.uint32(42).fork()).ldelim();
    }
    if (message.dateValue !== undefined) {
      writer.uint32(50).string(message.dateValue);
    }
    if (message.uuidValue !== undefined) {
      writer.uint32(58).string(message.uuidValue);
    }
    if (message.intValue !== undefined) {
      writer.uint32(64).int64(message.intValue);
    }
    if (message.geoValue !== undefined) {
      GeoCoordinate.encode(message.geoValue, writer.uint32(74).fork()).ldelim();
    }
    if (message.blobValue !== undefined) {
      writer.uint32(82).string(message.blobValue);
    }
    if (message.phoneValue !== undefined) {
      PhoneNumber.encode(message.phoneValue, writer.uint32(90).fork()).ldelim();
    }
    if (message.nullValue !== undefined) {
      writer.uint32(96).int32(message.nullValue);
    }
    if (message.textValue !== undefined) {
      writer.uint32(106).string(message.textValue);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Value {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.numberValue = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stringValue = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.boolValue = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.objectValue = Properties.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.listValue = ListValue.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.dateValue = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.uuidValue = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.intValue = longToNumber(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.geoValue = GeoCoordinate.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.blobValue = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.phoneValue = PhoneNumber.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.nullValue = reader.int32() as any;
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.textValue = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Value {
    return {
      numberValue: isSet(object.numberValue) ? globalThis.Number(object.numberValue) : undefined,
      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,
      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,
      objectValue: isSet(object.objectValue) ? Properties.fromJSON(object.objectValue) : undefined,
      listValue: isSet(object.listValue) ? ListValue.fromJSON(object.listValue) : undefined,
      dateValue: isSet(object.dateValue) ? globalThis.String(object.dateValue) : undefined,
      uuidValue: isSet(object.uuidValue) ? globalThis.String(object.uuidValue) : undefined,
      intValue: isSet(object.intValue) ? globalThis.Number(object.intValue) : undefined,
      geoValue: isSet(object.geoValue) ? GeoCoordinate.fromJSON(object.geoValue) : undefined,
      blobValue: isSet(object.blobValue) ? globalThis.String(object.blobValue) : undefined,
      phoneValue: isSet(object.phoneValue) ? PhoneNumber.fromJSON(object.phoneValue) : undefined,
      nullValue: isSet(object.nullValue) ? nullValueFromJSON(object.nullValue) : undefined,
      textValue: isSet(object.textValue) ? globalThis.String(object.textValue) : undefined,
    };
  },

  toJSON(message: Value): unknown {
    const obj: any = {};
    if (message.numberValue !== undefined) {
      obj.numberValue = message.numberValue;
    }
    if (message.stringValue !== undefined) {
      obj.stringValue = message.stringValue;
    }
    if (message.boolValue !== undefined) {
      obj.boolValue = message.boolValue;
    }
    if (message.objectValue !== undefined) {
      obj.objectValue = Properties.toJSON(message.objectValue);
    }
    if (message.listValue !== undefined) {
      obj.listValue = ListValue.toJSON(message.listValue);
    }
    if (message.dateValue !== undefined) {
      obj.dateValue = message.dateValue;
    }
    if (message.uuidValue !== undefined) {
      obj.uuidValue = message.uuidValue;
    }
    if (message.intValue !== undefined) {
      obj.intValue = Math.round(message.intValue);
    }
    if (message.geoValue !== undefined) {
      obj.geoValue = GeoCoordinate.toJSON(message.geoValue);
    }
    if (message.blobValue !== undefined) {
      obj.blobValue = message.blobValue;
    }
    if (message.phoneValue !== undefined) {
      obj.phoneValue = PhoneNumber.toJSON(message.phoneValue);
    }
    if (message.nullValue !== undefined) {
      obj.nullValue = nullValueToJSON(message.nullValue);
    }
    if (message.textValue !== undefined) {
      obj.textValue = message.textValue;
    }
    return obj;
  },

  create(base?: DeepPartial<Value>): Value {
    return Value.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Value>): Value {
    const message = createBaseValue();
    message.numberValue = object.numberValue ?? undefined;
    message.stringValue = object.stringValue ?? undefined;
    message.boolValue = object.boolValue ?? undefined;
    message.objectValue = (object.objectValue !== undefined && object.objectValue !== null)
      ? Properties.fromPartial(object.objectValue)
      : undefined;
    message.listValue = (object.listValue !== undefined && object.listValue !== null)
      ? ListValue.fromPartial(object.listValue)
      : undefined;
    message.dateValue = object.dateValue ?? undefined;
    message.uuidValue = object.uuidValue ?? undefined;
    message.intValue = object.intValue ?? undefined;
    message.geoValue = (object.geoValue !== undefined && object.geoValue !== null)
      ? GeoCoordinate.fromPartial(object.geoValue)
      : undefined;
    message.blobValue = object.blobValue ?? undefined;
    message.phoneValue = (object.phoneValue !== undefined && object.phoneValue !== null)
      ? PhoneNumber.fromPartial(object.phoneValue)
      : undefined;
    message.nullValue = object.nullValue ?? undefined;
    message.textValue = object.textValue ?? undefined;
    return message;
  },
};

function createBaseListValue(): ListValue {
  return {
    values: [],
    numberValues: undefined,
    boolValues: undefined,
    objectValues: undefined,
    dateValues: undefined,
    uuidValues: undefined,
    intValues: undefined,
    textValues: undefined,
  };
}

export const ListValue = {
  encode(message: ListValue, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      Value.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.numberValues !== undefined) {
      NumberValues.encode(message.numberValues, writer.uint32(18).fork()).ldelim();
    }
    if (message.boolValues !== undefined) {
      BoolValues.encode(message.boolValues, writer.uint32(26).fork()).ldelim();
    }
    if (message.objectValues !== undefined) {
      ObjectValues.encode(message.objectValues, writer.uint32(34).fork()).ldelim();
    }
    if (message.dateValues !== undefined) {
      DateValues.encode(message.dateValues, writer.uint32(42).fork()).ldelim();
    }
    if (message.uuidValues !== undefined) {
      UuidValues.encode(message.uuidValues, writer.uint32(50).fork()).ldelim();
    }
    if (message.intValues !== undefined) {
      IntValues.encode(message.intValues, writer.uint32(58).fork()).ldelim();
    }
    if (message.textValues !== undefined) {
      TextValues.encode(message.textValues, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListValue {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Value.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.numberValues = NumberValues.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.boolValues = BoolValues.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.objectValues = ObjectValues.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.dateValues = DateValues.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.uuidValues = UuidValues.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.intValues = IntValues.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.textValues = TextValues.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListValue {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Value.fromJSON(e)) : [],
      numberValues: isSet(object.numberValues) ? NumberValues.fromJSON(object.numberValues) : undefined,
      boolValues: isSet(object.boolValues) ? BoolValues.fromJSON(object.boolValues) : undefined,
      objectValues: isSet(object.objectValues) ? ObjectValues.fromJSON(object.objectValues) : undefined,
      dateValues: isSet(object.dateValues) ? DateValues.fromJSON(object.dateValues) : undefined,
      uuidValues: isSet(object.uuidValues) ? UuidValues.fromJSON(object.uuidValues) : undefined,
      intValues: isSet(object.intValues) ? IntValues.fromJSON(object.intValues) : undefined,
      textValues: isSet(object.textValues) ? TextValues.fromJSON(object.textValues) : undefined,
    };
  },

  toJSON(message: ListValue): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Value.toJSON(e));
    }
    if (message.numberValues !== undefined) {
      obj.numberValues = NumberValues.toJSON(message.numberValues);
    }
    if (message.boolValues !== undefined) {
      obj.boolValues = BoolValues.toJSON(message.boolValues);
    }
    if (message.objectValues !== undefined) {
      obj.objectValues = ObjectValues.toJSON(message.objectValues);
    }
    if (message.dateValues !== undefined) {
      obj.dateValues = DateValues.toJSON(message.dateValues);
    }
    if (message.uuidValues !== undefined) {
      obj.uuidValues = UuidValues.toJSON(message.uuidValues);
    }
    if (message.intValues !== undefined) {
      obj.intValues = IntValues.toJSON(message.intValues);
    }
    if (message.textValues !== undefined) {
      obj.textValues = TextValues.toJSON(message.textValues);
    }
    return obj;
  },

  create(base?: DeepPartial<ListValue>): ListValue {
    return ListValue.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListValue>): ListValue {
    const message = createBaseListValue();
    message.values = object.values?.map((e) => Value.fromPartial(e)) || [];
    message.numberValues = (object.numberValues !== undefined && object.numberValues !== null)
      ? NumberValues.fromPartial(object.numberValues)
      : undefined;
    message.boolValues = (object.boolValues !== undefined && object.boolValues !== null)
      ? BoolValues.fromPartial(object.boolValues)
      : undefined;
    message.objectValues = (object.objectValues !== undefined && object.objectValues !== null)
      ? ObjectValues.fromPartial(object.objectValues)
      : undefined;
    message.dateValues = (object.dateValues !== undefined && object.dateValues !== null)
      ? DateValues.fromPartial(object.dateValues)
      : undefined;
    message.uuidValues = (object.uuidValues !== undefined && object.uuidValues !== null)
      ? UuidValues.fromPartial(object.uuidValues)
      : undefined;
    message.intValues = (object.intValues !== undefined && object.intValues !== null)
      ? IntValues.fromPartial(object.intValues)
      : undefined;
    message.textValues = (object.textValues !== undefined && object.textValues !== null)
      ? TextValues.fromPartial(object.textValues)
      : undefined;
    return message;
  },
};

function createBaseNumberValues(): NumberValues {
  return { values: new Uint8Array(0) };
}

export const NumberValues = {
  encode(message: NumberValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.values.length !== 0) {
      writer.uint32(10).bytes(message.values);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NumberValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNumberValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NumberValues {
    return { values: isSet(object.values) ? bytesFromBase64(object.values) : new Uint8Array(0) };
  },

  toJSON(message: NumberValues): unknown {
    const obj: any = {};
    if (message.values.length !== 0) {
      obj.values = base64FromBytes(message.values);
    }
    return obj;
  },

  create(base?: DeepPartial<NumberValues>): NumberValues {
    return NumberValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NumberValues>): NumberValues {
    const message = createBaseNumberValues();
    message.values = object.values ?? new Uint8Array(0);
    return message;
  },
};

function createBaseTextValues(): TextValues {
  return { values: [] };
}

export const TextValues = {
  encode(message: TextValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TextValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TextValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<TextValues>): TextValues {
    return TextValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TextValues>): TextValues {
    const message = createBaseTextValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseBoolValues(): BoolValues {
  return { values: [] };
}

export const BoolValues = {
  encode(message: BoolValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.values) {
      writer.bool(v);
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BoolValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.values.push(reader.bool());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.values.push(reader.bool());
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.Boolean(e)) : [],
    };
  },

  toJSON(message: BoolValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<BoolValues>): BoolValues {
    return BoolValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BoolValues>): BoolValues {
    const message = createBaseBoolValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseObjectValues(): ObjectValues {
  return { values: [] };
}

export const ObjectValues = {
  encode(message: ObjectValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      Properties.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ObjectValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(Properties.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => Properties.fromJSON(e)) : [],
    };
  },

  toJSON(message: ObjectValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => Properties.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectValues>): ObjectValues {
    return ObjectValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectValues>): ObjectValues {
    const message = createBaseObjectValues();
    message.values = object.values?.map((e) => Properties.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDateValues(): DateValues {
  return { values: [] };
}

export const DateValues = {
  encode(message: DateValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DateValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDateValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DateValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DateValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<DateValues>): DateValues {
    return DateValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DateValues>): DateValues {
    const message = createBaseDateValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseUuidValues(): UuidValues {
  return { values: [] };
}

export const UuidValues = {
  encode(message: UuidValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UuidValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUuidValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UuidValues {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UuidValues): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<UuidValues>): UuidValues {
    return UuidValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UuidValues>): UuidValues {
    const message = createBaseUuidValues();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseIntValues(): IntValues {
  return { values: new Uint8Array(0) };
}

export const IntValues = {
  encode(message: IntValues, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.values.length !== 0) {
      writer.uint32(10).bytes(message.values);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): IntValues {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntValues();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntValues {
    return { values: isSet(object.values) ? bytesFromBase64(object.values) : new Uint8Array(0) };
  },

  toJSON(message: IntValues): unknown {
    const obj: any = {};
    if (message.values.length !== 0) {
      obj.values = base64FromBytes(message.values);
    }
    return obj;
  },

  create(base?: DeepPartial<IntValues>): IntValues {
    return IntValues.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IntValues>): IntValues {
    const message = createBaseIntValues();
    message.values = object.values ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGeoCoordinate(): GeoCoordinate {
  return { longitude: 0, latitude: 0 };
}

export const GeoCoordinate = {
  encode(message: GeoCoordinate, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.longitude !== 0) {
      writer.uint32(13).float(message.longitude);
    }
    if (message.latitude !== 0) {
      writer.uint32(21).float(message.latitude);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GeoCoordinate {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeoCoordinate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.longitude = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.latitude = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeoCoordinate {
    return {
      longitude: isSet(object.longitude) ? globalThis.Number(object.longitude) : 0,
      latitude: isSet(object.latitude) ? globalThis.Number(object.latitude) : 0,
    };
  },

  toJSON(message: GeoCoordinate): unknown {
    const obj: any = {};
    if (message.longitude !== 0) {
      obj.longitude = message.longitude;
    }
    if (message.latitude !== 0) {
      obj.latitude = message.latitude;
    }
    return obj;
  },

  create(base?: DeepPartial<GeoCoordinate>): GeoCoordinate {
    return GeoCoordinate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GeoCoordinate>): GeoCoordinate {
    const message = createBaseGeoCoordinate();
    message.longitude = object.longitude ?? 0;
    message.latitude = object.latitude ?? 0;
    return message;
  },
};

function createBasePhoneNumber(): PhoneNumber {
  return {
    countryCode: 0,
    defaultCountry: "",
    input: "",
    internationalFormatted: "",
    national: 0,
    nationalFormatted: "",
    valid: false,
  };
}

export const PhoneNumber = {
  encode(message: PhoneNumber, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.countryCode !== 0) {
      writer.uint32(8).uint64(message.countryCode);
    }
    if (message.defaultCountry !== "") {
      writer.uint32(18).string(message.defaultCountry);
    }
    if (message.input !== "") {
      writer.uint32(26).string(message.input);
    }
    if (message.internationalFormatted !== "") {
      writer.uint32(34).string(message.internationalFormatted);
    }
    if (message.national !== 0) {
      writer.uint32(40).uint64(message.national);
    }
    if (message.nationalFormatted !== "") {
      writer.uint32(50).string(message.nationalFormatted);
    }
    if (message.valid !== false) {
      writer.uint32(56).bool(message.valid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PhoneNumber {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePhoneNumber();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.countryCode = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.defaultCountry = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.input = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.internationalFormatted = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.national = longToNumber(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.nationalFormatted = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.valid = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PhoneNumber {
    return {
      countryCode: isSet(object.countryCode) ? globalThis.Number(object.countryCode) : 0,
      defaultCountry: isSet(object.defaultCountry) ? globalThis.String(object.defaultCountry) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      internationalFormatted: isSet(object.internationalFormatted)
        ? globalThis.String(object.internationalFormatted)
        : "",
      national: isSet(object.national) ? globalThis.Number(object.national) : 0,
      nationalFormatted: isSet(object.nationalFormatted) ? globalThis.String(object.nationalFormatted) : "",
      valid: isSet(object.valid) ? globalThis.Boolean(object.valid) : false,
    };
  },

  toJSON(message: PhoneNumber): unknown {
    const obj: any = {};
    if (message.countryCode !== 0) {
      obj.countryCode = Math.round(message.countryCode);
    }
    if (message.defaultCountry !== "") {
      obj.defaultCountry = message.defaultCountry;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.internationalFormatted !== "") {
      obj.internationalFormatted = message.internationalFormatted;
    }
    if (message.national !== 0) {
      obj.national = Math.round(message.national);
    }
    if (message.nationalFormatted !== "") {
      obj.nationalFormatted = message.nationalFormatted;
    }
    if (message.valid !== false) {
      obj.valid = message.valid;
    }
    return obj;
  },

  create(base?: DeepPartial<PhoneNumber>): PhoneNumber {
    return PhoneNumber.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PhoneNumber>): PhoneNumber {
    const message = createBasePhoneNumber();
    message.countryCode = object.countryCode ?? 0;
    message.defaultCountry = object.defaultCountry ?? "";
    message.input = object.input ?? "";
    message.internationalFormatted = object.internationalFormatted ?? "";
    message.national = object.national ?? 0;
    message.nationalFormatted = object.nationalFormatted ?? "";
    message.valid = object.valid ?? false;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}



---
File: /src/proto/v1/search_get.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/search_get.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { Struct } from "../google/protobuf/struct.js";
import {
  BooleanArrayProperties,
  ConsistencyLevel,
  consistencyLevelFromJSON,
  consistencyLevelToJSON,
  Filters,
  IntArrayProperties,
  NumberArrayProperties,
  ObjectArrayProperties,
  ObjectProperties,
  TextArrayProperties,
  Vectors,
} from "./base.js";
import { GenerativeReply, GenerativeResult, GenerativeSearch } from "./generative.js";
import { Properties } from "./properties.js";

export const protobufPackage = "weaviate.v1";

export enum CombinationMethod {
  COMBINATION_METHOD_UNSPECIFIED = 0,
  COMBINATION_METHOD_TYPE_SUM = 1,
  COMBINATION_METHOD_TYPE_MIN = 2,
  COMBINATION_METHOD_TYPE_AVERAGE = 3,
  COMBINATION_METHOD_TYPE_RELATIVE_SCORE = 4,
  COMBINATION_METHOD_TYPE_MANUAL = 5,
  UNRECOGNIZED = -1,
}

export function combinationMethodFromJSON(object: any): CombinationMethod {
  switch (object) {
    case 0:
    case "COMBINATION_METHOD_UNSPECIFIED":
      return CombinationMethod.COMBINATION_METHOD_UNSPECIFIED;
    case 1:
    case "COMBINATION_METHOD_TYPE_SUM":
      return CombinationMethod.COMBINATION_METHOD_TYPE_SUM;
    case 2:
    case "COMBINATION_METHOD_TYPE_MIN":
      return CombinationMethod.COMBINATION_METHOD_TYPE_MIN;
    case 3:
    case "COMBINATION_METHOD_TYPE_AVERAGE":
      return CombinationMethod.COMBINATION_METHOD_TYPE_AVERAGE;
    case 4:
    case "COMBINATION_METHOD_TYPE_RELATIVE_SCORE":
      return CombinationMethod.COMBINATION_METHOD_TYPE_RELATIVE_SCORE;
    case 5:
    case "COMBINATION_METHOD_TYPE_MANUAL":
      return CombinationMethod.COMBINATION_METHOD_TYPE_MANUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CombinationMethod.UNRECOGNIZED;
  }
}

export function combinationMethodToJSON(object: CombinationMethod): string {
  switch (object) {
    case CombinationMethod.COMBINATION_METHOD_UNSPECIFIED:
      return "COMBINATION_METHOD_UNSPECIFIED";
    case CombinationMethod.COMBINATION_METHOD_TYPE_SUM:
      return "COMBINATION_METHOD_TYPE_SUM";
    case CombinationMethod.COMBINATION_METHOD_TYPE_MIN:
      return "COMBINATION_METHOD_TYPE_MIN";
    case CombinationMethod.COMBINATION_METHOD_TYPE_AVERAGE:
      return "COMBINATION_METHOD_TYPE_AVERAGE";
    case CombinationMethod.COMBINATION_METHOD_TYPE_RELATIVE_SCORE:
      return "COMBINATION_METHOD_TYPE_RELATIVE_SCORE";
    case CombinationMethod.COMBINATION_METHOD_TYPE_MANUAL:
      return "COMBINATION_METHOD_TYPE_MANUAL";
    case CombinationMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SearchRequest {
  /** required */
  collection: string;
  /** parameters */
  tenant: string;
  consistencyLevel?:
    | ConsistencyLevel
    | undefined;
  /** what is returned */
  properties?: PropertiesRequest | undefined;
  metadata?: MetadataRequest | undefined;
  groupBy?:
    | GroupBy
    | undefined;
  /** affects order and length of results. 0/empty (default value) means disabled */
  limit: number;
  offset: number;
  autocut: number;
  after: string;
  /** protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED */
  sortBy: SortBy[];
  /** matches/searches for objects */
  filters?: Filters | undefined;
  hybridSearch?: Hybrid | undefined;
  bm25Search?: BM25 | undefined;
  nearVector?: NearVector | undefined;
  nearObject?: NearObject | undefined;
  nearText?: NearTextSearch | undefined;
  nearImage?: NearImageSearch | undefined;
  nearAudio?: NearAudioSearch | undefined;
  nearVideo?: NearVideoSearch | undefined;
  nearDepth?: NearDepthSearch | undefined;
  nearThermal?: NearThermalSearch | undefined;
  nearImu?: NearIMUSearch | undefined;
  generative?: GenerativeSearch | undefined;
  rerank?:
    | Rerank
    | undefined;
  /** @deprecated */
  uses123Api: boolean;
  /** @deprecated */
  uses125Api: boolean;
  uses127Api: boolean;
}

export interface GroupBy {
  /**
   * currently only supports one entry (eg just properties, no refs). But might
   * be extended in the future.
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   */
  path: string[];
  numberOfGroups: number;
  objectsPerGroup: number;
}

export interface SortBy {
  ascending: boolean;
  /**
   * currently only supports one entry (eg just properties, no refs). But the
   * weaviate datastructure already has paths in it and this makes it easily
   * extendable in the future
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   */
  path: string[];
}

export interface MetadataRequest {
  uuid: boolean;
  vector: boolean;
  creationTimeUnix: boolean;
  lastUpdateTimeUnix: boolean;
  distance: boolean;
  certainty: boolean;
  score: boolean;
  explainScore: boolean;
  isConsistent: boolean;
  vectors: string[];
}

export interface PropertiesRequest {
  nonRefProperties: string[];
  refProperties: RefPropertiesRequest[];
  objectProperties: ObjectPropertiesRequest[];
  returnAllNonrefProperties: boolean;
}

export interface ObjectPropertiesRequest {
  propName: string;
  primitiveProperties: string[];
  objectProperties: ObjectPropertiesRequest[];
}

export interface WeightsForTarget {
  target: string;
  weight: number;
}

export interface Targets {
  targetVectors: string[];
  combination: CombinationMethod;
  /**
   * deprecated in 1.26.2 - use weights_for_targets
   *
   * @deprecated
   */
  weights: { [key: string]: number };
  weightsForTargets: WeightsForTarget[];
}

export interface Targets_WeightsEntry {
  key: string;
  value: number;
}

export interface Hybrid {
  query: string;
  properties: string[];
  /**
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   *
   * @deprecated
   */
  vector: number[];
  alpha: number;
  fusionType: Hybrid_FusionType;
  vectorBytes: Uint8Array;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  /** targets in msg is ignored and should not be set for hybrid */
  nearText:
    | NearTextSearch
    | undefined;
  /** same as above. Use the target vector in the hybrid message */
  nearVector: NearVector | undefined;
  targets: Targets | undefined;
  vectorDistance?: number | undefined;
}

export enum Hybrid_FusionType {
  FUSION_TYPE_UNSPECIFIED = 0,
  FUSION_TYPE_RANKED = 1,
  FUSION_TYPE_RELATIVE_SCORE = 2,
  UNRECOGNIZED = -1,
}

export function hybrid_FusionTypeFromJSON(object: any): Hybrid_FusionType {
  switch (object) {
    case 0:
    case "FUSION_TYPE_UNSPECIFIED":
      return Hybrid_FusionType.FUSION_TYPE_UNSPECIFIED;
    case 1:
    case "FUSION_TYPE_RANKED":
      return Hybrid_FusionType.FUSION_TYPE_RANKED;
    case 2:
    case "FUSION_TYPE_RELATIVE_SCORE":
      return Hybrid_FusionType.FUSION_TYPE_RELATIVE_SCORE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Hybrid_FusionType.UNRECOGNIZED;
  }
}

export function hybrid_FusionTypeToJSON(object: Hybrid_FusionType): string {
  switch (object) {
    case Hybrid_FusionType.FUSION_TYPE_UNSPECIFIED:
      return "FUSION_TYPE_UNSPECIFIED";
    case Hybrid_FusionType.FUSION_TYPE_RANKED:
      return "FUSION_TYPE_RANKED";
    case Hybrid_FusionType.FUSION_TYPE_RELATIVE_SCORE:
      return "FUSION_TYPE_RELATIVE_SCORE";
    case Hybrid_FusionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface NearTextSearch {
  /** protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED */
  query: string[];
  certainty?: number | undefined;
  distance?: number | undefined;
  moveTo?: NearTextSearch_Move | undefined;
  moveAway?:
    | NearTextSearch_Move
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearTextSearch_Move {
  force: number;
  concepts: string[];
  uuids: string[];
}

export interface NearImageSearch {
  image: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearAudioSearch {
  audio: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearVideoSearch {
  video: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearDepthSearch {
  depth: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearThermalSearch {
  thermal: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearIMUSearch {
  imu: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface BM25 {
  query: string;
  properties: string[];
}

export interface RefPropertiesRequest {
  referenceProperty: string;
  properties: PropertiesRequest | undefined;
  metadata: MetadataRequest | undefined;
  targetCollection: string;
}

export interface VectorForTarget {
  name: string;
  vectorBytes: Uint8Array;
}

export interface NearVector {
  /**
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   *
   * @deprecated
   */
  vector: number[];
  certainty?: number | undefined;
  distance?: number | undefined;
  vectorBytes: Uint8Array;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets:
    | Targets
    | undefined;
  /**
   * deprecated in 1.26.2 - use vector_for_targets
   *
   * @deprecated
   */
  vectorPerTarget: { [key: string]: Uint8Array };
  vectorForTargets: VectorForTarget[];
}

export interface NearVector_VectorPerTargetEntry {
  key: string;
  value: Uint8Array;
}

export interface NearObject {
  id: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface Rerank {
  property: string;
  query?: string | undefined;
}

export interface SearchReply {
  took: number;
  results: SearchResult[];
  /** @deprecated */
  generativeGroupedResult?: string | undefined;
  groupByResults: GroupByResult[];
  generativeGroupedResults?: GenerativeResult | undefined;
}

export interface RerankReply {
  score: number;
}

export interface GroupByResult {
  name: string;
  minDistance: number;
  maxDistance: number;
  numberOfObjects: number;
  objects: SearchResult[];
  rerank?:
    | RerankReply
    | undefined;
  /** @deprecated */
  generative?: GenerativeReply | undefined;
  generativeResult?: GenerativeResult | undefined;
}

export interface SearchResult {
  properties: PropertiesResult | undefined;
  metadata: MetadataResult | undefined;
  generative?: GenerativeResult | undefined;
}

export interface MetadataResult {
  id: string;
  /**
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   *
   * @deprecated
   */
  vector: number[];
  creationTimeUnix: number;
  creationTimeUnixPresent: boolean;
  lastUpdateTimeUnix: number;
  lastUpdateTimeUnixPresent: boolean;
  distance: number;
  distancePresent: boolean;
  certainty: number;
  certaintyPresent: boolean;
  score: number;
  scorePresent: boolean;
  explainScore: string;
  explainScorePresent: boolean;
  isConsistent?:
    | boolean
    | undefined;
  /** @deprecated */
  generative: string;
  /** @deprecated */
  generativePresent: boolean;
  isConsistentPresent: boolean;
  vectorBytes: Uint8Array;
  idAsBytes: Uint8Array;
  rerankScore: number;
  rerankScorePresent: boolean;
  vectors: Vectors[];
}

export interface PropertiesResult {
  /** @deprecated */
  nonRefProperties: { [key: string]: any } | undefined;
  refProps: RefPropertiesResult[];
  targetCollection: string;
  metadata:
    | MetadataResult
    | undefined;
  /** @deprecated */
  numberArrayProperties: NumberArrayProperties[];
  /** @deprecated */
  intArrayProperties: IntArrayProperties[];
  /** @deprecated */
  textArrayProperties: TextArrayProperties[];
  /** @deprecated */
  booleanArrayProperties: BooleanArrayProperties[];
  /** @deprecated */
  objectProperties: ObjectProperties[];
  /** @deprecated */
  objectArrayProperties: ObjectArrayProperties[];
  nonRefProps: Properties | undefined;
  refPropsRequested: boolean;
}

export interface RefPropertiesResult {
  properties: PropertiesResult[];
  propName: string;
}

function createBaseSearchRequest(): SearchRequest {
  return {
    collection: "",
    tenant: "",
    consistencyLevel: undefined,
    properties: undefined,
    metadata: undefined,
    groupBy: undefined,
    limit: 0,
    offset: 0,
    autocut: 0,
    after: "",
    sortBy: [],
    filters: undefined,
    hybridSearch: undefined,
    bm25Search: undefined,
    nearVector: undefined,
    nearObject: undefined,
    nearText: undefined,
    nearImage: undefined,
    nearAudio: undefined,
    nearVideo: undefined,
    nearDepth: undefined,
    nearThermal: undefined,
    nearImu: undefined,
    generative: undefined,
    rerank: undefined,
    uses123Api: false,
    uses125Api: false,
    uses127Api: false,
  };
}

export const SearchRequest = {
  encode(message: SearchRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.tenant !== "") {
      writer.uint32(82).string(message.tenant);
    }
    if (message.consistencyLevel !== undefined) {
      writer.uint32(88).int32(message.consistencyLevel);
    }
    if (message.properties !== undefined) {
      PropertiesRequest.encode(message.properties, writer.uint32(162).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      MetadataRequest.encode(message.metadata, writer.uint32(170).fork()).ldelim();
    }
    if (message.groupBy !== undefined) {
      GroupBy.encode(message.groupBy, writer.uint32(178).fork()).ldelim();
    }
    if (message.limit !== 0) {
      writer.uint32(240).uint32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(248).uint32(message.offset);
    }
    if (message.autocut !== 0) {
      writer.uint32(256).uint32(message.autocut);
    }
    if (message.after !== "") {
      writer.uint32(266).string(message.after);
    }
    for (const v of message.sortBy) {
      SortBy.encode(v!, writer.uint32(274).fork()).ldelim();
    }
    if (message.filters !== undefined) {
      Filters.encode(message.filters, writer.uint32(322).fork()).ldelim();
    }
    if (message.hybridSearch !== undefined) {
      Hybrid.encode(message.hybridSearch, writer.uint32(330).fork()).ldelim();
    }
    if (message.bm25Search !== undefined) {
      BM25.encode(message.bm25Search, writer.uint32(338).fork()).ldelim();
    }
    if (message.nearVector !== undefined) {
      NearVector.encode(message.nearVector, writer.uint32(346).fork()).ldelim();
    }
    if (message.nearObject !== undefined) {
      NearObject.encode(message.nearObject, writer.uint32(354).fork()).ldelim();
    }
    if (message.nearText !== undefined) {
      NearTextSearch.encode(message.nearText, writer.uint32(362).fork()).ldelim();
    }
    if (message.nearImage !== undefined) {
      NearImageSearch.encode(message.nearImage, writer.uint32(370).fork()).ldelim();
    }
    if (message.nearAudio !== undefined) {
      NearAudioSearch.encode(message.nearAudio, writer.uint32(378).fork()).ldelim();
    }
    if (message.nearVideo !== undefined) {
      NearVideoSearch.encode(message.nearVideo, writer.uint32(386).fork()).ldelim();
    }
    if (message.nearDepth !== undefined) {
      NearDepthSearch.encode(message.nearDepth, writer.uint32(394).fork()).ldelim();
    }
    if (message.nearThermal !== undefined) {
      NearThermalSearch.encode(message.nearThermal, writer.uint32(402).fork()).ldelim();
    }
    if (message.nearImu !== undefined) {
      NearIMUSearch.encode(message.nearImu, writer.uint32(410).fork()).ldelim();
    }
    if (message.generative !== undefined) {
      GenerativeSearch.encode(message.generative, writer.uint32(482).fork()).ldelim();
    }
    if (message.rerank !== undefined) {
      Rerank.encode(message.rerank, writer.uint32(490).fork()).ldelim();
    }
    if (message.uses123Api !== false) {
      writer.uint32(800).bool(message.uses123Api);
    }
    if (message.uses125Api !== false) {
      writer.uint32(808).bool(message.uses125Api);
    }
    if (message.uses127Api !== false) {
      writer.uint32(816).bool(message.uses127Api);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tenant = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.consistencyLevel = reader.int32() as any;
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.properties = PropertiesRequest.decode(reader, reader.uint32());
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.metadata = MetadataRequest.decode(reader, reader.uint32());
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.groupBy = GroupBy.decode(reader, reader.uint32());
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.offset = reader.uint32();
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.autocut = reader.uint32();
          continue;
        case 33:
          if (tag !== 266) {
            break;
          }

          message.after = reader.string();
          continue;
        case 34:
          if (tag !== 274) {
            break;
          }

          message.sortBy.push(SortBy.decode(reader, reader.uint32()));
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.filters = Filters.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.hybridSearch = Hybrid.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.bm25Search = BM25.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.nearVector = NearVector.decode(reader, reader.uint32());
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.nearObject = NearObject.decode(reader, reader.uint32());
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.nearText = NearTextSearch.decode(reader, reader.uint32());
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.nearImage = NearImageSearch.decode(reader, reader.uint32());
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.nearAudio = NearAudioSearch.decode(reader, reader.uint32());
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.nearVideo = NearVideoSearch.decode(reader, reader.uint32());
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.nearDepth = NearDepthSearch.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.nearThermal = NearThermalSearch.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.nearImu = NearIMUSearch.decode(reader, reader.uint32());
          continue;
        case 60:
          if (tag !== 482) {
            break;
          }

          message.generative = GenerativeSearch.decode(reader, reader.uint32());
          continue;
        case 61:
          if (tag !== 490) {
            break;
          }

          message.rerank = Rerank.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 800) {
            break;
          }

          message.uses123Api = reader.bool();
          continue;
        case 101:
          if (tag !== 808) {
            break;
          }

          message.uses125Api = reader.bool();
          continue;
        case 102:
          if (tag !== 816) {
            break;
          }

          message.uses127Api = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      tenant: isSet(object.tenant) ? globalThis.String(object.tenant) : "",
      consistencyLevel: isSet(object.consistencyLevel) ? consistencyLevelFromJSON(object.consistencyLevel) : undefined,
      properties: isSet(object.properties) ? PropertiesRequest.fromJSON(object.properties) : undefined,
      metadata: isSet(object.metadata) ? MetadataRequest.fromJSON(object.metadata) : undefined,
      groupBy: isSet(object.groupBy) ? GroupBy.fromJSON(object.groupBy) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      autocut: isSet(object.autocut) ? globalThis.Number(object.autocut) : 0,
      after: isSet(object.after) ? globalThis.String(object.after) : "",
      sortBy: globalThis.Array.isArray(object?.sortBy) ? object.sortBy.map((e: any) => SortBy.fromJSON(e)) : [],
      filters: isSet(object.filters) ? Filters.fromJSON(object.filters) : undefined,
      hybridSearch: isSet(object.hybridSearch) ? Hybrid.fromJSON(object.hybridSearch) : undefined,
      bm25Search: isSet(object.bm25Search) ? BM25.fromJSON(object.bm25Search) : undefined,
      nearVector: isSet(object.nearVector) ? NearVector.fromJSON(object.nearVector) : undefined,
      nearObject: isSet(object.nearObject) ? NearObject.fromJSON(object.nearObject) : undefined,
      nearText: isSet(object.nearText) ? NearTextSearch.fromJSON(object.nearText) : undefined,
      nearImage: isSet(object.nearImage) ? NearImageSearch.fromJSON(object.nearImage) : undefined,
      nearAudio: isSet(object.nearAudio) ? NearAudioSearch.fromJSON(object.nearAudio) : undefined,
      nearVideo: isSet(object.nearVideo) ? NearVideoSearch.fromJSON(object.nearVideo) : undefined,
      nearDepth: isSet(object.nearDepth) ? NearDepthSearch.fromJSON(object.nearDepth) : undefined,
      nearThermal: isSet(object.nearThermal) ? NearThermalSearch.fromJSON(object.nearThermal) : undefined,
      nearImu: isSet(object.nearImu) ? NearIMUSearch.fromJSON(object.nearImu) : undefined,
      generative: isSet(object.generative) ? GenerativeSearch.fromJSON(object.generative) : undefined,
      rerank: isSet(object.rerank) ? Rerank.fromJSON(object.rerank) : undefined,
      uses123Api: isSet(object.uses123Api) ? globalThis.Boolean(object.uses123Api) : false,
      uses125Api: isSet(object.uses125Api) ? globalThis.Boolean(object.uses125Api) : false,
      uses127Api: isSet(object.uses127Api) ? globalThis.Boolean(object.uses127Api) : false,
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.tenant !== "") {
      obj.tenant = message.tenant;
    }
    if (message.consistencyLevel !== undefined) {
      obj.consistencyLevel = consistencyLevelToJSON(message.consistencyLevel);
    }
    if (message.properties !== undefined) {
      obj.properties = PropertiesRequest.toJSON(message.properties);
    }
    if (message.metadata !== undefined) {
      obj.metadata = MetadataRequest.toJSON(message.metadata);
    }
    if (message.groupBy !== undefined) {
      obj.groupBy = GroupBy.toJSON(message.groupBy);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.autocut !== 0) {
      obj.autocut = Math.round(message.autocut);
    }
    if (message.after !== "") {
      obj.after = message.after;
    }
    if (message.sortBy?.length) {
      obj.sortBy = message.sortBy.map((e) => SortBy.toJSON(e));
    }
    if (message.filters !== undefined) {
      obj.filters = Filters.toJSON(message.filters);
    }
    if (message.hybridSearch !== undefined) {
      obj.hybridSearch = Hybrid.toJSON(message.hybridSearch);
    }
    if (message.bm25Search !== undefined) {
      obj.bm25Search = BM25.toJSON(message.bm25Search);
    }
    if (message.nearVector !== undefined) {
      obj.nearVector = NearVector.toJSON(message.nearVector);
    }
    if (message.nearObject !== undefined) {
      obj.nearObject = NearObject.toJSON(message.nearObject);
    }
    if (message.nearText !== undefined) {
      obj.nearText = NearTextSearch.toJSON(message.nearText);
    }
    if (message.nearImage !== undefined) {
      obj.nearImage = NearImageSearch.toJSON(message.nearImage);
    }
    if (message.nearAudio !== undefined) {
      obj.nearAudio = NearAudioSearch.toJSON(message.nearAudio);
    }
    if (message.nearVideo !== undefined) {
      obj.nearVideo = NearVideoSearch.toJSON(message.nearVideo);
    }
    if (message.nearDepth !== undefined) {
      obj.nearDepth = NearDepthSearch.toJSON(message.nearDepth);
    }
    if (message.nearThermal !== undefined) {
      obj.nearThermal = NearThermalSearch.toJSON(message.nearThermal);
    }
    if (message.nearImu !== undefined) {
      obj.nearImu = NearIMUSearch.toJSON(message.nearImu);
    }
    if (message.generative !== undefined) {
      obj.generative = GenerativeSearch.toJSON(message.generative);
    }
    if (message.rerank !== undefined) {
      obj.rerank = Rerank.toJSON(message.rerank);
    }
    if (message.uses123Api !== false) {
      obj.uses123Api = message.uses123Api;
    }
    if (message.uses125Api !== false) {
      obj.uses125Api = message.uses125Api;
    }
    if (message.uses127Api !== false) {
      obj.uses127Api = message.uses127Api;
    }
    return obj;
  },

  create(base?: DeepPartial<SearchRequest>): SearchRequest {
    return SearchRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchRequest>): SearchRequest {
    const message = createBaseSearchRequest();
    message.collection = object.collection ?? "";
    message.tenant = object.tenant ?? "";
    message.consistencyLevel = object.consistencyLevel ?? undefined;
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? PropertiesRequest.fromPartial(object.properties)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataRequest.fromPartial(object.metadata)
      : undefined;
    message.groupBy = (object.groupBy !== undefined && object.groupBy !== null)
      ? GroupBy.fromPartial(object.groupBy)
      : undefined;
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    message.autocut = object.autocut ?? 0;
    message.after = object.after ?? "";
    message.sortBy = object.sortBy?.map((e) => SortBy.fromPartial(e)) || [];
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? Filters.fromPartial(object.filters)
      : undefined;
    message.hybridSearch = (object.hybridSearch !== undefined && object.hybridSearch !== null)
      ? Hybrid.fromPartial(object.hybridSearch)
      : undefined;
    message.bm25Search = (object.bm25Search !== undefined && object.bm25Search !== null)
      ? BM25.fromPartial(object.bm25Search)
      : undefined;
    message.nearVector = (object.nearVector !== undefined && object.nearVector !== null)
      ? NearVector.fromPartial(object.nearVector)
      : undefined;
    message.nearObject = (object.nearObject !== undefined && object.nearObject !== null)
      ? NearObject.fromPartial(object.nearObject)
      : undefined;
    message.nearText = (object.nearText !== undefined && object.nearText !== null)
      ? NearTextSearch.fromPartial(object.nearText)
      : undefined;
    message.nearImage = (object.nearImage !== undefined && object.nearImage !== null)
      ? NearImageSearch.fromPartial(object.nearImage)
      : undefined;
    message.nearAudio = (object.nearAudio !== undefined && object.nearAudio !== null)
      ? NearAudioSearch.fromPartial(object.nearAudio)
      : undefined;
    message.nearVideo = (object.nearVideo !== undefined && object.nearVideo !== null)
      ? NearVideoSearch.fromPartial(object.nearVideo)
      : undefined;
    message.nearDepth = (object.nearDepth !== undefined && object.nearDepth !== null)
      ? NearDepthSearch.fromPartial(object.nearDepth)
      : undefined;
    message.nearThermal = (object.nearThermal !== undefined && object.nearThermal !== null)
      ? NearThermalSearch.fromPartial(object.nearThermal)
      : undefined;
    message.nearImu = (object.nearImu !== undefined && object.nearImu !== null)
      ? NearIMUSearch.fromPartial(object.nearImu)
      : undefined;
    message.generative = (object.generative !== undefined && object.generative !== null)
      ? GenerativeSearch.fromPartial(object.generative)
      : undefined;
    message.rerank = (object.rerank !== undefined && object.rerank !== null)
      ? Rerank.fromPartial(object.rerank)
      : undefined;
    message.uses123Api = object.uses123Api ?? false;
    message.uses125Api = object.uses125Api ?? false;
    message.uses127Api = object.uses127Api ?? false;
    return message;
  },
};

function createBaseGroupBy(): GroupBy {
  return { path: [], numberOfGroups: 0, objectsPerGroup: 0 };
}

export const GroupBy = {
  encode(message: GroupBy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.path) {
      writer.uint32(10).string(v!);
    }
    if (message.numberOfGroups !== 0) {
      writer.uint32(16).int32(message.numberOfGroups);
    }
    if (message.objectsPerGroup !== 0) {
      writer.uint32(24).int32(message.objectsPerGroup);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupBy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.numberOfGroups = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.objectsPerGroup = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupBy {
    return {
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [],
      numberOfGroups: isSet(object.numberOfGroups) ? globalThis.Number(object.numberOfGroups) : 0,
      objectsPerGroup: isSet(object.objectsPerGroup) ? globalThis.Number(object.objectsPerGroup) : 0,
    };
  },

  toJSON(message: GroupBy): unknown {
    const obj: any = {};
    if (message.path?.length) {
      obj.path = message.path;
    }
    if (message.numberOfGroups !== 0) {
      obj.numberOfGroups = Math.round(message.numberOfGroups);
    }
    if (message.objectsPerGroup !== 0) {
      obj.objectsPerGroup = Math.round(message.objectsPerGroup);
    }
    return obj;
  },

  create(base?: DeepPartial<GroupBy>): GroupBy {
    return GroupBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupBy>): GroupBy {
    const message = createBaseGroupBy();
    message.path = object.path?.map((e) => e) || [];
    message.numberOfGroups = object.numberOfGroups ?? 0;
    message.objectsPerGroup = object.objectsPerGroup ?? 0;
    return message;
  },
};

function createBaseSortBy(): SortBy {
  return { ascending: false, path: [] };
}

export const SortBy = {
  encode(message: SortBy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ascending !== false) {
      writer.uint32(8).bool(message.ascending);
    }
    for (const v of message.path) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SortBy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSortBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ascending = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.path.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SortBy {
    return {
      ascending: isSet(object.ascending) ? globalThis.Boolean(object.ascending) : false,
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: SortBy): unknown {
    const obj: any = {};
    if (message.ascending !== false) {
      obj.ascending = message.ascending;
    }
    if (message.path?.length) {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<SortBy>): SortBy {
    return SortBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SortBy>): SortBy {
    const message = createBaseSortBy();
    message.ascending = object.ascending ?? false;
    message.path = object.path?.map((e) => e) || [];
    return message;
  },
};

function createBaseMetadataRequest(): MetadataRequest {
  return {
    uuid: false,
    vector: false,
    creationTimeUnix: false,
    lastUpdateTimeUnix: false,
    distance: false,
    certainty: false,
    score: false,
    explainScore: false,
    isConsistent: false,
    vectors: [],
  };
}

export const MetadataRequest = {
  encode(message: MetadataRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.uuid !== false) {
      writer.uint32(8).bool(message.uuid);
    }
    if (message.vector !== false) {
      writer.uint32(16).bool(message.vector);
    }
    if (message.creationTimeUnix !== false) {
      writer.uint32(24).bool(message.creationTimeUnix);
    }
    if (message.lastUpdateTimeUnix !== false) {
      writer.uint32(32).bool(message.lastUpdateTimeUnix);
    }
    if (message.distance !== false) {
      writer.uint32(40).bool(message.distance);
    }
    if (message.certainty !== false) {
      writer.uint32(48).bool(message.certainty);
    }
    if (message.score !== false) {
      writer.uint32(56).bool(message.score);
    }
    if (message.explainScore !== false) {
      writer.uint32(64).bool(message.explainScore);
    }
    if (message.isConsistent !== false) {
      writer.uint32(72).bool(message.isConsistent);
    }
    for (const v of message.vectors) {
      writer.uint32(82).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.uuid = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.vector = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.creationTimeUnix = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.lastUpdateTimeUnix = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.distance = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.certainty = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.score = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.explainScore = reader.bool();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.isConsistent = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.vectors.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataRequest {
    return {
      uuid: isSet(object.uuid) ? globalThis.Boolean(object.uuid) : false,
      vector: isSet(object.vector) ? globalThis.Boolean(object.vector) : false,
      creationTimeUnix: isSet(object.creationTimeUnix) ? globalThis.Boolean(object.creationTimeUnix) : false,
      lastUpdateTimeUnix: isSet(object.lastUpdateTimeUnix) ? globalThis.Boolean(object.lastUpdateTimeUnix) : false,
      distance: isSet(object.distance) ? globalThis.Boolean(object.distance) : false,
      certainty: isSet(object.certainty) ? globalThis.Boolean(object.certainty) : false,
      score: isSet(object.score) ? globalThis.Boolean(object.score) : false,
      explainScore: isSet(object.explainScore) ? globalThis.Boolean(object.explainScore) : false,
      isConsistent: isSet(object.isConsistent) ? globalThis.Boolean(object.isConsistent) : false,
      vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MetadataRequest): unknown {
    const obj: any = {};
    if (message.uuid !== false) {
      obj.uuid = message.uuid;
    }
    if (message.vector !== false) {
      obj.vector = message.vector;
    }
    if (message.creationTimeUnix !== false) {
      obj.creationTimeUnix = message.creationTimeUnix;
    }
    if (message.lastUpdateTimeUnix !== false) {
      obj.lastUpdateTimeUnix = message.lastUpdateTimeUnix;
    }
    if (message.distance !== false) {
      obj.distance = message.distance;
    }
    if (message.certainty !== false) {
      obj.certainty = message.certainty;
    }
    if (message.score !== false) {
      obj.score = message.score;
    }
    if (message.explainScore !== false) {
      obj.explainScore = message.explainScore;
    }
    if (message.isConsistent !== false) {
      obj.isConsistent = message.isConsistent;
    }
    if (message.vectors?.length) {
      obj.vectors = message.vectors;
    }
    return obj;
  },

  create(base?: DeepPartial<MetadataRequest>): MetadataRequest {
    return MetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetadataRequest>): MetadataRequest {
    const message = createBaseMetadataRequest();
    message.uuid = object.uuid ?? false;
    message.vector = object.vector ?? false;
    message.creationTimeUnix = object.creationTimeUnix ?? false;
    message.lastUpdateTimeUnix = object.lastUpdateTimeUnix ?? false;
    message.distance = object.distance ?? false;
    message.certainty = object.certainty ?? false;
    message.score = object.score ?? false;
    message.explainScore = object.explainScore ?? false;
    message.isConsistent = object.isConsistent ?? false;
    message.vectors = object.vectors?.map((e) => e) || [];
    return message;
  },
};

function createBasePropertiesRequest(): PropertiesRequest {
  return { nonRefProperties: [], refProperties: [], objectProperties: [], returnAllNonrefProperties: false };
}

export const PropertiesRequest = {
  encode(message: PropertiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.nonRefProperties) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.refProperties) {
      RefPropertiesRequest.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.objectProperties) {
      ObjectPropertiesRequest.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    if (message.returnAllNonrefProperties !== false) {
      writer.uint32(88).bool(message.returnAllNonrefProperties);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PropertiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nonRefProperties.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refProperties.push(RefPropertiesRequest.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.objectProperties.push(ObjectPropertiesRequest.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.returnAllNonrefProperties = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertiesRequest {
    return {
      nonRefProperties: globalThis.Array.isArray(object?.nonRefProperties)
        ? object.nonRefProperties.map((e: any) => globalThis.String(e))
        : [],
      refProperties: globalThis.Array.isArray(object?.refProperties)
        ? object.refProperties.map((e: any) => RefPropertiesRequest.fromJSON(e))
        : [],
      objectProperties: globalThis.Array.isArray(object?.objectProperties)
        ? object.objectProperties.map((e: any) => ObjectPropertiesRequest.fromJSON(e))
        : [],
      returnAllNonrefProperties: isSet(object.returnAllNonrefProperties)
        ? globalThis.Boolean(object.returnAllNonrefProperties)
        : false,
    };
  },

  toJSON(message: PropertiesRequest): unknown {
    const obj: any = {};
    if (message.nonRefProperties?.length) {
      obj.nonRefProperties = message.nonRefProperties;
    }
    if (message.refProperties?.length) {
      obj.refProperties = message.refProperties.map((e) => RefPropertiesRequest.toJSON(e));
    }
    if (message.objectProperties?.length) {
      obj.objectProperties = message.objectProperties.map((e) => ObjectPropertiesRequest.toJSON(e));
    }
    if (message.returnAllNonrefProperties !== false) {
      obj.returnAllNonrefProperties = message.returnAllNonrefProperties;
    }
    return obj;
  },

  create(base?: DeepPartial<PropertiesRequest>): PropertiesRequest {
    return PropertiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertiesRequest>): PropertiesRequest {
    const message = createBasePropertiesRequest();
    message.nonRefProperties = object.nonRefProperties?.map((e) => e) || [];
    message.refProperties = object.refProperties?.map((e) => RefPropertiesRequest.fromPartial(e)) || [];
    message.objectProperties = object.objectProperties?.map((e) => ObjectPropertiesRequest.fromPartial(e)) || [];
    message.returnAllNonrefProperties = object.returnAllNonrefProperties ?? false;
    return message;
  },
};

function createBaseObjectPropertiesRequest(): ObjectPropertiesRequest {
  return { propName: "", primitiveProperties: [], objectProperties: [] };
}

export const ObjectPropertiesRequest = {
  encode(message: ObjectPropertiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.propName !== "") {
      writer.uint32(10).string(message.propName);
    }
    for (const v of message.primitiveProperties) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.objectProperties) {
      ObjectPropertiesRequest.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ObjectPropertiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectPropertiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.propName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.primitiveProperties.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.objectProperties.push(ObjectPropertiesRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectPropertiesRequest {
    return {
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
      primitiveProperties: globalThis.Array.isArray(object?.primitiveProperties)
        ? object.primitiveProperties.map((e: any) => globalThis.String(e))
        : [],
      objectProperties: globalThis.Array.isArray(object?.objectProperties)
        ? object.objectProperties.map((e: any) => ObjectPropertiesRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ObjectPropertiesRequest): unknown {
    const obj: any = {};
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    if (message.primitiveProperties?.length) {
      obj.primitiveProperties = message.primitiveProperties;
    }
    if (message.objectProperties?.length) {
      obj.objectProperties = message.objectProperties.map((e) => ObjectPropertiesRequest.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ObjectPropertiesRequest>): ObjectPropertiesRequest {
    return ObjectPropertiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ObjectPropertiesRequest>): ObjectPropertiesRequest {
    const message = createBaseObjectPropertiesRequest();
    message.propName = object.propName ?? "";
    message.primitiveProperties = object.primitiveProperties?.map((e) => e) || [];
    message.objectProperties = object.objectProperties?.map((e) => ObjectPropertiesRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWeightsForTarget(): WeightsForTarget {
  return { target: "", weight: 0 };
}

export const WeightsForTarget = {
  encode(message: WeightsForTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.weight !== 0) {
      writer.uint32(21).float(message.weight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WeightsForTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightsForTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.weight = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightsForTarget {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: WeightsForTarget): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.weight !== 0) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create(base?: DeepPartial<WeightsForTarget>): WeightsForTarget {
    return WeightsForTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WeightsForTarget>): WeightsForTarget {
    const message = createBaseWeightsForTarget();
    message.target = object.target ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseTargets(): Targets {
  return { targetVectors: [], combination: 0, weights: {}, weightsForTargets: [] };
}

export const Targets = {
  encode(message: Targets, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.targetVectors) {
      writer.uint32(10).string(v!);
    }
    if (message.combination !== 0) {
      writer.uint32(16).int32(message.combination);
    }
    Object.entries(message.weights).forEach(([key, value]) => {
      Targets_WeightsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    for (const v of message.weightsForTargets) {
      WeightsForTarget.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Targets {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.combination = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Targets_WeightsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.weights[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.weightsForTargets.push(WeightsForTarget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Targets {
    return {
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      combination: isSet(object.combination) ? combinationMethodFromJSON(object.combination) : 0,
      weights: isObject(object.weights)
        ? Object.entries(object.weights).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      weightsForTargets: globalThis.Array.isArray(object?.weightsForTargets)
        ? object.weightsForTargets.map((e: any) => WeightsForTarget.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Targets): unknown {
    const obj: any = {};
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.combination !== 0) {
      obj.combination = combinationMethodToJSON(message.combination);
    }
    if (message.weights) {
      const entries = Object.entries(message.weights);
      if (entries.length > 0) {
        obj.weights = {};
        entries.forEach(([k, v]) => {
          obj.weights[k] = v;
        });
      }
    }
    if (message.weightsForTargets?.length) {
      obj.weightsForTargets = message.weightsForTargets.map((e) => WeightsForTarget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Targets>): Targets {
    return Targets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Targets>): Targets {
    const message = createBaseTargets();
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.combination = object.combination ?? 0;
    message.weights = Object.entries(object.weights ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.weightsForTargets = object.weightsForTargets?.map((e) => WeightsForTarget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTargets_WeightsEntry(): Targets_WeightsEntry {
  return { key: "", value: 0 };
}

export const Targets_WeightsEntry = {
  encode(message: Targets_WeightsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Targets_WeightsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargets_WeightsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Targets_WeightsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Targets_WeightsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Targets_WeightsEntry>): Targets_WeightsEntry {
    return Targets_WeightsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Targets_WeightsEntry>): Targets_WeightsEntry {
    const message = createBaseTargets_WeightsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseHybrid(): Hybrid {
  return {
    query: "",
    properties: [],
    vector: [],
    alpha: 0,
    fusionType: 0,
    vectorBytes: new Uint8Array(0),
    targetVectors: [],
    nearText: undefined,
    nearVector: undefined,
    targets: undefined,
    vectorDistance: undefined,
  };
}

export const Hybrid = {
  encode(message: Hybrid, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    for (const v of message.properties) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.alpha !== 0) {
      writer.uint32(37).float(message.alpha);
    }
    if (message.fusionType !== 0) {
      writer.uint32(40).int32(message.fusionType);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(50).bytes(message.vectorBytes);
    }
    for (const v of message.targetVectors) {
      writer.uint32(58).string(v!);
    }
    if (message.nearText !== undefined) {
      NearTextSearch.encode(message.nearText, writer.uint32(66).fork()).ldelim();
    }
    if (message.nearVector !== undefined) {
      NearVector.encode(message.nearVector, writer.uint32(74).fork()).ldelim();
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(82).fork()).ldelim();
    }
    if (message.vectorDistance !== undefined) {
      writer.uint32(165).float(message.vectorDistance);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Hybrid {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHybrid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.properties.push(reader.string());
          continue;
        case 3:
          if (tag === 29) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.alpha = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fusionType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.nearText = NearTextSearch.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.nearVector = NearVector.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 165) {
            break;
          }

          message.vectorDistance = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hybrid {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => globalThis.String(e))
        : [],
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      alpha: isSet(object.alpha) ? globalThis.Number(object.alpha) : 0,
      fusionType: isSet(object.fusionType) ? hybrid_FusionTypeFromJSON(object.fusionType) : 0,
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      nearText: isSet(object.nearText) ? NearTextSearch.fromJSON(object.nearText) : undefined,
      nearVector: isSet(object.nearVector) ? NearVector.fromJSON(object.nearVector) : undefined,
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
      vectorDistance: isSet(object.vectorDistance) ? globalThis.Number(object.vectorDistance) : undefined,
    };
  },

  toJSON(message: Hybrid): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.properties?.length) {
      obj.properties = message.properties;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.alpha !== 0) {
      obj.alpha = message.alpha;
    }
    if (message.fusionType !== 0) {
      obj.fusionType = hybrid_FusionTypeToJSON(message.fusionType);
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.nearText !== undefined) {
      obj.nearText = NearTextSearch.toJSON(message.nearText);
    }
    if (message.nearVector !== undefined) {
      obj.nearVector = NearVector.toJSON(message.nearVector);
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    if (message.vectorDistance !== undefined) {
      obj.vectorDistance = message.vectorDistance;
    }
    return obj;
  },

  create(base?: DeepPartial<Hybrid>): Hybrid {
    return Hybrid.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hybrid>): Hybrid {
    const message = createBaseHybrid();
    message.query = object.query ?? "";
    message.properties = object.properties?.map((e) => e) || [];
    message.vector = object.vector?.map((e) => e) || [];
    message.alpha = object.alpha ?? 0;
    message.fusionType = object.fusionType ?? 0;
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.nearText = (object.nearText !== undefined && object.nearText !== null)
      ? NearTextSearch.fromPartial(object.nearText)
      : undefined;
    message.nearVector = (object.nearVector !== undefined && object.nearVector !== null)
      ? NearVector.fromPartial(object.nearVector)
      : undefined;
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    message.vectorDistance = object.vectorDistance ?? undefined;
    return message;
  },
};

function createBaseNearTextSearch(): NearTextSearch {
  return {
    query: [],
    certainty: undefined,
    distance: undefined,
    moveTo: undefined,
    moveAway: undefined,
    targetVectors: [],
    targets: undefined,
  };
}

export const NearTextSearch = {
  encode(message: NearTextSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.query) {
      writer.uint32(10).string(v!);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    if (message.moveTo !== undefined) {
      NearTextSearch_Move.encode(message.moveTo, writer.uint32(34).fork()).ldelim();
    }
    if (message.moveAway !== undefined) {
      NearTextSearch_Move.encode(message.moveAway, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.targetVectors) {
      writer.uint32(50).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearTextSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearTextSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query.push(reader.string());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.moveTo = NearTextSearch_Move.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.moveAway = NearTextSearch_Move.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearTextSearch {
    return {
      query: globalThis.Array.isArray(object?.query) ? object.query.map((e: any) => globalThis.String(e)) : [],
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      moveTo: isSet(object.moveTo) ? NearTextSearch_Move.fromJSON(object.moveTo) : undefined,
      moveAway: isSet(object.moveAway) ? NearTextSearch_Move.fromJSON(object.moveAway) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearTextSearch): unknown {
    const obj: any = {};
    if (message.query?.length) {
      obj.query = message.query;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.moveTo !== undefined) {
      obj.moveTo = NearTextSearch_Move.toJSON(message.moveTo);
    }
    if (message.moveAway !== undefined) {
      obj.moveAway = NearTextSearch_Move.toJSON(message.moveAway);
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearTextSearch>): NearTextSearch {
    return NearTextSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearTextSearch>): NearTextSearch {
    const message = createBaseNearTextSearch();
    message.query = object.query?.map((e) => e) || [];
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.moveTo = (object.moveTo !== undefined && object.moveTo !== null)
      ? NearTextSearch_Move.fromPartial(object.moveTo)
      : undefined;
    message.moveAway = (object.moveAway !== undefined && object.moveAway !== null)
      ? NearTextSearch_Move.fromPartial(object.moveAway)
      : undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearTextSearch_Move(): NearTextSearch_Move {
  return { force: 0, concepts: [], uuids: [] };
}

export const NearTextSearch_Move = {
  encode(message: NearTextSearch_Move, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.force !== 0) {
      writer.uint32(13).float(message.force);
    }
    for (const v of message.concepts) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.uuids) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearTextSearch_Move {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearTextSearch_Move();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.force = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.concepts.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uuids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearTextSearch_Move {
    return {
      force: isSet(object.force) ? globalThis.Number(object.force) : 0,
      concepts: globalThis.Array.isArray(object?.concepts) ? object.concepts.map((e: any) => globalThis.String(e)) : [],
      uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: NearTextSearch_Move): unknown {
    const obj: any = {};
    if (message.force !== 0) {
      obj.force = message.force;
    }
    if (message.concepts?.length) {
      obj.concepts = message.concepts;
    }
    if (message.uuids?.length) {
      obj.uuids = message.uuids;
    }
    return obj;
  },

  create(base?: DeepPartial<NearTextSearch_Move>): NearTextSearch_Move {
    return NearTextSearch_Move.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearTextSearch_Move>): NearTextSearch_Move {
    const message = createBaseNearTextSearch_Move();
    message.force = object.force ?? 0;
    message.concepts = object.concepts?.map((e) => e) || [];
    message.uuids = object.uuids?.map((e) => e) || [];
    return message;
  },
};

function createBaseNearImageSearch(): NearImageSearch {
  return { image: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearImageSearch = {
  encode(message: NearImageSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.image !== "") {
      writer.uint32(10).string(message.image);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearImageSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearImageSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.image = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearImageSearch {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearImageSearch): unknown {
    const obj: any = {};
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearImageSearch>): NearImageSearch {
    return NearImageSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearImageSearch>): NearImageSearch {
    const message = createBaseNearImageSearch();
    message.image = object.image ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearAudioSearch(): NearAudioSearch {
  return { audio: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearAudioSearch = {
  encode(message: NearAudioSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.audio !== "") {
      writer.uint32(10).string(message.audio);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearAudioSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearAudioSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audio = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearAudioSearch {
    return {
      audio: isSet(object.audio) ? globalThis.String(object.audio) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearAudioSearch): unknown {
    const obj: any = {};
    if (message.audio !== "") {
      obj.audio = message.audio;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearAudioSearch>): NearAudioSearch {
    return NearAudioSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearAudioSearch>): NearAudioSearch {
    const message = createBaseNearAudioSearch();
    message.audio = object.audio ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearVideoSearch(): NearVideoSearch {
  return { video: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearVideoSearch = {
  encode(message: NearVideoSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.video !== "") {
      writer.uint32(10).string(message.video);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearVideoSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearVideoSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.video = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearVideoSearch {
    return {
      video: isSet(object.video) ? globalThis.String(object.video) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearVideoSearch): unknown {
    const obj: any = {};
    if (message.video !== "") {
      obj.video = message.video;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearVideoSearch>): NearVideoSearch {
    return NearVideoSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearVideoSearch>): NearVideoSearch {
    const message = createBaseNearVideoSearch();
    message.video = object.video ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearDepthSearch(): NearDepthSearch {
  return { depth: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearDepthSearch = {
  encode(message: NearDepthSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.depth !== "") {
      writer.uint32(10).string(message.depth);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearDepthSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearDepthSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.depth = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearDepthSearch {
    return {
      depth: isSet(object.depth) ? globalThis.String(object.depth) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearDepthSearch): unknown {
    const obj: any = {};
    if (message.depth !== "") {
      obj.depth = message.depth;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearDepthSearch>): NearDepthSearch {
    return NearDepthSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearDepthSearch>): NearDepthSearch {
    const message = createBaseNearDepthSearch();
    message.depth = object.depth ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearThermalSearch(): NearThermalSearch {
  return { thermal: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearThermalSearch = {
  encode(message: NearThermalSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.thermal !== "") {
      writer.uint32(10).string(message.thermal);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearThermalSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearThermalSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.thermal = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearThermalSearch {
    return {
      thermal: isSet(object.thermal) ? globalThis.String(object.thermal) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearThermalSearch): unknown {
    const obj: any = {};
    if (message.thermal !== "") {
      obj.thermal = message.thermal;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearThermalSearch>): NearThermalSearch {
    return NearThermalSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearThermalSearch>): NearThermalSearch {
    const message = createBaseNearThermalSearch();
    message.thermal = object.thermal ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearIMUSearch(): NearIMUSearch {
  return { imu: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearIMUSearch = {
  encode(message: NearIMUSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.imu !== "") {
      writer.uint32(10).string(message.imu);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearIMUSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearIMUSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imu = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearIMUSearch {
    return {
      imu: isSet(object.imu) ? globalThis.String(object.imu) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearIMUSearch): unknown {
    const obj: any = {};
    if (message.imu !== "") {
      obj.imu = message.imu;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearIMUSearch>): NearIMUSearch {
    return NearIMUSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearIMUSearch>): NearIMUSearch {
    const message = createBaseNearIMUSearch();
    message.imu = object.imu ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseBM25(): BM25 {
  return { query: "", properties: [] };
}

export const BM25 = {
  encode(message: BM25, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    for (const v of message.properties) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BM25 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBM25();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.properties.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BM25 {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: BM25): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.properties?.length) {
      obj.properties = message.properties;
    }
    return obj;
  },

  create(base?: DeepPartial<BM25>): BM25 {
    return BM25.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BM25>): BM25 {
    const message = createBaseBM25();
    message.query = object.query ?? "";
    message.properties = object.properties?.map((e) => e) || [];
    return message;
  },
};

function createBaseRefPropertiesRequest(): RefPropertiesRequest {
  return { referenceProperty: "", properties: undefined, metadata: undefined, targetCollection: "" };
}

export const RefPropertiesRequest = {
  encode(message: RefPropertiesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.referenceProperty !== "") {
      writer.uint32(10).string(message.referenceProperty);
    }
    if (message.properties !== undefined) {
      PropertiesRequest.encode(message.properties, writer.uint32(18).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      MetadataRequest.encode(message.metadata, writer.uint32(26).fork()).ldelim();
    }
    if (message.targetCollection !== "") {
      writer.uint32(34).string(message.targetCollection);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RefPropertiesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefPropertiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.referenceProperty = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.properties = PropertiesRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.metadata = MetadataRequest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetCollection = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefPropertiesRequest {
    return {
      referenceProperty: isSet(object.referenceProperty) ? globalThis.String(object.referenceProperty) : "",
      properties: isSet(object.properties) ? PropertiesRequest.fromJSON(object.properties) : undefined,
      metadata: isSet(object.metadata) ? MetadataRequest.fromJSON(object.metadata) : undefined,
      targetCollection: isSet(object.targetCollection) ? globalThis.String(object.targetCollection) : "",
    };
  },

  toJSON(message: RefPropertiesRequest): unknown {
    const obj: any = {};
    if (message.referenceProperty !== "") {
      obj.referenceProperty = message.referenceProperty;
    }
    if (message.properties !== undefined) {
      obj.properties = PropertiesRequest.toJSON(message.properties);
    }
    if (message.metadata !== undefined) {
      obj.metadata = MetadataRequest.toJSON(message.metadata);
    }
    if (message.targetCollection !== "") {
      obj.targetCollection = message.targetCollection;
    }
    return obj;
  },

  create(base?: DeepPartial<RefPropertiesRequest>): RefPropertiesRequest {
    return RefPropertiesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefPropertiesRequest>): RefPropertiesRequest {
    const message = createBaseRefPropertiesRequest();
    message.referenceProperty = object.referenceProperty ?? "";
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? PropertiesRequest.fromPartial(object.properties)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataRequest.fromPartial(object.metadata)
      : undefined;
    message.targetCollection = object.targetCollection ?? "";
    return message;
  },
};

function createBaseVectorForTarget(): VectorForTarget {
  return { name: "", vectorBytes: new Uint8Array(0) };
}

export const VectorForTarget = {
  encode(message: VectorForTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(18).bytes(message.vectorBytes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VectorForTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVectorForTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VectorForTarget {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: VectorForTarget): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    return obj;
  },

  create(base?: DeepPartial<VectorForTarget>): VectorForTarget {
    return VectorForTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VectorForTarget>): VectorForTarget {
    const message = createBaseVectorForTarget();
    message.name = object.name ?? "";
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNearVector(): NearVector {
  return {
    vector: [],
    certainty: undefined,
    distance: undefined,
    vectorBytes: new Uint8Array(0),
    targetVectors: [],
    targets: undefined,
    vectorPerTarget: {},
    vectorForTargets: [],
  };
}

export const NearVector = {
  encode(message: NearVector, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(34).bytes(message.vectorBytes);
    }
    for (const v of message.targetVectors) {
      writer.uint32(42).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(50).fork()).ldelim();
    }
    Object.entries(message.vectorPerTarget).forEach(([key, value]) => {
      NearVector_VectorPerTargetEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    for (const v of message.vectorForTargets) {
      VectorForTarget.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearVector {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = NearVector_VectorPerTargetEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.vectorPerTarget[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.vectorForTargets.push(VectorForTarget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearVector {
    return {
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
      vectorPerTarget: isObject(object.vectorPerTarget)
        ? Object.entries(object.vectorPerTarget).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      vectorForTargets: globalThis.Array.isArray(object?.vectorForTargets)
        ? object.vectorForTargets.map((e: any) => VectorForTarget.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NearVector): unknown {
    const obj: any = {};
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    if (message.vectorPerTarget) {
      const entries = Object.entries(message.vectorPerTarget);
      if (entries.length > 0) {
        obj.vectorPerTarget = {};
        entries.forEach(([k, v]) => {
          obj.vectorPerTarget[k] = base64FromBytes(v);
        });
      }
    }
    if (message.vectorForTargets?.length) {
      obj.vectorForTargets = message.vectorForTargets.map((e) => VectorForTarget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NearVector>): NearVector {
    return NearVector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearVector>): NearVector {
    const message = createBaseNearVector();
    message.vector = object.vector?.map((e) => e) || [];
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    message.vectorPerTarget = Object.entries(object.vectorPerTarget ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.vectorForTargets = object.vectorForTargets?.map((e) => VectorForTarget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNearVector_VectorPerTargetEntry(): NearVector_VectorPerTargetEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const NearVector_VectorPerTargetEntry = {
  encode(message: NearVector_VectorPerTargetEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearVector_VectorPerTargetEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearVector_VectorPerTargetEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearVector_VectorPerTargetEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: NearVector_VectorPerTargetEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<NearVector_VectorPerTargetEntry>): NearVector_VectorPerTargetEntry {
    return NearVector_VectorPerTargetEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearVector_VectorPerTargetEntry>): NearVector_VectorPerTargetEntry {
    const message = createBaseNearVector_VectorPerTargetEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNearObject(): NearObject {
  return { id: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearObject = {
  encode(message: NearObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearObject {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearObject): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearObject>): NearObject {
    return NearObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearObject>): NearObject {
    const message = createBaseNearObject();
    message.id = object.id ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseRerank(): Rerank {
  return { property: "", query: undefined };
}

export const Rerank = {
  encode(message: Rerank, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    if (message.query !== undefined) {
      writer.uint32(18).string(message.query);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Rerank {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRerank();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.query = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rerank {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      query: isSet(object.query) ? globalThis.String(object.query) : undefined,
    };
  },

  toJSON(message: Rerank): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.query !== undefined) {
      obj.query = message.query;
    }
    return obj;
  },

  create(base?: DeepPartial<Rerank>): Rerank {
    return Rerank.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Rerank>): Rerank {
    const message = createBaseRerank();
    message.property = object.property ?? "";
    message.query = object.query ?? undefined;
    return message;
  },
};

function createBaseSearchReply(): SearchReply {
  return {
    took: 0,
    results: [],
    generativeGroupedResult: undefined,
    groupByResults: [],
    generativeGroupedResults: undefined,
  };
}

export const SearchReply = {
  encode(message: SearchReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.took !== 0) {
      writer.uint32(13).float(message.took);
    }
    for (const v of message.results) {
      SearchResult.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.generativeGroupedResult !== undefined) {
      writer.uint32(26).string(message.generativeGroupedResult);
    }
    for (const v of message.groupByResults) {
      GroupByResult.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.generativeGroupedResults !== undefined) {
      GenerativeResult.encode(message.generativeGroupedResults, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.took = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.generativeGroupedResult = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.groupByResults.push(GroupByResult.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.generativeGroupedResults = GenerativeResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchReply {
    return {
      took: isSet(object.took) ? globalThis.Number(object.took) : 0,
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResult.fromJSON(e))
        : [],
      generativeGroupedResult: isSet(object.generativeGroupedResult)
        ? globalThis.String(object.generativeGroupedResult)
        : undefined,
      groupByResults: globalThis.Array.isArray(object?.groupByResults)
        ? object.groupByResults.map((e: any) => GroupByResult.fromJSON(e))
        : [],
      generativeGroupedResults: isSet(object.generativeGroupedResults)
        ? GenerativeResult.fromJSON(object.generativeGroupedResults)
        : undefined,
    };
  },

  toJSON(message: SearchReply): unknown {
    const obj: any = {};
    if (message.took !== 0) {
      obj.took = message.took;
    }
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResult.toJSON(e));
    }
    if (message.generativeGroupedResult !== undefined) {
      obj.generativeGroupedResult = message.generativeGroupedResult;
    }
    if (message.groupByResults?.length) {
      obj.groupByResults = message.groupByResults.map((e) => GroupByResult.toJSON(e));
    }
    if (message.generativeGroupedResults !== undefined) {
      obj.generativeGroupedResults = GenerativeResult.toJSON(message.generativeGroupedResults);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchReply>): SearchReply {
    return SearchReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchReply>): SearchReply {
    const message = createBaseSearchReply();
    message.took = object.took ?? 0;
    message.results = object.results?.map((e) => SearchResult.fromPartial(e)) || [];
    message.generativeGroupedResult = object.generativeGroupedResult ?? undefined;
    message.groupByResults = object.groupByResults?.map((e) => GroupByResult.fromPartial(e)) || [];
    message.generativeGroupedResults =
      (object.generativeGroupedResults !== undefined && object.generativeGroupedResults !== null)
        ? GenerativeResult.fromPartial(object.generativeGroupedResults)
        : undefined;
    return message;
  },
};

function createBaseRerankReply(): RerankReply {
  return { score: 0 };
}

export const RerankReply = {
  encode(message: RerankReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.score !== 0) {
      writer.uint32(9).double(message.score);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RerankReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRerankReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.score = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RerankReply {
    return { score: isSet(object.score) ? globalThis.Number(object.score) : 0 };
  },

  toJSON(message: RerankReply): unknown {
    const obj: any = {};
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<RerankReply>): RerankReply {
    return RerankReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RerankReply>): RerankReply {
    const message = createBaseRerankReply();
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseGroupByResult(): GroupByResult {
  return {
    name: "",
    minDistance: 0,
    maxDistance: 0,
    numberOfObjects: 0,
    objects: [],
    rerank: undefined,
    generative: undefined,
    generativeResult: undefined,
  };
}

export const GroupByResult = {
  encode(message: GroupByResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.minDistance !== 0) {
      writer.uint32(21).float(message.minDistance);
    }
    if (message.maxDistance !== 0) {
      writer.uint32(29).float(message.maxDistance);
    }
    if (message.numberOfObjects !== 0) {
      writer.uint32(32).int64(message.numberOfObjects);
    }
    for (const v of message.objects) {
      SearchResult.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.rerank !== undefined) {
      RerankReply.encode(message.rerank, writer.uint32(50).fork()).ldelim();
    }
    if (message.generative !== undefined) {
      GenerativeReply.encode(message.generative, writer.uint32(58).fork()).ldelim();
    }
    if (message.generativeResult !== undefined) {
      GenerativeResult.encode(message.generativeResult, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GroupByResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGroupByResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.minDistance = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.maxDistance = reader.float();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.numberOfObjects = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.objects.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.rerank = RerankReply.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.generative = GenerativeReply.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.generativeResult = GenerativeResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GroupByResult {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      minDistance: isSet(object.minDistance) ? globalThis.Number(object.minDistance) : 0,
      maxDistance: isSet(object.maxDistance) ? globalThis.Number(object.maxDistance) : 0,
      numberOfObjects: isSet(object.numberOfObjects) ? globalThis.Number(object.numberOfObjects) : 0,
      objects: globalThis.Array.isArray(object?.objects)
        ? object.objects.map((e: any) => SearchResult.fromJSON(e))
        : [],
      rerank: isSet(object.rerank) ? RerankReply.fromJSON(object.rerank) : undefined,
      generative: isSet(object.generative) ? GenerativeReply.fromJSON(object.generative) : undefined,
      generativeResult: isSet(object.generativeResult) ? GenerativeResult.fromJSON(object.generativeResult) : undefined,
    };
  },

  toJSON(message: GroupByResult): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.minDistance !== 0) {
      obj.minDistance = message.minDistance;
    }
    if (message.maxDistance !== 0) {
      obj.maxDistance = message.maxDistance;
    }
    if (message.numberOfObjects !== 0) {
      obj.numberOfObjects = Math.round(message.numberOfObjects);
    }
    if (message.objects?.length) {
      obj.objects = message.objects.map((e) => SearchResult.toJSON(e));
    }
    if (message.rerank !== undefined) {
      obj.rerank = RerankReply.toJSON(message.rerank);
    }
    if (message.generative !== undefined) {
      obj.generative = GenerativeReply.toJSON(message.generative);
    }
    if (message.generativeResult !== undefined) {
      obj.generativeResult = GenerativeResult.toJSON(message.generativeResult);
    }
    return obj;
  },

  create(base?: DeepPartial<GroupByResult>): GroupByResult {
    return GroupByResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GroupByResult>): GroupByResult {
    const message = createBaseGroupByResult();
    message.name = object.name ?? "";
    message.minDistance = object.minDistance ?? 0;
    message.maxDistance = object.maxDistance ?? 0;
    message.numberOfObjects = object.numberOfObjects ?? 0;
    message.objects = object.objects?.map((e) => SearchResult.fromPartial(e)) || [];
    message.rerank = (object.rerank !== undefined && object.rerank !== null)
      ? RerankReply.fromPartial(object.rerank)
      : undefined;
    message.generative = (object.generative !== undefined && object.generative !== null)
      ? GenerativeReply.fromPartial(object.generative)
      : undefined;
    message.generativeResult = (object.generativeResult !== undefined && object.generativeResult !== null)
      ? GenerativeResult.fromPartial(object.generativeResult)
      : undefined;
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return { properties: undefined, metadata: undefined, generative: undefined };
}

export const SearchResult = {
  encode(message: SearchResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.properties !== undefined) {
      PropertiesResult.encode(message.properties, writer.uint32(10).fork()).ldelim();
    }
    if (message.metadata !== undefined) {
      MetadataResult.encode(message.metadata, writer.uint32(18).fork()).ldelim();
    }
    if (message.generative !== undefined) {
      GenerativeResult.encode(message.generative, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.properties = PropertiesResult.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.metadata = MetadataResult.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.generative = GenerativeResult.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      properties: isSet(object.properties) ? PropertiesResult.fromJSON(object.properties) : undefined,
      metadata: isSet(object.metadata) ? MetadataResult.fromJSON(object.metadata) : undefined,
      generative: isSet(object.generative) ? GenerativeResult.fromJSON(object.generative) : undefined,
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (message.properties !== undefined) {
      obj.properties = PropertiesResult.toJSON(message.properties);
    }
    if (message.metadata !== undefined) {
      obj.metadata = MetadataResult.toJSON(message.metadata);
    }
    if (message.generative !== undefined) {
      obj.generative = GenerativeResult.toJSON(message.generative);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchResult>): SearchResult {
    return SearchResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchResult>): SearchResult {
    const message = createBaseSearchResult();
    message.properties = (object.properties !== undefined && object.properties !== null)
      ? PropertiesResult.fromPartial(object.properties)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataResult.fromPartial(object.metadata)
      : undefined;
    message.generative = (object.generative !== undefined && object.generative !== null)
      ? GenerativeResult.fromPartial(object.generative)
      : undefined;
    return message;
  },
};

function createBaseMetadataResult(): MetadataResult {
  return {
    id: "",
    vector: [],
    creationTimeUnix: 0,
    creationTimeUnixPresent: false,
    lastUpdateTimeUnix: 0,
    lastUpdateTimeUnixPresent: false,
    distance: 0,
    distancePresent: false,
    certainty: 0,
    certaintyPresent: false,
    score: 0,
    scorePresent: false,
    explainScore: "",
    explainScorePresent: false,
    isConsistent: undefined,
    generative: "",
    generativePresent: false,
    isConsistentPresent: false,
    vectorBytes: new Uint8Array(0),
    idAsBytes: new Uint8Array(0),
    rerankScore: 0,
    rerankScorePresent: false,
    vectors: [],
  };
}

export const MetadataResult = {
  encode(message: MetadataResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.creationTimeUnix !== 0) {
      writer.uint32(24).int64(message.creationTimeUnix);
    }
    if (message.creationTimeUnixPresent !== false) {
      writer.uint32(32).bool(message.creationTimeUnixPresent);
    }
    if (message.lastUpdateTimeUnix !== 0) {
      writer.uint32(40).int64(message.lastUpdateTimeUnix);
    }
    if (message.lastUpdateTimeUnixPresent !== false) {
      writer.uint32(48).bool(message.lastUpdateTimeUnixPresent);
    }
    if (message.distance !== 0) {
      writer.uint32(61).float(message.distance);
    }
    if (message.distancePresent !== false) {
      writer.uint32(64).bool(message.distancePresent);
    }
    if (message.certainty !== 0) {
      writer.uint32(77).float(message.certainty);
    }
    if (message.certaintyPresent !== false) {
      writer.uint32(80).bool(message.certaintyPresent);
    }
    if (message.score !== 0) {
      writer.uint32(93).float(message.score);
    }
    if (message.scorePresent !== false) {
      writer.uint32(96).bool(message.scorePresent);
    }
    if (message.explainScore !== "") {
      writer.uint32(106).string(message.explainScore);
    }
    if (message.explainScorePresent !== false) {
      writer.uint32(112).bool(message.explainScorePresent);
    }
    if (message.isConsistent !== undefined) {
      writer.uint32(120).bool(message.isConsistent);
    }
    if (message.generative !== "") {
      writer.uint32(130).string(message.generative);
    }
    if (message.generativePresent !== false) {
      writer.uint32(136).bool(message.generativePresent);
    }
    if (message.isConsistentPresent !== false) {
      writer.uint32(144).bool(message.isConsistentPresent);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(154).bytes(message.vectorBytes);
    }
    if (message.idAsBytes.length !== 0) {
      writer.uint32(162).bytes(message.idAsBytes);
    }
    if (message.rerankScore !== 0) {
      writer.uint32(169).double(message.rerankScore);
    }
    if (message.rerankScorePresent !== false) {
      writer.uint32(176).bool(message.rerankScorePresent);
    }
    for (const v of message.vectors) {
      Vectors.encode(v!, writer.uint32(186).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MetadataResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag === 21) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.creationTimeUnix = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.creationTimeUnixPresent = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.lastUpdateTimeUnix = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.lastUpdateTimeUnixPresent = reader.bool();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.distance = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.distancePresent = reader.bool();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.certainty = reader.float();
          continue;
        case 10:
          if (tag !== 80) {
            break;
          }

          message.certaintyPresent = reader.bool();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.score = reader.float();
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.scorePresent = reader.bool();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.explainScore = reader.string();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.explainScorePresent = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.isConsistent = reader.bool();
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.generative = reader.string();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.generativePresent = reader.bool();
          continue;
        case 18:
          if (tag !== 144) {
            break;
          }

          message.isConsistentPresent = reader.bool();
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.idAsBytes = reader.bytes();
          continue;
        case 21:
          if (tag !== 169) {
            break;
          }

          message.rerankScore = reader.double();
          continue;
        case 22:
          if (tag !== 176) {
            break;
          }

          message.rerankScorePresent = reader.bool();
          continue;
        case 23:
          if (tag !== 186) {
            break;
          }

          message.vectors.push(Vectors.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      creationTimeUnix: isSet(object.creationTimeUnix) ? globalThis.Number(object.creationTimeUnix) : 0,
      creationTimeUnixPresent: isSet(object.creationTimeUnixPresent)
        ? globalThis.Boolean(object.creationTimeUnixPresent)
        : false,
      lastUpdateTimeUnix: isSet(object.lastUpdateTimeUnix) ? globalThis.Number(object.lastUpdateTimeUnix) : 0,
      lastUpdateTimeUnixPresent: isSet(object.lastUpdateTimeUnixPresent)
        ? globalThis.Boolean(object.lastUpdateTimeUnixPresent)
        : false,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      distancePresent: isSet(object.distancePresent) ? globalThis.Boolean(object.distancePresent) : false,
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : 0,
      certaintyPresent: isSet(object.certaintyPresent) ? globalThis.Boolean(object.certaintyPresent) : false,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      scorePresent: isSet(object.scorePresent) ? globalThis.Boolean(object.scorePresent) : false,
      explainScore: isSet(object.explainScore) ? globalThis.String(object.explainScore) : "",
      explainScorePresent: isSet(object.explainScorePresent) ? globalThis.Boolean(object.explainScorePresent) : false,
      isConsistent: isSet(object.isConsistent) ? globalThis.Boolean(object.isConsistent) : undefined,
      generative: isSet(object.generative) ? globalThis.String(object.generative) : "",
      generativePresent: isSet(object.generativePresent) ? globalThis.Boolean(object.generativePresent) : false,
      isConsistentPresent: isSet(object.isConsistentPresent) ? globalThis.Boolean(object.isConsistentPresent) : false,
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
      idAsBytes: isSet(object.idAsBytes) ? bytesFromBase64(object.idAsBytes) : new Uint8Array(0),
      rerankScore: isSet(object.rerankScore) ? globalThis.Number(object.rerankScore) : 0,
      rerankScorePresent: isSet(object.rerankScorePresent) ? globalThis.Boolean(object.rerankScorePresent) : false,
      vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e: any) => Vectors.fromJSON(e)) : [],
    };
  },

  toJSON(message: MetadataResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.creationTimeUnix !== 0) {
      obj.creationTimeUnix = Math.round(message.creationTimeUnix);
    }
    if (message.creationTimeUnixPresent !== false) {
      obj.creationTimeUnixPresent = message.creationTimeUnixPresent;
    }
    if (message.lastUpdateTimeUnix !== 0) {
      obj.lastUpdateTimeUnix = Math.round(message.lastUpdateTimeUnix);
    }
    if (message.lastUpdateTimeUnixPresent !== false) {
      obj.lastUpdateTimeUnixPresent = message.lastUpdateTimeUnixPresent;
    }
    if (message.distance !== 0) {
      obj.distance = message.distance;
    }
    if (message.distancePresent !== false) {
      obj.distancePresent = message.distancePresent;
    }
    if (message.certainty !== 0) {
      obj.certainty = message.certainty;
    }
    if (message.certaintyPresent !== false) {
      obj.certaintyPresent = message.certaintyPresent;
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    if (message.scorePresent !== false) {
      obj.scorePresent = message.scorePresent;
    }
    if (message.explainScore !== "") {
      obj.explainScore = message.explainScore;
    }
    if (message.explainScorePresent !== false) {
      obj.explainScorePresent = message.explainScorePresent;
    }
    if (message.isConsistent !== undefined) {
      obj.isConsistent = message.isConsistent;
    }
    if (message.generative !== "") {
      obj.generative = message.generative;
    }
    if (message.generativePresent !== false) {
      obj.generativePresent = message.generativePresent;
    }
    if (message.isConsistentPresent !== false) {
      obj.isConsistentPresent = message.isConsistentPresent;
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    if (message.idAsBytes.length !== 0) {
      obj.idAsBytes = base64FromBytes(message.idAsBytes);
    }
    if (message.rerankScore !== 0) {
      obj.rerankScore = message.rerankScore;
    }
    if (message.rerankScorePresent !== false) {
      obj.rerankScorePresent = message.rerankScorePresent;
    }
    if (message.vectors?.length) {
      obj.vectors = message.vectors.map((e) => Vectors.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<MetadataResult>): MetadataResult {
    return MetadataResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MetadataResult>): MetadataResult {
    const message = createBaseMetadataResult();
    message.id = object.id ?? "";
    message.vector = object.vector?.map((e) => e) || [];
    message.creationTimeUnix = object.creationTimeUnix ?? 0;
    message.creationTimeUnixPresent = object.creationTimeUnixPresent ?? false;
    message.lastUpdateTimeUnix = object.lastUpdateTimeUnix ?? 0;
    message.lastUpdateTimeUnixPresent = object.lastUpdateTimeUnixPresent ?? false;
    message.distance = object.distance ?? 0;
    message.distancePresent = object.distancePresent ?? false;
    message.certainty = object.certainty ?? 0;
    message.certaintyPresent = object.certaintyPresent ?? false;
    message.score = object.score ?? 0;
    message.scorePresent = object.scorePresent ?? false;
    message.explainScore = object.explainScore ?? "";
    message.explainScorePresent = object.explainScorePresent ?? false;
    message.isConsistent = object.isConsistent ?? undefined;
    message.generative = object.generative ?? "";
    message.generativePresent = object.generativePresent ?? false;
    message.isConsistentPresent = object.isConsistentPresent ?? false;
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    message.idAsBytes = object.idAsBytes ?? new Uint8Array(0);
    message.rerankScore = object.rerankScore ?? 0;
    message.rerankScorePresent = object.rerankScorePresent ?? false;
    message.vectors = object.vectors?.map((e) => Vectors.fromPartial(e)) || [];
    return message;
  },
};

function createBasePropertiesResult(): PropertiesResult {
  return {
    nonRefProperties: undefined,
    refProps: [],
    targetCollection: "",
    metadata: undefined,
    numberArrayProperties: [],
    intArrayProperties: [],
    textArrayProperties: [],
    booleanArrayProperties: [],
    objectProperties: [],
    objectArrayProperties: [],
    nonRefProps: undefined,
    refPropsRequested: false,
  };
}

export const PropertiesResult = {
  encode(message: PropertiesResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.nonRefProperties !== undefined) {
      Struct.encode(Struct.wrap(message.nonRefProperties), writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.refProps) {
      RefPropertiesResult.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.targetCollection !== "") {
      writer.uint32(26).string(message.targetCollection);
    }
    if (message.metadata !== undefined) {
      MetadataResult.encode(message.metadata, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.numberArrayProperties) {
      NumberArrayProperties.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.intArrayProperties) {
      IntArrayProperties.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.textArrayProperties) {
      TextArrayProperties.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.booleanArrayProperties) {
      BooleanArrayProperties.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.objectProperties) {
      ObjectProperties.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    for (const v of message.objectArrayProperties) {
      ObjectArrayProperties.encode(v!, writer.uint32(82).fork()).ldelim();
    }
    if (message.nonRefProps !== undefined) {
      Properties.encode(message.nonRefProps, writer.uint32(90).fork()).ldelim();
    }
    if (message.refPropsRequested !== false) {
      writer.uint32(96).bool(message.refPropsRequested);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PropertiesResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropertiesResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nonRefProperties = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refProps.push(RefPropertiesResult.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.targetCollection = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.metadata = MetadataResult.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.numberArrayProperties.push(NumberArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.intArrayProperties.push(IntArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.textArrayProperties.push(TextArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.booleanArrayProperties.push(BooleanArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.objectProperties.push(ObjectProperties.decode(reader, reader.uint32()));
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.objectArrayProperties.push(ObjectArrayProperties.decode(reader, reader.uint32()));
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.nonRefProps = Properties.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.refPropsRequested = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropertiesResult {
    return {
      nonRefProperties: isObject(object.nonRefProperties) ? object.nonRefProperties : undefined,
      refProps: globalThis.Array.isArray(object?.refProps)
        ? object.refProps.map((e: any) => RefPropertiesResult.fromJSON(e))
        : [],
      targetCollection: isSet(object.targetCollection) ? globalThis.String(object.targetCollection) : "",
      metadata: isSet(object.metadata) ? MetadataResult.fromJSON(object.metadata) : undefined,
      numberArrayProperties: globalThis.Array.isArray(object?.numberArrayProperties)
        ? object.numberArrayProperties.map((e: any) => NumberArrayProperties.fromJSON(e))
        : [],
      intArrayProperties: globalThis.Array.isArray(object?.intArrayProperties)
        ? object.intArrayProperties.map((e: any) => IntArrayProperties.fromJSON(e))
        : [],
      textArrayProperties: globalThis.Array.isArray(object?.textArrayProperties)
        ? object.textArrayProperties.map((e: any) => TextArrayProperties.fromJSON(e))
        : [],
      booleanArrayProperties: globalThis.Array.isArray(object?.booleanArrayProperties)
        ? object.booleanArrayProperties.map((e: any) => BooleanArrayProperties.fromJSON(e))
        : [],
      objectProperties: globalThis.Array.isArray(object?.objectProperties)
        ? object.objectProperties.map((e: any) => ObjectProperties.fromJSON(e))
        : [],
      objectArrayProperties: globalThis.Array.isArray(object?.objectArrayProperties)
        ? object.objectArrayProperties.map((e: any) => ObjectArrayProperties.fromJSON(e))
        : [],
      nonRefProps: isSet(object.nonRefProps) ? Properties.fromJSON(object.nonRefProps) : undefined,
      refPropsRequested: isSet(object.refPropsRequested) ? globalThis.Boolean(object.refPropsRequested) : false,
    };
  },

  toJSON(message: PropertiesResult): unknown {
    const obj: any = {};
    if (message.nonRefProperties !== undefined) {
      obj.nonRefProperties = message.nonRefProperties;
    }
    if (message.refProps?.length) {
      obj.refProps = message.refProps.map((e) => RefPropertiesResult.toJSON(e));
    }
    if (message.targetCollection !== "") {
      obj.targetCollection = message.targetCollection;
    }
    if (message.metadata !== undefined) {
      obj.metadata = MetadataResult.toJSON(message.metadata);
    }
    if (message.numberArrayProperties?.length) {
      obj.numberArrayProperties = message.numberArrayProperties.map((e) => NumberArrayProperties.toJSON(e));
    }
    if (message.intArrayProperties?.length) {
      obj.intArrayProperties = message.intArrayProperties.map((e) => IntArrayProperties.toJSON(e));
    }
    if (message.textArrayProperties?.length) {
      obj.textArrayProperties = message.textArrayProperties.map((e) => TextArrayProperties.toJSON(e));
    }
    if (message.booleanArrayProperties?.length) {
      obj.booleanArrayProperties = message.booleanArrayProperties.map((e) => BooleanArrayProperties.toJSON(e));
    }
    if (message.objectProperties?.length) {
      obj.objectProperties = message.objectProperties.map((e) => ObjectProperties.toJSON(e));
    }
    if (message.objectArrayProperties?.length) {
      obj.objectArrayProperties = message.objectArrayProperties.map((e) => ObjectArrayProperties.toJSON(e));
    }
    if (message.nonRefProps !== undefined) {
      obj.nonRefProps = Properties.toJSON(message.nonRefProps);
    }
    if (message.refPropsRequested !== false) {
      obj.refPropsRequested = message.refPropsRequested;
    }
    return obj;
  },

  create(base?: DeepPartial<PropertiesResult>): PropertiesResult {
    return PropertiesResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PropertiesResult>): PropertiesResult {
    const message = createBasePropertiesResult();
    message.nonRefProperties = object.nonRefProperties ?? undefined;
    message.refProps = object.refProps?.map((e) => RefPropertiesResult.fromPartial(e)) || [];
    message.targetCollection = object.targetCollection ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? MetadataResult.fromPartial(object.metadata)
      : undefined;
    message.numberArrayProperties = object.numberArrayProperties?.map((e) => NumberArrayProperties.fromPartial(e)) ||
      [];
    message.intArrayProperties = object.intArrayProperties?.map((e) => IntArrayProperties.fromPartial(e)) || [];
    message.textArrayProperties = object.textArrayProperties?.map((e) => TextArrayProperties.fromPartial(e)) || [];
    message.booleanArrayProperties = object.booleanArrayProperties?.map((e) => BooleanArrayProperties.fromPartial(e)) ||
      [];
    message.objectProperties = object.objectProperties?.map((e) => ObjectProperties.fromPartial(e)) || [];
    message.objectArrayProperties = object.objectArrayProperties?.map((e) => ObjectArrayProperties.fromPartial(e)) ||
      [];
    message.nonRefProps = (object.nonRefProps !== undefined && object.nonRefProps !== null)
      ? Properties.fromPartial(object.nonRefProps)
      : undefined;
    message.refPropsRequested = object.refPropsRequested ?? false;
    return message;
  },
};

function createBaseRefPropertiesResult(): RefPropertiesResult {
  return { properties: [], propName: "" };
}

export const RefPropertiesResult = {
  encode(message: RefPropertiesResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.properties) {
      PropertiesResult.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.propName !== "") {
      writer.uint32(18).string(message.propName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RefPropertiesResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefPropertiesResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.properties.push(PropertiesResult.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RefPropertiesResult {
    return {
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => PropertiesResult.fromJSON(e))
        : [],
      propName: isSet(object.propName) ? globalThis.String(object.propName) : "",
    };
  },

  toJSON(message: RefPropertiesResult): unknown {
    const obj: any = {};
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => PropertiesResult.toJSON(e));
    }
    if (message.propName !== "") {
      obj.propName = message.propName;
    }
    return obj;
  },

  create(base?: DeepPartial<RefPropertiesResult>): RefPropertiesResult {
    return RefPropertiesResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RefPropertiesResult>): RefPropertiesResult {
    const message = createBaseRefPropertiesResult();
    message.properties = object.properties?.map((e) => PropertiesResult.fromPartial(e)) || [];
    message.propName = object.propName ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}



---
File: /src/proto/v1/tenants.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/tenants.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal.js";

export const protobufPackage = "weaviate.v1";

export enum TenantActivityStatus {
  TENANT_ACTIVITY_STATUS_UNSPECIFIED = 0,
  TENANT_ACTIVITY_STATUS_HOT = 1,
  TENANT_ACTIVITY_STATUS_COLD = 2,
  TENANT_ACTIVITY_STATUS_FROZEN = 4,
  TENANT_ACTIVITY_STATUS_UNFREEZING = 5,
  TENANT_ACTIVITY_STATUS_FREEZING = 6,
  /** TENANT_ACTIVITY_STATUS_ACTIVE - not used yet - added to let the clients already add code to handle this in the future */
  TENANT_ACTIVITY_STATUS_ACTIVE = 7,
  TENANT_ACTIVITY_STATUS_INACTIVE = 8,
  TENANT_ACTIVITY_STATUS_OFFLOADED = 9,
  TENANT_ACTIVITY_STATUS_OFFLOADING = 10,
  TENANT_ACTIVITY_STATUS_ONLOADING = 11,
  UNRECOGNIZED = -1,
}

export function tenantActivityStatusFromJSON(object: any): TenantActivityStatus {
  switch (object) {
    case 0:
    case "TENANT_ACTIVITY_STATUS_UNSPECIFIED":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_UNSPECIFIED;
    case 1:
    case "TENANT_ACTIVITY_STATUS_HOT":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_HOT;
    case 2:
    case "TENANT_ACTIVITY_STATUS_COLD":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_COLD;
    case 4:
    case "TENANT_ACTIVITY_STATUS_FROZEN":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_FROZEN;
    case 5:
    case "TENANT_ACTIVITY_STATUS_UNFREEZING":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_UNFREEZING;
    case 6:
    case "TENANT_ACTIVITY_STATUS_FREEZING":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_FREEZING;
    case 7:
    case "TENANT_ACTIVITY_STATUS_ACTIVE":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_ACTIVE;
    case 8:
    case "TENANT_ACTIVITY_STATUS_INACTIVE":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_INACTIVE;
    case 9:
    case "TENANT_ACTIVITY_STATUS_OFFLOADED":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_OFFLOADED;
    case 10:
    case "TENANT_ACTIVITY_STATUS_OFFLOADING":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_OFFLOADING;
    case 11:
    case "TENANT_ACTIVITY_STATUS_ONLOADING":
      return TenantActivityStatus.TENANT_ACTIVITY_STATUS_ONLOADING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TenantActivityStatus.UNRECOGNIZED;
  }
}

export function tenantActivityStatusToJSON(object: TenantActivityStatus): string {
  switch (object) {
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_UNSPECIFIED:
      return "TENANT_ACTIVITY_STATUS_UNSPECIFIED";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_HOT:
      return "TENANT_ACTIVITY_STATUS_HOT";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_COLD:
      return "TENANT_ACTIVITY_STATUS_COLD";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_FROZEN:
      return "TENANT_ACTIVITY_STATUS_FROZEN";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_UNFREEZING:
      return "TENANT_ACTIVITY_STATUS_UNFREEZING";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_FREEZING:
      return "TENANT_ACTIVITY_STATUS_FREEZING";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_ACTIVE:
      return "TENANT_ACTIVITY_STATUS_ACTIVE";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_INACTIVE:
      return "TENANT_ACTIVITY_STATUS_INACTIVE";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_OFFLOADED:
      return "TENANT_ACTIVITY_STATUS_OFFLOADED";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_OFFLOADING:
      return "TENANT_ACTIVITY_STATUS_OFFLOADING";
    case TenantActivityStatus.TENANT_ACTIVITY_STATUS_ONLOADING:
      return "TENANT_ACTIVITY_STATUS_ONLOADING";
    case TenantActivityStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TenantsGetRequest {
  collection: string;
  names?: TenantNames | undefined;
}

export interface TenantNames {
  values: string[];
}

export interface TenantsGetReply {
  took: number;
  tenants: Tenant[];
}

export interface Tenant {
  name: string;
  activityStatus: TenantActivityStatus;
}

function createBaseTenantsGetRequest(): TenantsGetRequest {
  return { collection: "", names: undefined };
}

export const TenantsGetRequest = {
  encode(message: TenantsGetRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.names !== undefined) {
      TenantNames.encode(message.names, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TenantsGetRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTenantsGetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.names = TenantNames.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TenantsGetRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      names: isSet(object.names) ? TenantNames.fromJSON(object.names) : undefined,
    };
  },

  toJSON(message: TenantsGetRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.names !== undefined) {
      obj.names = TenantNames.toJSON(message.names);
    }
    return obj;
  },

  create(base?: DeepPartial<TenantsGetRequest>): TenantsGetRequest {
    return TenantsGetRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TenantsGetRequest>): TenantsGetRequest {
    const message = createBaseTenantsGetRequest();
    message.collection = object.collection ?? "";
    message.names = (object.names !== undefined && object.names !== null)
      ? TenantNames.fromPartial(object.names)
      : undefined;
    return message;
  },
};

function createBaseTenantNames(): TenantNames {
  return { values: [] };
}

export const TenantNames = {
  encode(message: TenantNames, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.values) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TenantNames {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTenantNames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TenantNames {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TenantNames): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values;
    }
    return obj;
  },

  create(base?: DeepPartial<TenantNames>): TenantNames {
    return TenantNames.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TenantNames>): TenantNames {
    const message = createBaseTenantNames();
    message.values = object.values?.map((e) => e) || [];
    return message;
  },
};

function createBaseTenantsGetReply(): TenantsGetReply {
  return { took: 0, tenants: [] };
}

export const TenantsGetReply = {
  encode(message: TenantsGetReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.took !== 0) {
      writer.uint32(13).float(message.took);
    }
    for (const v of message.tenants) {
      Tenant.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TenantsGetReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTenantsGetReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.took = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tenants.push(Tenant.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TenantsGetReply {
    return {
      took: isSet(object.took) ? globalThis.Number(object.took) : 0,
      tenants: globalThis.Array.isArray(object?.tenants) ? object.tenants.map((e: any) => Tenant.fromJSON(e)) : [],
    };
  },

  toJSON(message: TenantsGetReply): unknown {
    const obj: any = {};
    if (message.took !== 0) {
      obj.took = message.took;
    }
    if (message.tenants?.length) {
      obj.tenants = message.tenants.map((e) => Tenant.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<TenantsGetReply>): TenantsGetReply {
    return TenantsGetReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TenantsGetReply>): TenantsGetReply {
    const message = createBaseTenantsGetReply();
    message.took = object.took ?? 0;
    message.tenants = object.tenants?.map((e) => Tenant.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTenant(): Tenant {
  return { name: "", activityStatus: 0 };
}

export const Tenant = {
  encode(message: Tenant, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.activityStatus !== 0) {
      writer.uint32(16).int32(message.activityStatus);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Tenant {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTenant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.activityStatus = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tenant {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      activityStatus: isSet(object.activityStatus) ? tenantActivityStatusFromJSON(object.activityStatus) : 0,
    };
  },

  toJSON(message: Tenant): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.activityStatus !== 0) {
      obj.activityStatus = tenantActivityStatusToJSON(message.activityStatus);
    }
    return obj;
  },

  create(base?: DeepPartial<Tenant>): Tenant {
    return Tenant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Tenant>): Tenant {
    const message = createBaseTenant();
    message.name = object.name ?? "";
    message.activityStatus = object.activityStatus ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}



---
File: /src/proto/v1/weaviate.ts
---

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/weaviate.proto

/* eslint-disable */
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { BatchObjectsReply, BatchObjectsRequest } from "./batch.js";
import { BatchDeleteReply, BatchDeleteRequest } from "./batch_delete.js";
import { SearchReply, SearchRequest } from "./search_get.js";
import { TenantsGetReply, TenantsGetRequest } from "./tenants.js";

export const protobufPackage = "weaviate.v1";

export type WeaviateDefinition = typeof WeaviateDefinition;
export const WeaviateDefinition = {
  name: "Weaviate",
  fullName: "weaviate.v1.Weaviate",
  methods: {
    search: {
      name: "Search",
      requestType: SearchRequest,
      requestStream: false,
      responseType: SearchReply,
      responseStream: false,
      options: {},
    },
    batchObjects: {
      name: "BatchObjects",
      requestType: BatchObjectsRequest,
      requestStream: false,
      responseType: BatchObjectsReply,
      responseStream: false,
      options: {},
    },
    batchDelete: {
      name: "BatchDelete",
      requestType: BatchDeleteRequest,
      requestStream: false,
      responseType: BatchDeleteReply,
      responseStream: false,
      options: {},
    },
    tenantsGet: {
      name: "TenantsGet",
      requestType: TenantsGetRequest,
      requestStream: false,
      responseType: TenantsGetReply,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface WeaviateServiceImplementation<CallContextExt = {}> {
  search(request: SearchRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SearchReply>>;
  batchObjects(
    request: BatchObjectsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchObjectsReply>>;
  batchDelete(
    request: BatchDeleteRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BatchDeleteReply>>;
  tenantsGet(request: TenantsGetRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TenantsGetReply>>;
}

export interface WeaviateClient<CallOptionsExt = {}> {
  search(request: DeepPartial<SearchRequest>, options?: CallOptions & CallOptionsExt): Promise<SearchReply>;
  batchObjects(
    request: DeepPartial<BatchObjectsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchObjectsReply>;
  batchDelete(
    request: DeepPartial<BatchDeleteRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BatchDeleteReply>;
  tenantsGet(request: DeepPartial<TenantsGetRequest>, options?: CallOptions & CallOptionsExt): Promise<TenantsGetReply>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;



---
File: /src/schema/classCreator.ts
---

import Connection from '../connection/index.js';
import { WeaviateClass } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class ClassCreator extends CommandBase {
  private class!: WeaviateClass;

  constructor(client: Connection) {
    super(client);
  }

  withClass = (classObj: object) => {
    this.class = classObj;
    return this;
  };

  validateClass = () => {
    if (this.class == undefined || this.class == null) {
      this.addError('class object must be set - set with .withClass(class)');
    }
  };

  validate() {
    this.validateClass();
  }

  do = (): Promise<WeaviateClass> => {
    this.validateClass();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const path = `/schema`;
    return this.client.postReturn(path, this.class);
  };
}



---
File: /src/schema/classDeleter.ts
---

import Connection from '../connection/index.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class ClassDeleter extends CommandBase {
  private className?: string;

  constructor(client: Connection) {
    super(client);
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  validate = () => {
    this.validateClassName();
  };

  do = (): Promise<void> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const path = `/schema/${this.className}`;
    return this.client.delete(path, undefined, false);
  };
}



---
File: /src/schema/classExists.ts
---

import Connection from '../connection/index.js';
import { WeaviateSchema } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class ClassExists extends CommandBase {
  private className?: string;

  constructor(client: Connection) {
    super(client);
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  validate = () => {
    this.validateClassName();
  };

  do = (): Promise<boolean> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const path = `/schema`;
    return this.client
      .get(path)
      .then((res: WeaviateSchema) => res.classes?.some((c) => c.class === this.className));
  };
}



---
File: /src/schema/classGetter.ts
---

import Connection from '../connection/index.js';
import { WeaviateClass } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class ClassGetter extends CommandBase {
  private className?: string;

  constructor(client: Connection) {
    super(client);
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  validate = () => {
    this.validateClassName();
  };

  do = (): Promise<WeaviateClass> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const path = `/schema/${this.className}`;
    return this.client.get(path);
  };
}



---
File: /src/schema/classUpdater.ts
---

import Connection from '../connection/index.js';
import { WeaviateClass } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class ClassUpdater extends CommandBase {
  private class!: WeaviateClass;

  constructor(client: Connection) {
    super(client);
  }

  withClass = (classObj: WeaviateClass) => {
    this.class = classObj;
    return this;
  };

  validateClass = () => {
    if (this.class == undefined || this.class == null) {
      this.addError('class object must be set - set with .withClass(class)');
    }
  };

  validate() {
    this.validateClass();
  }

  do = (): Promise<WeaviateClass> => {
    this.validateClass();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const path = `/schema/${this.class.class}`;
    return this.client.put(path, this.class, false);
  };
}



---
File: /src/schema/deleteAll.ts
---

import Connection from '../connection/index.js';
import ClassDeleter from './classDeleter.js';
import SchemaGetter from './getter.js';

export default async (client: Connection) => {
  const getter = new SchemaGetter(client);
  const schema = await getter.do();
  await Promise.all(
    schema.classes
      ? schema.classes.map((c) => {
          const deleter = new ClassDeleter(client);
          return deleter.withClassName(c.class as string).do();
        })
      : []
  );
};



---
File: /src/schema/getter.ts
---

import Connection from '../connection/index.js';
import { WeaviateSchema } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class SchemaGetter extends CommandBase {
  constructor(client: Connection) {
    super(client);
  }

  validate() {
    // nothing to validate
  }

  do = (): Promise<WeaviateSchema> => {
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const path = `/schema`;
    return this.client.get(path);
  };
}



---
File: /src/schema/index.ts
---

import Connection from '../connection/index.js';
import { Tenant } from '../openapi/types.js';
import ClassCreator from './classCreator.js';
import ClassDeleter from './classDeleter.js';
import ClassExists from './classExists.js';
import ClassGetter from './classGetter.js';
import ClassUpdater from './classUpdater.js';
import deleteAll from './deleteAll.js';
import SchemaGetter from './getter.js';
import PropertyCreator from './propertyCreator.js';
import ShardUpdater from './shardUpdater.js';
import ShardsGetter from './shardsGetter.js';
import ShardsUpdater from './shardsUpdater.js';
import TenantsCreator from './tenantsCreator.js';
import TenantsDeleter from './tenantsDeleter.js';
import TenantsExists from './tenantsExists.js';
import TenantsGetter from './tenantsGetter.js';
import TenantsUpdater from './tenantsUpdater.js';

export interface Schema {
  classCreator: () => ClassCreator;
  classDeleter: () => ClassDeleter;
  classGetter: () => ClassGetter;
  classUpdater: () => ClassUpdater;
  exists: (className: string) => Promise<boolean>;
  getter: () => SchemaGetter;
  propertyCreator: () => PropertyCreator;
  deleteAll: () => Promise<void>;
  shardsGetter: () => ShardsGetter;
  shardUpdater: () => ShardUpdater;
  shardsUpdater: () => ShardsUpdater;
  tenantsCreator: (className: string, tenants: Array<Tenant>) => TenantsCreator;
  tenantsGetter: (className: string) => TenantsGetter;
  tenantsUpdater: (className: string, tenants: Array<Tenant>) => TenantsUpdater;
  tenantsDeleter: (className: string, tenants: Array<string>) => TenantsDeleter;
  tenantsExists: (className: string, tenant: string) => TenantsExists;
}

const schema = (client: Connection): Schema => {
  return {
    classCreator: () => new ClassCreator(client),
    classDeleter: () => new ClassDeleter(client),
    classGetter: () => new ClassGetter(client),
    classUpdater: () => new ClassUpdater(client),
    exists: (className: string) => new ClassExists(client).withClassName(className).do(),
    getter: () => new SchemaGetter(client),
    propertyCreator: () => new PropertyCreator(client),
    deleteAll: () => deleteAll(client),
    shardsGetter: () => new ShardsGetter(client),
    shardUpdater: () => new ShardUpdater(client),
    shardsUpdater: () => new ShardsUpdater(client),
    tenantsCreator: (className: string, tenants: Array<Tenant>) =>
      new TenantsCreator(client, className, tenants),
    tenantsGetter: (className: string) => new TenantsGetter(client, className),
    tenantsUpdater: (className: string, tenants: Array<Tenant>) =>
      new TenantsUpdater(client, className, tenants),
    tenantsDeleter: (className: string, tenants: Array<string>) =>
      new TenantsDeleter(client, className, tenants),
    tenantsExists: (className: string, tenant: string) => new TenantsExists(client, className, tenant),
  };
};

export default schema;
export { default as ClassCreator } from './classCreator.js';
export { default as ClassDeleter } from './classDeleter.js';
export { default as ClassGetter } from './classGetter.js';
export { default as SchemaGetter } from './getter.js';
export { default as PropertyCreator } from './propertyCreator.js';
export { default as ShardUpdater } from './shardUpdater.js';
export { default as ShardsUpdater } from './shardsUpdater.js';
export { default as TenantsCreator } from './tenantsCreator.js';
export { default as TenantsDeleter } from './tenantsDeleter.js';
export { default as TenantsExists } from './tenantsExists.js';
export { default as TenantsGetter } from './tenantsGetter.js';
export { default as TenantsUpdater } from './tenantsUpdater.js';



---
File: /src/schema/journey.test.ts
---

/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { Meta, Property, ShardStatus, ShardStatusList, Tenant, WeaviateClass } from '../openapi/types.js';
import weaviate, { WeaviateClient } from '../v2/index.js';

const isVer = (client: WeaviateClient, minor: number, patch: number) =>
  client.misc
    .metaGetter()
    .do()
    .then((res: Meta) => res.version)
    .then((version: string | undefined) => {
      if (!version) {
        return false;
      }
      const semver = version
        .split('-')[0]
        .split('.')
        .map((v) => parseInt(v, 10));
      return semver[1] > minor ? true : semver[1] === minor && semver[2] >= patch;
    });

describe('schema', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  const classObjPromise = newClassObject('MyThingClass', client);

  it('creates a thing class (implicitly)', async () => {
    const classObj = await classObjPromise;
    return client.schema
      .classCreator()
      .withClass(classObj)
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toEqual(classObj);
      });
  });

  it('gets an existing class', async () => {
    const classObj = await classObjPromise;
    return client.schema
      .classGetter()
      .withClassName(classObj.class!)
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toEqual(classObj);
      });
  });

  it('checks class existence', async () => {
    const classObj = await classObjPromise;
    return client.schema.exists(classObj.class!).then((res) => expect(res).toEqual(true));
  });

  it('checks class non-existence', () => {
    return client.schema.exists('NonExistingClass').then((res) => expect(res).toEqual(false));
  });

  it('extends the thing class with a new property', async () => {
    const className = 'MyThingClass';
    const prop: Property = {
      dataType: ['text'],
      name: 'anotherProp',
      tokenization: 'field',
      indexFilterable: true,
      indexRangeFilters: (await isVer(client, 26, 0)) ? false : undefined,
      indexSearchable: true,
      moduleConfig: {
        'text2vec-contextionary': {
          skip: false,
          vectorizePropertyName: false,
        },
      },
    };

    return client.schema
      .propertyCreator()
      .withClassName(className)
      .withProperty(prop)
      .do()
      .then((res: any) => {
        expect(res).toEqual(prop);
      });
  });

  it('fails to extend the thing class with property having not supported tokenization (2)', () => {
    const className = 'MyThingClass';
    const prop: Property = {
      dataType: ['int[]'],
      name: 'yetAnotherProp',
      tokenization: 'word',
      moduleConfig: {
        'text2vec-contextionary': {
          skip: false,
          vectorizePropertyName: false,
        },
      },
    };

    return client.schema
      .propertyCreator()
      .withClassName(className)
      .withProperty(prop)
      .do()
      .catch((err: Error) => {
        expect(err.message).toEqual(
          'The request to Weaviate failed with status code: 422 and message: {"error":[{"message":"Tokenization is not allowed for data type \'int[]\'"}]}'
        );
      });
  });

  it('gets the shards of an existing class', async () => {
    const classObj = await classObjPromise;
    return client.schema
      .shardsGetter()
      .withClassName(classObj.class!)
      .do()
      .then((res: ShardStatusList) => {
        res.forEach((shard: ShardStatus) => {
          expect(shard.status).toEqual('READY');
        });
      });
  });

  it('updates a shard of an existing class to readonly', async () => {
    const classObj = await classObjPromise;
    const shards = await getShards(client, classObj.class!);
    expect(Array.isArray(shards)).toBe(true);
    expect(shards.length).toEqual(1);

    return client.schema
      .shardUpdater()
      .withClassName(classObj.class!)
      .withShardName(shards[0].name!)
      .withStatus('READONLY')
      .do()
      .then((res: ShardStatus) => {
        expect(res.status).toEqual('READONLY');
      });
  });

  it('updates a shard of an existing class to ready', async () => {
    const classObj = await classObjPromise;
    const shards = await getShards(client, classObj.class!);
    expect(Array.isArray(shards)).toBe(true);
    expect(shards.length).toEqual(1);

    return client.schema
      .shardUpdater()
      .withClassName(classObj.class!)
      .withShardName(shards[0].name!)
      .withStatus('READY')
      .do()
      .then((res: ShardStatus) => {
        expect(res.status).toEqual('READY');
      });
  });

  it('deletes an existing class', async () => {
    const classObj = await classObjPromise;
    return client.schema
      .classDeleter()
      .withClassName(classObj.class!)
      .do()
      .then((res: void) => {
        expect(res).toEqual(undefined);
      });
  });

  it('updates all shards in a class', async () => {
    const shardCount = 3;
    const newClass: any = await newClassObject('NewClass', client);
    newClass.shardingConfig.desiredCount = shardCount;

    await client.schema
      .classCreator()
      .withClass(newClass)
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toHaveProperty('shardingConfig.actualCount', 3);
      });

    const shards = await getShards(client, newClass.class);
    expect(Array.isArray(shards)).toBe(true);
    expect(shards.length).toEqual(shardCount);

    await client.schema
      .shardsUpdater()
      .withClassName(newClass.class)
      .withStatus('READONLY')
      .do()
      .then((res: ShardStatusList) => {
        expect(res.length).toEqual(shardCount);
        res.forEach((obj: ShardStatus) => {
          expect(obj.status).toEqual('READONLY');
        });
      });

    await client.schema
      .shardsUpdater()
      .withClassName(newClass.class)
      .withStatus('READY')
      .do()
      .then((res: any) => {
        expect(res.length).toEqual(shardCount);
        res.forEach((obj: any) => {
          expect(obj.status).toEqual('READY');
        });
      });

    return deleteClass(client, newClass.class);
  });

  it('has updated values of bm25 config', async () => {
    const newClass: any = await newClassObject('NewClass', client);
    const bm25Config = { k1: 1.13, b: 0.222 };

    newClass.invertedIndexConfig.bm25 = bm25Config;

    await client.schema
      .classCreator()
      .withClass(newClass)
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toHaveProperty('invertedIndexConfig.bm25', bm25Config);
      });

    return deleteClass(client, newClass.class);
  });

  it('has updated values of stopwords config', async () => {
    const newClass: any = await newClassObject('SpaceClass', client);
    const stopwordConfig: any = {
      preset: 'en',
      additions: ['star', 'nebula'],
      removals: ['a', 'the'],
    };

    newClass.invertedIndexConfig.stopwords = stopwordConfig;

    await client.schema
      .classCreator()
      .withClass(newClass)
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toHaveProperty('invertedIndexConfig.stopwords', stopwordConfig);
      });

    return deleteClass(client, newClass.class);
  });

  it('creates a class with bm25 and stopwords config', async () => {
    const newClass: any = {
      class: 'EmptyClass',
      properties: [{ dataType: ['string'], name: 'stringProp' }],
    };

    const bm25Config: any = { k1: 1.13, b: 0.222 };
    const stopwordConfig: any = {
      preset: 'en',
      additions: ['star', 'nebula'],
      removals: ['a', 'the'],
    };

    newClass.invertedIndexConfig = {
      bm25: bm25Config,
      stopwords: stopwordConfig,
    };

    await client.schema
      .classCreator()
      .withClass(newClass)
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toHaveProperty('invertedIndexConfig.bm25', bm25Config);
        expect(res).toHaveProperty('invertedIndexConfig.stopwords', stopwordConfig);
      });

    return deleteClass(client, newClass.class);
  });

  it('creates a class with explicit replication config', async () => {
    const replicationFactor = 1;
    const newClass: any = await newClassObject('SomeClass', client);
    newClass.replicationConfig.factor = replicationFactor;

    await client.schema
      .classCreator()
      .withClass(newClass)
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toHaveProperty('replicationConfig.factor', replicationFactor);
      });

    return deleteClass(client, newClass.class);
  });

  it('creates a class with implicit replication config', async () => {
    const newClass: any = await newClassObject('SomeClass', client);
    delete newClass.replicationConfig;

    await client.schema
      .classCreator()
      .withClass(newClass)
      .do()
      .then((res: WeaviateClass) => {
        expect(res).toHaveProperty('replicationConfig.factor', 1);
      });

    return deleteClass(client, newClass.class);
  });

  it('delete all data from the schema', async () => {
    const newClass: any = await newClassObject('LetsDeleteThisClass', client);
    const newClass2: any = await newClassObject('LetsDeleteThisClassToo', client);
    const classNames = [newClass.class, newClass2.class];
    Promise.all([
      client.schema.classCreator().withClass(newClass).do(),
      client.schema.classCreator().withClass(newClass2).do(),
    ])
      .then(() => client.schema.getter().do())
      .then((schema) => classNames.forEach((cn) => expect(schema.classes?.map((c) => c.class)).toContain(cn)))
      .then(() => client.schema.deleteAll())
      .then(() => client.schema.getter().do())
      .then((schema) =>
        classNames.forEach((cn) => expect(schema.classes?.map((c) => c.class)).not.toContain(cn))
      );
  });
});

describe('property setting defaults and migrations', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });

  test.each([
    ['text', null, 'text', 'word'],
    ['text', '', 'text', 'word'],
    ['text', 'word', 'text', 'word'],
    ['text', 'lowercase', 'text', 'lowercase'],
    ['text', 'whitespace', 'text', 'whitespace'],
    ['text', 'field', 'text', 'field'],

    ['text[]', null, 'text[]', 'word'],
    ['text[]', '', 'text[]', 'word'],
    ['text[]', 'word', 'text[]', 'word'],
    ['text[]', 'lowercase', 'text[]', 'lowercase'],
    ['text[]', 'whitespace', 'text[]', 'whitespace'],
    ['text[]', 'field', 'text[]', 'field'],

    ['string', null, 'text', 'whitespace'],
    ['string', '', 'text', 'whitespace'],
    ['string', 'word', 'text', 'whitespace'],
    ['string', 'field', 'text', 'field'],

    ['string[]', null, 'text[]', 'whitespace'],
    ['string[]', '', 'text[]', 'whitespace'],
    ['string[]', 'word', 'text[]', 'whitespace'],
    ['string[]', 'field', 'text[]', 'field'],

    ['int', null, 'int', null],
    ['int', '', 'int', null],

    ['int[]', null, 'int[]', null],
    ['int[]', '', 'int[]', null],
  ])(
    'succeeds creating prop with data type and tokenization',
    async (
      dataType: string,
      tokenization: string | null,
      expectedDataType: string,
      expectedTokenization: string | null
    ) => {
      await client.schema
        .classCreator()
        .withClass({
          class: 'SomeClass',
          properties: [
            {
              dataType: [dataType],
              name: 'property',
              tokenization: tokenization,
            },
          ],
        })
        .do()
        .then((res: WeaviateClass) => {
          expect(res).toBeDefined();
          expect(res.properties).toHaveLength(1);
          expect(res.properties![0]).toHaveProperty('dataType', [expectedDataType]);
          if (expectedTokenization != null) {
            expect(res.properties![0]).toHaveProperty('tokenization', expectedTokenization);
          } else {
            expect(res.properties![0]).not.toHaveProperty('tokenization');
          }
        });

      return deleteClass(client, 'SomeClass');
    }
  );

  test.each([
    ['string', 'whitespace'],
    ['string', 'lowercase'],

    ['string[]', 'whitespace'],
    ['string[]', 'lowercase'],

    ['int', 'word'],
    ['int', 'whitespace'],
    ['int', 'lowercase'],
    ['int', 'field'],

    ['int[]', 'word'],
    ['int[]', 'whitespace'],
    ['int[]', 'lowercase'],
    ['int[]', 'field'],
  ])(
    'fails creating prop with data type and tokenization',
    async (dataType: string, tokenization: string | null) => {
      await client.schema
        .classCreator()
        .withClass({
          class: 'SomeClass',
          properties: [
            {
              dataType: [dataType],
              name: 'property',
              tokenization: tokenization,
            },
          ],
        })
        .do()
        .catch((e: Error) => {
          expect(e.message).toContain('is not allowed for data type');
        });
    }
  );

  test.each([
    ['text', null, null, null, true, true],
    ['text', null, null, false, true, false],
    ['text', null, null, true, true, true],
    ['text', null, false, null, false, true],
    ['text', null, false, false, false, false],
    ['text', null, false, true, false, true],
    ['text', null, true, null, true, true],
    ['text', null, true, false, true, false],
    ['text', null, true, true, true, true],
    ['text', false, null, null, false, false],
    ['text', true, null, null, true, true],

    ['int', null, null, null, true, false],
    ['int', null, null, false, true, false],
    ['int', null, false, null, false, false],
    ['int', null, false, false, false, false],
    ['int', null, true, null, true, false],
    ['int', null, true, false, true, false],
    ['int', false, null, null, false, false],
    ['int', true, null, null, true, false],
  ])(
    'succeeds creating prop with data type and indexing',
    async (
      dataType: string,
      inverted: boolean | null,
      filterable: boolean | null,
      searchable: boolean | null,
      expectedFilterable: boolean,
      expectedSearchable: boolean
    ) => {
      await client.schema
        .classCreator()
        .withClass({
          class: 'SomeClass',
          properties: [
            {
              dataType: [dataType],
              name: 'property',
              indexInverted: inverted,
              indexFilterable: filterable,
              indexSearchable: searchable,
            },
          ],
        })
        .do()
        .then((res: WeaviateClass) => {
          expect(res).toBeDefined();
          expect(res.properties).toHaveLength(1);
          expect(res.properties![0]).toHaveProperty('indexFilterable', expectedFilterable);
          expect(res.properties![0]).toHaveProperty('indexSearchable', expectedSearchable);
          expect(res.properties![0]).not.toHaveProperty('indexInverted');
        });

      return deleteClass(client, 'SomeClass');
    }
  );

  const errMsg1 = isVer(client, 26, 0).then((yes) =>
    yes
      ? '`indexInverted` is deprecated and can not be set together with `indexFilterable`, `indexSearchable` or `indexRangeFilters`'
      : '`indexInverted` is deprecated and can not be set together with `indexFilterable` or `indexSearchable`'
  );
  const errMsg2 = Promise.resolve('`indexSearchable`');
  test.each([
    ['text', false, null, false, errMsg1],
    ['text', false, null, true, errMsg1],
    ['text', false, false, null, errMsg1],
    ['text', false, false, false, errMsg1],
    ['text', false, false, true, errMsg1],
    ['text', false, true, null, errMsg1],
    ['text', false, true, false, errMsg1],
    ['text', false, true, true, errMsg1],
    ['text', true, null, false, errMsg1],
    ['text', true, null, true, errMsg1],
    ['text', true, false, null, errMsg1],
    ['text', true, false, false, errMsg1],
    ['text', true, false, true, errMsg1],
    ['text', true, true, null, errMsg1],
    ['text', true, true, false, errMsg1],
    ['text', true, true, true, errMsg1],

    ['int', false, null, false, errMsg1],
    ['int', false, null, true, errMsg1],
    ['int', false, false, null, errMsg1],
    ['int', false, false, false, errMsg1],
    ['int', false, false, true, errMsg1],
    ['int', false, true, null, errMsg1],
    ['int', false, true, false, errMsg1],
    ['int', false, true, true, errMsg1],
    ['int', true, null, false, errMsg1],
    ['int', true, null, true, errMsg1],
    ['int', true, false, null, errMsg1],
    ['int', true, false, false, errMsg1],
    ['int', true, false, true, errMsg1],
    ['int', true, true, null, errMsg1],
    ['int', true, true, false, errMsg1],
    ['int', true, true, true, errMsg1],

    ['int', null, null, true, errMsg2],
    ['int', null, false, true, errMsg2],
    ['int', null, true, true, errMsg2],
  ])(
    'fails creating prop with data type and indexing',
    async (
      dataType: string,
      inverted: boolean | null,
      filterable: boolean | null,
      searchable: boolean | null,
      errMsg: Promise<string>
    ) => {
      await client.schema
        .classCreator()
        .withClass({
          class: 'SomeClass',
          properties: [
            {
              dataType: [dataType],
              name: 'property',
              indexInverted: inverted,
              indexFilterable: filterable,
              indexSearchable: searchable,
            },
          ],
        })
        .do()
        .catch(async (e: Error) => {
          expect(e.message).toContain(await errMsg);
        });
    }
  );
});

describe('multi tenancy', () => {
  const client = weaviate.client({
    scheme: 'http',
    host: 'localhost:8080',
  });
  const classObj: WeaviateClass = {
    class: 'MultiTenancy',
    properties: [
      {
        dataType: ['text'],
        name: 'tenant',
      },
      {
        dataType: ['text'],
        name: 'content',
      },
    ],
    vectorIndexType: 'hnsw',
    vectorizer: 'text2vec-contextionary',
    multiTenancyConfig: {
      autoTenantActivation: true,
      autoTenantCreation: true,
      enabled: true,
    },
  };
  const tenants: Array<Tenant> = [{ name: 'tenantA' }, { name: 'tenantB' }, { name: 'tenantC' }];

  it('creates a MultiTenancy class', async () => {
    if (!(await isVer(client, 25, 0))) {
      delete classObj.multiTenancyConfig?.autoTenantCreation;
    }
    if (!(await isVer(client, 25, 2))) {
      delete classObj.multiTenancyConfig?.autoTenantActivation;
    }
    return client.schema
      .classCreator()
      .withClass(classObj)
      .do()
      .then((res: WeaviateClass) => {
        expect(res.class).toEqual(classObj.class);
        expect(res.multiTenancyConfig).toEqual(classObj.multiTenancyConfig);
      });
  });

  it('defines tenants for MultiTenancy class', () => {
    return client.schema
      .tenantsCreator(classObj.class!, tenants)
      .do()
      .then((res: Array<Tenant>) => {
        expect(res).toHaveLength(tenants.length);
        expect(res).toEqual(expect.arrayContaining(tenants));
      });
  });

  it('gets tenants for MultiTenancy class', () => {
    return client.schema
      .tenantsGetter(classObj.class!)
      .do()
      .then((res: Array<Tenant>) => {
        expect(res).toHaveLength(3);
      });
  });

  it('delete one tenant in MultiTenancy class', () => {
    return client.schema
      .tenantsDeleter(classObj.class!, [tenants[0].name!])
      .do()
      .then((res) => {
        expect(res).toEqual(undefined);
      });
  });

  it('get tenants after delete for MultiTenancy class', () => {
    return client.schema
      .tenantsGetter(classObj.class!)
      .do()
      .then((res: Array<Tenant>) => {
        expect(res).toHaveLength(2);
      });
  });

  it('successfully finds an existing tenant for MultiTenancy class', async () => {
    if (!(await isVer(client, 25, 0))) {
      return Promise.resolve();
    }
    return client.schema
      .tenantsExists(classObj.class!, tenants[1].name!)
      .do()
      .then((res) => expect(res).toEqual(true));
  });

  it('successfully fails to find a non-existant tenant for MultiTenancy class', async () => {
    if (!(await isVer(client, 25, 0))) {
      return Promise.resolve();
    }
    return client.schema
      .tenantsExists(classObj.class!, 'nonExistantTenant')
      .do()
      .then((res) => expect(res).toEqual(false));
  });

  it('deletes MultiTenancy class', () => {
    return deleteClass(client, classObj.class!);
  });

  const classObjWithoutMultiTenancyConfig = newClassObject('NoMultiTenancy', client);

  it('creates a NoMultiTenancy class', async () => {
    return client.schema
      .classCreator()
      .withClass(await classObjWithoutMultiTenancyConfig)
      .do()
      .then(async (res: WeaviateClass) => {
        expect(res).toEqual(await classObjWithoutMultiTenancyConfig);
      });
  });

  it('fails to define tenants for NoMultiTenancy class', async () => {
    return client.schema
      .tenantsCreator((await classObjWithoutMultiTenancyConfig).class!, tenants)
      .do()
      .catch((e: Error) => {
        expect(e.message).toContain('multi-tenancy is not enabled for class \\"NoMultiTenancy\\"');
      });
  });

  it('deletes NoMultiTenancy class', async () => {
    return deleteClass(client, (await classObjWithoutMultiTenancyConfig).class!);
  });
});

async function newClassObject(className: string, client: WeaviateClient): Promise<WeaviateClass> {
  return {
    class: className,
    properties: [
      {
        dataType: ['text'],
        name: 'stringProp',
        tokenization: 'word',
        indexFilterable: true,
        indexRangeFilters: (await isVer(client, 26, 0)) ? false : undefined,
        indexSearchable: true,
        moduleConfig: {
          'text2vec-contextionary': {
            skip: false,
            vectorizePropertyName: false,
          },
        },
      },
    ],
    vectorIndexType: 'hnsw',
    vectorizer: 'text2vec-contextionary',
    vectorIndexConfig: {
      cleanupIntervalSeconds: 300,
      distance: 'cosine',
      dynamicEfFactor: 8,
      dynamicEfMax: 500,
      dynamicEfMin: 100,
      ef: -1,
      maxConnections: 64,
      pq: {
        bitCompression: false,
        centroids: 256,
        enabled: false,
        encoder: {
          distribution: 'log-normal',
          type: 'kmeans',
        },
        segments: 0,
        trainingLimit: 100000,
      },
      bq: {
        enabled: false,
      },
      sq: (await isVer(client, 26, 0))
        ? {
            enabled: false,
            rescoreLimit: 20,
            trainingLimit: 100000,
          }
        : undefined,
      skip: false,
      efConstruction: 128,
      vectorCacheMaxObjects: 500000,
      flatSearchCutoff: 40000,
      filterStrategy: (await isVer(client, 27, 0)) ? 'sweeping' : undefined,
    },
    invertedIndexConfig: {
      cleanupIntervalSeconds: 60,
      bm25: {
        b: 0.75,
        k1: 1.2,
      },
      stopwords: {
        preset: 'en',
        additions: null as unknown as undefined, // hack to deal with weird typing
        removals: null as unknown as undefined, // hack to deal with weird typing
      },
    },
    moduleConfig: {
      'text2vec-contextionary': {
        vectorizeClassName: true,
      },
    },
    multiTenancyConfig: {
      autoTenantActivation: (await isVer(client, 25, 2)) ? false : undefined,
      autoTenantCreation: (await isVer(client, 25, 0)) ? false : undefined,
      enabled: false,
    },
    shardingConfig: {
      actualCount: 1,
      actualVirtualCount: 128,
      desiredCount: 1,
      desiredVirtualCount: 128,
      function: 'murmur3',
      key: '_id',
      strategy: 'hash',
      virtualPerPhysical: 128,
    },
    replicationConfig: {
      asyncEnabled: (await isVer(client, 26, 0)) ? false : undefined,
      deletionStrategy: 'DeleteOnConflict',
      factor: 1,
    },
  };
}

function getShards(client: WeaviateClient, className: string): Promise<ShardStatusList> {
  return client.schema
    .shardsGetter()
    .withClassName(className)
    .do()
    .then((res: ShardStatusList) => {
      return res;
    });
}

function deleteClass(client: WeaviateClient, className: string) {
  return client.schema
    .classDeleter()
    .withClassName(className)
    .do()
    .then((res: void) => {
      expect(res).toEqual(undefined);
    });
}



---
File: /src/schema/propertyCreator.ts
---

import Connection from '../connection/index.js';
import { Property } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class PropertyCreator extends CommandBase {
  private className!: string;
  private property!: Property;

  constructor(client: Connection) {
    super(client);
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withProperty = (property: Property) => {
    this.property = property;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  validateProperty = () => {
    if (this.property == undefined || this.property == null) {
      this.addError('property must be set - set with .withProperty(property)');
    }
  };

  validate = () => {
    this.validateClassName();
    this.validateProperty();
  };

  do = (): Promise<Property> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error('invalid usage: ' + this.errors.join(', ')));
    }
    const path = `/schema/${this.className}/properties`;
    return this.client.postReturn(path, this.property);
  };
}



---
File: /src/schema/shardsGetter.ts
---

import Connection from '../connection/index.js';
import { ShardStatusList } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class ShardsGetter extends CommandBase {
  private className?: string;
  private tenant?: string;

  constructor(client: Connection) {
    super(client);
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  withTenant = (tenant: string) => {
    this.tenant = tenant;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  validate = () => {
    this.validateClassName();
  };

  do = (): Promise<ShardStatusList> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error(`invalid usage: ${this.errors.join(', ')}`));
    }

    return getShards(this.client, this.className, this.tenant);
  };
}

export function getShards(client: Connection, className: any, tenant?: string) {
  const path = `/schema/${className}/shards${tenant ? `?tenant=${tenant}` : ''}`;
  return client.get(path);
}



---
File: /src/schema/shardsUpdater.ts
---

import Connection from '../connection/index.js';
import { ShardStatusList } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';
import { updateShard } from './shardUpdater.js';
import { getShards } from './shardsGetter.js';

export default class ShardsUpdater extends CommandBase {
  private className!: string;
  private shards: ShardStatusList;
  private status!: string;

  constructor(client: Connection) {
    super(client);
    this.shards = [];
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  withStatus = (status: string) => {
    this.status = status;
    return this;
  };

  validateStatus = () => {
    if (!isValidStringProperty(this.status)) {
      this.addError('status must be set - set with .withStatus(status)');
    }
  };

  validate = () => {
    this.validateClassName();
    this.validateStatus();
  };

  updateShards = async () => {
    const payload: any = await Promise.all(
      Array.from({ length: this.shards.length }, (_, i) =>
        updateShard(this.client, this.className, this.shards[i].name || '', this.status)
          .then((res: any) => {
            return { name: this.shards[i].name, status: res.status };
          })
          .catch((err: any) => this.addError(err.toString()))
      )
    );

    if (this.errors.length > 0) {
      return Promise.reject(new Error(`failed to update shards: ${this.errors.join(', ')}`));
    }

    return Promise.resolve(payload);
  };

  do = (): Promise<ShardStatusList> => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error(`invalid usage: ${this.errors.join(', ')}`));
    }

    return getShards(this.client, this.className)
      .then((shards: ShardStatusList) => (this.shards = shards))
      .then(() => {
        return this.updateShards();
      })
      .then((payload: ShardStatusList) => {
        return payload;
      })
      .catch((err: any) => {
        return Promise.reject(err);
      });
  };
}



---
File: /src/schema/shardUpdater.ts
---

import Connection from '../connection/index.js';
import { CommandBase } from '../validation/commandBase.js';
import { isValidStringProperty } from '../validation/string.js';

export default class ShardUpdater extends CommandBase {
  private className!: string;
  private shardName!: string;
  private status!: string;

  constructor(client: Connection) {
    super(client);
  }

  withClassName = (className: string) => {
    this.className = className;
    return this;
  };

  validateClassName = () => {
    if (!isValidStringProperty(this.className)) {
      this.addError('className must be set - set with .withClassName(className)');
    }
  };

  withShardName = (shardName: string) => {
    this.shardName = shardName;
    return this;
  };

  validateShardName = () => {
    if (!isValidStringProperty(this.shardName)) {
      this.addError('shardName must be set - set with .withShardName(shardName)');
    }
  };

  withStatus = (status: string) => {
    this.status = status;
    return this;
  };

  validateStatus = () => {
    if (!isValidStringProperty(this.status)) {
      this.addError('status must be set - set with .withStatus(status)');
    }
  };

  validate = () => {
    this.validateClassName();
    this.validateShardName();
    this.validateStatus();
  };

  do = () => {
    this.validate();
    if (this.errors.length > 0) {
      return Promise.reject(new Error(`invalid usage: ${this.errors.join(', ')}`));
    }

    return updateShard(this.client, this.className, this.shardName, this.status);
  };
}

export function updateShard(client: Connection, className: string, shardName: string, status: string) {
  const path = `/schema/${className}/shards/${shardName}`;
  return client.put(path, { status: status }, true);
}



---
File: /src/schema/tenantsCreator.ts
---

import Connection from '../connection/index.js';
import { Tenant } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class TenantsCreator extends CommandBase {
  private className: string;
  private tenants: Array<Tenant>;

  constructor(client: Connection, className: string, tenants: Array<Tenant>) {
    super(client);
    this.className = className;
    this.tenants = tenants;
  }

  validate = () => {
    // nothing to validate
  };

  do = (): Promise<Array<Tenant>> => {
    return this.client.postReturn(`/schema/${this.className}/tenants`, this.tenants);
  };
}



---
File: /src/schema/tenantsDeleter.ts
---

import Connection from '../connection/index.js';
import { CommandBase } from '../validation/commandBase.js';

export default class TenantsDeleter extends CommandBase {
  private className: string;
  private tenants: Array<string>;

  constructor(client: Connection, className: string, tenants: Array<string>) {
    super(client);
    this.className = className;
    this.tenants = tenants;
  }

  validate = () => {
    // nothing to validate
  };

  do = (): Promise<void> => {
    return this.client.delete(`/schema/${this.className}/tenants`, this.tenants, false);
  };
}



---
File: /src/schema/tenantsExists.ts
---

import Connection from '../connection/index.js';
import { CommandBase } from '../validation/commandBase.js';

export default class TenantsExists extends CommandBase {
  private className: string;
  private tenant: string;

  constructor(client: Connection, className: string, tenant: string) {
    super(client);
    this.className = className;
    this.tenant = tenant;
  }

  validate = () => {
    // nothing to validate
  };

  do = (): Promise<boolean> => {
    return this.client.head(`/schema/${this.className}/tenants/${this.tenant}`, undefined);
  };
}



---
File: /src/schema/tenantsGetter.ts
---

import Connection from '../connection/index.js';
import { Tenant } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class TenantsGetter extends CommandBase {
  private className: string;

  constructor(client: Connection, className: string) {
    super(client);
    this.className = className;
  }

  validate = () => {
    // nothing to validate
  };

  do = (): Promise<Array<Tenant>> => {
    return this.client.get(`/schema/${this.className}/tenants`);
  };
}



---
File: /src/schema/tenantsUpdater.ts
---

import Connection from '../connection/index.js';
import { Tenant } from '../openapi/types.js';
import { CommandBase } from '../validation/commandBase.js';

export default class TenantsUpdater extends CommandBase {
  private className: string;
  private tenants: Array<Tenant>;

  constructor(client: Connection, className: string, tenants: Array<Tenant>) {
    super(client);
    this.className = className;
    this.tenants = tenants;
  }

  validate = () => {
    // nothing to validate
  };

  do = (): Promise<Array<Tenant>> => {
    return this.client.put(`/schema/${this.className}/tenants`, this.tenants);
  };
}



---
File: /src/utils/base64.ts
---

import fs from 'fs';

const isFilePromise = (file: string | Buffer): Promise<boolean> =>
  new Promise((resolve, reject) => {
    if (file instanceof Buffer) {
      resolve(false);
    }
    fs.stat(file, (err, stats) => {
      if (err) {
        if (err.code == 'ENAMETOOLONG') {
          resolve(false);
          return;
        }
        reject(err);
        return;
      }
      if (stats === undefined) {
        resolve(false);
        return;
      }
      resolve(stats.isFile());
    });
  });

const isBuffer = (file: string | Buffer): file is Buffer => file instanceof Buffer;

const fileToBase64 = (file: string | Buffer): Promise<string> =>
  isFilePromise(file).then((isFile) =>
    isFile
      ? new Promise((resolve, reject) => {
          fs.readFile(file, (err, data) => {
            if (err) {
              reject(err);
            }
            resolve(data.toString('base64'));
          });
        })
      : isBuffer(file)
      ? Promise.resolve(file.toString('base64'))
      : Promise.resolve(file)
  );

/**
 * This function converts a file buffer into a base64 string so that it can be
 * sent to Weaviate and stored as a media field.
 *
 * @param {string | Buffer} file The media to convert either as a base64 string, a file path string, or as a buffer. If you passed a base64 string, the function does nothing and returns the string as is.
 * @returns {string} The base64 string
 */
export const toBase64FromMedia = (media: string | Buffer): Promise<string> => fileToBase64(media);



---
File: /src/utils/beaconPath.ts
---

import { isValidStringProperty } from '../validation/string.js';
import { isValidWeaviateVersion } from '../validation/version.js';
import { DbVersionSupport } from './dbVersion.js';

const beaconPathPrefix = 'weaviate://localhost';

export class BeaconPath {
  private dbVersionSupport: DbVersionSupport;
  private beaconRegExp: RegExp;

  constructor(dbVersionSupport: DbVersionSupport) {
    this.dbVersionSupport = dbVersionSupport;
    // matches
    // weaviate://localhost/class/id    => match[2] = class, match[4] = id
    // weaviate://localhost/class/id/   => match[2] = class, match[4] = id
    // weaviate://localhost/id          => match[2] = id, match[4] = undefined
    // weaviate://localhost/id/         => match[2] = id, match[4] = undefined
    this.beaconRegExp = /^weaviate:\/\/localhost(\/([^\\/]+))?(\/([^\\/]+))?[\\/]?$/gi;
  }

  async rebuild(beacon: string) {
    const support = await this.dbVersionSupport.supportsClassNameNamespacedEndpointsPromise();
    const match = new RegExp(this.beaconRegExp).exec(beacon);
    if (!match) {
      return beacon;
    }
    let className;
    let id;
    if (match[4] !== undefined) {
      id = match[4];
      className = match[2];
    } else {
      id = match[2];
    }
    let beaconPath = beaconPathPrefix;
    if (support.supports) {
      if (isValidStringProperty(className)) {
        beaconPath = `${beaconPath}/${className}`;
      } else {
        support.warns.deprecatedNonClassNameNamespacedEndpointsForBeacons();
      }
    } else {
      support.warns.notSupportedClassNamespacedEndpointsForBeacons();
    }
    if (support.version) {
      if (!isValidWeaviateVersion(support.version)) {
        support.warns.deprecatedWeaviateTooOld();
      }
    }
    if (isValidStringProperty(id)) {
      beaconPath = `${beaconPath}/${id}`;
    }
    return beaconPath;
  }
}



---
File: /src/utils/dbVersion.ts
---

import { ConnectionGQL } from '../index.js';
import MetaGetter from '../misc/metaGetter.js';

export class DbVersionSupport {
  private dbVersionProvider: VersionProvider;

  constructor(dbVersionProvider: VersionProvider) {
    this.dbVersionProvider = dbVersionProvider;
  }

  getVersion = () => this.dbVersionProvider.getVersion();

  supportsClassNameNamespacedEndpointsPromise() {
    return this.dbVersionProvider
      .getVersion()
      .then((version) => version.show())
      .then((version) => ({
        version: version,
        supports: this.supportsClassNameNamespacedEndpoints(version),
        warns: {
          deprecatedNonClassNameNamespacedEndpointsForObjects: () =>
            console.warn(
              `Usage of objects paths without className is deprecated in Weaviate ${version}. Please provide className parameter`
            ),
          deprecatedNonClassNameNamespacedEndpointsForReferences: () =>
            console.warn(
              `Usage of references paths without className is deprecated in Weaviate ${version}. Please provide className parameter`
            ),
          deprecatedNonClassNameNamespacedEndpointsForBeacons: () =>
            console.warn(
              `Usage of beacons paths without className is deprecated in Weaviate ${version}. Please provide className parameter`
            ),
          deprecatedWeaviateTooOld: () =>
            console.warn(
              `Usage of weaviate ${version} is deprecated. Please consider upgrading to the latest version. See https://www.weaviate.io/developers/weaviate for details.`
            ),
          notSupportedClassNamespacedEndpointsForObjects: () =>
            console.warn(
              `Usage of objects paths with className is not supported in Weaviate ${version}. className parameter is ignored`
            ),
          notSupportedClassNamespacedEndpointsForReferences: () =>
            console.warn(
              `Usage of references paths with className is not supported in Weaviate ${version}. className parameter is ignored`
            ),
          notSupportedClassNamespacedEndpointsForBeacons: () =>
            console.warn(
              `Usage of beacons paths with className is not supported in Weaviate ${version}. className parameter is ignored`
            ),
          notSupportedClassParameterInEndpointsForObjects: () =>
            console.warn(
              `Usage of objects paths with class query parameter is not supported in Weaviate ${version}. class query parameter is ignored`
            ),
        },
      }));
  }

  // >= 1.14
  supportsClassNameNamespacedEndpoints(version?: string) {
    if (typeof version === 'string') {
      const versionNumbers = version.split('.');
      if (versionNumbers.length >= 2) {
        const major = parseInt(versionNumbers[0], 10);
        const minor = parseInt(versionNumbers[1], 10);
        return (major == 1 && minor >= 14) || major >= 2;
      }
    }
    return false;
  }

  private errorMessage = (feature: string, current: string, required: string) =>
    `${feature} is not supported with Weaviate version v${current}. Please use version v${required} or higher.`;

  supportsCompatibleGrpcService = () =>
    this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 23, 7),
        message: this.errorMessage('The gRPC API', version.show(), '1.23.7'),
      };
    });

  supportsHNSWAndBQ = () =>
    this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 24, 0),
        message: this.errorMessage('HNSW index and BQ quantizer', version.show(), '1.24.0'),
      };
    });

  supportsBm25AndHybridGroupByQueries = () =>
    this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 25, 0),
        message: (query: 'Bm25' | 'Hybrid') =>
          this.errorMessage(`GroupBy with ${query}`, version.show(), '1.25.0'),
      };
    });

  supportsHybridNearTextAndNearVectorSubsearchQueries = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 25, 0),
        message: this.errorMessage('Hybrid nearText/nearVector subsearching', version.show(), '1.25.0'),
      };
    });
  };

  supports125ListValue = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 25, 0),
        message: undefined,
      };
    });
  };

  supportsNamedVectors = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 24, 0),
        message: this.errorMessage('Named vectors', version.show(), '1.24.0'),
      };
    });
  };

  requiresNamedVectorsInsertFix = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports:
          (version.isAtLeast(1, 24, 0) && version.isLowerThan(1, 24, 26)) ||
          (version.isAtLeast(1, 25, 0) && version.isLowerThan(1, 25, 22)) ||
          (version.isAtLeast(1, 26, 0) && version.isLowerThan(1, 26, 8)) ||
          (version.isAtLeast(1, 27, 0) && version.isLowerThan(1, 27, 1)),
        message: this.errorMessage(
          'Named vectors insert fix',
          version.show(),
          '1.24.0 <= x < 1.24.26, 1.25.0 <= x < 1.25.22, 1.26.0 <= x < 1.26.8, 1.27.0 <= x < 1.27.1'
        ),
      };
    });
  };

  supportsTenantsGetGRPCMethod = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 25, 0),
        message: this.errorMessage('Tenants get method', version.show(), '1.25.0'),
      };
    });
  };

  supportsDynamicVectorIndex = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 25, 0),
        message: this.errorMessage('Dynamic vector index', version.show(), '1.25.0'),
      };
    });
  };

  supportsMultiTargetVectorSearch = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 26, 0),
        message: this.errorMessage('Multi-target vector search', version.show(), '1.26.0'),
      };
    });
  };

  supportsMultiVectorSearch = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 26, 0),
        message: this.errorMessage('Multi-vector search', version.show(), '1.26.0'),
      };
    });
  };

  supportsMultiVectorPerTargetSearch = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 27, 0),
        message: this.errorMessage('Multi-vector-per-target search', version.show(), '1.27.0'),
      };
    });
  };

  supportsMultiWeightsPerTargetSearch = () => {
    return this.dbVersionProvider.getVersion().then((version) => {
      return {
        version: version,
        supports: version.isAtLeast(1, 27, 0),
        message: this.errorMessage(
          'Multi-target vector search with multiple weights',
          version.show(),
          '1.27.0'
        ),
      };
    });
  };
}

const EMPTY_VERSION = '';

export interface VersionProvider {
  getVersionString(): Promise<string>;
  getVersion(): Promise<DbVersion>;
}

export class DbVersionProvider implements VersionProvider {
  private versionPromise?: Promise<DbVersion>;
  private versionStringGetter: () => Promise<string>;

  constructor(versionStringGetter: () => Promise<string>) {
    this.versionStringGetter = versionStringGetter;
    this.versionPromise = undefined;
  }

  getVersionString(): Promise<string> {
    return this.getVersion().then((version) => version.show());
  }

  getVersion(): Promise<DbVersion> {
    if (this.versionPromise) {
      return this.versionPromise;
    }
    return this.versionStringGetter().then((version) => this.cache(version));
  }

  refresh(force = false): Promise<boolean> {
    if (force || !this.versionPromise) {
      this.versionPromise = undefined;
      return this.versionStringGetter()
        .then((version) => this.cache(version))
        .then(() => Promise.resolve(true));
    }
    return Promise.resolve(false);
  }

  cache(version: string): Promise<DbVersion> {
    if (version === EMPTY_VERSION) {
      return Promise.resolve(new DbVersion(0, 0, 0));
    }
    this.versionPromise = Promise.resolve(DbVersion.fromString(version));
    return this.versionPromise;
  }
}

export function initDbVersionProvider(conn: ConnectionGQL) {
  const metaGetter = new MetaGetter(conn);
  const versionGetter = () => {
    return metaGetter.do().then((result) => (result.version ? result.version : ''));
  };
  return new DbVersionProvider(versionGetter);
}

export class DbVersion {
  private major: number;
  private minor: number;
  private patch?: number;

  constructor(major: number, minor: number, patch?: number) {
    this.major = major;
    this.minor = minor;
    this.patch = patch;
  }

  static fromString = (version: string) => {
    let regex = /^v?(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?$/;
    let match = version.match(regex);
    if (match) {
      const [_, major, minor, patch] = match;
      return new DbVersion(parseInt(major, 10), parseInt(minor, 10), parseInt(patch, 10));
    }

    regex = /^v?(\d+)\.(\d+)$/;
    match = version.match(regex);
    if (match) {
      const [_, major, minor] = match;
      return new DbVersion(parseInt(major, 10), parseInt(minor, 10));
    }

    throw new Error(`Invalid version string: ${version}`);
  };

  private checkNumber = (num: number) => {
    if (!Number.isSafeInteger(num)) {
      throw new Error(`Invalid number: ${num}`);
    }
  };

  show = () =>
    this.major === 0 && this.major === this.minor && this.minor === this.patch
      ? ''
      : `${this.major}.${this.minor}${this.patch !== undefined ? `.${this.patch}` : ''}`;

  isAtLeast = (major: number, minor: number, patch?: number) => {
    this.checkNumber(major);
    this.checkNumber(minor);

    if (this.major > major) return true;
    if (this.major < major) return false;

    if (this.minor > minor) return true;
    if (this.minor < minor) return false;

    if (this.patch !== undefined && patch !== undefined && this.patch >= patch) {
      this.checkNumber(patch);
      return true;
    }
    return false;
  };

  isLowerThan = (major: number, minor: number, patch: number) => !this.isAtLeast(major, minor, patch);
}



---
File: /src/utils/journey.test.ts
---

import { DbVersionProvider, DbVersionSupport } from './dbVersion.js';

const EMPTY_VERSION = '';
const VERSION_1 = '1.2.3';
const VERSION_2 = '2.3.4';

describe('db version provider', () => {
  it('should return empty version', () => {
    const versionGetter = () => Promise.resolve(EMPTY_VERSION);
    const dbVersionProvider = new DbVersionProvider(versionGetter);

    return dbVersionProvider.getVersionString().then((version) => expect(version).toBe(EMPTY_VERSION));
  });

  it('should return proper version', () => {
    const versionGetter = () => Promise.resolve(VERSION_1);
    const dbVersionProvider = new DbVersionProvider(versionGetter);

    return dbVersionProvider.getVersionString().then((version) => expect(version).toBe(VERSION_1));
  });

  it('should return new version after refresh', async () => {
    let callsCounter = 0;
    const versionGetter = () => {
      callsCounter += 1;
      switch (callsCounter) {
        case 1:
          return Promise.resolve(VERSION_1);
        case 2:
          return Promise.resolve(VERSION_2);
        default:
          fail('should not be called more then 2 times');
      }
    };
    const dbVersionProvider = new DbVersionProvider(versionGetter);

    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(VERSION_1));
    await dbVersionProvider.refresh(true);
    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(VERSION_2));
  });

  it('should fetch version once', async () => {
    let callsCounter = 0;
    const versionGetter = () => {
      callsCounter += 1;
      switch (callsCounter) {
        case 1:
          return Promise.resolve(VERSION_1);
        default:
          fail('should not be called more then 1 time');
      }
    };
    const dbVersionProvider = new DbVersionProvider(versionGetter);

    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(VERSION_1));
    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(VERSION_1));
    await dbVersionProvider.getVersion().then((version) => expect(version.show()).toBe(VERSION_1));

    expect(callsCounter).toBe(1);
  });

  it('should fetch version until success', async () => {
    let callsCounter = 0;
    const versionGetter = () => {
      callsCounter += 1;
      switch (callsCounter) {
        case 1:
        case 2:
          return Promise.resolve(EMPTY_VERSION);
        case 3:
          return Promise.resolve(VERSION_1);
        default:
          fail('should not be called more then 3 times');
      }
    };
    const dbVersionProvider = new DbVersionProvider(versionGetter);

    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(EMPTY_VERSION));
    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(EMPTY_VERSION));
    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(VERSION_1));
    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(VERSION_1));
    await dbVersionProvider.getVersionString().then((version) => expect(version).toBe(VERSION_1));

    expect(callsCounter).toBe(3);
  });
});

describe('db version support', () => {
  it('should not support', () => {
    const notSupportedVersions = ['0.11', '1.13.9', '1.13', '1.0'];
    notSupportedVersions.forEach(async (version) => {
      const dbVersionProvider = new DbVersionProvider(() => Promise.resolve(version));
      const dbVersionSupport = new DbVersionSupport(dbVersionProvider);

      const support = await dbVersionSupport.supportsClassNameNamespacedEndpointsPromise();
      expect(support.supports).toBe(false);
      expect(support.version).toBe(version);
    });
  });

  it('should support', () => {
    const supportedVersions = [
      {
        in: '1.14.0',
        exp: '1.14.0',
      },
      {
        in: '1.14.9',
        exp: '1.14.9',
      },
      {
        in: '1.100',
        exp: '1.100',
      },
      {
        in: '2.0',
        exp: '2.0',
      },
      {
        in: '10.11.12',
        exp: '10.11.12',
      },
      {
        in: '1.25.0-raft',
        exp: '1.25.0',
      },
    ];
    return supportedVersions.forEach(async (version) => {
      const dbVersionProvider = new DbVersionProvider(() => Promise.resolve(version.in));
      const dbVersionSupport = new DbVersionSupport(dbVersionProvider);

      const support = await dbVersionSupport.supportsClassNameNamespacedEndpointsPromise();

      expect(support.supports).toBe(true);
      expect(support.version).toBe(version.exp);
    });
  });
});



---
File: /src/utils/testData.ts
---

import { Property, WeaviateObject } from '../openapi/types.js';
import { WeaviateClient } from '../v2/index.js';

export const PIZZA_CLASS_NAME = 'Pizza';
export const SOUP_CLASS_NAME = 'Soup';

const foodProperties: Property[] = [
  {
    name: 'name',
    dataType: ['string'],
    description: 'name',
    tokenization: 'field',
  },
  {
    name: 'description',
    dataType: ['text'],
    description: 'description',
    tokenization: 'word',
  },
  {
    name: 'bestBefore',
    dataType: ['date'],
    description: 'best before',
  },
];

const pizzaClass = {
  class: PIZZA_CLASS_NAME,
  description: 'A delicious religion like food and arguably the best export of Italy.',
  invertedIndexConfig: {
    indexTimestamps: true,
  },
  properties: foodProperties,
};

const soupClass = {
  class: SOUP_CLASS_NAME,
  description: 'Mostly water based brew of sustenance for humans.',
  properties: foodProperties,
};

const pizzaObjects: WeaviateObject[] = [
  {
    class: PIZZA_CLASS_NAME,
    id: '10523cdd-15a2-42f4-81fa-267fe92f7cd6',
    properties: {
      name: 'Quattro Formaggi',
      description:
        "Pizza quattro formaggi Italian: ['kwattro for'maddÊ’i] (four cheese pizza) is a variety of pizza in Italian cuisine that is topped with a combination of four kinds of cheese, usually melted together, with (rossa, red) or without (bianca, white) tomato sauce. It is popular worldwide, including in Italy,[1] and is one of the iconic items from pizzerias's menus.",
      bestBefore: '2022-01-02T03:04:05+01:00',
    },
  },
  {
    class: PIZZA_CLASS_NAME,
    id: '927dd3ac-e012-4093-8007-7799cc7e81e4',
    properties: {
      name: 'Frutti di Mare',
      description:
        'Frutti di Mare is an Italian type of pizza that may be served with scampi, mussels or squid. It typically lacks cheese, with the seafood being served atop a tomato sauce.',
      bestBefore: '2022-02-03T04:05:06+02:00',
    },
  },
  {
    class: PIZZA_CLASS_NAME,
    id: 'f824a18e-c430-4475-9bef-847673fbb54e',
    properties: {
      name: 'Hawaii',
      description: 'Universally accepted to be the best pizza ever created.',
      bestBefore: '2022-03-04T05:06:07+03:00',
    },
  },
  {
    class: PIZZA_CLASS_NAME,
    id: 'd2b393ff-4b26-48c7-b554-218d970a9e17',
    properties: {
      name: 'Doener',
      description: 'A innovation, some say revolution, in the pizza industry.',
      bestBefore: '2022-04-05T06:07:08+04:00',
    },
  },
];

const soupObjects: WeaviateObject[] = [
  {
    class: SOUP_CLASS_NAME,
    id: '8c156d37-81aa-4ce9-a811-621e2702b825',
    properties: {
      name: 'ChickenSoup',
      description: 'Used by humans when their inferior genetics are attacked by microscopic organisms.',
      bestBefore: '2022-05-06T07:08:09+05:00',
    },
  },
  {
    class: SOUP_CLASS_NAME,
    id: '27351361-2898-4d1a-aad7-1ca48253eb0b',
    properties: {
      name: 'Beautiful',
      description: 'Putting the game of letter soups to a whole new level.',
      bestBefore: '2022-06-07T08:09:10+06:00',
    },
  },
];

export function createTestFoodSchema(client: WeaviateClient) {
  return Promise.all([
    client.schema.classCreator().withClass(pizzaClass).do(),
    client.schema.classCreator().withClass(soupClass).do(),
  ]);
}

export function createTestFoodData(client: WeaviateClient) {
  return client.batch
    .objectsBatcher()
    .withObjects(...pizzaObjects)
    .withObjects(...soupObjects)
    .do();
}

export function createTestFoodSchemaAndData(client: WeaviateClient) {
  return createTestFoodSchema(client).then(() => createTestFoodData(client));
}

export function cleanupTestFood(client: WeaviateClient) {
  return Promise.all([
    client.schema.classDeleter().withClassName(PIZZA_CLASS_NAME).do(),
    client.schema.classDeleter().withClassName(SOUP_CLASS_NAME).do(),
  ]);
}



---
File: /src/utils/uuid.ts
---

import { v5 as uuid5 } from 'uuid';

// Generates UUIDv5, used to consistently generate the same UUID for
// a specific identifier and namespace
export function generateUuid5(identifier: string | number, namespace: string | number = ''): string {
  const stringified = identifier.toString() + namespace.toString();
  return uuid5(stringified, uuid5.DNS).toString();
}



---
File: /src/v2/index.ts
---

import backup, { Backup } from '../backup/index.js';
import batch, { Batch } from '../batch/index.js';
import c11y, { C11y } from '../c11y/index.js';
import classifications, { Classifications } from '../classifications/index.js';
import cluster, { Cluster } from '../cluster/index.js';
import {
  ApiKey,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
  AuthUserPasswordCredentials,
  OidcAuthenticator,
} from '../connection/auth.js';
import { ConnectionGQL, InternalConnectionParams as ConnectionParams } from '../connection/index.js';
import data, { Data } from '../data/index.js';
import graphql, { GraphQL } from '../graphql/index.js';
import misc, { Misc } from '../misc/index.js';
import MetaGetter from '../misc/metaGetter.js';
import schema, { Schema } from '../schema/index.js';
import { DbVersionProvider, DbVersionSupport } from '../utils/dbVersion.js';

export interface WeaviateClient {
  graphql: GraphQL;
  schema: Schema;
  data: Data;
  classifications: Classifications;
  batch: Batch;
  misc: Misc;
  c11y: C11y;
  backup: Backup;
  cluster: Cluster;
  oidcAuth?: OidcAuthenticator;
}

const app = {
  client: function (params: ConnectionParams): WeaviateClient {
    // check if the URL is set
    if (!params.host) throw new Error('Missing `host` parameter');

    // check if headers are set
    if (!params.headers) params.headers = {};

    const conn = new ConnectionGQL(params);
    const dbVersionProvider = initDbVersionProvider(conn);
    const dbVersionSupport = new DbVersionSupport(dbVersionProvider);

    const ifc: WeaviateClient = {
      graphql: graphql(conn),
      schema: schema(conn),
      data: data(conn, dbVersionSupport),
      classifications: classifications(conn),
      batch: batch(conn, dbVersionSupport),
      misc: misc(conn, dbVersionProvider),
      c11y: c11y(conn),
      backup: backup(conn),
      cluster: cluster(conn),
    };

    if (conn.oidcAuth) ifc.oidcAuth = conn.oidcAuth;

    return ifc;
  },

  ApiKey,
  AuthUserPasswordCredentials,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
};

function initDbVersionProvider(conn: ConnectionGQL) {
  const metaGetter = new MetaGetter(conn);
  const versionGetter = () => {
    return metaGetter
      .do()
      .then((result: any) => result.version)
      .catch(() => Promise.resolve(''));
  };

  const dbVersionProvider = new DbVersionProvider(versionGetter);
  dbVersionProvider.refresh();

  return dbVersionProvider;
}

export default app;
export * from '../backup/index.js';
export * from '../batch/index.js';
export * from '../c11y/index.js';
export * from '../classifications/index.js';
export * from '../cluster/index.js';
export * from '../connection/index.js';
export * from '../data/index.js';
export * from '../graphql/index.js';
export * from '../misc/index.js';
export * from '../openapi/types.js';
export * from '../schema/index.js';
export * from '../utils/base64.js';
export * from '../utils/uuid.js';



---
File: /src/validation/commandBase.ts
---

import Connection from '../connection/index.js';

export interface ICommandBase {
  /**
   * The client's connection
   */
  client: Connection;
  /**
   * An array of validation errors
   */
  errors: string[];
  /**
   * Execute the command
   */
  do: () => Promise<any>;
  /**
   * Optional method to build the payload of an actual call
   */
  payload?: () => any;
  /**
   * validate that all the required parameters were feed to the builder
   */
  validate: () => void;
}

export abstract class CommandBase implements ICommandBase {
  private _errors: string[];
  public readonly client: Connection;

  protected constructor(client: Connection) {
    this.client = client;
    this._errors = [];
  }

  public get errors(): string[] {
    return this._errors;
  }

  addError(error: string) {
    this._errors = [...this.errors, error];
  }

  addErrors(errors: string[]) {
    this._errors = [...this.errors, ...errors];
  }

  abstract do(): Promise<any>;

  abstract validate(): void;
}



---
File: /src/validation/number.ts
---

export function isValidIntProperty(input: any) {
  return Number.isInteger(input);
}

export function isValidPositiveIntProperty(input: any) {
  return isValidIntProperty(input) && input >= 0;
}

export function isValidNumber(input: any) {
  return typeof input == 'number';
}

export function isValidNumberArray(input: any) {
  if (Array.isArray(input)) {
    for (const i in input) {
      if (!isValidNumber(input[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}



---
File: /src/validation/string.ts
---

export function isValidStringProperty(input: any) {
  return typeof input == 'string' && input.length > 0;
}

export function isValidStringArray(input: any) {
  if (Array.isArray(input)) {
    for (const i in input) {
      if (!isValidStringProperty(input[i])) {
        return false;
      }
    }
    return true;
  }
  return false;
}



---
File: /src/validation/version.ts
---

export function isValidWeaviateVersion(version: string) {
  if (typeof version === 'string') {
    const versionNumbers = version.split('.');
    if (versionNumbers.length >= 2) {
      const major = parseInt(versionNumbers[0], 10);
      const minor = parseInt(versionNumbers[1], 10);
      return !(major <= 1 && minor < 16);
    }
  }
  return true;
}



---
File: /src/errors.ts
---

class WeaviateError extends Error {
  public message: string;
  constructor(message: string) {
    super(message);
    this.message = message;
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

/**
 * Is thrown if the input to a function is invalid.
 */
export class WeaviateInvalidInputError extends WeaviateError {
  constructor(message: string) {
    super(`Invalid input provided: ${message}`);
  }
}

/**
 * Is thrown if a query (either gRPC or GraphQL) to Weaviate fails in any way.
 */
export class WeaviateQueryError extends WeaviateError {
  constructor(message: string, protocolType: 'GraphQL' | 'gRPC') {
    super(`Query call with protocol ${protocolType} failed with message: ${message}`);
  }
}

/**
 * Is thrown if a gRPC delete many request to Weaviate fails in any way.
 */
export class WeaviateDeleteManyError extends WeaviateError {
  constructor(message: string) {
    super(`Delete many failed with message: ${message}`);
  }
}

/**
 * Is thrown if a gRPC batch query to Weaviate fails in any way.
 */
export class WeaviateBatchError extends WeaviateError {
  constructor(message: string) {
    super(`Batch objects insert failed with message: ${message}`);
  }
}

/**
 * Is thrown if the gRPC health check against Weaviate fails.
 */
export class WeaviateGRPCUnavailableError extends WeaviateError {
  constructor(address: string) {
    const grpcMsg = `Please check that the server address and port: ${address} are correct.`;
    const msg = `Weaviate makes use of a high-speed gRPC API as well as a REST API.
      Unfortunately, the gRPC health check against Weaviate could not be completed.

      This error could be due to one of several reasons:
        - The gRPC traffic at the specified port is blocked by a firewall.
        - gRPC is not enabled or incorrectly configured on the server or the client.
            - ${grpcMsg}
        - your connection is unstable or has a high latency. In this case you can:
            - increase init-timeout in weaviate.connectToLocal({timeout: {init: X}})'
            - disable startup checks by connecting using 'skipInitChecks=true'
    `;
    super(msg);
  }
}

/**
 * Is thrown if data returned by Weaviate cannot be processed by the client.
 */
export class WeaviateDeserializationError extends WeaviateError {
  constructor(message: string) {
    super(`Converting data from Weaviate failed with message: ${message}`);
  }
}

/**
 * Is thrown if data to be sent to Weaviate cannot be processed by the client.
 */
export class WeaviateSerializationError extends WeaviateError {
  constructor(message: string) {
    super(`Converting data to Weaviate failed with message: ${message}`);
  }
}

/**
 * Is thrown if Weaviate returns an unexpected status code.
 */
export class WeaviateUnexpectedStatusCodeError extends WeaviateError {
  public code: number;
  constructor(code: number, message: string) {
    super(`The request to Weaviate failed with status code: ${code} and message: ${message}`);
    this.code = code;
  }
}

export class WeaviateUnexpectedResponseError extends WeaviateError {
  constructor(message: string) {
    super(`The response from Weaviate was unexpected: ${message}`);
  }
}

/**
 * Is thrown when a backup creation or restoration fails.
 */
export class WeaviateBackupFailed extends WeaviateError {
  constructor(message: string, kind: 'creation' | 'restoration') {
    super(`Backup ${kind} failed with message: ${message}`);
  }
}

/**
 * Is thrown when a backup creation or restoration fails.
 */
export class WeaviateBackupCanceled extends WeaviateError {
  constructor(kind: 'creation' | 'restoration') {
    super(`Backup ${kind} was canceled`);
  }
}

export class WeaviateBackupCancellationError extends WeaviateError {
  constructor(message: string) {
    super(`Backup cancellation failed with message: ${message}`);
  }
}

/**
 * Is thrown if the Weaviate server does not support a feature that the client is trying to use.
 */
export class WeaviateUnsupportedFeatureError extends WeaviateError {}

/**
 * Is thrown if the Weaviate server was not able to start up.
 */
export class WeaviateStartUpError extends WeaviateError {
  constructor(message: string) {
    super(`Weaviate startup failed with message: ${message}`);
  }
}

/**
 * Is thrown if a request to Weaviate times out.
 */
export class WeaviateRequestTimeoutError extends WeaviateError {
  constructor(message: string) {
    super(`Weaviate request timed out with message: ${message}`);
  }
}



---
File: /src/index.ts
---

import { Backend, BackupCompressionLevel, BackupStatus } from './backup/index.js';
import { Backup, backup } from './collections/backup/client.js';
import cluster, { Cluster } from './collections/cluster/index.js';
import { configGuards } from './collections/config/index.js';
import { configure, reconfigure } from './collections/configure/index.js';
import collections, { Collections } from './collections/index.js';
import {
  AccessTokenCredentialsInput,
  ApiKey,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
  AuthCredentials,
  AuthUserPasswordCredentials,
  ClientCredentialsInput,
  OidcAuthenticator,
  UserPasswordCredentialsInput,
  isApiKey,
  mapApiKey,
} from './connection/auth.js';
import * as helpers from './connection/helpers.js';
import {
  ConnectToCustomOptions,
  ConnectToLocalOptions,
  ConnectToWCDOptions,
  ConnectToWCSOptions,
  ConnectToWeaviateCloudOptions,
} from './connection/helpers.js';
import { ProxiesParams, TimeoutParams } from './connection/http.js';
import { ConnectionGRPC } from './connection/index.js';
import MetaGetter from './misc/metaGetter.js';
import { Meta } from './openapi/types.js';
import { DbVersion } from './utils/dbVersion.js';

import { Agent as HttpAgent } from 'http';
import { Agent as HttpsAgent } from 'https';
import { LiveChecker, OpenidConfigurationGetter, ReadyChecker } from './misc/index.js';

import weaviateV2 from './v2/index.js';

import { ConsistencyLevel } from './data/replication.js';

export type ProtocolParams = {
  /**
   * The host to connect to. E.g., `localhost` or `example.com`.
   */
  host: string;
  /**
   * The port to connect to. E.g., `8080` or `80`.
   */
  port: number;
  /**
   * Whether to use a secure connection (https).
   */
  secure: boolean;
  /**
   * An optional path in the case that you are using a forwarding proxy.
   *
   * E.g., http://localhost:8080/weaviate
   */
  path?: string;
};

export type ConnectionParams = {
  /**
   * The connection parameters for the REST and GraphQL APIs (http/1.1).
   */
  http: ProtocolParams;
  /**
   * The connection paramaters for the gRPC API (http/2).
   */
  grpc: ProtocolParams;
};

export type ClientParams = {
  /**
   * The connection parameters for Weaviate's public APIs.
   */
  connectionParams: ConnectionParams;
  /**
   * The credentials used to authenticate with Weaviate.
   *
   * Can be any of `AuthUserPasswordCredentials`, `AuthAccessTokenCredentials`, `AuthClientCredentials`, and `ApiKey`.
   */
  auth?: AuthCredentials;
  /**
   * Additional headers that should be passed to Weaviate in the underlying requests. E.g., X-OpenAI-Api-Key
   */
  headers?: HeadersInit;
  /**
   * The connection parameters for any tunnelling proxies that should be used.
   *
   * Note, if your proxy is a forwarding proxy then supply its configuration as if it were the Weaviate server itself using `rest` and `grpc`.
   */
  proxies?: ProxiesParams;
  /** The timeouts to use when making requests to Weaviate */
  timeout?: TimeoutParams;
  /** Whether to skip the initialization checks */
  skipInitChecks?: boolean;
};

export interface WeaviateClient {
  backup: Backup;
  cluster: Cluster;
  collections: Collections;
  oidcAuth?: OidcAuthenticator;

  close: () => Promise<void>;
  getMeta: () => Promise<Meta>;
  getOpenIDConfig?: () => Promise<any>;
  getWeaviateVersion: () => Promise<DbVersion>;
  isLive: () => Promise<boolean>;
  isReady: () => Promise<boolean>;
}

const cleanHost = (host: string, protocol: 'rest' | 'grpc') => {
  if (host.includes('http')) {
    console.warn(
      `The ${protocol}.host parameter should not include the protocol. Please remove the http:// or https:// from the ${protocol}.host parameter.\
      To specify a secure connection, set the secure parameter to true. The protocol will be inferred from the secure parameter instead.`
    );
    return host.replace('http://', '').replace('https://', '');
  }
  return host;
};

/**
 * Connect to a custom Weaviate deployment, e.g. your own self-hosted Kubernetes cluster.
 *
 * @param {ConnectToCustomOptions} options Options for the connection.
 * @returns {Promise<WeaviateClient>} A Promise that resolves to a client connected to your custom Weaviate deployment.
 */
export function connectToCustom(options: ConnectToCustomOptions): Promise<WeaviateClient> {
  return helpers.connectToCustom(client, options);
}

/**
 * Connect to a locally-deployed Weaviate instance, e.g. as a Docker compose stack.
 *
 * @param {ConnectToLocalOptions} [options] Options for the connection.
 * @returns {Promise<WeaviateClient>} A Promise that resolves to a client connected to your local Weaviate instance.
 */
export function connectToLocal(options?: ConnectToLocalOptions): Promise<WeaviateClient> {
  return helpers.connectToLocal(client, options);
}

/**
 * Connect to your own Weaviate Cloud (WCD) instance.
 *
 * @deprecated Use `connectToWeaviateCloud` instead.
 *
 * @param {string} clusterURL The URL of your WCD instance. E.g., `https://example.weaviate.network`.
 * @param {ConnectToWCDOptions} [options] Additional options for the connection.
 * @returns {Promise<WeaviateClient>} A Promise that resolves to a client connected to your WCD instance.
 */
export function connectToWCD(clusterURL: string, options?: ConnectToWCDOptions): Promise<WeaviateClient> {
  console.warn(
    'The `connectToWCD` method is deprecated. Please use `connectToWeaviateCloud` instead. This method will be removed in a future release.'
  );
  return helpers.connectToWeaviateCloud(clusterURL, client, options);
}

/**
 * Connect to your own Weaviate Cloud Service (WCS) instance.
 *
 * @deprecated Use `connectToWeaviateCloud` instead.
 *
 * @param {string} clusterURL The URL of your WCD instance. E.g., `https://example.weaviate.network`.
 * @param {ConnectToWCSOptions} [options] Additional options for the connection.
 * @returns {Promise<WeaviateClient>} A Promise that resolves to a client connected to your WCS instance.
 */
export function connectToWCS(clusterURL: string, options?: ConnectToWCSOptions): Promise<WeaviateClient> {
  console.warn(
    'The `connectToWCS` method is deprecated. Please use `connectToWeaviateCloud` instead. This method will be removed in a future release.'
  );
  return helpers.connectToWeaviateCloud(clusterURL, client, options);
}

/**
 * Connect to your own Weaviate Cloud (WCD) instance.
 *
 * @param {string} clusterURL The URL of your WCD instance. E.g., `https://example.weaviate.network`.
 * @param {ConnectToWeaviateCloudOptions} [options] Additional options for the connection.
 * @returns {Promise<WeaviateClient>} A Promise that resolves to a client connected to your WCD instance.
 */
export function connectToWeaviateCloud(
  clusterURL: string,
  options?: ConnectToWeaviateCloudOptions
): Promise<WeaviateClient> {
  return helpers.connectToWeaviateCloud(clusterURL, client, options);
}

async function client(params: ClientParams): Promise<WeaviateClient> {
  let { host: httpHost } = params.connectionParams.http;
  let { host: grpcHost } = params.connectionParams.grpc;
  const { port: httpPort, secure: httpSecure, path: httpPath } = params.connectionParams.http;
  const { port: grpcPort, secure: grpcSecure } = params.connectionParams.grpc;
  httpHost = cleanHost(httpHost, 'rest');
  grpcHost = cleanHost(grpcHost, 'grpc');

  // check if headers are set
  if (!params.headers) params.headers = {};

  const scheme = httpSecure ? 'https' : 'http';
  const agent = httpSecure ? new HttpsAgent({ keepAlive: true }) : new HttpAgent({ keepAlive: true });

  const { connection, dbVersionProvider, dbVersionSupport } = await ConnectionGRPC.use({
    host: `${scheme}://${httpHost}:${httpPort}${httpPath || ''}`,
    scheme: scheme,
    headers: params.headers,
    grpcAddress: `${grpcHost}:${grpcPort}`,
    grpcSecure: grpcSecure,
    grpcProxyUrl: params.proxies?.grpc,
    apiKey: isApiKey(params.auth) ? mapApiKey(params.auth) : undefined,
    authClientSecret: isApiKey(params.auth) ? undefined : params.auth,
    agent,
    timeout: params.timeout,
    skipInitChecks: params.skipInitChecks,
  });

  const ifc: WeaviateClient = {
    backup: backup(connection),
    cluster: cluster(connection),
    collections: collections(connection, dbVersionSupport),
    close: () => Promise.resolve(connection.close()), // hedge against future changes to add I/O to .close()
    getMeta: () => new MetaGetter(connection).do(),
    getOpenIDConfig: () => new OpenidConfigurationGetter(connection.http).do(),
    getWeaviateVersion: () => dbVersionSupport.getVersion(),
    isLive: () => new LiveChecker(connection, dbVersionProvider).do(),
    isReady: () => new ReadyChecker(connection, dbVersionProvider).do(),
  };
  if (connection.oidcAuth) ifc.oidcAuth = connection.oidcAuth;

  return ifc;
}

const app = {
  connectToCustom,
  connectToLocal,
  connectToWCD,
  connectToWCS,
  connectToWeaviateCloud,
  client,
  ApiKey,
  AuthUserPasswordCredentials,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
  configure,
  configGuards,
  reconfigure,
};

export default app;
export * from './collections/index.js';
export * from './connection/index.js';
export * from './utils/base64.js';
export * from './utils/uuid.js';
export {
  AccessTokenCredentialsInput,
  ApiKey,
  AuthAccessTokenCredentials,
  AuthClientCredentials,
  AuthCredentials,
  AuthUserPasswordCredentials,
  Backend,
  BackupCompressionLevel,
  BackupStatus,
  ClientCredentialsInput,
  ConsistencyLevel,
  ProxiesParams,
  TimeoutParams,
  UserPasswordCredentialsInput,
  weaviateV2,
};



---
File: /src/integration.test.ts
---

import weaviate from './index.js';

describe('Integration testing of the client methods', () => {
  it('should connect using connectToLocal defaults', () => {
    return weaviate.connectToLocal();
  });

  it('should connect using connectToLocal with schema-ed host', () => {
    const logSpy = jest.spyOn(console, 'warn');
    return weaviate
      .connectToLocal({
        host: 'http://localhost',
      })
      .then(() => expect(logSpy).toHaveBeenCalledTimes(2));
  });

  it('should connect using connectToLocal with non-schema-ed host', () => {
    return weaviate.connectToLocal({
      host: 'localhost',
    });
  });
});



---
File: /test/dbVersionProvider.ts
---

import { DbVersion, VersionProvider } from '../src/utils/dbVersion.js';

export class TestDbVersionProvider implements VersionProvider {
  private version: string;

  constructor(version: string) {
    this.version = version;
  }

  getVersionString(): Promise<string> {
    return Promise.resolve(this.version);
  }

  getVersion(): Promise<DbVersion> {
    return Promise.resolve(DbVersion.fromString(this.version));
  }
}



---
File: /test/images.journey.test.ts
---

import fs from 'fs';
import weaviate, { toBase64FromMedia } from '../src/';

describe('Journey testing of the image functionality', () => {
  const collectionName = 'ImageJourneyTesting';

  beforeAll(async () => {
    const client = await weaviate.connectToLocal();
    await client.collections.delete(collectionName);
  });

  it('should create a collection with an image property and capable vectorizer', async () => {
    const client = await weaviate.connectToLocal();
    await client.collections.create({
      name: collectionName,
      properties: [
        {
          name: 'image',
          dataType: 'blob',
        },
      ],
      vectorizers: weaviate.configure.vectorizer.img2VecNeural({
        imageFields: ['image'],
      }),
    });
  });

  it('should insert an encoded image', async () => {
    const client = await weaviate.connectToLocal();
    await client.collections.get(collectionName).data.insert({
      image: await toBase64FromMedia('./public/favicon.ico'),
    });
  });

  it('should retrieve the encoded image', async () => {
    const client = await weaviate.connectToLocal();
    const res = await client.collections
      .get(collectionName)
      .query.fetchObjects({ returnProperties: ['image'] });
    expect(res.objects[0].properties.image).toBeDefined();
  });

  it('should search on the encoded image vector with a file path string', async () => {
    const client = await weaviate.connectToLocal();
    const res = await client.collections.get(collectionName).query.nearImage('./public/favicon.ico');
    expect(res.objects.length).toEqual(1);
  });

  it('should search on the encoded image vector with a buffer', async () => {
    const client = await weaviate.connectToLocal();
    const res = await client.collections
      .get(collectionName)
      .query.nearImage(fs.readFileSync('./public/favicon.ico')); // eslint-disable-line no-sync
    expect(res.objects.length).toEqual(1);
  });
});



---
File: /test/server.ts
---

import bodyParser from '@curveball/bodyparser';
import { Application } from '@curveball/core';
import { IncomingMessage, Server, ServerResponse } from 'http';

export interface IServerCache {
  server: Server<typeof IncomingMessage, typeof ServerResponse>;
  app: Application;
  lastRequest: () => any;
  port: number;
  url: string;
  close: () => Promise<unknown>;
}

const port = 40101;
let serverCache: IServerCache | null = null;

export function testServer() {
  if (serverCache) {
    return serverCache;
  }

  let lastRequest: any = null;
  const app = new Application();

  app.use((bodyParser as any)());
  app.use((ctx, next) => {
    lastRequest = ctx.request;
    return next();
  });
  app.use(getLocalOidcConfig, getRemoteOidcConfig, issueToken, mockGetEndpoint, mockGraphQLResponse);
  const server = app.listen(port);

  serverCache = {
    server,
    app,
    lastRequest: () => lastRequest,
    port,
    url: 'http://localhost:' + port,
    close: () => {
      return new Promise((res: any) => {
        server.close(() => res());
      });
    },
  };

  return serverCache;
}

const mockGetEndpoint = (ctx: any, next: any) => {
  if (ctx.path !== '/v1/testEndpoint') {
    return next();
  }

  ctx.response.status = 200;
  ctx.response.body = { message: 'test endpoint' };
};

const mockGraphQLResponse = (ctx: any, next: any) => {
  if (ctx.path !== '/v1/graphql') {
    return next();
  }

  ctx.response.status = 200;
  ctx.response.body = {
    data: {
      someField: 'someValue',
    },
  };
};

const getLocalOidcConfig = (ctx: any, next: any) => {
  if (ctx.path !== '/v1/.well-known/openid-configuration') {
    return next();
  }

  ctx.response.type = 'application/json';
  ctx.response.body = {
    clientId: 'client123',
    href: 'http://localhost:' + port + '/remote-openid-configuration',
  };
};

const getRemoteOidcConfig = (ctx: any, next: any) => {
  if (ctx.path !== '/remote-openid-configuration') {
    return next();
  }

  ctx.response.type = 'application/json';
  ctx.response.body = {
    token_endpoint: 'http://localhost:' + port + '/token',
    grant_types_supported: ['refresh_token', 'password'],
  };
};

const issueToken = (ctx: any, next: any) => {
  if (ctx.path !== '/token') {
    return next();
  }

  ctx.response.type = 'application/json';
  ctx.response.body = {
    access_token: 'access_token_000',
    refresh_token: 'refresh_token_000',
    expires_in: 3600,
  };
};



---
File: /.eslintrc.cjs
---

module.exports = {
  env: {
    node: true,
    es6: true,
  },
  rules: {
    'accessor-pairs': 'error',
    'array-bracket-spacing': ['error', 'never'],
    'array-callback-return': 'off',
    'arrow-parens': 'error',
    'arrow-spacing': 'error',
    'block-scoped-var': 'off',
    'block-spacing': 'off',
    'brace-style': [
      'error',
      '1tbs',
      {
        allowSingleLine: true,
      },
    ],
    'capitalized-comments': 'off',
    'class-methods-use-this': 'off',
    'comma-dangle': 'off',
    'comma-spacing': 'off',
    'comma-style': ['error', 'last'],
    complexity: ['error', 25],
    'computed-property-spacing': ['error', 'never'],
    'consistent-return': 'off',
    'consistent-this': 'off',
    curly: 'error',
    'default-case': 'off',
    'dot-location': ['error', 'property'],
    'dot-notation': 'error',
    'eol-last': 'error',
    eqeqeq: 'off',
    'func-call-spacing': 'error',
    'func-name-matching': 'error',
    'func-names': 'off',
    'func-style': ['error', 'declaration', { allowArrowFunctions: true }],
    'generator-star-spacing': 'error',
    'global-require': 'off',
    'guard-for-in': 'off',
    'handle-callback-err': 'off',
    'id-blacklist': 'error',
    'id-length': 'off',
    'id-match': 'error',
    'init-declarations': 'off',
    'jsx-quotes': 'error',
    'key-spacing': 'error',
    'keyword-spacing': [
      'error',
      {
        after: true,
        before: true,
      },
    ],
    'line-comment-position': 'off',
    'linebreak-style': ['error', 'unix'],
    'lines-around-directive': 'error',
    'max-depth': 'error',
    'max-len': 'off',
    'max-lines': 'off',
    'max-nested-callbacks': 'error',
    'max-params': 'off',
    'max-statements': 'off',
    'max-statements-per-line': 'off',
    'multiline-ternary': 'off',
    'new-cap': 'error',
    'new-parens': 'error',
    'newline-after-var': 'off',
    'newline-before-return': 'off',
    'newline-per-chained-call': 'off',
    'no-alert': 'error',
    'no-array-constructor': 'error',
    'no-await-in-loop': 'error',
    'no-bitwise': 'off',
    'no-caller': 'error',
    'no-catch-shadow': 'off',
    'no-compare-neg-zero': 'error',
    'no-confusing-arrow': 'error',
    'no-continue': 'off',
    'no-div-regex': 'error',
    'no-duplicate-imports': 'error',
    'no-else-return': 'off',
    'no-empty-function': 'off',
    'no-eq-null': 'off',
    'no-eval': 'error',
    'no-extend-native': 'error',
    'no-extra-bind': 'error',
    'no-extra-label': 'error',
    'no-extra-parens': 'off',
    'no-floating-decimal': 'error',
    'no-implicit-globals': 'error',
    'no-implied-eval': 'error',
    'no-inline-comments': 'off',
    'no-inner-declarations': ['error', 'functions'],
    'no-invalid-this': 'off',
    'no-iterator': 'error',
    'no-label-var': 'error',
    'no-labels': 'error',
    'no-lone-blocks': 'error',
    'no-lonely-if': 'error',
    'no-loop-func': 'error',
    'no-magic-numbers': 'off',
    'no-mixed-requires': 'error',
    'no-multi-assign': 'off',
    'no-multi-spaces': 'error',
    'no-multi-str': 'error',
    'no-multiple-empty-lines': 'error',
    'no-native-reassign': 'error',
    'no-negated-condition': 'off',
    'no-negated-in-lhs': 'error',
    'no-nested-ternary': 'off',
    'no-new': 'error',
    'no-new-func': 'error',
    'no-new-object': 'error',
    'no-new-require': 'error',
    'no-new-wrappers': 'error',
    'no-octal-escape': 'error',
    'no-param-reassign': 'off',
    'no-path-concat': 'error',
    'no-plusplus': [
      'error',
      {
        allowForLoopAfterthoughts: true,
      },
    ],
    'no-process-env': 'off',
    'no-process-exit': 'error',
    'no-proto': 'error',
    'no-prototype-builtins': 'off',
    'no-restricted-globals': 'error',
    'no-restricted-imports': 'error',
    'no-restricted-modules': 'error',
    'no-restricted-properties': 'error',
    'no-restricted-syntax': 'error',
    'no-return-assign': 'error',
    'no-return-await': 'error',
    'no-script-url': 'error',
    'no-self-compare': 'error',
    'no-sequences': 'error',
    'no-shadow': 'off',
    'no-shadow-restricted-names': 'error',
    'no-spaced-func': 'error',
    'no-sync': 'error',
    'no-tabs': 'error',
    'no-template-curly-in-string': 'error',
    'no-ternary': 'off',
    'no-throw-literal': 'error',
    'no-trailing-spaces': 'error',
    'no-undef-init': 'error',
    'no-undefined': 'off',
    'no-underscore-dangle': 'off',
    'no-unmodified-loop-condition': 'error',
    'no-unneeded-ternary': 'error',
    'no-unused-expressions': 'error',
    'no-unused-vars': [
      'error',
      {
        args: 'none',
      },
    ],
    'no-use-before-define': 'off',
    'no-useless-call': 'error',
    'no-useless-computed-key': 'error',
    'no-useless-concat': 'error',
    'no-useless-constructor': 'off',
    'no-useless-escape': 'off',
    'no-useless-rename': 'error',
    'no-useless-return': 'error',
    'no-var': 'off',
    'no-void': 'error',
    'no-warning-comments': 'warn',
    'no-whitespace-before-property': 'error',
    'no-with': 'error',
    'nonblock-statement-body-position': 'error',
    'object-curly-newline': 'off',
    'object-curly-spacing': 'off',
    'object-property-newline': 'off',
    'object-shorthand': 'off',
    'one-var': 'off',
    'one-var-declaration-per-line': 'error',
    'operator-assignment': ['error', 'always'],
    'operator-linebreak': 'off',
    'padded-blocks': 'off',
    'prefer-arrow-callback': 'off',
    'prefer-const': 'error',
    'prefer-destructuring': [
      'error',
      {
        array: false,
        object: false,
      },
    ],
    'prefer-numeric-literals': 'error',
    'prefer-promise-reject-errors': 'error',
    'prefer-reflect': 'off',
    'prefer-rest-params': 'off',
    'prefer-spread': 'off',
    'prefer-template': 'off',
    'quote-props': 'off',
    quotes: [
      'error',
      'single',
      {
        avoidEscape: true,
      },
    ],
    radix: 'error',
    'require-await': 'error',
    'require-jsdoc': 'off',
    'rest-spread-spacing': 'error',
    semi: 'off',
    'semi-spacing': [
      'error',
      {
        after: true,
        before: false,
      },
    ],
    'sort-imports': 'off',
    'sort-keys': 'off',
    'sort-vars': 'error',
    'space-before-blocks': 'error',
    'space-before-function-paren': 'off',
    'space-in-parens': ['error', 'never'],
    'space-infix-ops': 'error',
    'space-unary-ops': 'error',
    'spaced-comment': ['error', 'always'],
    strict: 'off',
    'symbol-description': 'error',
    'template-curly-spacing': 'error',
    'template-tag-spacing': 'error',
    'unicode-bom': ['error', 'never'],
    'valid-jsdoc': 'off',
    'vars-on-top': 'off',
    'wrap-regex': 'off',
    'yield-star-spacing': 'error',
    yoda: ['error', 'never'],
  },
  parserOptions: {
    ecmaVersion: 2018,
  },
  plugins: ['prettier'],
  extends: ['plugin:prettier/recommended'],
  overrides: [
    {
      files: ['**/*.ts'],
      parser: '@typescript-eslint/parser',
      plugins: ['@typescript-eslint', 'prettier'],
      extends: [
        'eslint:recommended',
        'plugin:@typescript-eslint/eslint-recommended',
        'plugin:@typescript-eslint/recommended',
        'plugin:prettier/recommended',
      ],
      rules: {
        '@typescript-eslint/no-use-before-define': 0,
        '@typescript-eslint/no-empty-interface': 0,
        '@typescript-eslint/no-unused-vars': 0,
        '@typescript-eslint/triple-slash-reference': 0,
        '@typescript-eslint/ban-ts-comment': 'off',
        '@typescript-eslint/no-empty-function': 0,
        '@typescript-eslint/naming-convention': [
          'error',
          {
            selector: 'default',
            format: ['camelCase', 'UPPER_CASE', 'PascalCase'],
            leadingUnderscore: 'allow',
          },
          {
            selector: 'property',
            format: null,
          },
        ],
        '@typescript-eslint/no-explicit-any': 0,
        '@typescript-eslint/no-var-requires': 0,
        'prefer-rest-params': 'off',
      },
    },
  ],
};



---
File: /jest.config.ts
---

import { JestConfigWithTsJest } from 'ts-jest';

const config: JestConfigWithTsJest = {
  clearMocks: false,
  collectCoverage: false,
  coverageDirectory: 'coverage',
  coveragePathIgnorePatterns: ['/node_modules/', '/dist/', '/src/proto'],
  coverageProvider: 'v8',
  preset: 'ts-jest/presets/default-esm', // or other ESM presets
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },
  transform: {
    // '^.+\\.[tj]sx?$' to process js/ts with `ts-jest`
    // '^.+\\.m?[tj]sx?$' to process js/ts/mjs/mts with `ts-jest`
    '^.+\\.tsx?$': [
      'ts-jest',
      {
        useESM: true,
      },
    ],
  },
  testEnvironment: 'node',
  testMatch: ['**/*.test.ts'],
  testTimeout: 100000,
};

export default config;



---
File: /tsup.config.ts
---

import { defineConfig } from 'tsup';

export default defineConfig([
  {
    entry: [
      'src/v2/index.ts',
      '!src/index.ts',
      '!src/**/*.test.ts',
      '!src/collections/**/*.ts',
      '!src/connection/grpc.ts',
      '!src/connection/helpers.ts',
      '!src/proto/**/*.ts',
      '!src/grpc',
    ],
    format: ['cjs', 'esm'],
    outDir: 'dist/web',
    clean: true,
    platform: 'browser',
    minify: true,
    dts: true,
    splitting: true,
    treeshake: true,
  },
  // {
  //   entry: {
  //     index: 'src/index.ts',
  //   },
  //   format: ['cjs'],
  //   outDir: 'dist/node/cjs',
  //   dts: true,
  //   target: 'node16',
  //   platform: 'node',
  // },
]);

Directory Structure:

â””â”€â”€ ./
    â””â”€â”€ typescript-embedded-main
        â”œâ”€â”€ .github
        â”‚   â””â”€â”€ workflows
        â”‚       â””â”€â”€ main.yaml
        â”œâ”€â”€ examples
        â”‚   â”œâ”€â”€ embedded
        â”‚   â”‚   â”œâ”€â”€ index.ts
        â”‚   â”‚   â”œâ”€â”€ package.json
        â”‚   â”‚   â””â”€â”€ tsconfig.json
        â”‚   â””â”€â”€ README.md
        â”œâ”€â”€ src
        â”‚   â”œâ”€â”€ embedded.ts
        â”‚   â”œâ”€â”€ index.ts
        â”‚   â”œâ”€â”€ journey.test.ts
        â”‚   â””â”€â”€ unit.test.ts
        â”œâ”€â”€ tools
        â”‚   â”œâ”€â”€ prepare_release.sh
        â”‚   â””â”€â”€ run_embedded_tests_mac.sh
        â”œâ”€â”€ CODE_OF_CONDUCT.md
        â”œâ”€â”€ CONTRIBUTE.md
        â”œâ”€â”€ package-lock.json
        â”œâ”€â”€ package.json
        â”œâ”€â”€ README.md
        â”œâ”€â”€ tsconfig-test.json
        â””â”€â”€ tsconfig.json



---
File: /typescript-embedded-main/.github/workflows/main.yaml
---

on:
  push:
    branches:
      - main
    tags:
      - '**'
  pull_request:


jobs:
  checks:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '18.x'
    - name: "Run checks"
      run: |
        npm install
        npm run lint
        npm run format:check

  tests:
    needs: checks
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '18.x'
    - name: "Install dependencies"
      run: |
        npm ci
    - name: "Run tests"
      run: |
        npm test
        npm run build

  publish:
    needs: tests
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      # Setup .npmrc file to publish to npm
      - uses: actions/setup-node@v3
        with:
          node-version: '18.x'
          registry-url: 'https://registry.npmjs.org'
      - run: npm ci && npm run build
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_AUTOMATION_TOKEN }}



---
File: /typescript-embedded-main/examples/embedded/index.ts
---

import weaviate, { EmbeddedOptions } from 'weaviate-ts-embedded';

if (process.platform !== 'linux') {
  throw new Error('EmbeddedDB only supports Linux at the moment. Try me in a Docker container!');
}

const client = weaviate.client(
  new EmbeddedOptions({
    port: 9898,
  }),
  {
    scheme: 'http',
    host: 'localhost:9898',
  }
);

console.log('Weaviate binary:', client.embedded?.options.binaryPath);
console.log('Data path:', client.embedded?.options.persistenceDataPath);

await client.embedded.start();

console.info('\nEmbedded DB started\n');

// Create object with autoschema
const result = await client.data
  .creator()
  .withClassName('Wine')
  .withProperties({
    name: 'Pinot noir',
    description: 'Smooth taste',
  })
  .do();
console.log(result);

// Dump all objects
const objects = await client.data.getter().do();
console.log(objects);

// Dump metadata
const metadata = await client.misc.metaGetter().do();
console.log(metadata);

console.info('\nStopping...');
client.embedded.stop();
console.info('Exiting...');



---
File: /typescript-embedded-main/examples/embedded/package.json
---

{
  "name": "weaviate-embedded-example",
  "version": "1.0.0",
  "description": "",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "dependencies": {
    "weaviate-ts-embedded": "latest"
  },
  "scripts": {
    "start": "tsc && node dist/index.js"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/node": "^20.1.1",
    "typescript": "^4.9.5"
  }
}



---
File: /typescript-embedded-main/examples/embedded/tsconfig.json
---

{
  "compilerOptions": {
    "target": "esnext",
    "strict": true,
    "preserveConstEnums": true,
    "noEmit": false,
    "sourceMap": false,
    "module":"esnext",
    "moduleResolution":"node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "outDir": "./dist"
  },
  "include": ["**/*"],
  "exclude": ["node_modules"]
}



---
File: /typescript-embedded-main/examples/README.md
---

# Weaviate TypeScript Client Examples

These examples reflect the most current state of the client and its features, so please make sure that you have the latest version of `weaviate-ts-client` installed ðŸ™‚

## Embedded

Run the client with an embedded Weaviate instance! No need to run a separate container, the database will launch with the client.

**MacOS is now supported!**

## JavaScript

Usage within a CommonJS project.

## TypeScipt

TypeScript & ESM JavaScript usage.



---
File: /typescript-embedded-main/src/embedded.ts
---

/* eslint-disable no-sync */
import fs from 'fs';
import { get } from 'https';
import net from 'net';
import { spawn } from 'child_process';
import { dirname, basename } from 'path/posix';
import { homedir } from 'os';
import { join } from 'path';
import { extract } from 'tar';
import { createHash } from 'crypto';
import Unzipper from 'adm-zip';

const defaultBinaryPath = join(homedir(), '.cache/weaviate-embedded');
const defaultPersistenceDataPath = join(homedir(), '.local/share/weaviate');
const defaultVersion = 'latest';

export interface EmbeddedOptionsConfig {
  host?: string;
  port?: number;
  env?: object;
  version?: string;
  binaryUrl?: string;
}

export class EmbeddedOptions {
  binaryPath: string;
  persistenceDataPath: string;
  host: string;
  port: number;
  version?: string;
  binaryUrl?: string;
  env: NodeJS.ProcessEnv;

  constructor(cfg?: EmbeddedOptionsConfig) {
    if (this.version && this.binaryUrl) {
      throw new Error('cannot provide both version and binaryUrl');
    }
    this.host = cfg && cfg.host ? cfg.host : '127.0.0.1';
    this.port = cfg && cfg.port ? cfg.port : 6789;
    this.binaryUrl = cfg?.binaryUrl;
    this.version = this.parseVersion(cfg);
    this.binaryPath = this.getBinaryPath(cfg);
    this.persistenceDataPath = this.getPersistenceDataPath();
    this.env = this.parseEnv(cfg);
  }

  parseEnv(cfg?: EmbeddedOptionsConfig): NodeJS.ProcessEnv {
    if (!this.persistenceDataPath) {
      this.persistenceDataPath = this.getPersistenceDataPath();
    }

    const env: NodeJS.ProcessEnv = {
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: 'true',
      QUERY_DEFAULTS_LIMIT: '20',
      PERSISTENCE_DATA_PATH: this.persistenceDataPath,
      CLUSTER_HOSTNAME: `Embedded_at_${this.port}`,
      DEFAULT_VECTORIZER_MODULE: 'none',
      ENABLE_MODULES:
        'text2vec-openai,text2vec-cohere,text2vec-huggingface,' +
        'ref2vec-centroid,generative-openai,qna-openai',
      // Any above defaults can be overridden with export env vars
      ...process.env,
    };

    if (cfg && cfg.env) {
      Object.entries(cfg.env).forEach(([key, value]) => {
        env[key] = value;
      });
    }
    return env;
  }

  parseVersion(cfg?: EmbeddedOptionsConfig): string | undefined {
    // Use binaryUrl instead
    if (cfg && cfg.binaryUrl) {
      return;
    }
    if (!cfg || !cfg.version) {
      return defaultVersion;
    }
    if (cfg.version == 'latest') {
      return 'latest';
    }
    if (cfg.version.match(/[1-9]\.[1-9]{2}\..*/g)) {
      return cfg.version;
    }
    throw new Error(
      `invalid version: ${cfg.version}. version must resemble '{major}.{minor}.{patch}, or 'latest'`
    );
  }

  getBinaryPath(cfg?: EmbeddedOptionsConfig): string {
    let binaryPath = process.env.XDG_CACHE_HOME;
    if (!binaryPath) {
      binaryPath = defaultBinaryPath;
    }
    if (!this.version) {
      this.version = this.parseVersion(cfg);
    }
    if (this.binaryUrl) {
      const hash = createHash('md5').update(this.binaryUrl).digest('base64url');
      return `${binaryPath}-${hash}`;
    }
    return `${binaryPath}-${this.version}`;
  }

  getPersistenceDataPath(): string {
    let persistenceDataPath = process.env.XDG_DATA_HOME;
    if (!persistenceDataPath) {
      persistenceDataPath = defaultPersistenceDataPath;
    }
    return persistenceDataPath;
  }
}

export class EmbeddedDB {
  options: EmbeddedOptions;
  pid: number;

  constructor(opt: EmbeddedOptions) {
    this.options = opt;
    this.pid = 0;
    this.ensurePathsExist();
    checkSupportedPlatform();
  }

  async start() {
    if (await this.isListening()) {
      console.log(`Embedded db already listening @ ${this.options.host}:${this.options.port}`);
    }

    await this.resolveWeaviateVersion().then(async () => {
      await this.ensureWeaviateBinaryExists();
    });

    if (!this.options.env.CLUSTER_GOSSIP_BIND_PORT) {
      this.options.env.CLUSTER_GOSSIP_BIND_PORT = await getRandomPort();
    }

    const childProc = spawn(
      this.options.binaryPath,
      ['--host', this.options.host, '--port', `${this.options.port}`, '--scheme', 'http'],
      { env: this.options.env }
    );

    childProc.on('error', (err) => {
      console.log(`embedded db failed to start: ${JSON.stringify(err)}`);
    });

    childProc.stdout.pipe(process.stdout);
    childProc.stderr.pipe(process.stderr);

    this.pid = childProc.pid as number;
    console.log(
      `Started ${this.options.binaryPath} @ ${this.options.host}:${this.options.port} -- process ID ${this.pid}`
    );

    await this.waitTillListening();
  }

  stop() {
    try {
      process.kill(this.pid, 'SIGTERM');
      console.log(`Embedded db @ PID ${this.pid} successfully stopped`);
    } catch (err) {
      console.log(`Tried to stop embedded db @ PID ${this.pid}.`, `PID not found, so nothing will be done`);
    }
  }

  private resolveWeaviateVersion(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (this.options.version == 'latest') {
        get(
          'https://api.github.com/repos/weaviate/weaviate/releases/latest',
          { headers: { 'User-Agent': 'Weaviate-Embedded-DB' } },
          (resp) => {
            let body = '';
            resp.on('data', (chunk: string) => {
              body += chunk;
            });
            resp.on('end', () => {
              if (resp.statusCode === 200) {
                try {
                  const json = JSON.parse(body);
                  this.options.version = (json.tag_name as string).slice(1); // trim the `v` prefix
                  resolve();
                } catch (err) {
                  reject(new Error(`failed to parse latest binary version response: ${JSON.stringify(err)}`));
                }
              } else {
                reject(
                  new Error(`fetch latest binary version, unexpected status code ${resp.statusCode}: ${body}`)
                );
              }
            });
          }
        ).on('error', (err) => {
          reject(new Error(`failed to find latest binary version: ${JSON.stringify(err)}`));
        });
      } else {
        resolve();
      }
    });
  }

  private async ensureWeaviateBinaryExists() {
    if (!fs.existsSync(`${this.options.binaryPath}`)) {
      console.log(
        `Binary ${this.options.binaryPath} does not exist.`,
        `Downloading binary for version ${this.options.version || this.options.binaryPath}`
      );
      await this.downloadBinary().then(async (downloadPath) => {
        if (downloadPath.endsWith('tgz')) {
          await this.untarBinary(downloadPath);
        } else {
          await this.unzipBinary(downloadPath);
        }
      });
    }
  }

  private ensurePathsExist() {
    const binPathDir = dirname(this.options.binaryPath);
    fs.mkdirSync(binPathDir, { recursive: true });
    fs.mkdirSync(this.options.persistenceDataPath, { recursive: true });
  }

  private downloadBinary(): Promise<string> {
    const url = this.buildBinaryUrl();

    let path: string;
    if (url.endsWith('.zip')) {
      path = `${this.options.binaryPath}.zip`;
    } else {
      path = `${this.options.binaryPath}.tgz`;
    }

    const file = fs.createWriteStream(path);
    return new Promise((resolve, reject) => {
      get(url, (resp) => {
        if (resp.statusCode == 200) {
          resp.pipe(file);
          file.on('finish', () => {
            file.close();
            resolve(path);
          });
        } else if (resp.statusCode == 302 && resp.headers.location) {
          get(resp.headers.location, (resp) => {
            resp.pipe(file);
            file.on('finish', () => {
              file.close();
              resolve(path);
            });
          });
        } else if (resp.statusCode == 404) {
          reject(
            new Error(
              `failed to download binary: not found. ` +
                `are you sure Weaviate version ${this.options.version} exists? ` +
                `note that embedded db for linux is only supported for versions >= 1.18.0, ` +
                `and embedded db for mac is only supported for versions >= 1.19.8`
            )
          );
        } else {
          reject(new Error(`failed to download binary: unexpected status code: ${resp.statusCode}`));
        }
      }).on('error', (err) => {
        fs.unlinkSync(path);
        reject(new Error(`failed to download binary: ${err}`));
      });
    });
  }

  private buildBinaryUrl(): string {
    if (this.options.binaryUrl) {
      return this.options.binaryUrl;
    }
    let arch: string;
    switch (process.arch) {
      case 'arm64':
        arch = 'arm64';
        break;
      case 'x64':
        arch = 'amd64';
        break;
      default:
        throw new Error(`Embedded DB unsupported architecture: ${process.arch}`);
    }
    let ext = 'tar.gz';
    if (process.platform == 'darwin') {
      ext = 'zip';
      arch = 'all';
    }
    return (
      `https://github.com/weaviate/weaviate/releases/download/v${this.options.version}` +
      `/weaviate-v${this.options.version}-${process.platform}-${arch}.${ext}`
    );
  }

  private untarBinary(tarballPath: string): Promise<null> {
    const tarball = fs.createReadStream(tarballPath);
    return new Promise((resolve, reject) => {
      tarball.pipe(
        extract({
          cwd: dirname(tarballPath),
          strict: true,
        })
          .on('finish', () => {
            tarball.close();
            fs.unlinkSync(tarballPath);
            fs.renameSync(join(dirname(this.options.binaryPath), 'weaviate'), this.options.binaryPath);
            resolve(null);
          })
          .on('error', (err) => {
            if (this.options.binaryUrl) {
              reject(
                new Error(`failed to untar binary: ${err}, are you sure binaryUrl points to a tar file?`)
              );
            }
            reject(new Error(`failed to untar binary: ${JSON.stringify(err)}`));
          })
      );
    });
  }

  private unzipBinary(zipPath: string): Promise<null> {
    const zip = new Unzipper(zipPath);
    const entries = zip.getEntries();

    return new Promise((resolve, reject) => {
      entries.forEach((entry: Unzipper.IZipEntry) => {
        if (entry.entryName == 'weaviate') {
          zip.extractEntryTo(
            entry.entryName,
            dirname(this.options.binaryPath),
            false,
            true,
            false,
            basename(this.options.binaryPath)
          );
          fs.unlinkSync(zipPath);
          fs.chmodSync(this.options.binaryPath, 0o777);
          resolve(null);
        }
      });
      reject(new Error('failed to find binary in zip'));
    });
  }

  private waitTillListening(): Promise<null> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        clearTimeout(timeout);
        clearInterval(interval);
        reject(new Error(`failed to connect to embedded db @ ${this.options.host}:${this.options.port}`));
      }, 30000);

      const interval = setInterval(() => {
        this.isListening().then((listening) => {
          if (listening) {
            clearTimeout(timeout);
            clearInterval(interval);
            resolve(null);
          }
        });
      }, 500);
    });
  }

  private isListening(): Promise<boolean> {
    const sock = net.connect(this.options.port, this.options.host);
    return new Promise((resolve) => {
      sock
        .on('connect', () => {
          console.log('connected to embedded db!');
          sock.destroy();
          resolve(true);
        })
        .on('error', (err) => {
          console.log('Trying to connect to embedded db...', JSON.stringify(err));
          sock.destroy();
          resolve(false);
        });
    });
  }
}

function checkSupportedPlatform() {
  const platform: string = process.platform;
  if (platform != 'linux' && platform != 'darwin') {
    throw new Error(`${platform} is not supported with EmbeddedDB`);
  }
}

function getRandomPort(): Promise<string> {
  return new Promise((resolve, reject) => {
    const srv = net.createServer();
    srv.listen(0, () => {
      const { port } = srv.address() as net.AddressInfo;
      if (port) {
        srv.close(() => resolve(port.toString()));
      } else {
        reject(new Error('failed to find open port'));
      }
    });
  });
}



---
File: /typescript-embedded-main/src/index.ts
---

import { EmbeddedDB, EmbeddedOptions } from './embedded';
import weaviate, { ConnectionParams, WeaviateClient } from 'weaviate-ts-client';

export interface EmbeddedClient extends WeaviateClient {
  embedded: EmbeddedDB;
}

const app = {
  client: function (embedded: EmbeddedOptions, conn?: ConnectionParams): EmbeddedClient {
    if (!conn) conn = { host: '127.0.0.1:6789', scheme: 'http' };
    const client = weaviate.client(conn);
    const embeddedClient: EmbeddedClient = {
      ...client,
      embedded: new EmbeddedDB(embedded),
    };
    return embeddedClient;
  },
};

export default app;
export * from './embedded';



---
File: /typescript-embedded-main/src/journey.test.ts
---

import weaviate, { EmbeddedClient, EmbeddedOptions } from '.';
import { WeaviateClass } from 'weaviate-ts-client';

describe('embedded', () => {
  jest.setTimeout(60 * 1000);

  it('checks platform', () => {});
  if (process.platform != 'linux' && process.platform != 'darwin') {
    console.warn(`Skipping because EmbeddedDB does not support ${process.platform}`);
    return;
  }

  it('starts/stops EmbeddedDB with default options', async () => {
    const client: EmbeddedClient = weaviate.client(new EmbeddedOptions());
    await client.embedded.start();
    await checkClientServerConn(client).catch((err: any) => {
      throw new Error(`unexpected failure: ${err}`);
    });
    client.embedded.stop();
  });

  it('starts/stops EmbeddedDB with custom options', async () => {
    const client: EmbeddedClient = weaviate.client(
      new EmbeddedOptions({
        port: 7878,
        version: '1.19.8',
        env: {
          QUERY_DEFAULTS_LIMIT: 50,
          DEFAULT_VECTORIZER_MODULE: 'text2vec-openai',
        },
      }),
      {
        scheme: 'http',
        host: '127.0.0.1:7878',
      }
    );
    await client.embedded.start();
    await checkClientServerConn(client).catch((err: any) => {
      client.embedded.stop();
      throw new Error(`unexpected failure: ${err}`);
    });
    client.embedded.stop();
  });

  it('starts/stops EmbeddedDB with latest version', async () => {
    const client: EmbeddedClient = weaviate.client(
      new EmbeddedOptions({
        version: 'latest',
      })
    );
    await client.embedded.start();
    await checkClientServerConn(client).catch((err: any) => {
      client.embedded.stop();
      throw new Error(`unexpected failure: ${err}`);
    });
    client.embedded.stop();
  });

  it('starts/stops EmbeddedDB with binaryUrl', async () => {
    let binaryUrl = 'https://github.com/weaviate/weaviate/releases/download/v1.19.8/weaviate-v1.19.8-';
    if (process.platform == 'darwin') {
      binaryUrl += 'darwin-all.zip';
    } else {
      binaryUrl += `linux-amd64.tar.gz`;
    }
    const client: EmbeddedClient = weaviate.client(
      new EmbeddedOptions({
        binaryUrl: binaryUrl,
      })
    );
    await client.embedded.start();
    await checkClientServerConn(client).catch((err: any) => {
      client.embedded.stop();
      throw new Error(`unexpected failure: ${err}`);
    });
    client.embedded.stop();
  });
});

// Checks communication between the client and embedded server
// by creating, then deleting a class
async function checkClientServerConn(client: EmbeddedClient) {
  const testClass = {
    class: 'TestClass',
    properties: [{ name: 'stringProp', dataType: ['string'] }],
  };

  await client.schema
    .classCreator()
    .withClass(testClass)
    .do()
    .then((res: WeaviateClass) => {
      expect(res.class).toEqual('TestClass');
      console.log('class created!');
    })
    .catch((err: any) => {
      throw new Error(`unexpected error: ${err}`);
    });

  await client.schema
    .classDeleter()
    .withClassName(testClass.class)
    .do()
    .then(() => console.log('class deleted!'))
    .catch((err: any) => {
      throw new Error(`unexpected error: ${err}`);
    });
}



---
File: /typescript-embedded-main/src/unit.test.ts
---

import { homedir } from 'os';
import { join } from 'path';
import { EmbeddedOptions } from './embedded';

describe('embedded', () => {
  jest.setTimeout(60 * 1000);

  it('creates EmbeddedOptions with defaults', () => {
    const opt = new EmbeddedOptions();

    expect(opt.binaryPath).toEqual(join(homedir(), '.cache/weaviate-embedded-latest'));
    expect(opt.persistenceDataPath).toEqual(join(homedir(), '.local/share/weaviate'));
    expect(opt.host).toEqual('127.0.0.1');
    expect(opt.port).toEqual(6789);
    expect(opt.env).toHaveProperty('CLUSTER_HOSTNAME', 'Embedded_at_6789');
  });

  it('creates EmbeddedOptions with custom options', () => {
    const opt = new EmbeddedOptions({
      host: 'somehost.com',
      port: 7777,
      version: '1.18.1-alpha.0',
      env: {
        DEFAULT_VECTORIZER_MODULE: 'text2vec-contextionary',
        ENABLE_MODULES: 'text2vec-contextionary',
        CONTEXTIONARY_URL: 'contextionary:9999',
        QUERY_DEFAULTS_LIMIT: 100,
      },
    });

    // eslint-disable-next-line prettier/prettier
    expect(opt.env).toHaveProperty('DEFAULT_VECTORIZER_MODULE', 'text2vec-contextionary');
    expect(opt.env).toHaveProperty('ENABLE_MODULES', 'text2vec-contextionary');
    expect(opt.env).toHaveProperty('CONTEXTIONARY_URL', 'contextionary:9999');
    expect(opt.env).toHaveProperty('QUERY_DEFAULTS_LIMIT', 100);
    expect(opt.env).toHaveProperty('CLUSTER_HOSTNAME', 'Embedded_at_7777');
    expect(opt.host).toEqual('somehost.com');
    expect(opt.port).toEqual(7777);
  });

  it('overrides default env vars with inherited exported ones', () => {
    process.env.CLUSTER_HOSTNAME = 'custom-hostname';
    const opt = new EmbeddedOptions();
    expect(opt.env).toHaveProperty('CLUSTER_HOSTNAME', 'custom-hostname');
  });

  it('failed to create EmbeddedOptions with invalid version', () => {
    return expect(() => {
      const opt = new EmbeddedOptions({
        version: '123',
      });
    }).toThrow("invalid version: 123. version must resemble '{major}.{minor}.{patch}, or 'latest'");
  });
});



---
File: /typescript-embedded-main/tools/prepare_release.sh
---

#!/bin/bash

set -euo pipefail

VERSION=${1-}
REQUIRED_TOOLS="jq git"

if test -z "$VERSION"; then
  echo "Missing version parameter. Usage: $0 VERSION"
  exit 1
fi

if case $VERSION in v*) false;; esac; then
  VERSION="v$VERSION"
fi

for tool in $REQUIRED_TOOLS; do
  if ! hash "$tool" 2>/dev/null; then
    echo "This script requires '$tool', but it is not installed."
    exit 1
  fi
done

if git rev-parse "$VERSION" >/dev/null 2>&1; then
  echo "Cannot prepare release, a release for $VERSION already exists"
  exit 1
fi

npm version "${VERSION/v}"



---
File: /typescript-embedded-main/tools/run_embedded_tests_mac.sh
---

#!/bin/bash

### Some tests in src/embedded/journey.test.ts
### are unsupported on Mac. This script allows
### Mac users to run these tests.

set -euo pipefail

echo """---
services:
  embedded:
    image: node:18.15.0-buster
    volumes:
      - ../:/root/embedded
    working_dir: '/root/embedded'
    command:
      - npm
      - test
      - --
      - src/journey.test.ts
...""" > ./tools/docker-compose-embedded.yml

docker compose -f ./tools/docker-compose-embedded.yml up
echo Success!
docker compose -f ./tools/docker-compose-embedded.yml down --remove-orphans



---
File: /typescript-embedded-main/CODE_OF_CONDUCT.md
---

# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to make participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
  advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
  address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies within all project spaces, and it also applies when
an individual is representing the project or its community in public spaces.
Examples of representing a project or community include using an official
project e-mail address, posting via an official social media account, or acting
as an appointed representative at an online or offline event. Representation of
a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at laura@weaviate.io. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq



---
File: /typescript-embedded-main/CONTRIBUTE.md
---

### Thanks for looking into contributing to Weaviate TypeScript EmbeddedDB!
Contributing works pretty easy. You can do a pull request or you can commit if you are part of a Weaviate team.

### Code of Conduct
Please note that this project is released with a Contributor Code of Conduct. By participating in this project you agree to abide by its terms.
[![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-v2.0%20adopted-ff69b4.svg)](CODE_OF_CONDUCT.md)


### How we use Gitflow
How we use [Gitflow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow) and how you can contribute following a few steps.

- The main branch is what is released and developed currently.
- You can create a feature-branch that is named: feature/YOUR-FEATURE-NAME.
- Your feature branch always has the main branch as a starting point.
- When you are done with your feature you should create a pull request into the main branch.
- The main branch is protected.

### Tagging your commit

Always add a reference to your issue to your git commit.

For example: `gh-100: This is the commit message`

AKA: smart commits

### Pull Request

If you create a pull request without smart commits, the pull request will be [squashed into](https://blog.github.com/2016-04-01-squash-your-commits/) one git commit.

### Contributor License Agreement

Contributions to Weaviate TypeScript client must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution; this simply gives us permission to use and redistribute your contributions as part of Weaviate TypeScript client. Go to [this page](https://www.semi.technology/playbooks/misc/contributor-license-agreement.html) to read the current agreement.

The process works as follows:

- You contribute by opening a [pull request](#pull-request).
- If your account has no CLA, a DocuSign link will be added as a comment to the pull request.



---
File: /typescript-embedded-main/package-lock.json
---

{
  "name": "weaviate-ts-embedded",
  "version": "1.2.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "weaviate-ts-embedded",
      "version": "1.2.0",
      "license": "SEE LICENSE IN LICENSE",
      "dependencies": {
        "adm-zip": "^0.5.10",
        "tar": "^6.1.13",
        "weaviate-ts-client": "^2.2.0"
      },
      "devDependencies": {
        "@babel/core": "^7.20.12",
        "@babel/preset-typescript": "^7.18.6",
        "@babel/runtime": "^7.20.7",
        "@curveball/bodyparser": "^0.5.0",
        "@curveball/core": "^0.20.0",
        "@rollup/plugin-babel": "^5.3.1",
        "@types/adm-zip": "^0.5.0",
        "@types/jest": "^29.4.0",
        "@types/node": "^18.14.0",
        "@types/tar": "^6.1.4",
        "@typescript-eslint/eslint-plugin": "^5.54.1",
        "@typescript-eslint/parser": "^5.54.1",
        "babel-jest": "^29.4.3",
        "eslint": "^8.40.0",
        "eslint-config-prettier": "^8.7.0",
        "eslint-plugin-prettier": "^4.2.1",
        "husky": "^8.0.3",
        "jest": "^29.4.3",
        "lint-staged": "^13.2.0",
        "prettier": "^2.8.4",
        "ts-jest": "^29.0.5",
        "tsup": "^6.7.0",
        "typescript": "^4.9.5"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.2.0",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.1.0",
        "@jridgewell/trace-mapping": "^0.3.9"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.18.6",
      "dev": true,
      "dependencies": {
        "@babel/highlight": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.20.10",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.2.0",
        "@babel/code-frame": "^7.18.6",
        "@babel/generator": "^7.21.0",
        "@babel/helper-compilation-targets": "^7.20.7",
        "@babel/helper-module-transforms": "^7.21.0",
        "@babel/helpers": "^7.21.0",
        "@babel/parser": "^7.21.0",
        "@babel/template": "^7.20.7",
        "@babel/traverse": "^7.21.0",
        "@babel/types": "^7.21.0",
        "convert-source-map": "^1.7.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.2",
        "semver": "^6.3.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.21.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.21.0",
        "@jridgewell/gen-mapping": "^0.3.2",
        "@jridgewell/trace-mapping": "^0.3.17",
        "jsesc": "^2.5.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/generator/node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/set-array": "^1.0.1",
        "@jridgewell/sourcemap-codec": "^1.4.10",
        "@jridgewell/trace-mapping": "^0.3.9"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/helper-annotate-as-pure": {
      "version": "7.18.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.20.7",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.20.5",
        "@babel/helper-validator-option": "^7.18.6",
        "browserslist": "^4.21.3",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-create-class-features-plugin": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-annotate-as-pure": "^7.18.6",
        "@babel/helper-environment-visitor": "^7.18.9",
        "@babel/helper-function-name": "^7.21.0",
        "@babel/helper-member-expression-to-functions": "^7.21.0",
        "@babel/helper-optimise-call-expression": "^7.18.6",
        "@babel/helper-replace-supers": "^7.20.7",
        "@babel/helper-skip-transparent-expression-wrappers": "^7.20.0",
        "@babel/helper-split-export-declaration": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-environment-visitor": {
      "version": "7.18.9",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-function-name": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.20.7",
        "@babel/types": "^7.21.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-hoist-variables": {
      "version": "7.18.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-member-expression-to-functions": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.21.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.18.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-environment-visitor": "^7.18.9",
        "@babel/helper-module-imports": "^7.18.6",
        "@babel/helper-simple-access": "^7.20.2",
        "@babel/helper-split-export-declaration": "^7.18.6",
        "@babel/helper-validator-identifier": "^7.19.1",
        "@babel/template": "^7.20.7",
        "@babel/traverse": "^7.21.0",
        "@babel/types": "^7.21.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-optimise-call-expression": {
      "version": "7.18.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.20.2",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-replace-supers": {
      "version": "7.20.7",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-environment-visitor": "^7.18.9",
        "@babel/helper-member-expression-to-functions": "^7.20.7",
        "@babel/helper-optimise-call-expression": "^7.18.6",
        "@babel/template": "^7.20.7",
        "@babel/traverse": "^7.20.7",
        "@babel/types": "^7.20.7"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-simple-access": {
      "version": "7.20.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.20.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-skip-transparent-expression-wrappers": {
      "version": "7.20.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.20.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-split-export-declaration": {
      "version": "7.18.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.19.4",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.19.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.20.7",
        "@babel/traverse": "^7.21.0",
        "@babel/types": "^7.21.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/highlight": {
      "version": "7.18.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.18.6",
        "chalk": "^2.0.0",
        "js-tokens": "^4.0.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/highlight/node_modules/ansi-styles": {
      "version": "3.2.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^1.9.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@babel/highlight/node_modules/chalk": {
      "version": "2.4.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^3.2.1",
        "escape-string-regexp": "^1.0.5",
        "supports-color": "^5.3.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@babel/highlight/node_modules/color-convert": {
      "version": "1.9.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "1.1.3"
      }
    },
    "node_modules/@babel/highlight/node_modules/color-name": {
      "version": "1.1.3",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@babel/highlight/node_modules/has-flag": {
      "version": "3.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@babel/highlight/node_modules/supports-color": {
      "version": "5.5.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.21.1",
      "dev": true,
      "license": "MIT",
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-syntax-async-generators": {
      "version": "7.8.4",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-bigint": {
      "version": "7.8.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-class-properties": {
      "version": "7.12.13",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.12.13"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-import-meta": {
      "version": "7.10.4",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-json-strings": {
      "version": "7.8.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-jsx": {
      "version": "7.18.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.18.6"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-logical-assignment-operators": {
      "version": "7.10.4",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-nullish-coalescing-operator": {
      "version": "7.8.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-numeric-separator": {
      "version": "7.10.4",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.10.4"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-object-rest-spread": {
      "version": "7.8.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-optional-catch-binding": {
      "version": "7.8.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-optional-chaining": {
      "version": "7.8.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.8.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-top-level-await": {
      "version": "7.14.5",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.14.5"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-syntax-typescript": {
      "version": "7.20.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.19.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-typescript": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-create-class-features-plugin": "^7.21.0",
        "@babel/helper-plugin-utils": "^7.20.2",
        "@babel/plugin-syntax-typescript": "^7.20.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/preset-typescript": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.20.2",
        "@babel/helper-validator-option": "^7.21.0",
        "@babel/plugin-transform-typescript": "^7.21.0"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.20.7",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "regenerator-runtime": "^0.13.11"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.20.7",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.18.6",
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.18.6",
        "@babel/generator": "^7.21.0",
        "@babel/helper-environment-visitor": "^7.18.9",
        "@babel/helper-function-name": "^7.21.0",
        "@babel/helper-hoist-variables": "^7.18.6",
        "@babel/helper-split-export-declaration": "^7.18.6",
        "@babel/parser": "^7.21.0",
        "@babel/types": "^7.21.0",
        "debug": "^4.1.0",
        "globals": "^11.1.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.21.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.19.4",
        "@babel/helper-validator-identifier": "^7.19.1",
        "to-fast-properties": "^2.0.0"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@bcoe/v8-coverage": {
      "version": "0.2.3",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "optional": true,
      "peer": true,
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "optional": true,
      "peer": true,
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@curveball/bodyparser": {
      "version": "0.5.0",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@curveball/kernel": ">=0.20.0 <1"
      }
    },
    "node_modules/@curveball/core": {
      "version": "0.20.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@curveball/http-errors": "^0.4.0",
        "@curveball/kernel": "^0.20.0",
        "@types/ws": "^8.5.3",
        "raw-body": "^2.4.1",
        "ws": "^8.5.0"
      },
      "engines": {
        "node": ">=14.4"
      }
    },
    "node_modules/@curveball/core/node_modules/ws": {
      "version": "8.12.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/@curveball/http-errors": {
      "version": "0.4.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@curveball/kernel": {
      "version": "0.20.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@curveball/http-errors": "^0.4.0",
        "@types/ws": "^8.5.3",
        "accepts": "^1.3.7",
        "raw-body": "^2.4.1",
        "ws": "^8.5.0"
      },
      "engines": {
        "node": ">=14.4"
      }
    },
    "node_modules/@curveball/kernel/node_modules/ws": {
      "version": "8.12.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.17.10",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.4.0.tgz",
      "integrity": "sha512-1/sA4dwrzBAyeUoQ6oxahHKmrZvsnLCg4RfxW3ZFGGmQkSNQPFNLV9CUEFQP1x9EYXHTo5p6xdhZM1Ne9p/AfA==",
      "dev": true,
      "dependencies": {
        "eslint-visitor-keys": "^3.3.0"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.5.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.5.1.tgz",
      "integrity": "sha512-Z5ba73P98O1KUYCCJTUeVpja9RcGoMdncZ6T49FCUl2lN38JtCJ+3WgIDBv0AuY4WChU5PmtJmOCTlN6FZTFKQ==",
      "dev": true,
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-2.0.3.tgz",
      "integrity": "sha512-+5gy6OQfk+xx3q0d6jGZZC3f3KzAkXc/IanVxd1is/VIIziRqqt3ongQz0FiTUXqTk0c7aDB3OaFuKnuSoJicQ==",
      "dev": true,
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^9.5.2",
        "globals": "^13.19.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.0",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true
    },
    "node_modules/@eslint/eslintrc/node_modules/globals": {
      "version": "13.20.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-13.20.0.tgz",
      "integrity": "sha512-Qg5QtVkCy/kv3FUSlu4ukeZDVf9ee0iXLAUYX13gbR17bnejFTzr4iS9bY7kwCf1NztRNm1t91fjOiyx4CSwPQ==",
      "dev": true,
      "dependencies": {
        "type-fest": "^0.20.2"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dev": true,
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/type-fest": {
      "version": "0.20.2",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
      "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@eslint/js": {
      "version": "8.40.0",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-8.40.0.tgz",
      "integrity": "sha512-ElyB54bJIhXQYVKjDSvCkPO1iU1tSAeVQJbllWJq1XQSmmA4dgFk8CbiBGpiOPxleE48vDogxCtmMYku4HSVLA==",
      "dev": true,
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      }
    },
    "node_modules/@graphql-typed-document-node/core": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/@graphql-typed-document-node/core/-/core-3.2.0.tgz",
      "integrity": "sha512-mB9oAsNCm9aM3/SOv4YtBMqZbYj10R7dkq8byBqxGY/ncFwhf2oQzMV+LCRlWoDSEBJ3COiR1yeDvMtsoOsuFQ==",
      "peerDependencies": {
        "graphql": "^0.8.0 || ^0.9.0 || ^0.10.0 || ^0.11.0 || ^0.12.0 || ^0.13.0 || ^14.0.0 || ^15.0.0 || ^16.0.0 || ^17.0.0"
      }
    },
    "node_modules/@humanwhocodes/config-array": {
      "version": "0.11.8",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.11.8.tgz",
      "integrity": "sha512-UybHIJzJnR5Qc/MsD9Kr+RpO2h+/P1GhOwdiLPXK5TWk5sgTdu88bTD9UP+CKbPPh5Rni1u0GjAdYQLemG8g+g==",
      "dev": true,
      "dependencies": {
        "@humanwhocodes/object-schema": "^1.2.1",
        "debug": "^4.1.1",
        "minimatch": "^3.0.5"
      },
      "engines": {
        "node": ">=10.10.0"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/object-schema": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-1.2.1.tgz",
      "integrity": "sha512-ZnQMnLV4e7hDlUvw8H+U8ASL02SS2Gn6+9Ac3wGGLIe7+je2AeAOxPY+izIPJDfFDb7eDjev0Us8MO1iFRN8hA==",
      "dev": true
    },
    "node_modules/@istanbuljs/load-nyc-config": {
      "version": "1.1.0",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "camelcase": "^5.3.1",
        "find-up": "^4.1.0",
        "get-package-type": "^0.1.0",
        "js-yaml": "^3.13.1",
        "resolve-from": "^5.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@istanbuljs/schema": {
      "version": "0.1.3",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@jest/console": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "jest-message-util": "^29.4.3",
        "jest-util": "^29.4.3",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/core": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/console": "^29.4.3",
        "@jest/reporters": "^29.4.3",
        "@jest/test-result": "^29.4.3",
        "@jest/transform": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "ansi-escapes": "^4.2.1",
        "chalk": "^4.0.0",
        "ci-info": "^3.2.0",
        "exit": "^0.1.2",
        "graceful-fs": "^4.2.9",
        "jest-changed-files": "^29.4.3",
        "jest-config": "^29.4.3",
        "jest-haste-map": "^29.4.3",
        "jest-message-util": "^29.4.3",
        "jest-regex-util": "^29.4.3",
        "jest-resolve": "^29.4.3",
        "jest-resolve-dependencies": "^29.4.3",
        "jest-runner": "^29.4.3",
        "jest-runtime": "^29.4.3",
        "jest-snapshot": "^29.4.3",
        "jest-util": "^29.4.3",
        "jest-validate": "^29.4.3",
        "jest-watcher": "^29.4.3",
        "micromatch": "^4.0.4",
        "pretty-format": "^29.4.3",
        "slash": "^3.0.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/@jest/environment": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/fake-timers": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "jest-mock": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/expect": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "expect": "^29.4.3",
        "jest-snapshot": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/expect-utils": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "jest-get-type": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/fake-timers": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.4.3",
        "@sinonjs/fake-timers": "^10.0.2",
        "@types/node": "*",
        "jest-message-util": "^29.4.3",
        "jest-mock": "^29.4.3",
        "jest-util": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/globals": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/environment": "^29.4.3",
        "@jest/expect": "^29.4.3",
        "@jest/types": "^29.4.3",
        "jest-mock": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/reporters": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@bcoe/v8-coverage": "^0.2.3",
        "@jest/console": "^29.4.3",
        "@jest/test-result": "^29.4.3",
        "@jest/transform": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@jridgewell/trace-mapping": "^0.3.15",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "collect-v8-coverage": "^1.0.0",
        "exit": "^0.1.2",
        "glob": "^7.1.3",
        "graceful-fs": "^4.2.9",
        "istanbul-lib-coverage": "^3.0.0",
        "istanbul-lib-instrument": "^5.1.0",
        "istanbul-lib-report": "^3.0.0",
        "istanbul-lib-source-maps": "^4.0.0",
        "istanbul-reports": "^3.1.3",
        "jest-message-util": "^29.4.3",
        "jest-util": "^29.4.3",
        "jest-worker": "^29.4.3",
        "slash": "^3.0.0",
        "string-length": "^4.0.1",
        "strip-ansi": "^6.0.0",
        "v8-to-istanbul": "^9.0.1"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/@jest/schemas": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@sinclair/typebox": "^0.25.16"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/source-map": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.15",
        "callsites": "^3.0.0",
        "graceful-fs": "^4.2.9"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/test-result": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/console": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/istanbul-lib-coverage": "^2.0.0",
        "collect-v8-coverage": "^1.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/test-sequencer": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/test-result": "^29.4.3",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.4.3",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/transform": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.11.6",
        "@jest/types": "^29.4.3",
        "@jridgewell/trace-mapping": "^0.3.15",
        "babel-plugin-istanbul": "^6.1.1",
        "chalk": "^4.0.0",
        "convert-source-map": "^2.0.0",
        "fast-json-stable-stringify": "^2.1.0",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.4.3",
        "jest-regex-util": "^29.4.3",
        "jest-util": "^29.4.3",
        "micromatch": "^4.0.4",
        "pirates": "^4.0.4",
        "slash": "^3.0.0",
        "write-file-atomic": "^4.0.2"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jest/transform/node_modules/convert-source-map": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jest/types": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/schemas": "^29.4.3",
        "@types/istanbul-lib-coverage": "^2.0.0",
        "@types/istanbul-reports": "^3.0.0",
        "@types/node": "*",
        "@types/yargs": "^17.0.8",
        "chalk": "^4.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.1.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/set-array": "^1.0.0",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/set-array": {
      "version": "1.1.2",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.4.14",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.17",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "3.1.0",
        "@jridgewell/sourcemap-codec": "1.4.14"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@rollup/plugin-babel": {
      "version": "5.3.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.10.4",
        "@rollup/pluginutils": "^3.1.0"
      },
      "engines": {
        "node": ">= 10.0.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0",
        "@types/babel__core": "^7.1.9",
        "rollup": "^1.20.0||^2.0.0"
      },
      "peerDependenciesMeta": {
        "@types/babel__core": {
          "optional": true
        }
      }
    },
    "node_modules/@rollup/pluginutils": {
      "version": "3.1.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "0.0.39",
        "estree-walker": "^1.0.1",
        "picomatch": "^2.2.2"
      },
      "engines": {
        "node": ">= 8.0.0"
      },
      "peerDependencies": {
        "rollup": "^1.20.0||^2.0.0"
      }
    },
    "node_modules/@sinclair/typebox": {
      "version": "0.25.23",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@sinonjs/commons": {
      "version": "2.0.0",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "type-detect": "4.0.8"
      }
    },
    "node_modules/@sinonjs/fake-timers": {
      "version": "10.0.2",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@sinonjs/commons": "^2.0.0"
      }
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.9",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.9.tgz",
      "integrity": "sha512-jNsYVVxU8v5g43Erja32laIDHXeoNvFEpX33OK4d6hljo3jDhCBDhx5dhCCTMWUojscpAagGiRkBKxpdl9fxqA==",
      "dev": true,
      "optional": true,
      "peer": true
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true,
      "optional": true,
      "peer": true
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true,
      "optional": true,
      "peer": true
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.3.tgz",
      "integrity": "sha512-yOlFc+7UtL/89t2ZhjPvvB/DeAr3r+Dq58IgzsFkOAvVC6NMJXmCGjbptdXdR9qsX7pKcTL+s87FtYREi2dEEQ==",
      "dev": true,
      "optional": true,
      "peer": true
    },
    "node_modules/@types/adm-zip": {
      "version": "0.5.0",
      "resolved": "https://registry.npmjs.org/@types/adm-zip/-/adm-zip-0.5.0.tgz",
      "integrity": "sha512-FCJBJq9ODsQZUNURo5ILAQueuA8WJhRvuihS3ke2iI25mJlfV2LK8jG2Qj2z2AWg8U0FtWWqBHVRetceLskSaw==",
      "dev": true,
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.6.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.0.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.0.14",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.3.0"
      }
    },
    "node_modules/@types/color-name": {
      "version": "1.1.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/estree": {
      "version": "0.0.39",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/graceful-fs": {
      "version": "4.1.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/istanbul-lib-coverage": {
      "version": "2.0.4",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/istanbul-lib-report": {
      "version": "3.0.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/istanbul-lib-coverage": "*"
      }
    },
    "node_modules/@types/istanbul-reports": {
      "version": "3.0.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/istanbul-lib-report": "*"
      }
    },
    "node_modules/@types/jest": {
      "version": "29.4.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "expect": "^29.0.0",
        "pretty-format": "^29.0.0"
      }
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.11",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.11.tgz",
      "integrity": "sha512-wOuvG1SN4Us4rez+tylwwwCV1psiNVOkJeM3AUWUNWg/jDQY2+HE/444y5gc+jBmRqASOm2Oeh5c1axHobwRKQ==",
      "dev": true
    },
    "node_modules/@types/node": {
      "version": "18.14.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/prettier": {
      "version": "2.7.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/semver": {
      "version": "7.3.13",
      "resolved": "https://registry.npmjs.org/@types/semver/-/semver-7.3.13.tgz",
      "integrity": "sha512-21cFJr9z3g5dW8B0CVI9g2O9beqaThGQ6ZFBqHfwhzLDKUxaqTIy3vnfah/UPkfOiF2pLq+tGz+W8RyCskuslw==",
      "dev": true
    },
    "node_modules/@types/stack-utils": {
      "version": "2.0.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/tar": {
      "version": "6.1.4",
      "resolved": "https://registry.npmjs.org/@types/tar/-/tar-6.1.4.tgz",
      "integrity": "sha512-Cp4oxpfIzWt7mr2pbhHT2OTXGMAL0szYCzuf8lRWyIMCgsx6/Hfc3ubztuhvzXHXgraTQxyOCmmg7TDGIMIJJQ==",
      "dev": true,
      "dependencies": {
        "@types/node": "*",
        "minipass": "^4.0.0"
      }
    },
    "node_modules/@types/ws": {
      "version": "8.5.4",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/yargs": {
      "version": "17.0.22",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/yargs-parser": "*"
      }
    },
    "node_modules/@types/yargs-parser": {
      "version": "21.0.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "5.54.1",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-5.54.1.tgz",
      "integrity": "sha512-a2RQAkosH3d3ZIV08s3DcL/mcGc2M/UC528VkPULFxR9VnVPT8pBu0IyBAJJmVsCmhVfwQX1v6q+QGnmSe1bew==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/scope-manager": "5.54.1",
        "@typescript-eslint/type-utils": "5.54.1",
        "@typescript-eslint/utils": "5.54.1",
        "debug": "^4.3.4",
        "grapheme-splitter": "^1.0.4",
        "ignore": "^5.2.0",
        "natural-compare-lite": "^1.4.0",
        "regexpp": "^3.2.0",
        "semver": "^7.3.7",
        "tsutils": "^3.21.0"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^5.0.0",
        "eslint": "^6.0.0 || ^7.0.0 || ^8.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin/node_modules/lru-cache": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
      "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
      "dev": true,
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin/node_modules/semver": {
      "version": "7.3.8",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
      "integrity": "sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==",
      "dev": true,
      "dependencies": {
        "lru-cache": "^6.0.0"
      },
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin/node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
      "dev": true
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "5.54.1",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-5.54.1.tgz",
      "integrity": "sha512-8zaIXJp/nG9Ff9vQNh7TI+C3nA6q6iIsGJ4B4L6MhZ7mHnTMR4YP5vp2xydmFXIy8rpyIVbNAG44871LMt6ujg==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/scope-manager": "5.54.1",
        "@typescript-eslint/types": "5.54.1",
        "@typescript-eslint/typescript-estree": "5.54.1",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || ^8.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "5.54.1",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-5.54.1.tgz",
      "integrity": "sha512-zWKuGliXxvuxyM71UA/EcPxaviw39dB2504LqAmFDjmkpO8qNLHcmzlh6pbHs1h/7YQ9bnsO8CCcYCSA8sykUg==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "5.54.1",
        "@typescript-eslint/visitor-keys": "5.54.1"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "5.54.1",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-5.54.1.tgz",
      "integrity": "sha512-WREHsTz0GqVYLIbzIZYbmUUr95DKEKIXZNH57W3s+4bVnuF1TKe2jH8ZNH8rO1CeMY3U4j4UQeqPNkHMiGem3g==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/typescript-estree": "5.54.1",
        "@typescript-eslint/utils": "5.54.1",
        "debug": "^4.3.4",
        "tsutils": "^3.21.0"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "*"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "5.54.1",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-5.54.1.tgz",
      "integrity": "sha512-G9+1vVazrfAfbtmCapJX8jRo2E4MDXxgm/IMOF4oGh3kq7XuK3JRkOg6y2Qu1VsTRmWETyTkWt1wxy7X7/yLkw==",
      "dev": true,
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "5.54.1",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-5.54.1.tgz",
      "integrity": "sha512-bjK5t+S6ffHnVwA0qRPTZrxKSaFYocwFIkZx5k7pvWfsB1I57pO/0M0Skatzzw1sCkjJ83AfGTL0oFIFiDX3bg==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "5.54.1",
        "@typescript-eslint/visitor-keys": "5.54.1",
        "debug": "^4.3.4",
        "globby": "^11.1.0",
        "is-glob": "^4.0.3",
        "semver": "^7.3.7",
        "tsutils": "^3.21.0"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/lru-cache": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
      "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
      "dev": true,
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/semver": {
      "version": "7.3.8",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
      "integrity": "sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==",
      "dev": true,
      "dependencies": {
        "lru-cache": "^6.0.0"
      },
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
      "dev": true
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "5.54.1",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-5.54.1.tgz",
      "integrity": "sha512-IY5dyQM8XD1zfDe5X8jegX6r2EVU5o/WJnLu/znLPWCBF7KNGC+adacXnt5jEYS9JixDcoccI6CvE4RCjHMzCQ==",
      "dev": true,
      "dependencies": {
        "@types/json-schema": "^7.0.9",
        "@types/semver": "^7.3.12",
        "@typescript-eslint/scope-manager": "5.54.1",
        "@typescript-eslint/types": "5.54.1",
        "@typescript-eslint/typescript-estree": "5.54.1",
        "eslint-scope": "^5.1.1",
        "eslint-utils": "^3.0.0",
        "semver": "^7.3.7"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/@typescript-eslint/utils/node_modules/lru-cache": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
      "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
      "dev": true,
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/utils/node_modules/semver": {
      "version": "7.3.8",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
      "integrity": "sha512-NB1ctGL5rlHrPJtFDVIVzTyQylMLu9N9VICA6HSFJo8MCGVTMW6gfpicwKmmK/dAjTOrqu5l63JJOpDSrAis3A==",
      "dev": true,
      "dependencies": {
        "lru-cache": "^6.0.0"
      },
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/utils/node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
      "dev": true
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "5.54.1",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-5.54.1.tgz",
      "integrity": "sha512-q8iSoHTgwCfgcRJ2l2x+xCbu8nBlRAlsQ33k24Adj8eoVBE0f8dUeI+bAa8F84Mv05UGbAx57g2zrRsYIooqQg==",
      "dev": true,
      "dependencies": {
        "@typescript-eslint/types": "5.54.1",
        "eslint-visitor-keys": "^3.3.0"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/acorn": {
      "version": "8.8.2",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.8.2.tgz",
      "integrity": "sha512-xjIYgE8HBrkpd/sJqOGNspf8uHG+NOHGOw6a/Urj8taM2EXfdNAH2oFcPeIFfsv3+kz/mJrS5VuMqbNLjCa2vw==",
      "dev": true,
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.2.0.tgz",
      "integrity": "sha512-k+iyHEuPgSw6SbuDpGQM+06HQUa04DZ3o+F6CSzXMvvI5KMvnaEqXe+YVe555R9nn6GPt404fos4wcgpw12SDA==",
      "dev": true,
      "optional": true,
      "peer": true,
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/adm-zip": {
      "version": "0.5.10",
      "resolved": "https://registry.npmjs.org/adm-zip/-/adm-zip-0.5.10.tgz",
      "integrity": "sha512-x0HvcHqVJNTPk/Bw8JbLWlWoo6Wwnsug0fnYYro1HBrjxZ3G7/AZk7Ahv8JwDe1uIcz8eBqvu86FuF1POiG7vQ==",
      "engines": {
        "node": ">=6.0"
      }
    },
    "node_modules/aggregate-error": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/aggregate-error/-/aggregate-error-3.1.0.tgz",
      "integrity": "sha512-4I7Td01quW/RpocfNayFdFVk1qSuoh0E7JrbRJ16nH01HhKFQ88INq9Sd+nd72zqRySlr9BmDA8xlEJ6vJMrYA==",
      "dev": true,
      "dependencies": {
        "clean-stack": "^2.0.0",
        "indent-string": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-escapes": {
      "version": "4.3.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "type-fest": "^0.21.3"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.2.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/color-name": "^1.1.1",
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/any-promise": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/any-promise/-/any-promise-1.3.0.tgz",
      "integrity": "sha512-7UvmKalWRt1wgjL1RrGxoSJW/0QZFIegpeGvZG9kjp8vrRu55XTHbwnqq2GpXm9uLbcuhxm3IqX9OB4MZR1b2A==",
      "dev": true
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true,
      "optional": true,
      "peer": true
    },
    "node_modules/argparse": {
      "version": "1.0.10",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "sprintf-js": "~1.0.2"
      }
    },
    "node_modules/array-union": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
      "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/astral-regex": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/astral-regex/-/astral-regex-2.0.0.tgz",
      "integrity": "sha512-Z7tMw1ytTXt5jqMcOP+OQteU1VuNK9Y02uuJtKQ1Sv69jXQKKg5cibLwGJow8yzZP+eAc18EmLGPal0bp36rvQ==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q=="
    },
    "node_modules/babel-jest": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/transform": "^29.4.3",
        "@types/babel__core": "^7.1.14",
        "babel-plugin-istanbul": "^6.1.1",
        "babel-preset-jest": "^29.4.3",
        "chalk": "^4.0.0",
        "graceful-fs": "^4.2.9",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.8.0"
      }
    },
    "node_modules/babel-plugin-istanbul": {
      "version": "6.1.1",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.0.0",
        "@istanbuljs/load-nyc-config": "^1.0.0",
        "@istanbuljs/schema": "^0.1.2",
        "istanbul-lib-instrument": "^5.0.4",
        "test-exclude": "^6.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/babel-plugin-jest-hoist": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.3.3",
        "@babel/types": "^7.3.3",
        "@types/babel__core": "^7.1.14",
        "@types/babel__traverse": "^7.0.6"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/babel-preset-current-node-syntax": {
      "version": "1.0.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/plugin-syntax-async-generators": "^7.8.4",
        "@babel/plugin-syntax-bigint": "^7.8.3",
        "@babel/plugin-syntax-class-properties": "^7.8.3",
        "@babel/plugin-syntax-import-meta": "^7.8.3",
        "@babel/plugin-syntax-json-strings": "^7.8.3",
        "@babel/plugin-syntax-logical-assignment-operators": "^7.8.3",
        "@babel/plugin-syntax-nullish-coalescing-operator": "^7.8.3",
        "@babel/plugin-syntax-numeric-separator": "^7.8.3",
        "@babel/plugin-syntax-object-rest-spread": "^7.8.3",
        "@babel/plugin-syntax-optional-catch-binding": "^7.8.3",
        "@babel/plugin-syntax-optional-chaining": "^7.8.3",
        "@babel/plugin-syntax-top-level-await": "^7.8.3"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/babel-preset-jest": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "babel-plugin-jest-hoist": "^29.4.3",
        "babel-preset-current-node-syntax": "^1.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/binary-extensions": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz",
      "integrity": "sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.21.4",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "caniuse-lite": "^1.0.30001400",
        "electron-to-chromium": "^1.4.251",
        "node-releases": "^2.0.6",
        "update-browserslist-db": "^1.0.9"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/bs-logger": {
      "version": "0.2.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-json-stable-stringify": "2.x"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/bser": {
      "version": "2.1.1",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "node-int64": "^0.4.0"
      }
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/bundle-require": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bundle-require/-/bundle-require-4.0.1.tgz",
      "integrity": "sha512-9NQkRHlNdNpDBGmLpngF3EFDcwodhMUuLz9PaWYciVcQF9SE4LFjM2DB/xV1Li5JiuDMv7ZUWuC3rGbqR0MAXQ==",
      "dev": true,
      "dependencies": {
        "load-tsconfig": "^0.2.3"
      },
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      },
      "peerDependencies": {
        "esbuild": ">=0.17"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/cac": {
      "version": "6.7.14",
      "resolved": "https://registry.npmjs.org/cac/-/cac-6.7.14.tgz",
      "integrity": "sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/camelcase": {
      "version": "5.3.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001441",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "4.1.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/char-regex": {
      "version": "1.0.2",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/chokidar": {
      "version": "3.5.3",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.5.3.tgz",
      "integrity": "sha512-Dr3sfKRP6oTcjf2JmUmFJfeVMvXBdegxB0iVQ5eb2V10uFJUCAS8OByZdVAyVb8xXNz3GjjTgj9kLWsZTqE6kw==",
      "dev": true,
      "funding": [
        {
          "type": "individual",
          "url": "https://paulmillr.com/funding/"
        }
      ],
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/chokidar/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/chownr": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
      "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/ci-info": {
      "version": "3.8.0",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/sibiraj-s"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/cjs-module-lexer": {
      "version": "1.2.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/clean-stack": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/clean-stack/-/clean-stack-2.2.0.tgz",
      "integrity": "sha512-4diC9HaTE+KRAMWhDhrGOECgWZxoevMc5TlkObMqNSsVU62PYzXZ/SMTjzyGAFF1YusgxGcSWTEXBhp0CPwQ1A==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/cli-cursor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/cli-cursor/-/cli-cursor-3.1.0.tgz",
      "integrity": "sha512-I/zHAwsKf9FqGoXM4WWRACob9+SNukZTd94DWF57E4toouRulbCxcUh6RKUEOQlYTHJnzkPMySvPNaaSLNfLZw==",
      "dev": true,
      "dependencies": {
        "restore-cursor": "^3.1.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/cli-truncate": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/cli-truncate/-/cli-truncate-3.1.0.tgz",
      "integrity": "sha512-wfOBkjXteqSnI59oPcJkcPl/ZmwvMMOj340qUIY1SKZCv0B9Cf4D4fAucRkIKQmsIuYK3x1rrgU7MeGRruiuiA==",
      "dev": true,
      "dependencies": {
        "slice-ansi": "^5.0.0",
        "string-width": "^5.0.0"
      },
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/cli-truncate/node_modules/ansi-regex": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.0.1.tgz",
      "integrity": "sha512-n5M855fKb2SsfMIiFFoVrABHJC8QtHwVx+mHWP3QcEqBHYienj5dHSgjbxtC0WEZXYt4wcD6zrQElDPhFuZgfA==",
      "dev": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/cli-truncate/node_modules/emoji-regex": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
      "dev": true
    },
    "node_modules/cli-truncate/node_modules/string-width": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
      "dev": true,
      "dependencies": {
        "eastasianwidth": "^0.2.0",
        "emoji-regex": "^9.2.2",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/cli-truncate/node_modules/strip-ansi": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.0.1.tgz",
      "integrity": "sha512-cXNxvT8dFNRVfhVME3JAe98mkXDYN2O1l7jmcwMnOslDeESg1rF/OZMtK0nRAhiari1unG5cD4jG3rapUAkLbw==",
      "dev": true,
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/cliui": {
      "version": "8.0.1",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^4.2.0",
        "strip-ansi": "^6.0.1",
        "wrap-ansi": "^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/co": {
      "version": "4.6.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">= 1.0.0",
        "node": ">= 0.12.0"
      }
    },
    "node_modules/collect-v8-coverage": {
      "version": "1.0.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/colorette": {
      "version": "2.0.19",
      "resolved": "https://registry.npmjs.org/colorette/-/colorette-2.0.19.tgz",
      "integrity": "sha512-3tlv/dIP7FWvj3BsbHrGLJ6l/oKh1O3TcgBqMn+yyCagOxc23fyzDS6HypQbgxWbkpDnf52p1LuR4eWDQ/K9WQ==",
      "dev": true
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/commander": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-10.0.0.tgz",
      "integrity": "sha512-zS5PnTI22FIRM6ylNW8G4Ap0IEOyk62fhLSD0+uHRT9McRCLGpkVNvao4bjimpK/GShynyQkFFxHhwMcETmduA==",
      "dev": true,
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "1.7.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.1"
      }
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true,
      "optional": true,
      "peer": true
    },
    "node_modules/cross-fetch": {
      "version": "3.1.5",
      "resolved": "https://registry.npmjs.org/cross-fetch/-/cross-fetch-3.1.5.tgz",
      "integrity": "sha512-lvb1SBsI0Z7GDwmuid+mU3kWVBwTVUbe7S0H52yaaAdQOXq2YktTCZdlAcNKFzE6QtRz0snpw9bNiPeOIkkQvw==",
      "dependencies": {
        "node-fetch": "2.6.7"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/debug": {
      "version": "4.3.4",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.4.tgz",
      "integrity": "sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "2.1.2"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/dedent": {
      "version": "0.7.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true
    },
    "node_modules/deepmerge": {
      "version": "4.3.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/detect-newline": {
      "version": "3.1.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "optional": true,
      "peer": true,
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/diff-sequences": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/dir-glob": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
      "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
      "dev": true,
      "dependencies": {
        "path-type": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "dev": true,
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/eastasianwidth": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
      "dev": true
    },
    "node_modules/electron-to-chromium": {
      "version": "1.4.284",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/emittery": {
      "version": "0.13.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/emittery?sponsor=1"
      }
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/error-ex": {
      "version": "1.3.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-arrayish": "^0.2.1"
      }
    },
    "node_modules/esbuild": {
      "version": "0.17.10",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/android-arm": "0.17.10",
        "@esbuild/android-arm64": "0.17.10",
        "@esbuild/android-x64": "0.17.10",
        "@esbuild/darwin-arm64": "0.17.10",
        "@esbuild/darwin-x64": "0.17.10",
        "@esbuild/freebsd-arm64": "0.17.10",
        "@esbuild/freebsd-x64": "0.17.10",
        "@esbuild/linux-arm": "0.17.10",
        "@esbuild/linux-arm64": "0.17.10",
        "@esbuild/linux-ia32": "0.17.10",
        "@esbuild/linux-loong64": "0.17.10",
        "@esbuild/linux-mips64el": "0.17.10",
        "@esbuild/linux-ppc64": "0.17.10",
        "@esbuild/linux-riscv64": "0.17.10",
        "@esbuild/linux-s390x": "0.17.10",
        "@esbuild/linux-x64": "0.17.10",
        "@esbuild/netbsd-x64": "0.17.10",
        "@esbuild/openbsd-x64": "0.17.10",
        "@esbuild/sunos-x64": "0.17.10",
        "@esbuild/win32-arm64": "0.17.10",
        "@esbuild/win32-ia32": "0.17.10",
        "@esbuild/win32-x64": "0.17.10"
      }
    },
    "node_modules/escalade": {
      "version": "3.1.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "1.0.5",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.0"
      }
    },
    "node_modules/eslint": {
      "version": "8.40.0",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-8.40.0.tgz",
      "integrity": "sha512-bvR+TsP9EHL3TqNtj9sCNJVAFK3fBN8Q7g5waghxyRsPLIMwL73XSKnZFK0hk/O2ANC+iAoq6PWMQ+IfBAJIiQ==",
      "dev": true,
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.2.0",
        "@eslint-community/regexpp": "^4.4.0",
        "@eslint/eslintrc": "^2.0.3",
        "@eslint/js": "8.40.0",
        "@humanwhocodes/config-array": "^0.11.8",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@nodelib/fs.walk": "^1.2.8",
        "ajv": "^6.10.0",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.2",
        "debug": "^4.3.2",
        "doctrine": "^3.0.0",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^7.2.0",
        "eslint-visitor-keys": "^3.4.1",
        "espree": "^9.5.2",
        "esquery": "^1.4.2",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^6.0.1",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "globals": "^13.19.0",
        "grapheme-splitter": "^1.0.4",
        "ignore": "^5.2.0",
        "import-fresh": "^3.0.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "is-path-inside": "^3.0.3",
        "js-sdsl": "^4.1.4",
        "js-yaml": "^4.1.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "levn": "^0.4.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.1",
        "strip-ansi": "^6.0.1",
        "strip-json-comments": "^3.1.0",
        "text-table": "^0.2.0"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-config-prettier": {
      "version": "8.7.0",
      "resolved": "https://registry.npmjs.org/eslint-config-prettier/-/eslint-config-prettier-8.7.0.tgz",
      "integrity": "sha512-HHVXLSlVUhMSmyW4ZzEuvjpwqamgmlfkutD53cYXLikh4pt/modINRcCIApJ84czDxM4GZInwUrromsDdTImTA==",
      "dev": true,
      "bin": {
        "eslint-config-prettier": "bin/cli.js"
      },
      "peerDependencies": {
        "eslint": ">=7.0.0"
      }
    },
    "node_modules/eslint-plugin-prettier": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-plugin-prettier/-/eslint-plugin-prettier-4.2.1.tgz",
      "integrity": "sha512-f/0rXLXUt0oFYs8ra4w49wYZBG5GKZpAYsJSm6rnYL5uVDjd+zowwMwVZHnAjf4edNrKpCDYfXDgmRE/Ak7QyQ==",
      "dev": true,
      "dependencies": {
        "prettier-linter-helpers": "^1.0.0"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "eslint": ">=7.28.0",
        "prettier": ">=2.0.0"
      },
      "peerDependenciesMeta": {
        "eslint-config-prettier": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-scope": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
      "integrity": "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
      "dev": true,
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^4.1.1"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/eslint-utils": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/eslint-utils/-/eslint-utils-3.0.0.tgz",
      "integrity": "sha512-uuQC43IGctw68pJA1RgbQS8/NP7rch6Cwd4j3ZBtgo4/8Flj4eGE7ZYSZRN3iq5pVUv6GPdW5Z1RFleo84uLDA==",
      "dev": true,
      "dependencies": {
        "eslint-visitor-keys": "^2.0.0"
      },
      "engines": {
        "node": "^10.0.0 || ^12.0.0 || >= 14.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/mysticatea"
      },
      "peerDependencies": {
        "eslint": ">=5"
      }
    },
    "node_modules/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-2.1.0.tgz",
      "integrity": "sha512-0rSmRBzXgDzIsD6mGdJgevzgezI534Cer5L/vyMX0kHzT/jiB43jRhd9YUlMGYLQy2zprNmoT8qasCGtY+QaKw==",
      "dev": true,
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "3.4.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.1.tgz",
      "integrity": "sha512-pZnmmLwYzf+kWaM/Qgrvpen51upAktaaiI01nsJD/Yr3lMOdNtq0cxkrrg16w64VtisN6okbs7Q8AfGqj4c9fA==",
      "dev": true,
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint/node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true
    },
    "node_modules/eslint/node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint/node_modules/eslint-scope": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-7.2.0.tgz",
      "integrity": "sha512-DYj5deGlHBfMt15J7rdtyKNq/Nqlv5KfU4iodrQ019XESsRnwXH9KAE0y3cwtUHDo2ob7CypAnCqefh6vioWRw==",
      "dev": true,
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint/node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/eslint/node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint/node_modules/globals": {
      "version": "13.20.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-13.20.0.tgz",
      "integrity": "sha512-Qg5QtVkCy/kv3FUSlu4ukeZDVf9ee0iXLAUYX13gbR17bnejFTzr4iS9bY7kwCf1NztRNm1t91fjOiyx4CSwPQ==",
      "dev": true,
      "dependencies": {
        "type-fest": "^0.20.2"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint/node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dev": true,
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/eslint/node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint/node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint/node_modules/type-fest": {
      "version": "0.20.2",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
      "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
      "dev": true,
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/espree": {
      "version": "9.5.2",
      "resolved": "https://registry.npmjs.org/espree/-/espree-9.5.2.tgz",
      "integrity": "sha512-7OASN1Wma5fum5SrNhFMAMJxOUAbhyfQ8dQ//PJaJbNw0URTPWqIghHWt1MmAANKhHZIYOHruW4Kw4ruUWOdGw==",
      "dev": true,
      "dependencies": {
        "acorn": "^8.8.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^3.4.1"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esprima": {
      "version": "4.0.1",
      "dev": true,
      "license": "BSD-2-Clause",
      "bin": {
        "esparse": "bin/esparse.js",
        "esvalidate": "bin/esvalidate.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/esquery": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.5.0.tgz",
      "integrity": "sha512-YQLXUplAwJgCydQ78IMJywZCceoqk1oH01OERdSAJc/7U2AylwjhSCLDEtqwg811idIS/9fIU5GjG73IgjKMVg==",
      "dev": true,
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esquery/node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esrecurse/node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
      "integrity": "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
      "dev": true,
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estree-walker": {
      "version": "1.0.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/execa": {
      "version": "5.1.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cross-spawn": "^7.0.3",
        "get-stream": "^6.0.0",
        "human-signals": "^2.1.0",
        "is-stream": "^2.0.0",
        "merge-stream": "^2.0.0",
        "npm-run-path": "^4.0.1",
        "onetime": "^5.1.2",
        "signal-exit": "^3.0.3",
        "strip-final-newline": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/execa?sponsor=1"
      }
    },
    "node_modules/exit": {
      "version": "0.1.2",
      "dev": true,
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/expect": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/expect-utils": "^29.4.3",
        "jest-get-type": "^29.4.3",
        "jest-matcher-utils": "^29.4.3",
        "jest-message-util": "^29.4.3",
        "jest-util": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/extract-files": {
      "version": "9.0.0",
      "resolved": "https://registry.npmjs.org/extract-files/-/extract-files-9.0.0.tgz",
      "integrity": "sha512-CvdFfHkC95B4bBBk36hcEmvdR2awOdhhVUYH6S/zrVj3477zven/fJMYg7121h4T1xHZC+tetUpubpAhxwI7hQ==",
      "engines": {
        "node": "^10.17.0 || ^12.0.0 || >= 13.7.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/jaydenseric"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true
    },
    "node_modules/fast-diff": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/fast-diff/-/fast-diff-1.2.0.tgz",
      "integrity": "sha512-xJuoT5+L99XlZ8twedaRf6Ax2TgQVxvgZOYoPKqZufmJib0tL2tegPBOZb1pVNgIhlqDlA0eO0c3wBvQcmzx4w==",
      "dev": true
    },
    "node_modules/fast-glob": {
      "version": "3.2.12",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.2.12.tgz",
      "integrity": "sha512-DVj4CQIYYow0BlaelwK1pHl5n5cRSJfM60UA0zK891sVInoPri2Ekj7+e1CT3/3qxXenpI+nBBmQAcJPJgaj4w==",
      "dev": true,
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.4"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true
    },
    "node_modules/fastq": {
      "version": "1.15.0",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.15.0.tgz",
      "integrity": "sha512-wBrocU2LCXXa+lWBt8RoIRD89Fi8OdABODa/kEnyeyjS5aZO5/GNvI5sEINADqP/h8M29UHTHUb53sUu5Ihqdw==",
      "dev": true,
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/fb-watchman": {
      "version": "2.0.2",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "bser": "2.1.1"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
      "integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
      "dev": true,
      "dependencies": {
        "flat-cache": "^3.0.4"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.0.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "4.1.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^5.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/flat-cache": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.0.4.tgz",
      "integrity": "sha512-dm9s5Pw7Jc0GvMYbshN6zchCA9RgQlzzEZX3vylR9IqFfS8XciblUXOKfW6SiuJ0e13eDYZoZV5wdrev7P3Nwg==",
      "dev": true,
      "dependencies": {
        "flatted": "^3.1.0",
        "rimraf": "^3.0.2"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/flatted": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.2.7.tgz",
      "integrity": "sha512-5nqDSxl8nn5BSNxyR3n4I6eDmbolI6WT+QqR547RwxQapgjQBmtktdP+HTBb/a/zLsbzERTONyUB5pefh5TtjQ==",
      "dev": true
    },
    "node_modules/form-data": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-3.0.1.tgz",
      "integrity": "sha512-RHkBKtLWUVwd7SqRIvCZMEvAMoGUp0XU+seQiZejj0COz3RI3hWP4sCv3gZWWLjJTd7rGwcsF5eKZGii0r/hbg==",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fs-minipass": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-2.1.0.tgz",
      "integrity": "sha512-V/JgOLFCS+R6Vcq0slCuaeWEdNC3ouDlJMNIsacH2VtALiu9mV4LPrHc5cDl8k5aw6J8jwgWWpiTo5RYhmIzvg==",
      "dependencies": {
        "minipass": "^3.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/fs-minipass/node_modules/minipass": {
      "version": "3.3.6",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.3.6.tgz",
      "integrity": "sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/fs-minipass/node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/fsevents": {
      "version": "2.3.2",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-caller-file": {
      "version": "2.0.5",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": "6.* || 8.* || >= 10.*"
      }
    },
    "node_modules/get-package-type": {
      "version": "0.1.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/get-stream": {
      "version": "6.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/glob": {
      "version": "7.2.3",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "11.12.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/globby": {
      "version": "11.1.0",
      "resolved": "https://registry.npmjs.org/globby/-/globby-11.1.0.tgz",
      "integrity": "sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==",
      "dev": true,
      "dependencies": {
        "array-union": "^2.1.0",
        "dir-glob": "^3.0.1",
        "fast-glob": "^3.2.9",
        "ignore": "^5.2.0",
        "merge2": "^1.4.1",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/graceful-fs": {
      "version": "4.2.10",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/grapheme-splitter": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/grapheme-splitter/-/grapheme-splitter-1.0.4.tgz",
      "integrity": "sha512-bzh50DW9kTPM00T8y4o8vQg89Di9oLJVLW/KaOGIXJWP/iqCN6WKYkbNOF04vFLJhwcpYUh9ydh/+5vpOqV4YQ==",
      "dev": true
    },
    "node_modules/graphql": {
      "version": "16.6.0",
      "resolved": "https://registry.npmjs.org/graphql/-/graphql-16.6.0.tgz",
      "integrity": "sha512-KPIBPDlW7NxrbT/eh4qPXz5FiFdL5UbaA0XUNz2Rp3Z3hqBSkbj0GVjwFDztsWVauZUWsbKHgMg++sk8UX0bkw==",
      "peer": true,
      "engines": {
        "node": "^12.22.0 || ^14.16.0 || ^16.0.0 || >=17.0.0"
      }
    },
    "node_modules/graphql-request": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/graphql-request/-/graphql-request-5.2.0.tgz",
      "integrity": "sha512-pLhKIvnMyBERL0dtFI3medKqWOz/RhHdcgbZ+hMMIb32mEPa5MJSzS4AuXxfI4sRAu6JVVk5tvXuGfCWl9JYWQ==",
      "dependencies": {
        "@graphql-typed-document-node/core": "^3.1.1",
        "cross-fetch": "^3.1.5",
        "extract-files": "^9.0.0",
        "form-data": "^3.0.0"
      },
      "peerDependencies": {
        "graphql": "14 - 16"
      }
    },
    "node_modules/has": {
      "version": "1.0.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.1"
      },
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/html-escaper": {
      "version": "2.0.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/human-signals": {
      "version": "2.1.0",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=10.17.0"
      }
    },
    "node_modules/husky": {
      "version": "8.0.3",
      "resolved": "https://registry.npmjs.org/husky/-/husky-8.0.3.tgz",
      "integrity": "sha512-+dQSyqPh4x1hlO1swXBiNb2HzTDN1I2IGLQx1GrBuiqFJfoMrnZWwVmatvSiO+Iz8fBUnf+lekwNo4c2LlXItg==",
      "dev": true,
      "bin": {
        "husky": "lib/bin.js"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/typicode"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ignore": {
      "version": "5.2.4",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.2.4.tgz",
      "integrity": "sha512-MAb38BcSbH0eHNBxn7ql2NH/kX33OkB3lZ1BNdh7ENeRChHTYsTvWrMubiIAMNS2llXEEgZ1MUOBtXChP3kaFQ==",
      "dev": true,
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.0.tgz",
      "integrity": "sha512-veYYhQa+D1QBKznvhUHxb8faxlrwUnxseDAbAp457E0wLNio2bOSKnjYDhMj+YiAq61xrMGhQk9iXVk5FzgQMw==",
      "dev": true,
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/import-fresh/node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/import-local": {
      "version": "3.1.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "pkg-dir": "^4.2.0",
        "resolve-cwd": "^3.0.0"
      },
      "bin": {
        "import-local-fixture": "fixtures/cli.js"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/indent-string": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz",
      "integrity": "sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/is-arrayish": {
      "version": "0.2.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.11.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has": "^1.0.3"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-generator-fn": {
      "version": "2.1.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-path-inside": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-3.0.3.tgz",
      "integrity": "sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-stream": {
      "version": "2.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/istanbul-lib-coverage": {
      "version": "3.2.0",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-instrument": {
      "version": "5.2.1",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/core": "^7.12.3",
        "@babel/parser": "^7.14.7",
        "@istanbuljs/schema": "^0.1.2",
        "istanbul-lib-coverage": "^3.2.0",
        "semver": "^6.3.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-report": {
      "version": "3.0.0",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "istanbul-lib-coverage": "^3.0.0",
        "make-dir": "^3.0.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-source-maps": {
      "version": "4.0.1",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "debug": "^4.1.1",
        "istanbul-lib-coverage": "^3.0.0",
        "source-map": "^0.6.1"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-reports": {
      "version": "3.1.5",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "html-escaper": "^2.0.0",
        "istanbul-lib-report": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/jest": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/core": "^29.4.3",
        "@jest/types": "^29.4.3",
        "import-local": "^3.0.2",
        "jest-cli": "^29.4.3"
      },
      "bin": {
        "jest": "bin/jest.js"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/jest-changed-files": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "execa": "^5.0.0",
        "p-limit": "^3.1.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-circus": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/environment": "^29.4.3",
        "@jest/expect": "^29.4.3",
        "@jest/test-result": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "co": "^4.6.0",
        "dedent": "^0.7.0",
        "is-generator-fn": "^2.0.0",
        "jest-each": "^29.4.3",
        "jest-matcher-utils": "^29.4.3",
        "jest-message-util": "^29.4.3",
        "jest-runtime": "^29.4.3",
        "jest-snapshot": "^29.4.3",
        "jest-util": "^29.4.3",
        "p-limit": "^3.1.0",
        "pretty-format": "^29.4.3",
        "slash": "^3.0.0",
        "stack-utils": "^2.0.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-cli": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/core": "^29.4.3",
        "@jest/test-result": "^29.4.3",
        "@jest/types": "^29.4.3",
        "chalk": "^4.0.0",
        "exit": "^0.1.2",
        "graceful-fs": "^4.2.9",
        "import-local": "^3.0.2",
        "jest-config": "^29.4.3",
        "jest-util": "^29.4.3",
        "jest-validate": "^29.4.3",
        "prompts": "^2.0.1",
        "yargs": "^17.3.1"
      },
      "bin": {
        "jest": "bin/jest.js"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "node-notifier": "^8.0.1 || ^9.0.0 || ^10.0.0"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/jest-config": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.11.6",
        "@jest/test-sequencer": "^29.4.3",
        "@jest/types": "^29.4.3",
        "babel-jest": "^29.4.3",
        "chalk": "^4.0.0",
        "ci-info": "^3.2.0",
        "deepmerge": "^4.2.2",
        "glob": "^7.1.3",
        "graceful-fs": "^4.2.9",
        "jest-circus": "^29.4.3",
        "jest-environment-node": "^29.4.3",
        "jest-get-type": "^29.4.3",
        "jest-regex-util": "^29.4.3",
        "jest-resolve": "^29.4.3",
        "jest-runner": "^29.4.3",
        "jest-util": "^29.4.3",
        "jest-validate": "^29.4.3",
        "micromatch": "^4.0.4",
        "parse-json": "^5.2.0",
        "pretty-format": "^29.4.3",
        "slash": "^3.0.0",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "@types/node": "*",
        "ts-node": ">=9.0.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "ts-node": {
          "optional": true
        }
      }
    },
    "node_modules/jest-diff": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chalk": "^4.0.0",
        "diff-sequences": "^29.4.3",
        "jest-get-type": "^29.4.3",
        "pretty-format": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-docblock": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "detect-newline": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-each": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.4.3",
        "chalk": "^4.0.0",
        "jest-get-type": "^29.4.3",
        "jest-util": "^29.4.3",
        "pretty-format": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-environment-node": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/environment": "^29.4.3",
        "@jest/fake-timers": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "jest-mock": "^29.4.3",
        "jest-util": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-get-type": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-haste-map": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.4.3",
        "@types/graceful-fs": "^4.1.3",
        "@types/node": "*",
        "anymatch": "^3.0.3",
        "fb-watchman": "^2.0.0",
        "graceful-fs": "^4.2.9",
        "jest-regex-util": "^29.4.3",
        "jest-util": "^29.4.3",
        "jest-worker": "^29.4.3",
        "micromatch": "^4.0.4",
        "walker": "^1.0.8"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "optionalDependencies": {
        "fsevents": "^2.3.2"
      }
    },
    "node_modules/jest-leak-detector": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "jest-get-type": "^29.4.3",
        "pretty-format": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-matcher-utils": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chalk": "^4.0.0",
        "jest-diff": "^29.4.3",
        "jest-get-type": "^29.4.3",
        "pretty-format": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-message-util": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.12.13",
        "@jest/types": "^29.4.3",
        "@types/stack-utils": "^2.0.0",
        "chalk": "^4.0.0",
        "graceful-fs": "^4.2.9",
        "micromatch": "^4.0.4",
        "pretty-format": "^29.4.3",
        "slash": "^3.0.0",
        "stack-utils": "^2.0.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-mock": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "jest-util": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-pnp-resolver": {
      "version": "1.2.3",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      },
      "peerDependencies": {
        "jest-resolve": "*"
      },
      "peerDependenciesMeta": {
        "jest-resolve": {
          "optional": true
        }
      }
    },
    "node_modules/jest-regex-util": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-resolve": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chalk": "^4.0.0",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.4.3",
        "jest-pnp-resolver": "^1.2.2",
        "jest-util": "^29.4.3",
        "jest-validate": "^29.4.3",
        "resolve": "^1.20.0",
        "resolve.exports": "^2.0.0",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-resolve-dependencies": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "jest-regex-util": "^29.4.3",
        "jest-snapshot": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-runner": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/console": "^29.4.3",
        "@jest/environment": "^29.4.3",
        "@jest/test-result": "^29.4.3",
        "@jest/transform": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "emittery": "^0.13.1",
        "graceful-fs": "^4.2.9",
        "jest-docblock": "^29.4.3",
        "jest-environment-node": "^29.4.3",
        "jest-haste-map": "^29.4.3",
        "jest-leak-detector": "^29.4.3",
        "jest-message-util": "^29.4.3",
        "jest-resolve": "^29.4.3",
        "jest-runtime": "^29.4.3",
        "jest-util": "^29.4.3",
        "jest-watcher": "^29.4.3",
        "jest-worker": "^29.4.3",
        "p-limit": "^3.1.0",
        "source-map-support": "0.5.13"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-runtime": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/environment": "^29.4.3",
        "@jest/fake-timers": "^29.4.3",
        "@jest/globals": "^29.4.3",
        "@jest/source-map": "^29.4.3",
        "@jest/test-result": "^29.4.3",
        "@jest/transform": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "cjs-module-lexer": "^1.0.0",
        "collect-v8-coverage": "^1.0.0",
        "glob": "^7.1.3",
        "graceful-fs": "^4.2.9",
        "jest-haste-map": "^29.4.3",
        "jest-message-util": "^29.4.3",
        "jest-mock": "^29.4.3",
        "jest-regex-util": "^29.4.3",
        "jest-resolve": "^29.4.3",
        "jest-snapshot": "^29.4.3",
        "jest-util": "^29.4.3",
        "slash": "^3.0.0",
        "strip-bom": "^4.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-snapshot": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.11.6",
        "@babel/generator": "^7.7.2",
        "@babel/plugin-syntax-jsx": "^7.7.2",
        "@babel/plugin-syntax-typescript": "^7.7.2",
        "@babel/traverse": "^7.7.2",
        "@babel/types": "^7.3.3",
        "@jest/expect-utils": "^29.4.3",
        "@jest/transform": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/babel__traverse": "^7.0.6",
        "@types/prettier": "^2.1.5",
        "babel-preset-current-node-syntax": "^1.0.0",
        "chalk": "^4.0.0",
        "expect": "^29.4.3",
        "graceful-fs": "^4.2.9",
        "jest-diff": "^29.4.3",
        "jest-get-type": "^29.4.3",
        "jest-haste-map": "^29.4.3",
        "jest-matcher-utils": "^29.4.3",
        "jest-message-util": "^29.4.3",
        "jest-util": "^29.4.3",
        "natural-compare": "^1.4.0",
        "pretty-format": "^29.4.3",
        "semver": "^7.3.5"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-snapshot/node_modules/lru-cache": {
      "version": "6.0.0",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/jest-snapshot/node_modules/semver": {
      "version": "7.3.8",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "lru-cache": "^6.0.0"
      },
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/jest-snapshot/node_modules/yallist": {
      "version": "4.0.0",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/jest-util": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "chalk": "^4.0.0",
        "ci-info": "^3.2.0",
        "graceful-fs": "^4.2.9",
        "picomatch": "^2.2.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-validate": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/types": "^29.4.3",
        "camelcase": "^6.2.0",
        "chalk": "^4.0.0",
        "jest-get-type": "^29.4.3",
        "leven": "^3.1.0",
        "pretty-format": "^29.4.3"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-validate/node_modules/camelcase": {
      "version": "6.3.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/jest-watcher": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/test-result": "^29.4.3",
        "@jest/types": "^29.4.3",
        "@types/node": "*",
        "ansi-escapes": "^4.2.1",
        "chalk": "^4.0.0",
        "emittery": "^0.13.1",
        "jest-util": "^29.4.3",
        "string-length": "^4.0.1"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-worker": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "jest-util": "^29.4.3",
        "merge-stream": "^2.0.0",
        "supports-color": "^8.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/jest-worker/node_modules/supports-color": {
      "version": "8.1.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/supports-color?sponsor=1"
      }
    },
    "node_modules/joycon": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/joycon/-/joycon-3.1.1.tgz",
      "integrity": "sha512-34wB/Y7MW7bzjKRjUKTa46I2Z7eV62Rkhva+KkopW7Qvv/OSWBqvkSY7vusOPrNuZcUG3tApvdVgNB8POj3SPw==",
      "dev": true,
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/js-sdsl": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/js-sdsl/-/js-sdsl-4.3.0.tgz",
      "integrity": "sha512-mifzlm2+5nZ+lEcLJMoBK0/IH/bDg8XnJfd/Wq6IP+xoCjLZsTOnV2QpxlVbX9bMnkl5PdEjNtBJ9Cj1NjifhQ==",
      "dev": true,
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/js-sdsl"
      }
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "3.14.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^1.0.7",
        "esprima": "^4.0.0"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsesc": {
      "version": "2.5.2",
      "dev": true,
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/json-parse-even-better-errors": {
      "version": "2.3.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/kleur": {
      "version": "3.0.3",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/leven": {
      "version": "3.1.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lilconfig": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/lilconfig/-/lilconfig-2.1.0.tgz",
      "integrity": "sha512-utWOt/GHzuUxnLKxB6dk81RoOeoNeHgbrXiuGk4yyF5qlRz+iIVWu56E2fqGHFrXz0QNUhLB/8nKqvRH66JKGQ==",
      "dev": true,
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lint-staged": {
      "version": "13.2.0",
      "resolved": "https://registry.npmjs.org/lint-staged/-/lint-staged-13.2.0.tgz",
      "integrity": "sha512-GbyK5iWinax5Dfw5obm2g2ccUiZXNGtAS4mCbJ0Lv4rq6iEtfBSjOYdcbOtAIFtM114t0vdpViDDetjVTSd8Vw==",
      "dev": true,
      "dependencies": {
        "chalk": "5.2.0",
        "cli-truncate": "^3.1.0",
        "commander": "^10.0.0",
        "debug": "^4.3.4",
        "execa": "^7.0.0",
        "lilconfig": "2.1.0",
        "listr2": "^5.0.7",
        "micromatch": "^4.0.5",
        "normalize-path": "^3.0.0",
        "object-inspect": "^1.12.3",
        "pidtree": "^0.6.0",
        "string-argv": "^0.3.1",
        "yaml": "^2.2.1"
      },
      "bin": {
        "lint-staged": "bin/lint-staged.js"
      },
      "engines": {
        "node": "^14.13.1 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/lint-staged"
      }
    },
    "node_modules/lint-staged/node_modules/chalk": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-5.2.0.tgz",
      "integrity": "sha512-ree3Gqw/nazQAPuJJEy+avdl7QfZMcUvmHIKgEZkGL+xOBzRvup5Hxo6LHuMceSxOabuJLJm5Yp/92R9eMmMvA==",
      "dev": true,
      "engines": {
        "node": "^12.17.0 || ^14.13 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/lint-staged/node_modules/execa": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/execa/-/execa-7.0.0.tgz",
      "integrity": "sha512-tQbH0pH/8LHTnwTrsKWideqi6rFB/QNUawEwrn+WHyz7PX1Tuz2u7wfTvbaNBdP5JD5LVWxNo8/A8CHNZ3bV6g==",
      "dev": true,
      "dependencies": {
        "cross-spawn": "^7.0.3",
        "get-stream": "^6.0.1",
        "human-signals": "^4.3.0",
        "is-stream": "^3.0.0",
        "merge-stream": "^2.0.0",
        "npm-run-path": "^5.1.0",
        "onetime": "^6.0.0",
        "signal-exit": "^3.0.7",
        "strip-final-newline": "^3.0.0"
      },
      "engines": {
        "node": "^14.18.0 || ^16.14.0 || >=18.0.0"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/execa?sponsor=1"
      }
    },
    "node_modules/lint-staged/node_modules/human-signals": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/human-signals/-/human-signals-4.3.0.tgz",
      "integrity": "sha512-zyzVyMjpGBX2+6cDVZeFPCdtOtdsxOeseRhB9tkQ6xXmGUNrcnBzdEKPy3VPNYz+4gy1oukVOXcrJCunSyc6QQ==",
      "dev": true,
      "engines": {
        "node": ">=14.18.0"
      }
    },
    "node_modules/lint-staged/node_modules/is-stream": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-stream/-/is-stream-3.0.0.tgz",
      "integrity": "sha512-LnQR4bZ9IADDRSkvpqMGvt/tEJWclzklNgSw48V5EAaAeDd6qGvN8ei6k5p0tvxSR171VmGyHuTiAOfxAbr8kA==",
      "dev": true,
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lint-staged/node_modules/mimic-fn": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/mimic-fn/-/mimic-fn-4.0.0.tgz",
      "integrity": "sha512-vqiC06CuhBTUdZH+RYl8sFrL096vA45Ok5ISO6sE/Mr1jRbGH4Csnhi8f3wKVl7x8mO4Au7Ir9D3Oyv1VYMFJw==",
      "dev": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lint-staged/node_modules/npm-run-path": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/npm-run-path/-/npm-run-path-5.1.0.tgz",
      "integrity": "sha512-sJOdmRGrY2sjNTRMbSvluQqg+8X7ZK61yvzBEIDhz4f8z1TZFYABsqjjCBd/0PUNE9M6QDgHJXQkGUEm7Q+l9Q==",
      "dev": true,
      "dependencies": {
        "path-key": "^4.0.0"
      },
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lint-staged/node_modules/onetime": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/onetime/-/onetime-6.0.0.tgz",
      "integrity": "sha512-1FlR+gjXK7X+AsAHso35MnyN5KqGwJRi/31ft6x0M194ht7S+rWAvd7PHss9xSKMzE0asv1pyIHaJYq+BbacAQ==",
      "dev": true,
      "dependencies": {
        "mimic-fn": "^4.0.0"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lint-staged/node_modules/path-key": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-4.0.0.tgz",
      "integrity": "sha512-haREypq7xkM7ErfgIyA0z+Bj4AGKlMSdlQE2jvJo6huWD1EdkKYV+G/T4nq0YEF2vgTT8kqMFKo1uHn950r4SQ==",
      "dev": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lint-staged/node_modules/strip-final-newline": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-final-newline/-/strip-final-newline-3.0.0.tgz",
      "integrity": "sha512-dOESqjYr96iWYylGObzd39EuNTa5VJxyvVAEm5Jnh7KGo75V43Hk1odPQkNDyXNmUR6k+gEiDVXnjB8HJ3crXw==",
      "dev": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/listr2": {
      "version": "5.0.7",
      "resolved": "https://registry.npmjs.org/listr2/-/listr2-5.0.7.tgz",
      "integrity": "sha512-MD+qXHPmtivrHIDRwPYdfNkrzqDiuaKU/rfBcec3WMyMF3xylQj3jMq344OtvQxz7zaCFViRAeqlr2AFhPvXHw==",
      "dev": true,
      "dependencies": {
        "cli-truncate": "^2.1.0",
        "colorette": "^2.0.19",
        "log-update": "^4.0.0",
        "p-map": "^4.0.0",
        "rfdc": "^1.3.0",
        "rxjs": "^7.8.0",
        "through": "^2.3.8",
        "wrap-ansi": "^7.0.0"
      },
      "engines": {
        "node": "^14.13.1 || >=16.0.0"
      },
      "peerDependencies": {
        "enquirer": ">= 2.3.0 < 3"
      },
      "peerDependenciesMeta": {
        "enquirer": {
          "optional": true
        }
      }
    },
    "node_modules/listr2/node_modules/cli-truncate": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/cli-truncate/-/cli-truncate-2.1.0.tgz",
      "integrity": "sha512-n8fOixwDD6b/ObinzTrp1ZKFzbgvKZvuz/TvejnLn1aQfC6r52XEx85FmuC+3HI+JM7coBRXUvNqEU2PHVrHpg==",
      "dev": true,
      "dependencies": {
        "slice-ansi": "^3.0.0",
        "string-width": "^4.2.0"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/listr2/node_modules/slice-ansi": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-3.0.0.tgz",
      "integrity": "sha512-pSyv7bSTC7ig9Dcgbw9AuRNUb5k5V6oDudjZoMBSr13qpLBG7tB+zgCkARjq7xIUgdz5P1Qe8u+rSGdouOOIyQ==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "astral-regex": "^2.0.0",
        "is-fullwidth-code-point": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/load-tsconfig": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/load-tsconfig/-/load-tsconfig-0.2.5.tgz",
      "integrity": "sha512-IXO6OCs9yg8tMKzfPZ1YmheJbZCiEsnBdcB03l0OcfK9prKnJb96siuHCr5Fl37/yo9DnKU+TLpxzTUspw9shg==",
      "dev": true,
      "engines": {
        "node": "^12.20.0 || ^14.13.1 || >=16.0.0"
      }
    },
    "node_modules/locate-path": {
      "version": "5.0.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^4.1.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/lodash.memoize": {
      "version": "4.1.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true
    },
    "node_modules/lodash.sortby": {
      "version": "4.7.0",
      "resolved": "https://registry.npmjs.org/lodash.sortby/-/lodash.sortby-4.7.0.tgz",
      "integrity": "sha512-HDWXG8isMntAyRF5vZ7xKuEvOhT4AhlRt/3czTSjvGUxjYCBVRQY48ViDHyfYz9VIoBkW4TMGQNapx+l3RUwdA==",
      "dev": true
    },
    "node_modules/log-update": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/log-update/-/log-update-4.0.0.tgz",
      "integrity": "sha512-9fkkDevMefjg0mmzWFBW8YkFP91OrizzkW3diF7CpG+S2EYdy4+TVfGwz1zeF8x7hCx1ovSPTOE9Ngib74qqUg==",
      "dev": true,
      "dependencies": {
        "ansi-escapes": "^4.3.0",
        "cli-cursor": "^3.1.0",
        "slice-ansi": "^4.0.0",
        "wrap-ansi": "^6.2.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/log-update/node_modules/slice-ansi": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-4.0.0.tgz",
      "integrity": "sha512-qMCMfhY040cVHT43K9BFygqYbUPFZKHOg7K73mtTWJRb8pyP3fzf4Ixd5SzdEJQ6MRUg/WBnOLxghZtKKurENQ==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "astral-regex": "^2.0.0",
        "is-fullwidth-code-point": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/slice-ansi?sponsor=1"
      }
    },
    "node_modules/log-update/node_modules/wrap-ansi": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-6.2.0.tgz",
      "integrity": "sha512-r6lPcBGxZXlIcymEu7InxDMhdW0KDxpLgoFLcguasxCaJ/SOIZwINatK9KY/tf+ZrlywOKU0UDj3ATXUBfxJXA==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/make-dir": {
      "version": "3.1.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^6.0.0"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/makeerror": {
      "version": "1.0.12",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "tmpl": "1.0.5"
      }
    },
    "node_modules/merge-stream": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.5",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.2",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mimic-fn": {
      "version": "2.1.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minipass": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-4.2.5.tgz",
      "integrity": "sha512-+yQl7SX3bIT83Lhb4BVorMAHVuqsskxRdlmO9kTpyukp8vsm2Sn/fUOV9xlnG8/a5JsypJzap21lz/y3FBMJ8Q==",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/minizlib": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-2.1.2.tgz",
      "integrity": "sha512-bAxsR8BVfj60DWXHE3u30oHzfl4G7khkSuPW+qvpd7jFRHm7dLxOjUk1EHACJ/hxLY8phGJ0YhYHZo7jil7Qdg==",
      "dependencies": {
        "minipass": "^3.0.0",
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/minizlib/node_modules/minipass": {
      "version": "3.3.6",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.3.6.tgz",
      "integrity": "sha512-DxiNidxSEK+tHG6zOIklvNOwm3hvCrbUrdtzY74U6HKTJxvIDfOUL5W5P2Ghd3DTkhhKPYGqeNUIh5qcM4YBfw==",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/minizlib/node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
    },
    "node_modules/mkdirp": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
      "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
      "bin": {
        "mkdirp": "bin/cmd.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/ms": {
      "version": "2.1.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/mz": {
      "version": "2.7.0",
      "resolved": "https://registry.npmjs.org/mz/-/mz-2.7.0.tgz",
      "integrity": "sha512-z81GNO7nnYMEhrGh9LeymoE4+Yr0Wn5McHIZMK5cfQCl+NDX08sCZgUc9/6MHni9IWuFLm1Z3HTCXu2z9fN62Q==",
      "dev": true,
      "dependencies": {
        "any-promise": "^1.0.0",
        "object-assign": "^4.0.1",
        "thenify-all": "^1.0.0"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/natural-compare-lite": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare-lite/-/natural-compare-lite-1.4.0.tgz",
      "integrity": "sha512-Tj+HTDSJJKaZnfiuw+iaF9skdPpTo2GtEly5JHnWV/hfv2Qj/9RKsGISQtLh2ox3l5EAGw487hnBee0sIJ6v2g==",
      "dev": true
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/node-int64": {
      "version": "0.4.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/node-releases": {
      "version": "2.0.8",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/npm-run-path": {
      "version": "4.0.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.12.3",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.3.tgz",
      "integrity": "sha512-geUvdk7c+eizMNUDkRpW1wJwgfOiOeHbxBR/hLXK1aT6zmVSO0jsQcs7fj6MGw89jC/cjGfLcNOrtMYtGqm81g==",
      "dev": true,
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/onetime": {
      "version": "5.1.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mimic-fn": "^2.1.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.1",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.1.tgz",
      "integrity": "sha512-74RlY5FCnhq4jRxVUPKDaRwrVNXMqsGsiW6AJw4XK8hmtm10wC0ypZBLw5IIp85NZMr91+qd1RvvENwg7jjRFw==",
      "dev": true,
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.3"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "4.1.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^2.2.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/p-locate/node_modules/p-limit": {
      "version": "2.3.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-try": "^2.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-map": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/p-map/-/p-map-4.0.0.tgz",
      "integrity": "sha512-/bjOqmgETBYB5BoEeGVea8dmvHb2m9GLy1E9W43yeyfP6QQCZGFNa+XRceJEuDB6zqr+gKpIAmlLebMpykw/MQ==",
      "dev": true,
      "dependencies": {
        "aggregate-error": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-try": {
      "version": "2.2.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parse-json": {
      "version": "5.2.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.0.0",
        "error-ex": "^1.3.1",
        "json-parse-even-better-errors": "^2.3.0",
        "lines-and-columns": "^1.1.6"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/path-type": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/picocolors": {
      "version": "1.0.0",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pidtree": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/pidtree/-/pidtree-0.6.0.tgz",
      "integrity": "sha512-eG2dWTVw5bzqGRztnHExczNxt5VGsE6OwTeCG3fdUf9KBsZzO3R5OIIIzWR+iZA0NtZ+RDVdaoE2dK1cn6jH4g==",
      "dev": true,
      "bin": {
        "pidtree": "bin/pidtree.js"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/pirates": {
      "version": "4.0.5",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/pkg-dir": {
      "version": "4.2.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "find-up": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/postcss-load-config": {
      "version": "3.1.4",
      "resolved": "https://registry.npmjs.org/postcss-load-config/-/postcss-load-config-3.1.4.tgz",
      "integrity": "sha512-6DiM4E7v4coTE4uzA8U//WhtPwyhiim3eyjEMFCnUpzbrkK9wJHgKDT2mR+HbtSrd/NubVaYTOpSpjUl8NQeRg==",
      "dev": true,
      "dependencies": {
        "lilconfig": "^2.0.5",
        "yaml": "^1.10.2"
      },
      "engines": {
        "node": ">= 10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/postcss/"
      },
      "peerDependencies": {
        "postcss": ">=8.0.9",
        "ts-node": ">=9.0.0"
      },
      "peerDependenciesMeta": {
        "postcss": {
          "optional": true
        },
        "ts-node": {
          "optional": true
        }
      }
    },
    "node_modules/postcss-load-config/node_modules/yaml": {
      "version": "1.10.2",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-1.10.2.tgz",
      "integrity": "sha512-r3vXyErRCYJ7wg28yvBY5VSoAF8ZvlcW9/BwUzEtUsjvX/DKs24dIkuwjtuprwJJHsbyUbLApepYTR1BN4uHrg==",
      "dev": true,
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/prettier": {
      "version": "2.8.4",
      "resolved": "https://registry.npmjs.org/prettier/-/prettier-2.8.4.tgz",
      "integrity": "sha512-vIS4Rlc2FNh0BySk3Wkd6xmwxB0FpOndW5fisM5H8hsZSxU2VWVB5CWIkIjWvrHjIhxk2g3bfMKM87zNTrZddw==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "prettier": "bin-prettier.js"
      },
      "engines": {
        "node": ">=10.13.0"
      },
      "funding": {
        "url": "https://github.com/prettier/prettier?sponsor=1"
      }
    },
    "node_modules/prettier-linter-helpers": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/prettier-linter-helpers/-/prettier-linter-helpers-1.0.0.tgz",
      "integrity": "sha512-GbK2cP9nraSSUF9N2XwUwqfzlAFlMNYYl+ShE/V+H8a9uNl/oUqB1w2EL54Jh0OlyRSd8RfWYJ3coVS4TROP2w==",
      "dev": true,
      "dependencies": {
        "fast-diff": "^1.1.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/pretty-format": {
      "version": "29.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jest/schemas": "^29.4.3",
        "ansi-styles": "^5.0.0",
        "react-is": "^18.0.0"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      }
    },
    "node_modules/pretty-format/node_modules/ansi-styles": {
      "version": "5.2.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/prompts": {
      "version": "2.4.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "kleur": "^3.0.3",
        "sisteransi": "^1.0.5"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.0.tgz",
      "integrity": "sha512-rRV+zQD8tVFys26lAGR9WUuS4iUAngJScM+ZRSKtvl5tKeZ2t5bvdNFdNHBW9FWR4guGHlgmsZ1G7BSm2wTbuA==",
      "dev": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/raw-body": {
      "version": "2.5.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/react-is": {
      "version": "18.2.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/regenerator-runtime": {
      "version": "0.13.11",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/regexpp": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/regexpp/-/regexpp-3.2.0.tgz",
      "integrity": "sha512-pq2bWo9mVD43nbts2wGv17XLiNLya+GklZ8kaDLV2Z08gDCsGpnKn9BFMepvWuHCbyVvY7J5o5+BVvoQbmlJLg==",
      "dev": true,
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/mysticatea"
      }
    },
    "node_modules/require-directory": {
      "version": "2.1.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/resolve": {
      "version": "1.22.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.9.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-cwd": {
      "version": "3.0.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "resolve-from": "^5.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/resolve-from": {
      "version": "5.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/resolve.exports": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/restore-cursor": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/restore-cursor/-/restore-cursor-3.1.0.tgz",
      "integrity": "sha512-l+sSefzHpj5qimhFSE5a8nufZYAM3sBSVMAPtYkmC+4EH2anSGaEMXSD0izRQbu9nfyQ9y5JrVmp7E8oZrUjvA==",
      "dev": true,
      "dependencies": {
        "onetime": "^5.1.0",
        "signal-exit": "^3.0.2"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/reusify": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.0.4.tgz",
      "integrity": "sha512-U9nH88a3fc/ekCF1l0/UP1IosiuIjyTh7hBvXVMHYgVcfGvt897Xguj2UOLDeI5BG2m7/uwyaLVT6fbtCwTyzw==",
      "dev": true,
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rfdc": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/rfdc/-/rfdc-1.3.0.tgz",
      "integrity": "sha512-V2hovdzFbOi77/WajaSMXk2OLm+xNIeQdMMuB7icj7bk6zi2F8GGAxigcnDFpJHbNyNcgyJDiP+8nOrY5cZGrA==",
      "dev": true
    },
    "node_modules/rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "dev": true,
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/rollup": {
      "version": "2.79.1",
      "dev": true,
      "license": "MIT",
      "peer": true,
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=10.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/rxjs": {
      "version": "7.8.0",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.8.0.tgz",
      "integrity": "sha512-F2+gxDshqmIub1KdvZkaEfGDwLNpPvk9Fs6LD/MyQxNgMds/WH9OdDDXOmxUZpME+iSK3rQCctkL0DYyytUqMg==",
      "dev": true,
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/rxjs/node_modules/tslib": {
      "version": "2.5.0",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.5.0.tgz",
      "integrity": "sha512-336iVw3rtn2BUK7ORdIAHTyxHGRIHVReokCR3XjbckJMK7ms8FysBfhLR8IXnAgy7T0PTPNBWKiH514FOW/WSg==",
      "dev": true
    },
    "node_modules/safe-buffer": {
      "version": "5.1.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.0",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/signal-exit": {
      "version": "3.0.7",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/sisteransi": {
      "version": "1.0.5",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/slash": {
      "version": "3.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/slice-ansi": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/slice-ansi/-/slice-ansi-5.0.0.tgz",
      "integrity": "sha512-FC+lgizVPfie0kkhqUScwRu1O/lF6NOgJmlCgK+/LYxDCTk8sGelYaHDhFcDN+Sn3Cv+3VSa4Byeo+IMCzpMgQ==",
      "dev": true,
      "dependencies": {
        "ansi-styles": "^6.0.0",
        "is-fullwidth-code-point": "^4.0.0"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/slice-ansi?sponsor=1"
      }
    },
    "node_modules/slice-ansi/node_modules/ansi-styles": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.1.tgz",
      "integrity": "sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==",
      "dev": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/slice-ansi/node_modules/is-fullwidth-code-point": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-4.0.0.tgz",
      "integrity": "sha512-O4L094N2/dZ7xqVdrXhh9r1KODPJpFms8B5sGdJLPy664AgvXsreZUyCQQNItZRDlYug4xStLjNp/sz3HvBowQ==",
      "dev": true,
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/source-map": {
      "version": "0.6.1",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-support": {
      "version": "0.5.13",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "node_modules/sprintf-js": {
      "version": "1.0.3",
      "dev": true,
      "license": "BSD-3-Clause"
    },
    "node_modules/stack-utils": {
      "version": "2.0.6",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "escape-string-regexp": "^2.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/stack-utils/node_modules/escape-string-regexp": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/string-argv": {
      "version": "0.3.1",
      "resolved": "https://registry.npmjs.org/string-argv/-/string-argv-0.3.1.tgz",
      "integrity": "sha512-a1uQGz7IyVy9YwhqjZIZu1c8JO8dNIe20xBmSS6qu9kv++k3JGzCVmprbNN5Kn+BgzD5E7YYwg1CcjuJMRNsvg==",
      "dev": true,
      "engines": {
        "node": ">=0.6.19"
      }
    },
    "node_modules/string-length": {
      "version": "4.0.2",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "char-regex": "^1.0.2",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/string-width": {
      "version": "4.2.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-bom": {
      "version": "4.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-final-newline": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/sucrase": {
      "version": "3.32.0",
      "resolved": "https://registry.npmjs.org/sucrase/-/sucrase-3.32.0.tgz",
      "integrity": "sha512-ydQOU34rpSyj2TGyz4D2p8rbktIOZ8QY9s+DGLvFU1i5pWJE8vkpruCjGCMHsdXwnD7JDcS+noSwM/a7zyNFDQ==",
      "dev": true,
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.2",
        "commander": "^4.0.0",
        "glob": "7.1.6",
        "lines-and-columns": "^1.1.6",
        "mz": "^2.7.0",
        "pirates": "^4.0.1",
        "ts-interface-checker": "^0.1.9"
      },
      "bin": {
        "sucrase": "bin/sucrase",
        "sucrase-node": "bin/sucrase-node"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/sucrase/node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.3",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.3.tgz",
      "integrity": "sha512-HLhSWOLRi875zjjMG/r+Nv0oCW8umGb0BgEhyX3dDX3egwZtB8PqLnjz3yedt8R5StBrzcg4aBpnh8UA9D1BoQ==",
      "dev": true,
      "dependencies": {
        "@jridgewell/set-array": "^1.0.1",
        "@jridgewell/sourcemap-codec": "^1.4.10",
        "@jridgewell/trace-mapping": "^0.3.9"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/sucrase/node_modules/commander": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/commander/-/commander-4.1.1.tgz",
      "integrity": "sha512-NOKm8xhkzAjzFx8B2v5OAHT+u5pRQc2UCa2Vq9jYL/31o2wi9mxBA7LIFs3sV5VSC49z6pEhfbMULvShKj26WA==",
      "dev": true,
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/sucrase/node_modules/glob": {
      "version": "7.1.6",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.6.tgz",
      "integrity": "sha512-LwaxwyZ72Lk7vZINtNNrywX0ZuLyStrdDtabefZKAY5ZGJhVtgdznluResxNmPitE0SAO+O26sWTHeKSI2wMBA==",
      "dev": true,
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/tar": {
      "version": "6.1.13",
      "resolved": "https://registry.npmjs.org/tar/-/tar-6.1.13.tgz",
      "integrity": "sha512-jdIBIN6LTIe2jqzay/2vtYLlBHa3JF42ot3h1dW8Q0PaAG4v8rm0cvpVePtau5C6OKXGGcgO9q2AMNSWxiLqKw==",
      "dependencies": {
        "chownr": "^2.0.0",
        "fs-minipass": "^2.0.0",
        "minipass": "^4.0.0",
        "minizlib": "^2.1.1",
        "mkdirp": "^1.0.3",
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/tar/node_modules/yallist": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
      "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
    },
    "node_modules/test-exclude": {
      "version": "6.0.0",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@istanbuljs/schema": "^0.1.2",
        "glob": "^7.1.4",
        "minimatch": "^3.0.4"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/text-table": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
      "integrity": "sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==",
      "dev": true
    },
    "node_modules/thenify": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/thenify/-/thenify-3.3.1.tgz",
      "integrity": "sha512-RVZSIV5IG10Hk3enotrhvz0T9em6cyHBLkH/YAZuKqd8hRkKhSfCGIcP2KUY0EPxndzANBmNllzWPwak+bheSw==",
      "dev": true,
      "dependencies": {
        "any-promise": "^1.0.0"
      }
    },
    "node_modules/thenify-all": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/thenify-all/-/thenify-all-1.6.0.tgz",
      "integrity": "sha512-RNxQH/qI8/t3thXJDwcstUO4zeqo64+Uy/+sNVRBx4Xn2OX+OZ9oP+iJnNFqplFra2ZUVeKCSa2oVWi3T4uVmA==",
      "dev": true,
      "dependencies": {
        "thenify": ">= 3.1.0 < 4"
      },
      "engines": {
        "node": ">=0.8"
      }
    },
    "node_modules/through": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/through/-/through-2.3.8.tgz",
      "integrity": "sha512-w89qg7PI8wAdvX60bMDP+bFoD5Dvhm9oLheFp5O4a2QF0cSBGsBX4qZmadPMvVqlLJBBci+WqGGOAPvcDeNSVg==",
      "dev": true
    },
    "node_modules/tmpl": {
      "version": "1.0.5",
      "dev": true,
      "license": "BSD-3-Clause"
    },
    "node_modules/to-fast-properties": {
      "version": "2.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "node_modules/tree-kill": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/tree-kill/-/tree-kill-1.2.2.tgz",
      "integrity": "sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==",
      "dev": true,
      "bin": {
        "tree-kill": "cli.js"
      }
    },
    "node_modules/ts-interface-checker": {
      "version": "0.1.13",
      "resolved": "https://registry.npmjs.org/ts-interface-checker/-/ts-interface-checker-0.1.13.tgz",
      "integrity": "sha512-Y/arvbn+rrz3JCKl9C4kVNfTfSm2/mEp5FSz5EsZSANGPSlQrpRI5M4PKF+mJnE52jOO90PnPSc3Ur3bTQw0gA==",
      "dev": true
    },
    "node_modules/ts-jest": {
      "version": "29.0.5",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "bs-logger": "0.x",
        "fast-json-stable-stringify": "2.x",
        "jest-util": "^29.0.0",
        "json5": "^2.2.3",
        "lodash.memoize": "4.x",
        "make-error": "1.x",
        "semver": "7.x",
        "yargs-parser": "^21.0.1"
      },
      "bin": {
        "ts-jest": "cli.js"
      },
      "engines": {
        "node": "^14.15.0 || ^16.10.0 || >=18.0.0"
      },
      "peerDependencies": {
        "@babel/core": ">=7.0.0-beta.0 <8",
        "@jest/types": "^29.0.0",
        "babel-jest": "^29.0.0",
        "jest": "^29.0.0",
        "typescript": ">=4.3"
      },
      "peerDependenciesMeta": {
        "@babel/core": {
          "optional": true
        },
        "@jest/types": {
          "optional": true
        },
        "babel-jest": {
          "optional": true
        },
        "esbuild": {
          "optional": true
        }
      }
    },
    "node_modules/ts-jest/node_modules/lru-cache": {
      "version": "6.0.0",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/ts-jest/node_modules/semver": {
      "version": "7.3.8",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "lru-cache": "^6.0.0"
      },
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/ts-jest/node_modules/yallist": {
      "version": "4.0.0",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/ts-node": {
      "version": "10.9.1",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.1.tgz",
      "integrity": "sha512-NtVysVPkxxrwFGUUxGYhfux8k78pQB3JqYBXlLRZgdGUqTO5wU/UyHop5p70iEbGhB7q5KmiZiU0Y3KlJrScEw==",
      "dev": true,
      "optional": true,
      "peer": true,
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/tslib": {
      "version": "1.14.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-1.14.1.tgz",
      "integrity": "sha512-Xni35NKzjgMrwevysHTCArtLDpPvye8zV/0E4EyYn43P7/7qvQwPh9BGkHewbMulVntbigmcT7rdX3BNo9wRJg==",
      "dev": true
    },
    "node_modules/tsup": {
      "version": "6.7.0",
      "resolved": "https://registry.npmjs.org/tsup/-/tsup-6.7.0.tgz",
      "integrity": "sha512-L3o8hGkaHnu5TdJns+mCqFsDBo83bJ44rlK7e6VdanIvpea4ArPcU3swWGsLVbXak1PqQx/V+SSmFPujBK+zEQ==",
      "dev": true,
      "dependencies": {
        "bundle-require": "^4.0.0",
        "cac": "^6.7.12",
        "chokidar": "^3.5.1",
        "debug": "^4.3.1",
        "esbuild": "^0.17.6",
        "execa": "^5.0.0",
        "globby": "^11.0.3",
        "joycon": "^3.0.1",
        "postcss-load-config": "^3.0.1",
        "resolve-from": "^5.0.0",
        "rollup": "^3.2.5",
        "source-map": "0.8.0-beta.0",
        "sucrase": "^3.20.3",
        "tree-kill": "^1.2.2"
      },
      "bin": {
        "tsup": "dist/cli-default.js",
        "tsup-node": "dist/cli-node.js"
      },
      "engines": {
        "node": ">=14.18"
      },
      "peerDependencies": {
        "@swc/core": "^1",
        "postcss": "^8.4.12",
        "typescript": ">=4.1.0"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "postcss": {
          "optional": true
        },
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/tsup/node_modules/rollup": {
      "version": "3.21.5",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-3.21.5.tgz",
      "integrity": "sha512-a4NTKS4u9PusbUJcfF4IMxuqjFzjm6ifj76P54a7cKnvVzJaG12BLVR+hgU2YDGHzyMMQNxLAZWuALsn8q2oQg==",
      "dev": true,
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=14.18.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/tsup/node_modules/source-map": {
      "version": "0.8.0-beta.0",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.8.0-beta.0.tgz",
      "integrity": "sha512-2ymg6oRBpebeZi9UUNsgQ89bhx01TcTkmNTGnNO88imTmbSgy4nfujrgVEFKWpMTEGA11EDkTt7mqObTPdigIA==",
      "dev": true,
      "dependencies": {
        "whatwg-url": "^7.0.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/tsup/node_modules/tr46": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-1.0.1.tgz",
      "integrity": "sha512-dTpowEjclQ7Kgx5SdBkqRzVhERQXov8/l9Ft9dVM9fmg0W0KQSVaXX9T4i6twCPNtYiZM53lpSSUAwJbFPOHxA==",
      "dev": true,
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/tsup/node_modules/webidl-conversions": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-4.0.2.tgz",
      "integrity": "sha512-YQ+BmxuTgd6UXZW3+ICGfyqRyHXVlD5GtQr5+qjiNW7bF0cqrzX500HVXPBOvgXb5YnzDd+h0zqyv61KUD7+Sg==",
      "dev": true
    },
    "node_modules/tsup/node_modules/whatwg-url": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-7.1.0.tgz",
      "integrity": "sha512-WUu7Rg1DroM7oQvGWfOiAK21n74Gg+T4elXEQYkOhtyLeWiJFoOGLXPKI/9gzIie9CtwVLm8wtw6YJdKyxSjeg==",
      "dev": true,
      "dependencies": {
        "lodash.sortby": "^4.7.0",
        "tr46": "^1.0.1",
        "webidl-conversions": "^4.0.2"
      }
    },
    "node_modules/tsutils": {
      "version": "3.21.0",
      "resolved": "https://registry.npmjs.org/tsutils/-/tsutils-3.21.0.tgz",
      "integrity": "sha512-mHKK3iUXL+3UF6xL5k0PEhKRUBKPBCv/+RkEOpjRWxxx27KKRBmmA60A9pgOUvMi8GKhRMPEmjBRPzs2W7O1OA==",
      "dev": true,
      "dependencies": {
        "tslib": "^1.8.1"
      },
      "engines": {
        "node": ">= 6"
      },
      "peerDependencies": {
        "typescript": ">=2.8.0 || >= 3.2.0-dev || >= 3.3.0-dev || >= 3.4.0-dev || >= 3.5.0-dev || >= 3.6.0-dev || >= 3.6.0-beta || >= 3.7.0-dev || >= 3.7.0-beta"
      }
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/type-detect": {
      "version": "4.0.8",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/type-fest": {
      "version": "0.21.3",
      "dev": true,
      "license": "(MIT OR CC0-1.0)",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/typescript": {
      "version": "4.9.5",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=4.2.0"
      }
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/update-browserslist-db": {
      "version": "1.0.10",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.1.1",
        "picocolors": "^1.0.0"
      },
      "bin": {
        "browserslist-lint": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/uuid": {
      "version": "9.0.1",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-9.0.1.tgz",
      "integrity": "sha512-b+1eJOlsR9K8HJpow9Ok3fiWOWSIcIzXodvv0rQjVoOVNpWMpxf1wZNpt4y9h10odCNrqnYp1OBzRktckBe3sA==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true,
      "optional": true,
      "peer": true
    },
    "node_modules/v8-to-istanbul": {
      "version": "9.1.0",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.12",
        "@types/istanbul-lib-coverage": "^2.0.1",
        "convert-source-map": "^1.6.0"
      },
      "engines": {
        "node": ">=10.12.0"
      }
    },
    "node_modules/walker": {
      "version": "1.0.8",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "makeerror": "1.0.12"
      }
    },
    "node_modules/weaviate-ts-client": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/weaviate-ts-client/-/weaviate-ts-client-2.2.0.tgz",
      "integrity": "sha512-sOvX1Gt8+u9wIVmiYii26N4KSpZ8jM5fM4DMmtRL6yPNO9u8elsvg5g7eJOwmrICsn1Zt2efxhxuSChI0M8FzQ==",
      "license": "SEE LICENSE IN LICENSE",
      "dependencies": {
        "graphql-request": "^5.2.0",
        "uuid": "^9.0.1"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.3.tgz",
      "integrity": "sha512-Hz/mrNwitNRh/HUAtM/VT/5VH+ygD6DV7mYKZAtHOrbs8U7lvPS6xf7EJKMF0uW1KJCl0H701g3ZGus+muE5vQ==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "7.0.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/write-file-atomic": {
      "version": "4.0.2",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "imurmurhash": "^0.1.4",
        "signal-exit": "^3.0.7"
      },
      "engines": {
        "node": "^12.13.0 || ^14.15.0 || >=16.0.0"
      }
    },
    "node_modules/y18n": {
      "version": "5.0.8",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yaml": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.2.2.tgz",
      "integrity": "sha512-CBKFWExMn46Foo4cldiChEzn7S7SRV+wqiluAb6xmueD/fGyRHIhX8m14vVGgeFWjN540nKCNVj6P21eQjgTuA==",
      "dev": true,
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/yargs": {
      "version": "17.7.1",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cliui": "^8.0.1",
        "escalade": "^3.1.1",
        "get-caller-file": "^2.0.5",
        "require-directory": "^2.1.1",
        "string-width": "^4.2.3",
        "y18n": "^5.0.5",
        "yargs-parser": "^21.1.1"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/yargs-parser": {
      "version": "21.1.1",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "optional": true,
      "peer": true,
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    }
  }
}



---
File: /typescript-embedded-main/package.json
---

{
  "name": "weaviate-ts-embedded",
  "version": "1.2.0",
  "description": "Weaviate TypeScript EmbeddedDB",
  "main": "dist/index.js",
  "types": "./dist/index.d.ts",
  "engines": {
    "node": ">=16.0.0"
  },
  "type": "module",
  "files": [
    "/dist/index.js",
    "/dist/index.mjs",
    "/dist/index.d.ts"
  ],
  "scripts": {
    "test": "tsc -noEmit -p tsconfig-test.json && jest --useStderr --runInBand --detectOpenHandles",
    "build": "npm run lint && tsup src/index.ts --format esm --dts --clean --platform node --minify",
    "prepack": "npm run build",
    "lint": "eslint --ext .ts,.js .",
    "lint:fix": "npm run lint -- --fix",
    "format": "prettier --write --no-error-on-unmatched-pattern '**/*.{ts,js}' '!dist/**'",
    "format:check": "prettier --check --no-error-on-unmatched-pattern '**/*.{ts,js}' '!dist/**'",
    "prepare": "husky install"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/weaviate/typescript-embedded.git"
  },
  "keywords": [
    "weaviate"
  ],
  "author": "Weaviate",
  "license": "SEE LICENSE IN LICENSE",
  "bugs": {
    "url": "https://github.com/weaviate/typescript-embedded/issues"
  },
  "homepage": "https://github.com/weaviate/typescript-embedded#readme",
  "dependencies": {
    "adm-zip": "^0.5.10",
    "tar": "^6.1.13",
    "weaviate-ts-client": "^2.2.0"
  },
  "devDependencies": {
    "@babel/core": "^7.20.12",
    "@babel/preset-typescript": "^7.18.6",
    "@babel/runtime": "^7.20.7",
    "@curveball/bodyparser": "^0.5.0",
    "@curveball/core": "^0.20.0",
    "@rollup/plugin-babel": "^5.3.1",
    "@types/adm-zip": "^0.5.0",
    "@types/jest": "^29.4.0",
    "@types/node": "^18.14.0",
    "@types/tar": "^6.1.4",
    "@typescript-eslint/eslint-plugin": "^5.54.1",
    "@typescript-eslint/parser": "^5.54.1",
    "babel-jest": "^29.4.3",
    "eslint": "^8.40.0",
    "eslint-config-prettier": "^8.7.0",
    "eslint-plugin-prettier": "^4.2.1",
    "husky": "^8.0.3",
    "jest": "^29.4.3",
    "lint-staged": "^13.2.0",
    "prettier": "^2.8.4",
    "ts-jest": "^29.0.5",
    "tsup": "^6.7.0",
    "typescript": "^4.9.5"
  },
  "lint-staged": {
    "*.{ts,js}": [
      "npm run format:check",
      "npm run lint -- --cache"
    ]
  }
}



---
File: /typescript-embedded-main/README.md
---

# Weaviate TypeScript EmbeddedDB <img alt='Weaviate logo' src='https://weaviate.io/img/site/weaviate-logo-light.png' width='148' align='right' />

An embedded Weaviate database with TypeScript client interface, available for Linux and Mac

## Documentation

- [Documentation](https://weaviate.io/developers/weaviate/installation/embedded).

## Examples

### With default options

Defaults:
- Host: `127.0.0.1`
- Port: `6666`
- Weaviate version: `latest`

```ts
import weaviate, { EmbeddedClient, EmbeddedOptions } from 'weaviate-ts-embedded';

const client: EmbeddedClient = weaviate.client(new EmbeddedOptions());
await client.embedded.start();
// use the client to interact with embedded Weaviate
client.embedded.stop();
```

### With custom options

```ts
import weaviate, { EmbeddedClient, EmbeddedOptions } from 'weaviate-ts-embedded';

const client: EmbeddedClient = weaviate.client(
  new EmbeddedOptions({
    port: 7878,
    version: '1.18.1',
    env: {
      QUERY_DEFAULTS_LIMIT: 50,
      DEFAULT_VECTORIZER_MODULE: 'text2vec-openai',
    },
  }),
  // weaviate-ts-client ConnectionParams
  {
    scheme: 'http',
    host: '127.0.0.1:7878',
  }
);
await client.embedded.start();
// use the client to interact with embedded Weaviate
client.embedded.stop();
```

### With direct binary url

```ts
import weaviate, { EmbeddedClient, EmbeddedOptions } from 'weaviate-ts-embedded';

const binaryUrl = 'https://some-link-to-weaviate-binary';
const client: EmbeddedClient = weaviate.client(
  new EmbeddedOptions({
    binaryUrl: binaryUrl,
  })
);
await client.embedded.start();
// use the client to interact with embedded Weaviate
client.embedded.stop();
```

## Support

- [Stackoverflow for questions](https://stackoverflow.com/questions/tagged/weaviate).
- [Github for issues](https://github.com/weaviate/typescript-embedded/issues).

## Contributing

- [How to Contribute](https://github.com/weaviate/typescript-embedded/blob/main/CONTRIBUTE.md).

## Build Status

[![Build Status](https://github.com/weaviate/typescript-embedded/actions/workflows/.github/workflows/main.yaml/badge.svg?branch=main)](https://github.com/weaviate/typescript-embedded/actions/workflows/.github/workflows/main.yaml)



---
File: /typescript-embedded-main/tsconfig-test.json
---

{
  "compilerOptions": {
    "target": "esnext",
    "strict": true,
    "preserveConstEnums": true,
    "noEmit": false,
    "sourceMap": true,
    "module":"esnext",
    "moduleResolution":"node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "outDir": "./dist"
  },
  "include": ["**/*"],
  "exclude": ["node_modules", "examples"]
}



---
File: /typescript-embedded-main/tsconfig.json
---

{
  "compilerOptions": {
    "target": "esnext",
    "strict": true,
    "preserveConstEnums": true,
    "noEmit": false,
    "alwaysStrict": true,
    "noImplicitAny": true,
    "noImplicitThis": true,
    "strictFunctionTypes": true,
    "allowJs": true,
    "checkJs": false,
    "sourceMap": false,
    "module": "esnext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "outDir": "./types",
    "declaration": true,
    "rootDir": "./src",
    "types": ["node"]
  },
  "include": ["./src/**/*"],
  "exclude": ["**/*.test.ts"]
}

