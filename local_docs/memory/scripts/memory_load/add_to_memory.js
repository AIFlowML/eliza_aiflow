/**
 * Memory Loading Script for Eliza AI
 * 
 * This script loads data from various file formats into Eliza's memory system.
 * It uses the same embedding model and configuration as the main Eliza system.
 * 
 * @module add_to_memory
 */

import { 
  Memory, 
  AgentRuntime, 
  settings, 
  elizaLogger,
  MemoryType,
  ErrorCode,
  RuntimeError,
  MemoryManager
} from "@ai16z/eliza";
import fs from "fs/promises";
import path from "path";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import { glob } from "glob";
import { v4 as uuidv4 } from 'uuid';

// Initialize Eliza runtime with proper configuration
const runtime = new AgentRuntime({
  settings: {
    ...settings,
    MODEL_PROVIDER: process.env.MODEL_PROVIDER || "openai",
    EMBEDDING_MODEL: process.env.EMBEDDING_MODEL || "text-embedding-ada-002",
    DATABASE_URL: process.env.DATABASE_URL,
  }
});

// Configure logger context
elizaLogger.setContext({ component: 'memory-loader' });
elizaLogger.info('Initializing memory loader', {
  modelProvider: runtime.settings.MODEL_PROVIDER,
  embeddingModel: runtime.settings.EMBEDDING_MODEL
});

// Get memory manager from runtime
const memoryManager = runtime.getMemoryManager();
const DEFAULT_ROOM_ID = uuidv4();

/**
 * Create base memory object with common fields
 * @param {string} content - Memory content
 * @param {string} type - Memory type
 * @param {object} metadata - Additional metadata
 * @returns {Memory} Memory object
 */
function createBaseMemory(content, type, metadata = {}) {
  return {
    id: uuidv4(),
    roomId: DEFAULT_ROOM_ID,
    type,
    content,
    metadata: {
      ...metadata,
      source: 'memory-loader',
      importedAt: new Date().toISOString(),
      version: '1.0'
    },
    relationships: [],
    embedding: null // Will be generated by memory manager
  };
}

/**
 * Load memory from a JSON file
 * @param {string} filePath - Path to JSON file
 * @returns {Promise<Memory>} Created memory object
 */
async function loadJsonMemory(filePath) {
  try {
    elizaLogger.debug(`Processing JSON file`, { filePath });
    const data = JSON.parse(await fs.readFile(filePath, "utf-8"));
    
    if (!data.type || !data.content) {
      throw new RuntimeError(
        'Invalid JSON memory format',
        ErrorCode.INVALID_INPUT,
        { filePath }
      );
    }

    const memory = createBaseMemory(
      data.content,
      data.type,
      {
        originalFile: path.basename(filePath),
        ...data.metadata
      }
    );

    return await memoryManager.createMemory(memory);
  } catch (error) {
    elizaLogger.error('Failed to load JSON memory', {
      error: error.message,
      filePath,
      code: error.code
    });
    throw error;
  }
}

/**
 * Load memory from a text file
 * @param {string} filePath - Path to text file
 * @returns {Promise<Memory>} Created memory object
 */
async function loadTextMemory(filePath) {
  try {
    elizaLogger.debug(`Processing text file`, { filePath });
    const content = await fs.readFile(filePath, "utf-8");
    
    const memory = createBaseMemory(
      content,
      MemoryType.TEXT,
      {
        originalFile: path.basename(filePath),
        format: 'text/plain'
      }
    );

    return await memoryManager.createMemory(memory);
  } catch (error) {
    elizaLogger.error('Failed to load text memory', {
      error: error.message,
      filePath,
      code: error.code
    });
    throw error;
  }
}

/**
 * Load memory from a PDF file
 * @param {string} filePath - Path to PDF file
 * @returns {Promise<Memory>} Created memory object
 */
async function loadPdfMemory(filePath) {
  // TODO: Implement PDF loading
  elizaLogger.warn('PDF loading not yet implemented', { filePath });
  throw new RuntimeError(
    'PDF loading not implemented',
    ErrorCode.NOT_IMPLEMENTED,
    { filePath }
  );
}

/**
 * Find all files of specified types in directories
 * @param {string[]} directories - List of directories to scan
 * @param {string[]} extensions - File extensions to look for
 * @returns {Promise<string[]>} List of file paths
 */
async function findFiles(directories, extensions) {
  elizaLogger.info('Scanning directories for files:', { directories, extensions });
  const files = [];
  for (const dir of directories) {
    const pattern = path.join(dir, `**/*.{${extensions.join(',')}}`);
    elizaLogger.debug(`Scanning with pattern: ${pattern}`);
    const matches = await new Promise((resolve, reject) => {
      glob(pattern, (err, matches) => {
        if (err) reject(err);
        else resolve(matches);
      });
    });
    files.push(...matches);
  }
  elizaLogger.info(`Found ${files.length} files to process`);
  return files;
}

/**
 * Process a single file based on its type
 * @param {string} filePath - Path to the file
 * @returns {Promise<Memory>} Created memory object
 */
async function processFile(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  elizaLogger.debug(`Processing file: ${filePath} with extension ${ext}`);
  
  switch (ext) {
    case '.json':
      return await loadJsonMemory(filePath);
    case '.txt':
      return await loadTextMemory(filePath);
    case '.pdf':
      return await loadPdfMemory(filePath);
    default:
      elizaLogger.warn(`Unsupported file type: ${ext} for file ${filePath}`);
      return null;
  }
}

/**
 * Main execution function
 */
async function main() {
  try {
    const argv = await yargs(hideBin(process.argv))
      .option("directories", {
        alias: "d",
        type: "array",
        description: "Directories to scan for files",
        default: ["."],
      })
      .option("extensions", {
        alias: "e",
        type: "array",
        description: "File extensions to process",
        default: [".json", ".txt"],
      })
      .help()
      .argv;

    elizaLogger.info('Starting memory import', {
      directories: argv.directories,
      extensions: argv.extensions
    });

    const files = await findFiles(argv.directories, argv.extensions);
    elizaLogger.info(`Found ${files.length} files to process`);

    const results = await Promise.allSettled(
      files.map(async (file) => {
        try {
          const memory = await processFile(file);
          elizaLogger.info('Successfully imported memory', {
            file,
            memoryId: memory.id
          });
          return memory;
        } catch (error) {
          elizaLogger.error('Failed to process file', {
            file,
            error: error.message,
            code: error.code
          });
          return null;
        }
      })
    );

    const successful = results.filter(r => r.status === 'fulfilled' && r.value).length;
    const failed = results.filter(r => r.status === 'rejected' || !r.value).length;

    elizaLogger.info('Memory import completed', {
      total: files.length,
      successful,
      failed
    });

    // Clean up
    await runtime.shutdown();
  } catch (error) {
    elizaLogger.error('Fatal error during memory import', {
      error: error.message,
      code: error.code
    });
    process.exit(1);
  }
}

main();
