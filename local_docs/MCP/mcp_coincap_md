Directory Structure:

└── ./
    └── coincap-mcp-main
        ├── src
        │   ├── tools
        │   │   ├── BaseTool.ts
        │   │   ├── BitcoinPrice.ts
        │   │   ├── GetCryptoPrice.ts
        │   │   └── ListAssets.ts
        │   ├── utils
        │   │   └── toolLoader.ts
        │   ├── constants.ts
        │   └── index.ts
        ├── package-lock.json
        ├── package.json
        ├── README.md
        └── tsconfig.json



---
File: /coincap-mcp-main/src/tools/BaseTool.ts
---

import {
  CallToolRequestSchema,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";

export interface BaseTool {
  name: string;
  toolDefinition: Tool;
  toolCall(request: z.infer<typeof CallToolRequestSchema>): Promise<any>;
}

export abstract class BaseToolImplementation implements BaseTool {
  abstract name: string;
  abstract toolDefinition: Tool;
  abstract toolCall(
    request: z.infer<typeof CallToolRequestSchema>
  ): Promise<any>;
}



---
File: /coincap-mcp-main/src/tools/BitcoinPrice.ts
---

import { Tool } from "@modelcontextprotocol/sdk/types.js";
import { BITCOIN_PRICE_URL } from "../constants.js";
import { BaseToolImplementation } from "./BaseTool.js";

class BitcoinPriceTool extends BaseToolImplementation {
  name = "bitcoin_price";
  toolDefinition: Tool = {
    name: this.name,
    description: "Get realtime bitcoin price",
    inputSchema: {
      type: "object",
    },
  };

  toolCall = async () => {
    try {
      const response = await fetch(BITCOIN_PRICE_URL);
      if (!response.ok) {
        throw new Error("Error fetching coincap data");
      }

      const body = await response.json();

      return {
        content: [{ type: "text", text: `${JSON.stringify(body.data)}` }],
      };
    } catch (error) {
      return {
        content: [
          { type: "error", text: JSON.stringify((error as any).message) },
        ],
      };
    }
  };
}

export default BitcoinPriceTool;



---
File: /coincap-mcp-main/src/tools/GetCryptoPrice.ts
---

import { Tool } from "@modelcontextprotocol/sdk/types.js";
import { CONSTANTS } from "../constants.js";
import { z } from "zod";
import { CallToolRequestSchema } from "@modelcontextprotocol/sdk/types.js";
import { BaseToolImplementation } from "./BaseTool.js";

class GetCryptoPrice extends BaseToolImplementation {
  name = "get_crypto_price";
  toolDefinition: Tool = {
    name: this.name,
    description: "Get realtime crypto price on crypto",
    inputSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          description: "Name of the crypto coin",
        },
      },
    },
  };

  async toolCall(request: z.infer<typeof CallToolRequestSchema>) {
    try {
      const cryptoName = request.params.arguments?.name;
      if (!cryptoName) {
        throw new Error("Missing crypto name");
      }
      const url = CONSTANTS.CRYPTO_PRICE_URL + cryptoName;

      const response = await fetch(url);
      if (!response.ok) {
        throw new Error("Error fetching coincap data");
      }

      const body = await response.json();

      return {
        content: [{ type: "text", text: JSON.stringify(body.data) }],
      };
    } catch (error) {
      return {
        content: [
          { type: "error", text: JSON.stringify((error as any).message) },
        ],
      };
    }
  }
}

export default GetCryptoPrice;



---
File: /coincap-mcp-main/src/tools/ListAssets.ts
---

import { Tool } from "@modelcontextprotocol/sdk/types.js";
import { CONSTANTS } from "../constants.js";
import { BaseToolImplementation } from "./BaseTool.js";

class ListAssetsTool extends BaseToolImplementation {
  name = "list_assets";
  toolDefinition: Tool = {
    name: this.name,
    description: "Get all available crypto assets",
    inputSchema: {
      type: "object",
    },
  };

  toolCall = async () => {
    try {
      const url = CONSTANTS.CRYPTO_PRICE_URL;

      const response = await fetch(url);
      if (!response.ok) {
        throw new Error("Error fetching coincap data");
      }

      const body = await response.json();

      return {
        content: [{ type: "text", text: JSON.stringify(body.data) }],
      };
    } catch (error) {
      return {
        content: [
          { type: "error", text: JSON.stringify((error as any).message) },
        ],
      };
    }
  };
}

export default ListAssetsTool;



---
File: /coincap-mcp-main/src/utils/toolLoader.ts
---

import { BaseTool } from "../tools/BaseTool.js";
import { fileURLToPath } from "url";
import { dirname, join } from "path";
import { promises as fs } from "fs";

async function findToolsPath(): Promise<string> {
  const currentFilePath = fileURLToPath(import.meta.url);
  const currentDir = dirname(currentFilePath);

  const possiblePaths = [
    join(currentDir, "..", "tools"),
    join(currentDir, "..", "..", "build", "tools"),
    join(dirname(dirname(currentDir)), "tools"),
    join(dirname(dirname(dirname(currentDir))), "build", "tools"),
    join(process.cwd(), "build", "tools"),
  ];

  for (const path of possiblePaths) {
    try {
      const stats = await fs.stat(path);
      if (stats.isDirectory()) {
        const files = await fs.readdir(path);
        if (
          files.some(
            (file) => file.endsWith(".js") && !file.includes("BaseTool")
          )
        ) {
          return path;
        }
      }
    } catch {
      continue;
    }
  }

  throw new Error("Could not find tools directory");
}

const isToolFile = (file: string): boolean => {
  return (
    file.endsWith(".js") &&
    !file.includes("BaseTool") &&
    !file.includes("index") &&
    !file.endsWith(".test.js") &&
    !file.endsWith(".spec.js") &&
    !file.endsWith(".d.js")
  );
};

export async function loadTools(): Promise<BaseTool[]> {
  try {
    const toolsPath = await findToolsPath();
    const files = await fs.readdir(toolsPath);
    const tools: BaseTool[] = [];

    for (const file of files) {
      if (!isToolFile(file)) {
        continue;
      }

      try {
        const modulePath = `file://${join(toolsPath, file)}`;
        const { default: ToolClass } = await import(modulePath);

        if (!ToolClass) {
          continue;
        }

        const tool = new ToolClass();

        if (
          tool.name &&
          tool.toolDefinition &&
          typeof tool.toolCall === "function"
        ) {
          tools.push(tool);
        }
      } catch (error) {
        console.error(`Error loading tool from ${file}:`, error);
      }
    }

    return tools;
  } catch (error) {
    console.error(`Failed to load tools:`, error);
    return [];
  }
}

export function createToolsMap(tools: BaseTool[]): Map<string, BaseTool> {
  return new Map(tools.map((tool) => [tool.name, tool]));
}



---
File: /coincap-mcp-main/src/constants.ts
---

export const BITCOIN_PRICE_URL = "https://api.coincap.io/v2/assets/bitcoin";
export const CONSTANTS = {
  CRYPTO_PRICE_URL: "https://api.coincap.io/v2/assets/",
  PROJECT_NAME: "coincap-mcp",
  PROJECT_VERSION: "0.9.2",
};



---
File: /coincap-mcp-main/src/index.ts
---

#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { CONSTANTS } from "./constants.js";
import { loadTools, createToolsMap } from "./utils/toolLoader.js";

const { PROJECT_NAME, PROJECT_VERSION } = CONSTANTS;

let toolsMap: Map<string, any>;

const server = new Server(
  {
    name: PROJECT_NAME,
    version: PROJECT_VERSION,
  },
  {
    capabilities: {
      tools: {
        enabled: true,
      },
    },
  }
);

server.setRequestHandler(ListToolsRequestSchema, async () => {
  if (!toolsMap || toolsMap.size === 0) {
    console.warn("No tools available for listing");
    return { tools: [] };
  }
  return {
    tools: Array.from(toolsMap.values()).map((tool) => tool.toolDefinition),
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (!toolsMap) {
    throw new Error("Tools not initialized");
  }

  const tool = toolsMap.get(request.params.name);
  if (!tool) {
    throw new Error(
      `Unknown tool: ${request.params.name}. Available tools: ${Array.from(
        toolsMap.keys()
      ).join(", ")}`
    );
  }
  return tool.toolCall(request);
});

async function main() {
  try {
    console.log("Starting Coincap MCP Server...");

    const tools = await loadTools();
    if (tools.length === 0) {
      console.error("No tools were loaded! Server may not function correctly.");
    }

    toolsMap = createToolsMap(tools);
    console.log(
      `Initialized with ${tools.length} tools:`,
      Array.from(toolsMap.keys()).join(", ")
    );

    const transport = new StdioServerTransport();
    console.log("Connecting to transport...");
    await server.connect(transport);
    console.log("Server started successfully!");
  } catch (error) {
    console.error("Fatal error during server initialization:", error);
    process.exit(1);
  }
}

process.on("unhandledRejection", (error) => {
  console.error("Unhandled promise rejection:", error);
});

main().catch((error) => {
  console.error("Server error:", error);
  process.exit(1);
});



---
File: /coincap-mcp-main/package-lock.json
---

{
  "name": "coincap-mcp",
  "version": "0.1.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "coincap-mcp",
      "version": "0.1.0",
      "dependencies": {
        "@modelcontextprotocol/sdk": "0.6.0",
        "zod": "^3.23.8"
      },
      "bin": {
        "coincap-mcp": "build/index.js"
      },
      "devDependencies": {
        "@types/node": "^20.11.24",
        "typescript": "^5.3.3"
      }
    },
    "node_modules/@modelcontextprotocol/sdk": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/@modelcontextprotocol/sdk/-/sdk-0.6.0.tgz",
      "integrity": "sha512-9rsDudGhDtMbvxohPoMMyAUOmEzQsOK+XFchh6gZGqo8sx9sBuZQs+CUttXqa8RZXKDaJRCN2tUtgGof7jRkkw==",
      "dependencies": {
        "content-type": "^1.0.5",
        "raw-body": "^3.0.0",
        "zod": "^3.23.8"
      }
    },
    "node_modules/@types/node": {
      "version": "20.17.9",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.17.9.tgz",
      "integrity": "sha512-0JOXkRyLanfGPE2QRCwgxhzlBAvaRdCNMcvbd7jFfpmD4eEXll7LRwy5ymJmyeZqk7Nh7eD2LeUyQ68BbndmXw==",
      "dev": true,
      "dependencies": {
        "undici-types": "~6.19.2"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
      "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/raw-body": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.0.tgz",
      "integrity": "sha512-RmkhL8CAyCRPXCE28MMH0z2PNWQBNk2Q09ZdxM9IOOXwxwZbN+qbWaatPkdkWIKL2ZVDImrN/pK5HTRz2PcS4g==",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.6.3",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg=="
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/typescript": {
      "version": "5.7.2",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.7.2.tgz",
      "integrity": "sha512-i5t66RHxDvVN40HfDd1PsEThGNnlMCMT3jMUuoh9/0TaqWevNontacunWyN02LA9/fIbEWlcHZcgTKb9QoaLfg==",
      "dev": true,
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "6.19.8",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.19.8.tgz",
      "integrity": "sha512-ve2KP6f/JnbPBFyobGHuerC9g1FYGn/F8n1LWTwNxCEzd6IfqTwUQcNXgEtmmQ6DlRrC1hrSrBnCZPokRrDHjw==",
      "dev": true
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/zod": {
      "version": "3.23.8",
      "resolved": "https://registry.npmjs.org/zod/-/zod-3.23.8.tgz",
      "integrity": "sha512-XBx9AXhXktjUqnepgTiE5flcKIYWi/rme0Eaj+5Y0lftuGBq+jyRu/md4WnuxqgP1ubdpNCsYEYPxrzVHD8d6g==",
      "funding": {
        "url": "https://github.com/sponsors/colinhacks"
      }
    }
  }
}



---
File: /coincap-mcp-main/package.json
---

{
  "name": "coincap-mcp",
  "version": "0.9.3",
  "author": {
    "name": "Alex Andru",
    "email": "alex007d@gmail.com"
  },
  "description": "A MCP server to get crypto prices from coincap",
  "license": "MIT",
  "type": "module",
  "bin": {
    "coincap-mcp": "build/index.js"
  },
  "main": "build/index.js",
  "files": [
    "build",
    "build/**/*"
  ],
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
    "prepare": "npm run build",
    "watch": "tsc --watch",
    "inspector": "npx @modelcontextprotocol/inspector build/index.js",
    "prepack": "npm run build"
  },
  "keywords": [
    "mcp",
    "claude",
    "coincap",
    "anthropic",
    "ai",
    "cryptocurrency"
  ],
  "dependencies": {
    "@modelcontextprotocol/sdk": "0.6.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/node": "^20.11.24",
    "typescript": "^5.3.3"
  },
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/QuantGeekDev/coincap-mcp.git"
  },
  "bugs": {
    "url": "https://github.com/QuantGeekDev/coincap-mcp/issues"
  },
  "engines": {
    "node": ">=18"
  }
}



---
File: /coincap-mcp-main/README.md
---

# Coincap MCP

## What does this server do?

Allows you to query crypto information from coincap's public API - no API keys or registration required

## 🚀 Quick Start

To get started, add this configuration to your Claude Desktop config file:

**MacOS**: `~/Library/Application\ Support/Claude/claude_desktop_config.json`
**Windows**: `%APPDATA%/Claude/claude_desktop_config.json`

```json
{
  "mcpServers": {
    "mongodb": {
      "command": "npx",
      "args": ["coincap-mcp"]
    }
  }
}
```

### Prerequisites

- Node.js 18+
- npx

Then, launch Claude Desktop and you're ready to go!

## Sample Prompts

- What is the price of bitcoin?
- What are the available crypto assets?
- What is the market cap of ethereum?

## Tools

#### Bitcoin Price Tool

Gets price for Bitcoin specifically, it's a simple example of a primitive API call tool

#### Get Crypto Price Tool

Gets price for any cryptocurrency available on coincap API. It's a good example of how to get mandatory parameter data for your tool calls

#### List Assets

Gets a list of all crypto assets available in coincap API

## Development - local build

To build it locally:

On MacOS: `~/Library/Application Support/Claude/claude_desktop_config.json`
On Windows: `%APPDATA%/Claude/claude_desktop_config.json`

```json
{
  "mcpServers": {
    "coincap-mcp": {
      "command": "/path/to/coincap-mcp/build/index.js"
    }
  }
}
```

## Development

Install dependencies:

```bash
npm install
```

Build the server:

```bash
npm run build
```

For development with auto-rebuild:

```bash
npm run watch
```

## 📜 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.



---
File: /coincap-mcp-main/tsconfig.json
---

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

